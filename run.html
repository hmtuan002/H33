<!DOCTYPE HTML>
<html lang="vi">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="phet-sim-level" content="production">
  <meta property="og:title" content="&#8234;T&#7841;o d&#7921;ng nguy&ecirc;n t&#7917;&#8236;"/>
  <meta property="og:type" content="phet:simulation"/>
  <meta property="og:url" content="https://phet.colorado.edu/sims/html/build-an-atom/latest/build-an-atom_vi.html"/>
  <meta property="og:image" content="https://phet.colorado.edu/sims/html/build-an-atom/latest/build-an-atom-600.png"/>
  <title>&#8234;T&#7841;o d&#7921;ng nguy&ecirc;n t&#7917;&#8236;</title>
</head>
<body style="background-color:black;">
<div id='aria-live-elements' style="position: absolute; left: 0px; top: 0px; width: 0px; height: 0px; clip: rect(0px 0px 0px 0px); pointer-events: none;">
  <p id="assertive" aria-live="assertive"></p>
  <p id="polite" aria-live="polite"></p>
  <p id="assertive-alert" aria-live="assertive" role="alert"></p>
  <p id="polite-status" aria-live="polite" role="status"></p>
</div>
<script type="text/javascript">
  window.phet = {};
  window.phet.chipper = {};
  window.phet.chipper.project = 'build-an-atom';
  window.phet.chipper.version = '1.6.34';
  window.phet.chipper.buildTimestamp = '2025-06-10 17:47:18 UTC+7';
  window.phet.chipper.brand = 'phet';
  window.phet.chipper.locale = 'vi';
  window.phet.chipper.localeData = {"am":{"locale3":"amh","englishName":"Amharic","localizedName":"አማርኛ","direction":"ltr","bcp47":"am"},"ar":{"locale3":"ara","englishName":"Arabic","localizedName":"العربية","direction":"rtl","bcp47":"ar"},"ar_AE":{"englishName":"Arabic (U.A.E.)","localizedName":"العربية (الإمارات العربية المتحدة)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_BH":{"englishName":"Arabic (Bahrain)","localizedName":"العربية (البحرين)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_DJ":{"englishName":"Arabic (Djibouti)","localizedName":"العربية (جيبوتي)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_DZ":{"englishName":"Arabic (Algeria)","localizedName":"العربية (الجزائر)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_EG":{"locale3":"arz","englishName":"Arabic (Egypt)","localizedName":"العربية (مصر)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"arz"},"ar_EH":{"englishName":"Arabic (Sahrawi Republic)","localizedName":"العربية (الجمهورية الصحراوية)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_ER":{"englishName":"Arabic (Eritrea)","localizedName":"العربية (إريتريا)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_IQ":{"englishName":"Arabic (Iraq)","localizedName":"العربية (العراق)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_JO":{"englishName":"Arabic (Jordan)","localizedName":"العربية (الأردن)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_KM":{"englishName":"Arabic (Comoros)","localizedName":"العربية (جزر القمر)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_KW":{"englishName":"Arabic (Kuwait)","localizedName":"العربية (الكويت)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_LB":{"englishName":"Arabic (Lebanon)","localizedName":"العربية (لبنان)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_LY":{"englishName":"Arabic (Libya)","localizedName":"العربية (ليبيا)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_MA":{"locale3":"ary","englishName":"Arabic, Morocco","localizedName":"العربية (المغرب)","direction":"rtl","fallbackLocales":["ar"],"bcp47":"ary"},"ar_MR":{"englishName":"Arabic (Mauritania)","localizedName":"العربية (موريتانيا)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_OM":{"englishName":"Arabic (Oman)","localizedName":"العربية (عُمان)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_QA":{"englishName":"Arabic (Qatar)","localizedName":"العربية (قطر)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_SA":{"englishName":"Arabic, Saudi Arabia","localizedName":"العربية (السعودية)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_SD":{"englishName":"Arabic (Sudan)","localizedName":"العربية (السودان)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_SO":{"englishName":"Arabic (Somalia)","localizedName":"العربية (الصومال)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_SY":{"englishName":"Arabic (Syria)","localizedName":"العربية (سوريا)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_TD":{"englishName":"Arabic (Chad)","localizedName":"العربية (تشاد)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_TN":{"englishName":"Arabic (Tunisia)","localizedName":"العربية (تونس)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"ar_YE":{"englishName":"Arabic (Yemen)","localizedName":"العربية (اليمن)","direction":"rtl","fallbackLocales":["ar","ar_MA"],"bcp47":"ar"},"az":{"locale3":"aze","englishName":"Azerbaijani","localizedName":"azərbaycan dili","direction":"ltr","bcp47":"az"},"be":{"locale3":"bel","englishName":"Belarusian","localizedName":"беларуская мова","direction":"ltr","bcp47":"be"},"bg":{"locale3":"bul","englishName":"Bulgarian","localizedName":"български език","direction":"ltr","bcp47":"bg"},"bn":{"locale3":"ben","englishName":"Bengali","localizedName":"বাংলা","direction":"ltr","bcp47":"bn"},"bo":{"locale3":"bod","englishName":"Tibetan","localizedName":"བོད་ཡིག","direction":"ltr","bcp47":"bo"},"bs":{"locale3":"bos","englishName":"Bosnian","localizedName":"bosanski jezik","direction":"ltr","bcp47":"bs"},"ca":{"locale3":"cat","englishName":"Catalan","localizedName":"Català","direction":"ltr","bcp47":"ca"},"cs":{"locale3":"ces","englishName":"Czech","localizedName":"čeština","direction":"ltr","bcp47":"cs"},"cy":{"locale3":"cym","englishName":"Welsh","localizedName":"Cymraeg","direction":"ltr","bcp47":"cy"},"da":{"locale3":"dan","englishName":"Danish","localizedName":"dansk","direction":"ltr","bcp47":"da"},"de":{"locale3":"deu","englishName":"German","localizedName":"Deutsch","direction":"ltr","bcp47":"de"},"de_AT":{"englishName":"German (Austria)","localizedName":"Deutsch (Österreich)","direction":"ltr","fallbackLocales":["de"],"bcp47":"de"},"de_CH":{"englishName":"German (Switzerland)","localizedName":"Deutsch (Schweiz)","direction":"ltr","fallbackLocales":["de"],"bcp47":"de"},"de_LI":{"englishName":"German (Liechtenstein)","localizedName":"Deutsch (Liechtenstein)","direction":"ltr","fallbackLocales":["de"],"bcp47":"de"},"de_LU":{"englishName":"German (Luxembourg)","localizedName":"Deutsch (Luxemburg)","direction":"ltr","fallbackLocales":["de"],"bcp47":"de"},"ee":{"locale3":"ewe","englishName":"Ewe","localizedName":"Eʋegbe","direction":"ltr","bcp47":"ee"},"el":{"locale3":"ell","englishName":"Greek","localizedName":"Ελληνικά","direction":"ltr","bcp47":"el"},"en":{"locale3":"eng","englishName":"English","localizedName":"English","direction":"ltr","bcp47":"en"},"es":{"locale3":"spa","englishName":"Spanish","localizedName":"español","direction":"ltr","bcp47":"es"},"es_AR":{"englishName":"Spanish (Argentina)","localizedName":"español (Argentina)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_BO":{"englishName":"Spanish (Bolivia)","localizedName":"español (Bolivia)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_CL":{"englishName":"Spanish (Chile)","localizedName":"español (Chile)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_CO":{"englishName":"Spanish, Colombia","localizedName":"español (Colombia)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_CR":{"englishName":"Spanish, Costa Rica","localizedName":"español (Costa Rica)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_DO":{"englishName":"Spanish (Dominican Republic)","localizedName":"español (Dominican Republic)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_EC":{"englishName":"Spanish (Ecuador)","localizedName":"español (Ecuador)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_ES":{"englishName":"Spanish, Spain","localizedName":"español (España)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_GQ":{"englishName":"Spanish (Equatorial Guinea)","localizedName":"español (Equatorial Guinea)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_GT":{"englishName":"Spanish (Guatemala)","localizedName":"español (Guatemala)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_HN":{"englishName":"Spanish (Honduras)","localizedName":"español (Honduras)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_MX":{"englishName":"Spanish, Mexico","localizedName":"español (México)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_NI":{"englishName":"Spanish (Nicaragua)","localizedName":"español (Nicaragua)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_PA":{"englishName":"Spanish (Panama)","localizedName":"español (Panama)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_PE":{"englishName":"Spanish, Peru","localizedName":"español (Perú)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_PR":{"englishName":"Spanish (Puerto Rico)","localizedName":"español (Puerto Rico)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_PY":{"englishName":"Spanish (Paraguay)","localizedName":"español (Paraguay)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_SV":{"englishName":"Spanish (El Salvador)","localizedName":"español (El Salvador)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_US":{"englishName":"Spanish (United States)","localizedName":"español (United States)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_UY":{"englishName":"Spanish (Uruguay)","localizedName":"español (Uruguay)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"es_VE":{"englishName":"Spanish (Venezuela)","localizedName":"español (Venezuela)","direction":"ltr","fallbackLocales":["es"],"bcp47":"es"},"et":{"locale3":"est","englishName":"Estonian","localizedName":"eesti","direction":"ltr","bcp47":"et"},"eu":{"locale3":"eus","englishName":"Basque","localizedName":"euskara","direction":"ltr","bcp47":"eu"},"fa":{"locale3":"fas","englishName":"Persian","localizedName":"فارسی","direction":"rtl","bcp47":"fa"},"fa_DA":{"locale3":"prs","englishName":"Persian (Dari)","localizedName":"دری","direction":"rtl","bcp47":"prs"},"fi":{"locale3":"fin","englishName":"Finnish","localizedName":"suomi","direction":"ltr","bcp47":"fi"},"fo":{"locale3":"fao","englishName":"Faroese","localizedName":"føroyskt","direction":"ltr","bcp47":"fo"},"fr":{"locale3":"fra","englishName":"French","localizedName":"français","direction":"ltr","bcp47":"fr"},"fr_BE":{"englishName":"French (Belgium)","localizedName":"français (Belgium)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_BF":{"englishName":"French (Burkina Faso)","localizedName":"français (Burkina Faso)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_BI":{"englishName":"French (Burundi)","localizedName":"français (Burundi)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_BJ":{"englishName":"French (Benin)","localizedName":"français (Bénin)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CA":{"englishName":"French (Canada)","localizedName":"français (Canada)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CD":{"englishName":"French (DR Congo)","localizedName":"français (RD Congo)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CF":{"englishName":"French (Central African Republic)","localizedName":"français (République centrafricaine)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CG":{"englishName":"French (Congo Republic)","localizedName":"français (République du Congo)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CH":{"englishName":"French (Switzerland)","localizedName":"français (Suisse)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CI":{"englishName":"French (Côte d’Ivoire)","localizedName":"français (Côte d'Ivoire)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_CM":{"englishName":"French (Cameroon)","localizedName":"français (Cameroon)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_DJ":{"englishName":"French (Djibouti)","localizedName":"français (Djibouti)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_EH":{"englishName":"French (Sahrawi Republic)","localizedName":"français (République sahraouie)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_GA":{"englishName":"French (Gabon)","localizedName":"français (Gabon)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_GN":{"englishName":"French (Guinea)","localizedName":"français (Guinée)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_GQ":{"englishName":"French (Equatorial Guinea)","localizedName":"français (Guinée Équatoriale)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_KM":{"englishName":"French (Comoros)","localizedName":"français (Comores)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_LU":{"englishName":"French (Luxembourg)","localizedName":"français (Luxembourg)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_MC":{"englishName":"French (Monaco)","localizedName":"français (Monaco)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_MG":{"englishName":"French (Madagascar)","localizedName":"français (Madagascar)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_ML":{"englishName":"French (Mali)","localizedName":"français (Mali)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_NE":{"englishName":"French (Niger)","localizedName":"français (Niger)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_RW":{"englishName":"French (Rwanda)","localizedName":"français (Rwanda)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_SC":{"englishName":"French (Seychelles)","localizedName":"français (les Seychelles)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_SN":{"englishName":"French (Senegal)","localizedName":"français (Sénégal)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_TD":{"englishName":"French (Chad)","localizedName":"français (Tchad)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"fr_TG":{"englishName":"French (Togo)","localizedName":"français (Togo)","direction":"ltr","fallbackLocales":["fr"],"bcp47":"fr"},"ga":{"locale3":"gle","englishName":"Irish","localizedName":"Gaeilge","direction":"ltr","bcp47":"ga"},"gl":{"locale3":"glg","englishName":"Galician","localizedName":"galego","direction":"ltr","bcp47":"gl"},"gu":{"locale3":"guj","englishName":"Gujarati","localizedName":"ગુજરાતી","direction":"ltr","bcp47":"gu"},"ha":{"locale3":"hau","englishName":"Hausa","localizedName":"Hausa","direction":"ltr","bcp47":"ha"},"hi":{"locale3":"hin","englishName":"Hindi","localizedName":"हिन्दी","direction":"ltr","bcp47":"hi"},"hr":{"locale3":"hrv","englishName":"Croatian","localizedName":"Hrvatski","direction":"ltr","bcp47":"hr"},"hr_BA":{"englishName":"Croatian (Latin, Bosnia, and Herzegovina)","localizedName":"hrvatski (Latinica, Bosna i Hercegovina)","direction":"ltr","fallbackLocales":["hr"],"bcp47":"hr"},"ht":{"locale3":"hat","englishName":"Haitian","localizedName":"Kreyòl ayisyen","direction":"ltr","bcp47":"ht"},"hu":{"locale3":"hun","englishName":"Hungarian","localizedName":"magyar","direction":"ltr","bcp47":"hu"},"hy":{"locale3":"hye","englishName":"Armenian","localizedName":"Հայերեն","direction":"ltr","bcp47":"hy"},"ig":{"locale3":"ibo","englishName":"Igbo","localizedName":"Asụsụ Igbo","direction":"ltr","bcp47":"ig"},"in":{"locale3":"ind","englishName":"Indonesian","localizedName":"Bahasa Indonesia","direction":"ltr","bcp47":"in"},"is":{"locale3":"isl","englishName":"Icelandic","localizedName":"Íslenska","direction":"ltr","bcp47":"is"},"it":{"locale3":"ita","englishName":"Italian","localizedName":"italiano","direction":"ltr","bcp47":"it"},"it_CH":{"englishName":"Italian (Switzerland)","localizedName":"italiano(Svizzera)","direction":"ltr","fallbackLocales":["it"],"bcp47":"it"},"iw":{"locale3":"heb","englishName":"Hebrew","localizedName":"עברית","direction":"rtl","bcp47":"iw"},"ja":{"locale3":"jpn","englishName":"Japanese","localizedName":"日本語","direction":"ltr","bcp47":"ja"},"ka":{"locale3":"kat","englishName":"Georgian","localizedName":"ქართული ენა","direction":"ltr","bcp47":"ka"},"kk":{"locale3":"kaz","englishName":"Kazakh","localizedName":"қазақ тілі","direction":"ltr","bcp47":"kk"},"km":{"locale3":"khm","englishName":"Khmer","localizedName":"ខេមរភាសា","direction":"ltr","bcp47":"km"},"kn":{"locale3":"kan","englishName":"Kannada","localizedName":"ಕನ್ನಡ","direction":"ltr","bcp47":"kn"},"ko":{"locale3":"kor","englishName":"Korean","localizedName":"한국어","direction":"ltr","bcp47":"ko"},"ku":{"locale3":"kur","englishName":"Kurdish (Sorani)","localizedName":"سۆرانی","direction":"rtl","bcp47":"ku"},"lg":{"locale3":"lug","englishName":"Ganda","localizedName":"Luganda","direction":"ltr","bcp47":"lg"},"lo":{"locale3":"lao","englishName":"Lao","localizedName":"ພາສາລາວ","direction":"ltr","bcp47":"lo"},"lt":{"locale3":"lit","englishName":"Lithuanian","localizedName":"lietuvių kalba","direction":"ltr","bcp47":"lt"},"lv":{"locale3":"lav","englishName":"Latvian","localizedName":"latviešu valoda","direction":"ltr","bcp47":"lv"},"mi":{"locale3":"mri","englishName":"Maori","localizedName":"reo Māori","direction":"ltr","bcp47":"mi"},"mk":{"locale3":"mkd","englishName":"Macedonian","localizedName":"македонски јазик","direction":"ltr","bcp47":"mk"},"mn":{"locale3":"mon","englishName":"Mongolian","localizedName":"Монгол хэл","direction":"ltr","bcp47":"mn"},"mo":{"locale3":"mol","englishName":"Moldavian","localizedName":"Moldavian","direction":"ltr","bcp47":"mo"},"mr":{"locale3":"mar","englishName":"Marathi","localizedName":"मराठी","direction":"ltr","bcp47":"mr"},"ms":{"locale3":"msa","englishName":"Malay","localizedName":"Bahasa Malaysia","direction":"ltr","bcp47":"ms"},"ms_MY":{"englishName":"Malay (Standard)","localizedName":"بهاس ملايو مليسيا","direction":"rtl","fallbackLocales":["ms"],"bcp47":"ms"},"mt":{"locale3":"mlt","englishName":"Maltese","localizedName":"Malti","direction":"ltr","bcp47":"mt"},"nb":{"locale3":"nob","englishName":"Norwegian Bokmal","localizedName":"Norwegian Bokmål","direction":"ltr","bcp47":"nb"},"nl":{"locale3":"nld","englishName":"Dutch","localizedName":"Nederlands","direction":"ltr","bcp47":"nl"},"nl_BE":{"englishName":"Dutch (Belgium)","localizedName":"Nederlands (België)","direction":"ltr","fallbackLocales":["nl"],"bcp47":"nl"},"nn":{"locale3":"nno","englishName":"Norwegian Nynorsk","localizedName":"Norsk nynorsk","direction":"ltr","bcp47":"nn"},"ny":{"locale3":"nya","englishName":"Chichewa","localizedName":"Nyanja","direction":"ltr","bcp47":"ny"},"om":{"locale3":"orm","englishName":"Oromo","localizedName":"Afaan Oromoo","direction":"ltr","bcp47":"om"},"or":{"locale3":"ori","englishName":"Oriya","localizedName":"ଓଡ଼ିଆ","direction":"ltr","bcp47":"or"},"pl":{"locale3":"pol","englishName":"Polish","localizedName":"Polski","direction":"ltr","bcp47":"pl"},"ps":{"locale3":"pus","englishName":"Pashto","localizedName":"پښتو","direction":"ltr","bcp47":"ps"},"pt":{"locale3":"por","englishName":"Portuguese","localizedName":"Português","direction":"ltr","fallbackLocales":["pt_BR"],"bcp47":"pt"},"pt_AO":{"englishName":"Portuguese(Angola)","localizedName":"português(Angola)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"pt_BR":{"englishName":"Portuguese, Brazil","localizedName":"português (Brasil)","direction":"ltr","bcp47":"pt"},"pt_CV":{"englishName":"Portuguese(Cabo verde)","localizedName":"português(Cabo verde)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"pt_GQ":{"englishName":"Portuguese(Equatorial Guinea)","localizedName":"português(Guiné Equatorial)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"pt_GW":{"englishName":"Portuguese(Guinea-Bissau)","localizedName":"português(Guiné-Bissau)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"pt_MZ":{"englishName":"Portuguese(Mozambique)","localizedName":"português(Moçambique)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"pt_ST":{"englishName":"Portuguese(São Tomé and Príncipe)","localizedName":"português(São Tomé e Príncipe)","direction":"ltr","fallbackLocales":["pt","pt_BR"],"bcp47":"pt"},"ro":{"locale3":"ron","englishName":"Romanian","localizedName":"Română","direction":"ltr","bcp47":"ro"},"ru":{"locale3":"rus","englishName":"Russian","localizedName":"Русский","direction":"ltr","bcp47":"ru"},"rw":{"locale3":"kin","englishName":"Kinyarwanda","localizedName":"Ikinyarwanda","direction":"ltr","bcp47":"rw"},"se":{"locale3":"sme","englishName":"Northern Sami","localizedName":"Davvisámegiella","direction":"ltr","bcp47":"se"},"si":{"locale3":"sin","englishName":"Sinhalese","localizedName":"සිංහල","direction":"ltr","bcp47":"si"},"sk":{"locale3":"slk","englishName":"Slovak","localizedName":"slovenčina","direction":"ltr","bcp47":"sk"},"sl":{"locale3":"slv","englishName":"Slovenian","localizedName":"slovenščina","direction":"ltr","bcp47":"sl"},"sn":{"locale3":"sna","englishName":"Shona","localizedName":"chiShona","direction":"ltr","bcp47":"sn"},"sq":{"locale3":"sqi","englishName":"Albanian","localizedName":"Shqip","direction":"ltr","bcp47":"sq"},"sr":{"locale3":"srp","englishName":"Serbian","localizedName":"српски језик","direction":"ltr","bcp47":"sr"},"sr_BA":{"englishName":"Serbian (Bosnia and Herzegovina)","localizedName":"Српски (Босна и Херцеговина)","direction":"ltr","fallbackLocales":["sr"],"bcp47":"sr"},"st":{"locale3":"sot","englishName":"Sotho","localizedName":"Sesotho","direction":"ltr","bcp47":"st"},"sv":{"locale3":"swe","englishName":"Swedish","localizedName":"Svenska","direction":"ltr","bcp47":"sv"},"sv_FI":{"englishName":"Swedish (Finland)","localizedName":"svenska (Finland)","direction":"ltr","fallbackLocales":["sv"],"bcp47":"sv"},"sw":{"locale3":"swa","englishName":"Swahili","localizedName":"Kiswahili","direction":"ltr","bcp47":"sw"},"ta":{"locale3":"tam","englishName":"Tamil","localizedName":"தமிழ்","direction":"ltr","bcp47":"ta"},"te":{"locale3":"tel","englishName":"Telugu","localizedName":"తెలుగు","direction":"ltr","bcp47":"te"},"tg":{"locale3":"tgk","englishName":"Tajik","localizedName":"тоҷикӣ","direction":"ltr","bcp47":"tg"},"th":{"locale3":"tha","englishName":"Thai","localizedName":"ไทย","direction":"ltr","bcp47":"th"},"ti":{"locale3":"tir","englishName":"Tigrinya","localizedName":"ትግርኛ","direction":"ltr","bcp47":"ti"},"tk":{"locale3":"tuk","englishName":"Turkmen","localizedName":"Türkmen","direction":"ltr","bcp47":"tk"},"tn":{"locale3":"tsn","englishName":"Tswana","localizedName":"Setswana","direction":"ltr","bcp47":"tn"},"tr":{"locale3":"tur","englishName":"Turkish","localizedName":"Türkçe","direction":"ltr","bcp47":"tr"},"tw":{"locale3":"twi","englishName":"Twi","localizedName":"Twi","direction":"ltr","fallbackLocales":["ak"],"bcp47":"tw"},"uk":{"locale3":"ukr","englishName":"Ukrainian","localizedName":"Українська","direction":"ltr","bcp47":"uk"},"ur":{"locale3":"urd","englishName":"Urdu","localizedName":"اردو","direction":"rtl","bcp47":"ur"},"uz":{"locale3":"uzb","englishName":"Uzbek","localizedName":"ЎзбекЎзбек тили","direction":"ltr","bcp47":"uz"},"vi":{"locale3":"vie","englishName":"Vietnamese","localizedName":"Tiếng Việt","direction":"ltr","bcp47":"vi"},"yo":{"locale3":"yor","englishName":"Yoruba","localizedName":"Yorùbá","direction":"ltr","bcp47":"yo"},"zh_CN":{"locale3":"zho","englishName":"Chinese, Simplified","localizedName":"中文 (中国)","direction":"ltr","bcp47":"zh"},"zh_TW":{"englishName":"Chinese, Traditional","localizedName":"中文 (台灣)","direction":"ltr","bcp47":"zh"},"zu":{"locale3":"zul","englishName":"Zulu","localizedName":"isiZulu","direction":"ltr","bcp47":"zu"}};
  window.phet.chipper.thirdPartyLicenseEntries = {
  "lib": {
    "almond-0.2.9.js": {
      "text": [
        "Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved."
      ],
      "projectURL": "https://github.com/jrburke/almond",
      "license": "The MIT License",
      "notes": "Allows a RequireJS-based simulation to run in its compiled (smaller, faster) form",
      "licenseText": [
        "MIT License",
        "-----------",
        "",
        "Copyright (c) 2010-2011, The Dojo Foundation",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE."
      ]
    },
    "base64-js-1.2.0.js": {
      "text": [
        "Copyright (c) 2014"
      ],
      "license": "The MIT License",
      "projectURL": "https://github.com/beatgammit/base64-js",
      "notes": "For converting typed arrays to base64 (helps converting encoded SVG data URLs)",
      "licenseText": [
        "The MIT License (MIT)",
        "",
        "Copyright (c) 2014",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE.",
        ""
      ]
    },
    "FileSaver-b8054a2.js": {
      "text": [
        "Copyright (c) 2015 Eli Grey. (http://eligrey.com)"
      ],
      "license": "The MIT License",
      "projectURL": "https://github.com/eligrey/FileSaver.js",
      "notes": "Used for saving screenshot images",
      "licenseText": [
        "Copyright © 2014 Eli Grey.",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
        ""
      ]
    },
    "font-awesome-4.5.0": {
      "text": [
        "Created by Dave Gandy"
      ],
      "license": "Font Awesome licensed under SIL OFL 1.1 · Code licensed under MIT License · Documentation licensed under CC BY 3.0",
      "projectURL": "http://fontawesome.io/",
      "notes": "Provides shapes and icons for phet-io wrappers, SVG for icons in FontAwesomeNode",
      "licenseText": [
        "Copyright (c) 2013, Dave Gandy - http://fontawesome.io",
        "with Reserved Font Name Font Awesome.",
        "",
        "This Font Software is licensed under the SIL Open Font License, Version 1.1.",
        "This license is copied below, and is also available with a FAQ at:",
        "http://scripts.sil.org/OFL",
        "",
        "",
        "-----------------------------------------------------------",
        "SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007",
        "-----------------------------------------------------------",
        "",
        "PREAMBLE",
        "The goals of the Open Font License (OFL) are to stimulate worldwide",
        "development of collaborative font projects, to support the font creation",
        "efforts of academic and linguistic communities, and to provide a free and",
        "open framework in which fonts may be shared and improved in partnership",
        "with others.",
        "",
        "The OFL allows the licensed fonts to be used, studied, modified and",
        "redistributed freely as long as they are not sold by themselves. The",
        "fonts, including any derivative works, can be bundled, embedded,",
        "redistributed and/or sold with any software provided that any reserved",
        "names are not used by derivative works. The fonts and derivatives,",
        "however, cannot be released under any other type of license. The",
        "requirement for fonts to remain under this license does not apply",
        "to any document created using the fonts or their derivatives.",
        "",
        "DEFINITIONS",
        "\"Font Software\" refers to the set of files released by the Copyright",
        "Holder(s) under this license and clearly marked as such. This may",
        "include source files, build scripts and documentation.",
        "",
        "\"Reserved Font Name\" refers to any names specified as such after the",
        "copyright statement(s).",
        "",
        "\"Original Version\" refers to the collection of Font Software components as",
        "distributed by the Copyright Holder(s).",
        "",
        "\"Modified Version\" refers to any derivative made by adding to, deleting,",
        "or substituting -- in part or in whole -- any of the components of the",
        "Original Version, by changing formats or by porting the Font Software to a",
        "new environment.",
        "",
        "\"Author\" refers to any designer, engineer, programmer, technical",
        "writer or other person who contributed to the Font Software.",
        "",
        "PERMISSION & CONDITIONS",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of the Font Software, to use, study, copy, merge, embed, modify,",
        "redistribute, and sell modified and unmodified copies of the Font",
        "Software, subject to the following conditions:",
        "",
        "1) Neither the Font Software nor any of its individual components,",
        "in Original or Modified Versions, may be sold by itself.",
        "",
        "2) Original or Modified Versions of the Font Software may be bundled,",
        "redistributed and/or sold with any software, provided that each copy",
        "contains the above copyright notice and this license. These can be",
        "included either as stand-alone text files, human-readable headers or",
        "in the appropriate machine-readable metadata fields within text or",
        "binary files as long as those fields can be easily viewed by the user.",
        "",
        "3) No Modified Version of the Font Software may use the Reserved Font",
        "Name(s) unless explicit written permission is granted by the corresponding",
        "Copyright Holder. This restriction only applies to the primary font name as",
        "presented to the users.",
        "",
        "4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font",
        "Software shall not be used to promote, endorse or advertise any",
        "Modified Version, except to acknowledge the contribution(s) of the",
        "Copyright Holder(s) and the Author(s) or with their explicit written",
        "permission.",
        "",
        "5) The Font Software, modified or unmodified, in part or in whole,",
        "must be distributed entirely under this license, and must not be",
        "distributed under any other license. The requirement for fonts to",
        "remain under this license does not apply to any document created",
        "using the Font Software.",
        "",
        "TERMINATION",
        "This license becomes null and void if any of the above conditions are",
        "not met.",
        "",
        "DISCLAIMER",
        "THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT",
        "OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE",
        "COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,",
        "INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL",
        "DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING",
        "FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM",
        "OTHER DEALINGS IN THE FONT SOFTWARE.",
        ""
      ]
    },
    "game-up-camera-1.0.0.js": {
      "text": [
        "Copyright (c) BrainPOP"
      ],
      "license": "MIT",
      "projectURL": "https://github.com/phetsims/sherpa/blob/master/lib/game-up-camera-1.0.0.js",
      "notes": "Allows a simulation to return a snapshot to BrainPOP/GameUp/SnapThought",
      "licenseText": [
        "The MIT License (MIT) Copyright (c) 2016 BrainPOP",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "himalaya-0.2.7.js": {
      "text": [
        "Copyright (c) 2015, Chris Andrejewski <christopher.andrejewski@gmail.com>"
      ],
      "license": "ISC License",
      "projectURL": "https://github.com/andrejewski/himalaya",
      "notes": "Used for HTML parsing in simulations, to sanitize/handle rich HTML text",
      "licenseText": [
        "Copyright (c) 2015, Chris Andrejewski <christopher.andrejewski@gmail.com>",
        "",
        "Permission to use, copy, modify, and/or distribute this software for any",
        "purpose with or without fee is hereby granted, provided that the above",
        "copyright notice and this permission notice appear in all copies.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES",
        "WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF",
        "MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR",
        "ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES",
        "WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN",
        "ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF",
        "OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
        ""
      ]
    },
    "jama-1.0.2": {
      "text": [
        "a basic linear algebra package for Java."
      ],
      "license": "Public Domain",
      "projectURL": "http://math.nist.gov/javanumerics/jama/",
      "notes": "A derived work (certain ported and modified files) is used in Dot, mainly for matrix decompositions. Used in assorted simulations.",
      "licenseText": [
        "Public Domain",
        "",
        "Copyright Notice This software is a cooperative product of The MathWorks and the National Institute of Standards and Technology (NIST) which has been released to the public domain. ",
        "Neither The MathWorks nor NIST assumes any responsibility whatsoever for its use by other parties, and makes no guarantees, expressed or implied, about its quality, reliability, or any other characteristic."
      ]
    },
    "jquery-2.1.0.js": {
      "text": [
        "Copyright (c) 2005, 2014 jQuery Foundation, Inc. and other contributors",
        "(includes Sizzle.js, http://sizzlejs.com)"
      ],
      "license": "The MIT License",
      "projectURL": "http://jquery.com",
      "notes": "Facilitates interaction with browser DOM elements, mainly used in Scenery",
      "licenseText": [
        "Copyright 2013 jQuery Foundation and other contributors",
        "http://jquery.com/",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of this software and associated documentation files (the",
        "\"Software\"), to deal in the Software without restriction, including",
        "without limitation the rights to use, copy, modify, merge, publish,",
        "distribute, sublicense, and/or sell copies of the Software, and to",
        "permit persons to whom the Software is furnished to do so, subject to",
        "the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
        "LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
        "OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
        "WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "lodash-4.17.4.js": {
      "text": [
        "Lodash <https://lodash.com/>",
        "Copyright JS Foundation and other contributors <https://js.foundation/>",
        "Released under MIT license <https://lodash.com/license>",
        "Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>",
        "Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors"
      ],
      "license": "The MIT License",
      "projectURL": "http://lodash.com",
      "notes": "Adds common data structure operations such as sorting, grouping, etc.",
      "licenseText": [
        "Copyright JS Foundation and other contributors <https://js.foundation/>",
        "",
        "Based on Underscore.js, copyright Jeremy Ashkenas,",
        "DocumentCloud and Investigative Reporters & Editors <http://underscorejs.org/>",
        "",
        "This software consists of voluntary contributions made by many",
        "individuals. For exact contribution history, see the revision history",
        "available at https://github.com/lodash/lodash",
        "",
        "The following license applies to all parts of this software except as",
        "documented below:",
        "",
        "====",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining",
        "a copy of this software and associated documentation files (the",
        "\"Software\"), to deal in the Software without restriction, including",
        "without limitation the rights to use, copy, modify, merge, publish,",
        "distribute, sublicense, and/or sell copies of the Software, and to",
        "permit persons to whom the Software is furnished to do so, subject to",
        "the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",
        "MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE",
        "LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION",
        "OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION",
        "WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
        "",
        "====",
        "",
        "Copyright and related rights for sample code are waived via CC0. Sample",
        "code is defined as all source code displayed within the prose of the",
        "documentation.",
        "",
        "CC0: http://creativecommons.org/publicdomain/zero/1.0/",
        "",
        "====",
        "",
        "Files located in the node_modules and vendor directories are externally",
        "maintained libraries used by this software which have their own",
        "licenses; we recommend you read them, as their terms may differ from the",
        "terms above."
      ]
    },
    "pegjs-0.7.0.js": {
      "text": [
        "Copyright (c) 2010-2012 David Majda"
      ],
      "license": "The MIT License",
      "projectURL": "http://pegjs.majda.cz",
      "notes": "Parser Generator for JavaScript. SVG path parsing in Kite",
      "licenseText": [
        "Copyright (c) 2010-2012 David Majda",
        "",
        "Permission is hereby granted, free of charge, to any person",
        "obtaining a copy of this software and associated documentation",
        "files (the \"Software\"), to deal in the Software without",
        "restriction, including without limitation the rights to use,",
        "copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the",
        "Software is furnished to do so, subject to the following",
        "conditions:",
        "",
        "The above copyright notice and this permission notice shall be",
        "included in all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,",
        "EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES",
        "OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND",
        "NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT",
        "HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,",
        "WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING",
        "FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR",
        "OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "seedrandom-2.4.2.js": {
      "text": [
        "Copyright 2015 David Bau."
      ],
      "license": "MIT",
      "projectURL": "https://github.com/davidbau/seedrandom",
      "notes": "seeded random number generator for Javascript",
      "licenseText": [
        "Copyright 2015 David Bau.",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated",
        "documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the",
        "rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit",
        "persons to whom the Software is furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the",
        "Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE",
        "WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR",
        "COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR",
        "OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
      ]
    },
    "text-2.0.12.js": {
      "text": [
        "Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved."
      ],
      "license": "The MIT License",
      "projectURL": "http://github.com/requirejs/text",
      "notes": "Loads strings to be displayed in the sim, including internationalized strings.",
      "licenseText": [
        "MIT License",
        "-----------",
        "",
        "Copyright (c) 2010-2011, The Dojo Foundation",
        "",
        "Permission is hereby granted, free of charge, to any person obtaining a copy",
        "of this software and associated documentation files (the \"Software\"), to deal",
        "in the Software without restriction, including without limitation the rights",
        "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
        "copies of the Software, and to permit persons to whom the Software is",
        "furnished to do so, subject to the following conditions:",
        "",
        "The above copyright notice and this permission notice shall be included in",
        "all copies or substantial portions of the Software.",
        "",
        "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
        "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
        "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
        "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
        "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
        "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
        "THE SOFTWARE."
      ]
    },
    "TextEncoderLite-3c9f6f0.js": {
      "text": [
        "AJ ONeal <awesome@coolaj86.com>"
      ],
      "license": "Apache 2.0",
      "projectURL": "https://github.com/coolaj86/TextEncoderLite",
      "notes": "Used for encoding unicode strings to typed arrays, for Scenery foreign object rasterization",
      "licenseText": [
        "",
        "                                 Apache License",
        "                           Version 2.0, January 2011",
        "                        http://www.apache.org/licenses/",
        "",
        "   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION",
        "",
        "   1. Definitions.",
        "",
        "      \"License\" shall mean the terms and conditions for use, reproduction,",
        "      and distribution as defined by Sections 1 through 9 of this document.",
        "",
        "      \"Licensor\" shall mean the copyright owner or entity authorized by",
        "      the copyright owner that is granting the License.",
        "",
        "      \"Legal Entity\" shall mean the union of the acting entity and all",
        "      other entities that control, are controlled by, or are under common",
        "      control with that entity. For the purposes of this definition,",
        "      \"control\" means (i) the power, direct or indirect, to cause the",
        "      direction or management of such entity, whether by contract or",
        "      otherwise, or (ii) ownership of fifty percent (50%) or more of the",
        "      outstanding shares, or (iii) beneficial ownership of such entity.",
        "",
        "      \"You\" (or \"Your\") shall mean an individual or Legal Entity",
        "      exercising permissions granted by this License.",
        "",
        "      \"Source\" form shall mean the preferred form for making modifications,",
        "      including but not limited to software source code, documentation",
        "      source, and configuration files.",
        "",
        "      \"Object\" form shall mean any form resulting from mechanical",
        "      transformation or translation of a Source form, including but",
        "      not limited to compiled object code, generated documentation,",
        "      and conversions to other media types.",
        "",
        "      \"Work\" shall mean the work of authorship, whether in Source or",
        "      Object form, made available under the License, as indicated by a",
        "      copyright notice that is included in or attached to the work",
        "      (an example is provided in the Appendix below).",
        "",
        "      \"Derivative Works\" shall mean any work, whether in Source or Object",
        "      form, that is based on (or derived from) the Work and for which the",
        "      editorial revisions, annotations, elaborations, or other modifications",
        "      represent, as a whole, an original work of authorship. For the purposes",
        "      of this License, Derivative Works shall not include works that remain",
        "      separable from, or merely link (or bind by name) to the interfaces of,",
        "      the Work and Derivative Works thereof.",
        "",
        "      \"Contribution\" shall mean any work of authorship, including",
        "      the original version of the Work and any modifications or additions",
        "      to that Work or Derivative Works thereof, that is intentionally",
        "      submitted to Licensor for inclusion in the Work by the copyright owner",
        "      or by an individual or Legal Entity authorized to submit on behalf of",
        "      the copyright owner. For the purposes of this definition, \"submitted\"",
        "      means any form of electronic, verbal, or written communication sent",
        "      to the Licensor or its representatives, including but not limited to",
        "      communication on electronic mailing lists, source code control systems,",
        "      and issue tracking systems that are managed by, or on behalf of, the",
        "      Licensor for the purpose of discussing and improving the Work, but",
        "      excluding communication that is conspicuously marked or otherwise",
        "      designated in writing by the copyright owner as \"Not a Contribution.\"",
        "",
        "      \"Contributor\" shall mean Licensor and any individual or Legal Entity",
        "      on behalf of whom a Contribution has been received by Licensor and",
        "      subsequently incorporated within the Work.",
        "",
        "   2. Grant of Copyright License. Subject to the terms and conditions of",
        "      this License, each Contributor hereby grants to You a perpetual,",
        "      worldwide, non-exclusive, no-charge, royalty-free, irrevocable",
        "      copyright license to reproduce, prepare Derivative Works of,",
        "      publicly display, publicly perform, sublicense, and distribute the",
        "      Work and such Derivative Works in Source or Object form.",
        "",
        "   3. Grant of Patent License. Subject to the terms and conditions of",
        "      this License, each Contributor hereby grants to You a perpetual,",
        "      worldwide, non-exclusive, no-charge, royalty-free, irrevocable",
        "      (except as stated in this section) patent license to make, have made,",
        "      use, offer to sell, sell, import, and otherwise transfer the Work,",
        "      where such license applies only to those patent claims licensable",
        "      by such Contributor that are necessarily infringed by their",
        "      Contribution(s) alone or by combination of their Contribution(s)",
        "      with the Work to which such Contribution(s) was submitted. If You",
        "      institute patent litigation against any entity (including a",
        "      cross-claim or counterclaim in a lawsuit) alleging that the Work",
        "      or a Contribution incorporated within the Work constitutes direct",
        "      or contributory patent infringement, then any patent licenses",
        "      granted to You under this License for that Work shall terminate",
        "      as of the date such litigation is filed.",
        "",
        "   4. Redistribution. You may reproduce and distribute copies of the",
        "      Work or Derivative Works thereof in any medium, with or without",
        "      modifications, and in Source or Object form, provided that You",
        "      meet the following conditions:",
        "",
        "      (a) You must give any other recipients of the Work or",
        "          Derivative Works a copy of this License; and",
        "",
        "      (b) You must cause any modified files to carry prominent notices",
        "          stating that You changed the files; and",
        "",
        "      (c) You must retain, in the Source form of any Derivative Works",
        "          that You distribute, all copyright, patent, trademark, and",
        "          attribution notices from the Source form of the Work,",
        "          excluding those notices that do not pertain to any part of",
        "          the Derivative Works; and",
        "",
        "      (d) If the Work includes a \"NOTICE\" text file as part of its",
        "          distribution, then any Derivative Works that You distribute must",
        "          include a readable copy of the attribution notices contained",
        "          within such NOTICE file, excluding those notices that do not",
        "          pertain to any part of the Derivative Works, in at least one",
        "          of the following places: within a NOTICE text file distributed",
        "          as part of the Derivative Works; within the Source form or",
        "          documentation, if provided along with the Derivative Works; or,",
        "          within a display generated by the Derivative Works, if and",
        "          wherever such third-party notices normally appear. The contents",
        "          of the NOTICE file are for informational purposes only and",
        "          do not modify the License. You may add Your own attribution",
        "          notices within Derivative Works that You distribute, alongside",
        "          or as an addendum to the NOTICE text from the Work, provided",
        "          that such additional attribution notices cannot be construed",
        "          as modifying the License.",
        "",
        "      You may add Your own copyright statement to Your modifications and",
        "      may provide additional or different license terms and conditions",
        "      for use, reproduction, or distribution of Your modifications, or",
        "      for any such Derivative Works as a whole, provided Your use,",
        "      reproduction, and distribution of the Work otherwise complies with",
        "      the conditions stated in this License.",
        "",
        "   5. Submission of Contributions. Unless You explicitly state otherwise,",
        "      any Contribution intentionally submitted for inclusion in the Work",
        "      by You to the Licensor shall be under the terms and conditions of",
        "      this License, without any additional terms or conditions.",
        "      Notwithstanding the above, nothing herein shall supersede or modify",
        "      the terms of any separate license agreement you may have executed",
        "      with Licensor regarding such Contributions.",
        "",
        "   6. Trademarks. This License does not grant permission to use the trade",
        "      names, trademarks, service marks, or product names of the Licensor,",
        "      except as required for reasonable and customary use in describing the",
        "      origin of the Work and reproducing the content of the NOTICE file.",
        "",
        "   7. Disclaimer of Warranty. Unless required by applicable law or",
        "      agreed to in writing, Licensor provides the Work (and each",
        "      Contributor provides its Contributions) on an \"AS IS\" BASIS,",
        "      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or",
        "      implied, including, without limitation, any warranties or conditions",
        "      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A",
        "      PARTICULAR PURPOSE. You are solely responsible for determining the",
        "      appropriateness of using or redistributing the Work and assume any",
        "      risks associated with Your exercise of permissions under this License.",
        "",
        "   8. Limitation of Liability. In no event and under no legal theory,",
        "      whether in tort (including negligence), contract, or otherwise,",
        "      unless required by applicable law (such as deliberate and grossly",
        "      negligent acts) or agreed to in writing, shall any Contributor be",
        "      liable to You for damages, including any direct, indirect, special,",
        "      incidental, or consequential damages of any character arising as a",
        "      result of this License or out of the use or inability to use the",
        "      Work (including but not limited to damages for loss of goodwill,",
        "      work stoppage, computer failure or malfunction, or any and all",
        "      other commercial damages or losses), even if such Contributor",
        "      has been advised of the possibility of such damages.",
        "",
        "   9. Accepting Warranty or Additional Liability. While redistributing",
        "      the Work or Derivative Works thereof, You may choose to offer,",
        "      and charge a fee for, acceptance of support, warranty, indemnity,",
        "      or other liability obligations and/or rights consistent with this",
        "      License. However, in accepting such obligations, You may act only",
        "      on Your own behalf and on Your sole responsibility, not on behalf",
        "      of any other Contributor, and only if You agree to indemnify,",
        "      defend, and hold each Contributor harmless for any liability",
        "      incurred by, or claims asserted against, such Contributor by reason",
        "      of your accepting any such warranty or additional liability.",
        "",
        "   END OF TERMS AND CONDITIONS",
        "",
        "   APPENDIX: How to apply the Apache License to your work.",
        "",
        "      To apply the Apache License to your work, attach the following",
        "      boilerplate notice, with the fields enclosed by brackets \"[]\"",
        "      replaced with your own identifying information. (Don't include",
        "      the brackets!)  The text should be enclosed in the appropriate",
        "      comment syntax for the file format. We also recommend that a",
        "      file or class name and description of purpose be included on the",
        "      same \"printed page\" as the copyright notice for easier",
        "      identification within third-party archives.",
        "",
        "   Copyright [yyyy] [name of copyright owner]",
        "",
        "   Licensed under the Apache License, Version 2.0 (the \"License\");",
        "   you may not use this file except in compliance with the License.",
        "   You may obtain a copy of the License at",
        "",
        "       http://www.apache.org/licenses/LICENSE-2.0",
        "",
        "   Unless required by applicable law or agreed to in writing, software",
        "   distributed under the License is distributed on an \"AS IS\" BASIS,",
        "   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
        "   See the License for the specific language governing permissions and",
        "   limitations under the License.",
        ""
      ]
    }
  },
  "images": {
    "BUILD_AN_ATOM/scale.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Sharon Siman-Tov"
    },
    "BUILD_AN_ATOM/atom_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Sharon Siman-Tov"
    },
    "BUILD_AN_ATOM/atom_icon_small.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "BUILD_AN_ATOM/mass_charge_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "BUILD_AN_ATOM/periodic_table_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "BUILD_AN_ATOM/question_mark_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "BUILD_AN_ATOM/symbol_question_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "BUILD_AN_ATOM/game_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Sharon Siman-Tov"
    },
    "BUILD_AN_ATOM/game_icon_small.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco and Sharon Siman-Tov"
    },
    "BRAND/logo.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": ""
    },
    "BRAND/logo-on-white.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": ""
    },
    "JOIST/keyboard-icon.png": {
      "text": [
        "Copyright 2016 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar based on original icon from Font Awesome"
    },
    "JOIST/keyboard-icon-on-white.png": {
      "text": [
        "Copyright 2016 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Amy Rouinfar based on original icon from Font Awesome"
    },
    "BUILD_AN_ATOM/element_icon.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by Sharon Siman-Tov"
    },
    "BUILD_AN_ATOM/element_icon_small.png": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco and Sharon Siman-Tov"
    }
  },
  "audio": {
    "VIBE/empty.mp3": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "required for iOS+Safari workaround, see Sound.js"
    },
    "VEGAS/ding.mp3": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "VEGAS/ding.ogg": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "VEGAS/boing.mp3": {
      "text": [
        "Public Domain"
      ],
      "projectURL": "http://freesound.org",
      "license": "Public Domain",
      "notes": "Creative Commons 0 license, modified by John B"
    },
    "VEGAS/boing.ogg": {
      "text": [
        "Public Domain"
      ],
      "projectURL": "http://freesound.org",
      "license": "Public Domain",
      "notes": "Creative Commons 0 license, modified by John B"
    },
    "VEGAS/trumpet.mp3": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "VEGAS/trumpet.ogg": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by John Blanco"
    },
    "VEGAS/cheer.mp3": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by the PhET Team"
    },
    "VEGAS/cheer.ogg": {
      "text": [
        "Copyright 2002-2015 CLB Sáng tạo trẻ"
      ],
      "projectURL": "http://phet.colorado.edu",
      "license": "contact phethelp@colorado.edu",
      "notes": "created by the PhET Team"
    }
  }
};
  window.phet.chipper.dependencies = {
  "comment": "# build-an-atom 1.6.34 Tue Jun 10 2025 11:47:17 GMT-0600 (Mountain Daylight Time)",
  "assert": {
    "sha": "5c3f92048a9c2ffd6df8ede54fd64f1f7a7e4ef2",
    "branch": "HEAD"
  },
  "axon": {
    "sha": "fd28f6a09e20467383bd261e423eb34faa7e2a3a",
    "branch": "HEAD"
  },
  "babel": {
    "sha": "4a3fe3743125cad6b1f9c480e8ba69258e29ef9a",
    "branch": "main"
  },
  "brand": {
    "sha": "87aad2110d0f32cf9198de430cde044a599593c5",
    "branch": "HEAD"
  },
  "build-an-atom": {
    "sha": "d842aee83000a50b68fc38b890c5d66e567ab1ad",
    "branch": "HEAD"
  },
  "chipper": {
    "sha": "05758f81b0b2f51e951ab299ff250cfc5d2f9ff4",
    "branch": "HEAD"
  },
  "dot": {
    "sha": "f7d9de8b5650a10126d3f8755a98cf64a0acc93c",
    "branch": "HEAD"
  },
  "joist": {
    "sha": "b36a363e22349a8aee93b0796e4f0a80c15f36f7",
    "branch": "HEAD"
  },
  "kite": {
    "sha": "41ac3b7a27f0313bcafb9eb0fde1c1860a5c2cc6",
    "branch": "HEAD"
  },
  "phet-core": {
    "sha": "461e373526f826064d715cdee8545a1460c3d969",
    "branch": "HEAD"
  },
  "phetcommon": {
    "sha": "36a46cabaff6a4b519b9844fb42a978905aa4482",
    "branch": "HEAD"
  },
  "phetmarks": {
    "sha": "6b33d85cec84c8a1f0040e4ee530f15be9475203",
    "branch": "HEAD"
  },
  "query-string-machine": {
    "sha": "c74e454ec68033a9546b8181d4d962eb8ceef81f",
    "branch": "HEAD"
  },
  "scenery": {
    "sha": "120af28edb719b9ae531ada95189515b919810a3",
    "branch": "HEAD"
  },
  "scenery-phet": {
    "sha": "df075d2ea149346cbc521fd707979291a89fab5e",
    "branch": "HEAD"
  },
  "sherpa": {
    "sha": "f1937ecb1c2fd45be748815eddeb89ff6a7ad537",
    "branch": "HEAD"
  },
  "shred": {
    "sha": "f0010c79cf374a4fc44b53689b37b3cac8cfa90b",
    "branch": "HEAD"
  },
  "sun": {
    "sha": "e1d62999cacb686393a8338d5dda4e19f5160ba4",
    "branch": "HEAD"
  },
  "tandem": {
    "sha": "29cd4f635cd74ace76ffabc575ab92bef491b680",
    "branch": "HEAD"
  },
  "vegas": {
    "sha": "d5f8b3d193019827615dd445f8a2219c1493ebd1",
    "branch": "HEAD"
  },
  "vibe": {
    "sha": "6833849cc1fa836d566b60f02539472d5acc155e",
    "branch": "HEAD"
  }
};
  window.phet.chipper.strings = {"vi":{"SHRED/hydrogen":"‪Hydrogen‬","SHRED/helium":"‪Helium‬","SHRED/lithium":"‪Lithium‬","SHRED/beryllium":"‪Beryllium‬","SHRED/boron":"‪Bor‬","SHRED/carbon":"‪Carbon‬","SHRED/nitrogen":"‪Nitrogen‬","SHRED/oxygen":"‪Oxygen‬","SHRED/fluorine":"‪Fluor‬","SHRED/neon":"‪Neon‬","SHRED/sodium":"‪Natrium‬","SHRED/magnesium":"‪Magnesium‬","SHRED/aluminum":"‪Nhôm‬","SHRED/silicon":"‪Silic‬","SHRED/phosphorus":"‪Phosphor‬","SHRED/sulfur":"‪Sulfur‬","SHRED/chlorine":"‪Clor‬","SHRED/argon":"‪Argon‬","SHRED/potassium":"‪Potassium‬","SHRED/calcium":"‪Calcium‬","SHRED/scandium":"‪Scandium‬","SHRED/titanium":"‪Titanium‬","SHRED/vanadium":"‪Vanadium‬","SHRED/chromium":"‪Chrom‬","SHRED/manganese":"‪Mangan‬","SHRED/iron":"‪Sắt‬","SHRED/cobalt":"‪Cobalt‬","SHRED/nickel":"‪Nickel‬","SHRED/copper":"‪Đồng‬","SHRED/zinc":"‪Kẽm‬","SHRED/gallium":"‪Gallium‬","SHRED/germanium":"‪Germanium‬","SHRED/arsenic":"‪Arsen‬","SHRED/selenium":"‪Selenium‬","SHRED/bromine":"‪Brom‬","SHRED/krypton":"‪Krypton‬","SHRED/rubidium":"‪Rubidium‬","SHRED/strontium":"‪Strontium‬","SHRED/yttrium":"‪Yttrium‬","SHRED/zirconium":"‪Zirconium‬","SHRED/niobium":"‪Niobium‬","SHRED/molybdenum":"‪Molybdenum‬","SHRED/technetium":"‪Technetium‬","SHRED/ruthenium":"‪Ruthenium‬","SHRED/rhodium":"‪Rhodium‬","SHRED/palladium":"‪Palladium‬","SHRED/silver":"‪Bạc‬","SHRED/cadmium":"‪Cadmium‬","SHRED/indium":"‪Indium‬","SHRED/tin":"‪Thiếc‬","SHRED/antimony":"‪Antimony‬","SHRED/tellurium":"‪Tellurium‬","SHRED/iodine":"‪Iod‬","SHRED/xenon":"‪Xenon‬","SHRED/cesium":"‪Cesium‬","SHRED/barium":"‪Barium‬","SHRED/lanthanum":"‪Lanthanum‬","SHRED/cerium":"‪Cerium‬","SHRED/praseodymium":"‪Praseodymium‬","SHRED/neodymium":"‪Neodymium‬","SHRED/promethium":"‪Promethium‬","SHRED/samarium":"‪Samarium‬","SHRED/europium":"‪Europium‬","SHRED/gadolinium":"‪Gadolinium‬","SHRED/terbium":"‪Terbium‬","SHRED/dysprosium":"‪Dysprosium‬","SHRED/holmium":"‪Holmium‬","SHRED/erbium":"‪Erbium‬","SHRED/thulium":"‪Thulium‬","SHRED/ytterbium":"‪Ytterbium‬","SHRED/lutetium":"‪Lutetium‬","SHRED/hafnium":"‪Hafnium‬","SHRED/tantalum":"‪Tantalum‬","SHRED/tungsten":"‪Tungsten‬","SHRED/rhenium":"‪Rhenium‬","SHRED/osmium":"‪Osmium‬","SHRED/iridium":"‪Iridium‬","SHRED/platinum":"‪Platinum‬","SHRED/gold":"‪Vàng‬","SHRED/mercury":"‪Thuỷ ngân‬","SHRED/thallium":"‪Thallium‬","SHRED/lead":"‪Chì‬","SHRED/bismuth":"‪Bismuth‬","SHRED/polonium":"‪Polonium‬","SHRED/astatine":"‪Astatine‬","SHRED/radon":"‪Radon‬","SHRED/francium":"‪Francium‬","SHRED/radium":"‪Radium‬","SHRED/actinium":"‪Actinium‬","SHRED/thorium":"‪Thorium‬","SHRED/protactinium":"‪Protactinium‬","SHRED/uranium":"‪Uranium‬","SHRED/neptunium":"‪Neptunium‬","SHRED/plutonium":"‪Plutonium‬","SHRED/americium":"‪Americium‬","SHRED/curium":"‪Curium‬","SHRED/berkelium":"‪Berkelium‬","SHRED/californium":"‪Californium‬","SHRED/einsteinium":"‪Einsteinium‬","SHRED/fermium":"‪Fermium‬","SHRED/mendelevium":"‪Mendelevium‬","SHRED/nobelium":"‪Nobelium‬","SHRED/lawrencium":"‪Lawrencium‬","SHRED/rutherfordium":"‪Rutherfordium‬","SHRED/dubnium":"‪Dubnium‬","SHRED/seaborgium":"‪Seaborgium‬","SHRED/bohrium":"‪Bohrium‬","SHRED/hassium":"‪Hassium‬","SHRED/meitnerium":"‪Meitnerium‬","SHRED/darmstadtium":"‪Darmstadtium‬","SHRED/roentgenium":"‪Roentgenium‬","SHRED/ununbium":"‪Copernicium‬","SHRED/ununtrium":"‪Nihonium‬","SHRED/flerovium":"‪Flerovium‬","SHRED/ununpentium":"‪Moscovium‬","SHRED/livermorium":"‪Livermorium‬","SHRED/ununseptium":"‪Tennessine‬","SHRED/ununoctium":"‪Oganesson‬","SHRED/minusSignIon":"‪Ion-‬","SHRED/neutralAtom":"‪Nguyên tử trung hoà‬","SHRED/positiveSignIon":"‪Ion+‬","SHRED/stable":"‪Bền‬","SHRED/unstable":"‪Không bền‬","SHRED/protonsColon":"‪Proton‬","SHRED/neutronsColon":"‪Neutron‬","SHRED/electronsColon":"‪Electron‬","SCENERY_PHET/ResetAllButton.name":"‪Reset All‬","BUILD_AN_ATOM/element":"‪Nguyên tố‬","BUILD_AN_ATOM/neutralSlashIon":"‪Trung hoà/Ion‬","BUILD_AN_ATOM/stableSlashUnstable":"‪Bền/Không bền‬","BUILD_AN_ATOM/show":"‪Hiển thị‬","BUILD_AN_ATOM/orbits":"‪Quỹ đạo‬","BUILD_AN_ATOM/cloud":"‪Mây điện tử‬","BUILD_AN_ATOM/model":"‪Mô hình:‬","BUILD_AN_ATOM/protons":"‪Proton‬","BUILD_AN_ATOM/neutrons":"‪Neutron‬","BUILD_AN_ATOM/electrons":"‪Electron‬","BUILD_AN_ATOM/massNumber":"‪Số khối‬","BUILD_AN_ATOM/netCharge":"‪Điện tích‬","BUILD_AN_ATOM/atom":"‪Nguyên tử‬","BUILD_AN_ATOM/protonsColonPattern":"‪Protons: {0}‬","BUILD_AN_ATOM/neutronsColonPattern":"‪Neutrons: {0}‬","BUILD_AN_ATOM/electronsColonPattern":"‪Electrons: {0}‬","VEGAS/check":"‪Chấm điểm‬","VEGAS/tryAgain":"‪Thử lại‬","VEGAS/showAnswer":"‪Hiển thị câu trả lời‬","VEGAS/next":"‪Kế tiếp‬","BUILD_AN_ATOM/whatIsTheTotalCharge":"‪Tổng điện tích\nlà bao nhiêu?‬","BUILD_AN_ATOM/findTheElement":"‪Tìm Nguyên tố‬","BUILD_AN_ATOM/ion":"‪Ion‬","BUILD_AN_ATOM/neutralAtom":"‪Nguyên tử trung hoà‬","BUILD_AN_ATOM/isIt":"‪Đó là:‬","BUILD_AN_ATOM/whatIsTheMassNumber":"‪Số khối là bao nhiêu?‬","BUILD_AN_ATOM/protonsColon":"‪Proton:‬","BUILD_AN_ATOM/neutronsColon":"‪neutron:‬","BUILD_AN_ATOM/electronsColon":"‪electron:‬","VEGAS/pattern.0hours.1minutes.2seconds":"‪{0}:{1}:{2}‬","VEGAS/pattern.0minutes.1seconds":"‪{0}: {1}‬","VEGAS/keepTrying":"‪Tiếp tục‬","VEGAS/good":"‪Tốt!‬","VEGAS/great":"‪Giỏi!‬","VEGAS/excellent":"‪Tuyệt vời!‬","VEGAS/label.score.max":"‪Điểm: {0} / {1}‬","VEGAS/label.time":"‪Thời gian: {0}‬","VEGAS/yourNewBest":"‪(Kỷ lục mới!)‬","VEGAS/pattern.0yourBest":"‪(Điểm cao nhất: {0})‬","VEGAS/continue":"‪Tiếp tục‬","VEGAS/label.level":"‪Mức độ: {0}‬","VEGAS/startOver":"‪Trở lại từ đầu‬","VEGAS/label.scorePattern":"‪Điểm: {0}‬","VEGAS/pattern.0challenge.1max":"‪Câu đố {0}/{1}‬","BUILD_AN_ATOM/chooseYourGame":"‪Hãy chọn game!‬","BUILD_AN_ATOM/game":"‪Game‬","JOIST/options.title":"‪Tuỳ chọn‬","BUILD_AN_ATOM/highContrastParticles":"‪Đánh dẫu rõ các hạt","JOIST/credits.title":"Nhóm phát triển‬","JOIST/credits.leadDesign":"Quản lý dự án‪: {0}‬","JOIST/credits.softwareDevelopment":"Nhóm phát triển: {0}‬","JOIST/credits.team":"‪Thiết kế: {0}‬","JOIST/credits.contributors":"Hỗ trợ:{0}‬","JOIST/credits.qualityAssurance":"‪Đánh gia, sửa lỗi: {0}‬","JOIST/credits.graphicArts":"‪Đồ hoạ: {0}‬","JOIST/credits.translation":"‪Biên dịch‬","JOIST/credits.thanks":"‪Ngôn ngữ lập trình‬","JOIST/termsPrivacyAndLicensing":"‪Các điều khoản về sự riêng tư, cấp phép‬","JOIST/translation.credits.link":"‪Công trạng phần biên dịch‬","JOIST/thirdParty.credits.link":"‪Công trạng bên thứ ba‬","JOIST/updates.upToDate":"‪Phiên bản đã cập nhật‬","JOIST/updates.outOfDate":"‪Đã có phiên bản mới‬","JOIST/updates.checking":"‪Kiểm tra phiên bản...‬","JOIST/updates.offline":"‪Không thể kiểm tra phiên bản‬","JOIST/updates.newVersionAvailable":"‪Đã có phiên bản mới: {0}‬","JOIST/updates.yourCurrentVersion":"‪Phiên bản hiện tại: {0}‬","JOIST/updates.getUpdate":"‪Tải cập nhật...‬","JOIST/updates.noThanks":"‪Không, cám ơn‬","JOIST/versionPattern":"‪phiên bản {0}‬","JOIST/menuItem.options":"‪Tuỳ chọn...‬","JOIST/menuItem.about":"‪Thông tin...‬","JOIST/menuItem.mailInputEventsLog":"‪Mail Input Events Log‬","JOIST/menuItem.outputInputEventsLog":"‪Output Input Events Log‬","JOIST/menuItem.phetWebsite":"‪Trang thông tin…‬","JOIST/menuItem.reportAProblem":"Báo lỗi...‬","JOIST/menuItem.screenshot":"‪Ảnh chụp màn hình‬","JOIST/menuItem.fullscreen":"‪Toàn màn hình‬","JOIST/menuItem.getUpdate":"‪Kiểm tra phiên bản...‬","JOIST/menuItem.submitInputEventsLog":"‪Submit Input Events Log‬","JOIST/keyboardShortcuts.title":"‪Phím tắt‬","BUILD_AN_ATOM/symbol":"‪Ký hiệu‬","BUILD_AN_ATOM/build-an-atom.title":"‪Khám phá nguyên tử‬"},"en":{"SHRED/hydrogen":"‪Hydrogen‬","SHRED/helium":"‪Helium‬","SHRED/lithium":"‪Lithium‬","SHRED/beryllium":"‪Beryllium‬","SHRED/boron":"‪Boron‬","SHRED/carbon":"‪Carbon‬","SHRED/nitrogen":"‪Nitrogen‬","SHRED/oxygen":"‪Oxygen‬","SHRED/fluorine":"‪Fluorine‬","SHRED/neon":"‪Neon‬","SHRED/sodium":"‪Sodium‬","SHRED/magnesium":"‪Magnesium‬","SHRED/aluminum":"‪Aluminum‬","SHRED/silicon":"‪Silicon‬","SHRED/phosphorus":"‪Phosphorus‬","SHRED/sulfur":"‪Sulfur‬","SHRED/chlorine":"‪Chlorine‬","SHRED/argon":"‪Argon‬","SHRED/potassium":"‪Potassium‬","SHRED/calcium":"‪Calcium‬","SHRED/scandium":"‪Scandium‬","SHRED/titanium":"‪Titanium‬","SHRED/vanadium":"‪Vanadium‬","SHRED/chromium":"‪Chromium‬","SHRED/manganese":"‪Manganese‬","SHRED/iron":"‪Iron‬","SHRED/cobalt":"‪Cobalt‬","SHRED/nickel":"‪Nickel‬","SHRED/copper":"‪Copper‬","SHRED/zinc":"‪Zinc‬","SHRED/gallium":"‪Gallium‬","SHRED/germanium":"‪Germanium‬","SHRED/arsenic":"‪Arsenic‬","SHRED/selenium":"‪Selenium‬","SHRED/bromine":"‪Bromine‬","SHRED/krypton":"‪Krypton‬","SHRED/rubidium":"‪Rubidium‬","SHRED/strontium":"‪Strontium‬","SHRED/yttrium":"‪Yttrium‬","SHRED/zirconium":"‪Zirconium‬","SHRED/niobium":"‪Niobium‬","SHRED/molybdenum":"‪Molybdenum‬","SHRED/technetium":"‪Technetium‬","SHRED/ruthenium":"‪Ruthenium‬","SHRED/rhodium":"‪Rhodium‬","SHRED/palladium":"‪Palladium‬","SHRED/silver":"‪Silver‬","SHRED/cadmium":"‪Cadmium‬","SHRED/indium":"‪Indium‬","SHRED/tin":"‪Tin‬","SHRED/antimony":"‪Antimony‬","SHRED/tellurium":"‪Tellurium‬","SHRED/iodine":"‪Iodine‬","SHRED/xenon":"‪Xenon‬","SHRED/cesium":"‪Cesium‬","SHRED/barium":"‪Barium‬","SHRED/lanthanum":"‪Lanthanum‬","SHRED/cerium":"‪Cerium‬","SHRED/praseodymium":"‪Praseodymium‬","SHRED/neodymium":"‪Neodymium‬","SHRED/promethium":"‪Promethium‬","SHRED/samarium":"‪Samarium‬","SHRED/europium":"‪Europium‬","SHRED/gadolinium":"‪Gadolinium‬","SHRED/terbium":"‪Terbium‬","SHRED/dysprosium":"‪Dysprosium‬","SHRED/holmium":"‪Holmium‬","SHRED/erbium":"‪Erbium‬","SHRED/thulium":"‪Thulium‬","SHRED/ytterbium":"‪Ytterbium‬","SHRED/lutetium":"‪Lutetium‬","SHRED/hafnium":"‪Hafnium‬","SHRED/tantalum":"‪Tantalum‬","SHRED/tungsten":"‪Tungsten‬","SHRED/rhenium":"‪Rhenium‬","SHRED/osmium":"‪Osmium‬","SHRED/iridium":"‪Iridium‬","SHRED/platinum":"‪Platinum‬","SHRED/gold":"‪Gold‬","SHRED/mercury":"‪Mercury‬","SHRED/thallium":"‪Thallium‬","SHRED/lead":"‪Lead‬","SHRED/bismuth":"‪Bismuth‬","SHRED/polonium":"‪Polonium‬","SHRED/astatine":"‪Astatine‬","SHRED/radon":"‪Radon‬","SHRED/francium":"‪Francium‬","SHRED/radium":"‪Radium‬","SHRED/actinium":"‪Actinium‬","SHRED/thorium":"‪Thorium‬","SHRED/protactinium":"‪Protactinium‬","SHRED/uranium":"‪Uranium‬","SHRED/neptunium":"‪Neptunium‬","SHRED/plutonium":"‪Plutonium‬","SHRED/americium":"‪Americium‬","SHRED/curium":"‪Curium‬","SHRED/berkelium":"‪Berkelium‬","SHRED/californium":"‪Californium‬","SHRED/einsteinium":"‪Einsteinium‬","SHRED/fermium":"‪Fermium‬","SHRED/mendelevium":"‪Mendelevium‬","SHRED/nobelium":"‪Nobelium‬","SHRED/lawrencium":"‪Lawrencium‬","SHRED/rutherfordium":"‪Rutherfordium‬","SHRED/dubnium":"‪Dubnium‬","SHRED/seaborgium":"‪Seaborgium‬","SHRED/bohrium":"‪Bohrium‬","SHRED/hassium":"‪Hassium‬","SHRED/meitnerium":"‪Meitnerium‬","SHRED/darmstadtium":"‪Darmstadtium‬","SHRED/roentgenium":"‪Roentgenium‬","SHRED/ununbium":"‪Ununbium‬","SHRED/ununtrium":"‪Ununtrium‬","SHRED/flerovium":"‪Flerovium‬","SHRED/ununpentium":"‪Ununpentium‬","SHRED/livermorium":"‪Livermorium‬","SHRED/ununseptium":"‪Ununseptium‬","SHRED/ununoctium":"‪Ununoctium‬","SHRED/minusSignIon":"‪- Ion‬","SHRED/neutralAtom":"‪Neutral Atom‬","SHRED/positiveSignIon":"‪+ Ion‬","SHRED/stable":"‪Stable‬","SHRED/unstable":"‪Unstable‬","SHRED/protonsColon":"‪Protons:‬","SHRED/neutronsColon":"‪Neutrons:‬","SHRED/electronsColon":"‪Electrons:‬","SCENERY_PHET/ResetAllButton.name":"‪Reset All‬","BUILD_AN_ATOM/element":"‪Element‬","BUILD_AN_ATOM/neutralSlashIon":"‪Neutral/Ion‬","BUILD_AN_ATOM/stableSlashUnstable":"‪Stable/Unstable‬","BUILD_AN_ATOM/show":"‪Show‬","BUILD_AN_ATOM/orbits":"‪Orbits‬","BUILD_AN_ATOM/cloud":"‪Cloud‬","BUILD_AN_ATOM/model":"‪Model:‬","BUILD_AN_ATOM/protons":"‪Protons‬","BUILD_AN_ATOM/neutrons":"‪Neutrons‬","BUILD_AN_ATOM/electrons":"‪Electrons‬","BUILD_AN_ATOM/massNumber":"‪Mass Number‬","BUILD_AN_ATOM/netCharge":"‪Net Charge‬","BUILD_AN_ATOM/atom":"‪Atom‬","BUILD_AN_ATOM/protonsColonPattern":"‪Protons: {0}‬","BUILD_AN_ATOM/neutronsColonPattern":"‪Neutrons: {0}‬","BUILD_AN_ATOM/electronsColonPattern":"‪Electrons: {0}‬","VEGAS/check":"‪Check‬","VEGAS/tryAgain":"‪Try Again‬","VEGAS/showAnswer":"‪Show Answer‬","VEGAS/next":"‪Next‬","BUILD_AN_ATOM/whatIsTheTotalCharge":"‪What is the\ntotal charge?‬","BUILD_AN_ATOM/findTheElement":"‪Find the element:‬","BUILD_AN_ATOM/ion":"‪Ion‬","BUILD_AN_ATOM/neutralAtom":"‪Neutral Atom‬","BUILD_AN_ATOM/isIt":"‪Is it:‬","BUILD_AN_ATOM/whatIsTheMassNumber":"‪What is the\nmass number?‬","BUILD_AN_ATOM/protonsColon":"‪Protons:‬","BUILD_AN_ATOM/neutronsColon":"‪Neutrons:‬","BUILD_AN_ATOM/electronsColon":"‪Electrons:‬","VEGAS/pattern.0hours.1minutes.2seconds":"‪{0}:{1}:{2}‬","VEGAS/pattern.0minutes.1seconds":"‪{0}:{1}‬","VEGAS/keepTrying":"‪Keep Trying‬","VEGAS/good":"‪Good!‬","VEGAS/great":"‪Great!‬","VEGAS/excellent":"‪Excellent!‬","VEGAS/label.score.max":"‪Score: {0} out of {1}‬","VEGAS/label.time":"‪Time: {0}‬","VEGAS/yourNewBest":"‪(Your New Best!)‬","VEGAS/pattern.0yourBest":"‪(Your Best: {0})‬","VEGAS/continue":"‪Continue‬","VEGAS/label.level":"‪Level: {0}‬","VEGAS/startOver":"‪Start Over‬","VEGAS/label.scorePattern":"‪Score: {0}‬","VEGAS/pattern.0challenge.1max":"‪Challenge {0} of {1}‬","BUILD_AN_ATOM/chooseYourGame":"‪Choose Your Game!‬","BUILD_AN_ATOM/game":"‪Game‬","JOIST/options.title":"‪Options‬","BUILD_AN_ATOM/highContrastParticles":"‪High Contrast Particles‬","JOIST/credits.title":"‪Credits‬","JOIST/credits.leadDesign":"‪Lead Design: {0}‬","JOIST/credits.softwareDevelopment":"‪Software Development: {0}‬","JOIST/credits.team":"‪Team: {0}‬","JOIST/credits.contributors":"‪Contributors: {0}‬","JOIST/credits.qualityAssurance":"‪Quality Assurance: {0}‬","JOIST/credits.graphicArts":"‪Graphic Arts: {0}‬","JOIST/credits.translation":"‪Translation‬","JOIST/credits.thanks":"‪Thanks‬","JOIST/termsPrivacyAndLicensing":"‪Terms, Privacy & Licensing‬","JOIST/translation.credits.link":"‪Translation Credits‬","JOIST/thirdParty.credits.link":"‪Third-party Credits‬","JOIST/updates.upToDate":"‪This simulation is up to date.‬","JOIST/updates.outOfDate":"‪New version available‬","JOIST/updates.checking":"‪Checking for updates…‬","JOIST/updates.offline":"‪Unable to check for updates.‬","JOIST/updates.newVersionAvailable":"‪There is a new version available: {0}.‬","JOIST/updates.yourCurrentVersion":"‪Your current version is: {0}.‬","JOIST/updates.getUpdate":"‪Get Update…‬","JOIST/updates.noThanks":"‪No Thanks‬","JOIST/versionPattern":"‪version {0}‬","JOIST/menuItem.options":"‪Options…‬","JOIST/menuItem.about":"‪About…‬","JOIST/menuItem.mailInputEventsLog":"‪Mail Input Events Log‬","JOIST/menuItem.outputInputEventsLog":"‪Output Input Events Log‬","JOIST/menuItem.phetWebsite":"‪PhET Website…‬","JOIST/menuItem.reportAProblem":"‪Report a Problem…‬","JOIST/menuItem.screenshot":"‪Screenshot‬","JOIST/menuItem.fullscreen":"‪Full Screen‬","JOIST/menuItem.getUpdate":"‪Check for Updates…‬","JOIST/menuItem.submitInputEventsLog":"‪Submit Input Events Log‬","JOIST/keyboardShortcuts.title":"‪Keyboard Shortcuts‬","BUILD_AN_ATOM/symbol":"‪Symbol‬","BUILD_AN_ATOM/build-an-atom.title":"‪Build an Atom‬"}};
</script>
<img id="splash" style="position: absolute;top: 45%;left: 50%;margin-left: -137px;margin-top: -65px;" src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDE2LjAuNCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHdpZHRoPSIyNzZweCIgaGVpZ2h0PSIxMzJweCIgdmlld0JveD0iMCAwIDI3NiAxMzIiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDI3NiAxMzIiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8Zz4KCTxnPgoJCTxyZWN0IHg9IjAuNDk5IiB5PSIxMTYuNzgxIiBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMy42IiBoZWlnaHQ9IjEzLjk4NCIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iMTYuOTQyLDEyNS4xNzIgMTEuMjYxLDExNi43ODEgNy42NTEsMTE2Ljc4MSA3LjY1MSwxMzAuNzY2IDExLjI2MSwxMzAuNzY2IDExLjI2MSwxMjIuNDQxIAoJCQkxNi45ODcsMTMwLjc2NiAyMC41NTMsMTMwLjc2NiAyMC41NTMsMTE2Ljc4MSAxNi45NDIsMTE2Ljc4MSAJCSIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iMjMuMDUxLDEyMC4wNSAyNy4wNzcsMTIwLjA1IDI3LjA3NywxMzAuNzY2IDMwLjY4MywxMzAuNzY2IDMwLjY4MywxMjAuMDUgMzQuNzU3LDEyMC4wNSAKCQkJMzQuNzU3LDExNi43ODEgMjMuMDUxLDExNi43ODEgCQkiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjM3LjAyNCwxMzAuNzY2IDQ2Ljc3NiwxMzAuNzY2IDQ2Ljc3NiwxMjcuODEyIDQwLjYyOSwxMjcuODEyIDQwLjYyOSwxMjUuMjQ4IDQ1Ljk1OSwxMjUuMjQ4IAoJCQk0NS45NTksMTIyLjI5MSA0MC42MjksMTIyLjI5MSA0MC42MjksMTE5LjcxNSA0Ni43NzYsMTE5LjcxNSA0Ni43NzYsMTE2Ljc4MSAzNy4wMjQsMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik02MC44MjksMTIxLjMyOWMwLTIuOTU0LTIuMzAzLTQuNTUyLTUuNjM3LTQuNTUyaC01LjUxOXYxMy45ODhoMy42MXYtNC42NzZoMS40OWwyLjU5OSw0LjY3Nmg0LjAyNgoJCQlsLTMuMzc5LTUuMjE5QzU5LjY0MSwxMjUuMDE4LDYwLjgyOSwxMjMuNjM3LDYwLjgyOSwxMjEuMzI5eiBNNTUuNDIyLDEyMy4zODVoLTIuMTM4di0zLjY3aDIuMTM4CgkJCWMwLjkzNywwLDEuODAyLDAuNzEzLDEuODAyLDEuODQ2QzU3LjIyNCwxMjIuNjY5LDU2LjM1OCwxMjMuMzg1LDU1LjQyMiwxMjMuMzg1eiIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik02OC43ODgsMTE2Ljc4MWwtNS41NjIsMTMuOTg0aDMuODg0bDEuMDg4LTMuMzUzaDQuNTcxbDEuMDk1LDMuMzUzaDMuODc5bC01LjU1OS0xMy45ODRINjguNzg4egoJCQkgTTY5LjA2LDEyNC43NDhsMS40My00LjM0MmwxLjQwMSw0LjM0Mkg2OS4wNnoiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNNzkuMDI4LDEyMy43NjJjMCw1LjkxMSwzLjU2Miw3LjE1NCw2LjU2NCw3LjE1NGMxLjQ4OSwwLDMuMDIxLTAuMzk4LDQuNDg2LTAuOTg4di0zLjEyNwoJCQljLTEuNTMxLDAuNzM3LTIuODMyLDEuMDEyLTQuMjc0LDEuMDEyYy0xLjY2MSwwLTMuMTcxLTAuNzM2LTMuMTcxLTQuMDUxYzAtMy4zMTUsMS41MS00LjA0OSwzLjE3MS00LjA0OQoJCQljMS40NDIsMCwyLjc0NCwwLjI3MSw0LjI3NCwxLjAwNHYtMy4xMjNjLTEuNDYzLTAuNTg2LTIuOTk3LTAuOTg0LTQuNDg2LTAuOTg0QzgyLjU5MSwxMTYuNjA5LDc5LjAyOCwxMTcuODQ2LDc5LjAyOCwxMjMuNzYyeiIvPgoJCTxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iOTEuOTk1LDEyMC4wNSA5Ni4wMjEsMTIwLjA1IDk2LjAyMSwxMzAuNzY2IDk5LjYyOSwxMzAuNzY2IDk5LjYyOSwxMjAuMDUgMTAzLjY5NiwxMjAuMDUgCgkJCTEwMy42OTYsMTE2Ljc4MSA5MS45OTUsMTE2Ljc4MSAJCSIvPgoJCTxyZWN0IHg9IjEwNS45ODUiIHk9IjExNi43ODEiIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSIzLjYwNyIgaGVpZ2h0PSIxMy45ODQiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjExOC44MDIsMTI2LjY3NiAxMTUuNjgxLDExNi43ODEgMTExLjgyMywxMTYuNzgxIDExNy4xOSwxMzAuNzY2IDEyMC40NjIsMTMwLjc2NiAxMjUuNzksMTE2Ljc4MSAKCQkJMTIxLjkzMiwxMTYuNzgxIAkJIi8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIxMjcuOTU0LDEzMC43NjYgMTM3LjcwNCwxMzAuNzY2IDEzNy43MDQsMTI3LjgxMiAxMzEuNTYsMTI3LjgxMiAxMzEuNTYsMTI1LjI0OCAxMzYuODg5LDEyNS4yNDggCgkJCTEzNi44ODksMTIyLjI5MSAxMzEuNTYsMTIyLjI5MSAxMzEuNTYsMTE5LjcxNSAxMzcuNzA0LDExOS43MTUgMTM3LjcwNCwxMTYuNzgxIDEyNy45NTQsMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0xNDcuNjg2LDEyMC40OWMwLTEuNTUxLDEuMjM4LTIuMzkzLDMuNDY0LTIuMzkzYzEuNDI2LDAsMi41NzcsMC40NDEsMy4zNTQsMC44ODV2LTEuNTU4CgkJCWMtMC44OTktMC40NDItMi4wODEtMC44MzUtMy41MDQtMC44MzVjLTMuNTY0LDAtNC44MjQsMi4wMTQtNC44MjQsMy44OTljMCw0LjY4Myw3LjcxNywyLjYyLDcuNzE3LDYuNzEKCQkJYzAsMS44NDctMS45NDYsMi4yMjUtMy41NjksMi4yMjVjLTEuOSwwLTMuMjAxLTAuNTY0LTQuMDIxLTEuMTExdjEuNjM4YzAuOTg1LDAuNTI4LDIuMzQ5LDAuOTg3LDQuMTMxLDAuOTg3CgkJCWMzLjEyNiwwLDQuOTc0LTEuNDEsNC45NzQtMy43MzdDMTU1LjQwNSwxMjEuODUyLDE0Ny42ODYsMTIzLjU1MSwxNDcuNjg2LDEyMC40OXoiLz4KCQk8cmVjdCB4PSIxNTguNTE1IiB5PSIxMTYuNzc3IiBmaWxsPSIjRkZGRkZGIiB3aWR0aD0iMS41MSIgaGVpZ2h0PSIxMy45ODgiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjE3MC4wODksMTIzLjg5MSAxNjUuMjg4LDExNi43ODEgMTYzLjY1MywxMTYuNzgxIDE2My42NTMsMTMwLjc2NiAxNjUuMTYzLDEzMC43NjYgCgkJCTE2NS4xNjMsMTE5LjI1MiAxNzAuMDg5LDEyNi4zODQgMTc1LjA0MSwxMTkuMjUyIDE3NS4wNDEsMTMwLjc2NiAxNzYuNTUxLDEzMC43NjYgMTc2LjU1MSwxMTYuNzgxIDE3NC45MTksMTE2Ljc4MSAJCSIvPgoJCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0xOTAuMTEsMTI1LjEwNGMwLDMtMS4zNjUsNC40NDktNC4xNzcsNC40NDlzLTQuMTc4LTEuNDQ5LTQuMTc4LTQuNDQ5di04LjMyMmgtMS41MDd2OC4yMzQKCQkJYzAsMy44MjQsMi4wMTcsNS45MjIsNS42ODUsNS45MjJjMy42NzMsMCw1LjY4NS0yLjA5OCw1LjY4NS01LjkyMnYtOC4yMzRoLTEuNTA4VjEyNS4xMDRMMTkwLjExLDEyNS4xMDR6Ii8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIxOTYuNjU3LDExNi43ODEgMTk1LjE0NSwxMTYuNzgxIDE5NS4xNDUsMTMwLjc2NiAyMDMuODA5LDEzMC43NjYgMjAzLjgwOSwxMjkuMjk5IAoJCQkxOTYuNjU3LDEyOS4yOTkgCQkiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjExLjEzNCwxMTYuNzgxbC01LjU4LDEzLjk4NGgxLjYzM2wxLjY4LTQuMzU1aDYuMDQzbDEuNjc5LDQuMzU1aDEuNjFsLTUuNTU4LTEzLjk4NEgyMTEuMTM0egoJCQkgTTIwOS40MjksMTI0Ljk1OWwyLjQ2LTYuMzk4bDIuNDUyLDYuMzk4SDIwOS40Mjl6Ii8+CgkJPHBvbHlnb24gZmlsbD0iI0ZGRkZGRiIgcG9pbnRzPSIyMTcuNDg5LDExOC4yNDQgMjIyLjQzOCwxMTguMjQ0IDIyMi40MzgsMTMwLjc2NiAyMjMuOTUyLDEzMC43NjYgMjIzLjk1MiwxMTguMjQ0IAoJCQkyMjguODc5LDExOC4yNDQgMjI4Ljg3OSwxMTYuNzgxIDIxNy40ODksMTE2Ljc4MSAJCSIvPgoJCTxyZWN0IHg9IjIzMS4xNjciIHk9IjExNi43NzciIGZpbGw9IiNGRkZGRkYiIHdpZHRoPSIxLjUwOSIgaGVpZ2h0PSIxMy45ODgiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjQyLjE4MiwxMTYuNTljLTQuMjk3LDAtNi40NzksMi40MDktNi40NzksNy4xNzJjMCw0Ljc2LDIuMTgzLDcuMTc2LDYuNDc5LDcuMTc2CgkJCWM0LjMyMSwwLDYuNTA3LTIuNDE2LDYuNTA3LTcuMTc0QzI0OC42ODgsMTE4Ljk5OSwyNDYuNTAzLDExNi41OSwyNDIuMTgyLDExNi41OXogTTI0Mi4xODIsMTI5LjUxCgkJCWMtMy40MzgsMC00Ljk3Mi0xLjc2Mi00Ljk3Mi01Ljc0NmMwLTMuOTY1LDEuNTMzLTUuNzQ4LDQuOTcyLTUuNzQ4YzMuNDY2LDAsNC45OTUsMS43ODMsNC45OTUsNS43NDgKCQkJQzI0Ny4xNzYsMTI3Ljc0OCwyNDUuNjQ2LDEyOS41MSwyNDIuMTgyLDEyOS41MXoiLz4KCQk8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBwb2ludHM9IjI2MS43MTUsMTI4LjU2NCAyNTMuMzY5LDExNi43ODEgMjUxLjY0OCwxMTYuNzgxIDI1MS42NDgsMTMwLjc2NiAyNTMuMTU4LDEzMC43NjYgCgkJCTI1My4xNTgsMTE4Ljk4MiAyNjEuNTI0LDEzMC43NjYgMjYzLjIyNSwxMzAuNzY2IDI2My4yMjUsMTE2Ljc4MSAyNjEuNzE1LDExNi43ODEgCQkiLz4KCQk8cGF0aCBmaWxsPSIjRkZGRkZGIiBkPSJNMjY3Ljc3OCwxMjAuNDljMC0xLjU1MSwxLjIzNi0yLjM5MywzLjQ2NS0yLjM5M2MxLjQyNSwwLDIuNTc2LDAuNDQxLDMuMzU1LDAuODg1di0xLjU1OAoJCQljLTAuOTAyLTAuNDQyLTIuMDc3LTAuODM1LTMuNTA1LTAuODM1Yy0zLjU2MywwLTQuODIxLDIuMDE0LTQuODIxLDMuODk5YzAsNC42ODMsNy43MjIsMi42Miw3LjcyMiw2LjcxCgkJCWMwLDEuODQ3LTEuOTU1LDIuMjI1LTMuNTcsMi4yMjVjLTEuOTA3LDAtMy4yMDctMC41NjQtNC4wMjctMS4xMTF2MS42MzhjMC45ODYsMC41MjgsMi4zNTQsMC45ODcsNC4xMzMsMC45ODcKCQkJYzMuMTI1LDAsNC45NzItMS40MSw0Ljk3Mi0zLjczN0MyNzUuNDk5LDEyMS44NTIsMjY3Ljc3OCwxMjMuNTUxLDI2Ny43NzgsMTIwLjQ5eiIvPgoJPC9nPgoJPGc+CgkJPHBhdGggZmlsbD0iIzZBQ0VGNSIgZD0iTTM0LjcyMywyNS4zNTlIMi41MTFjLTEuMTExLDAtMi4wMTIsMC45MDQtMi4wMTIsMi4wMDl2ODAuNTQyYzAsMS4xMTEsMC45LDIuMDEyLDIuMDEyLDIuMDEyaDE3Ljc3NwoJCQljMS4xMTUsMCwyLjAxNi0wLjksMi4wMTYtMi4wMTJWODYuODRjMC0xLjExOSwwLjg5OC0yLjAxNiwyLjAxNi0yLjAxNmgxMC40MDFjMjAuNTQ0LDAsMzIuMzM0LTEwLjkwNSwzMi4zMzQtMjkuNzk5CgkJCUM2Ny4wNTgsMzYuMjY0LDU1LjI2NywyNS4zNTksMzQuNzIzLDI1LjM1OSBNMzIuNjk2LDY2LjgyMmgtOC4zNzVjLTEuMTE5LDAtMi4wMTctMC45MDUtMi4wMTctMi4wMlY0NS4xMjQKCQkJYzAtMS4xMTUsMC44OTctMi4wMTIsMi4wMTctMi4wMTJoOC4zNzVjOS42MzEsMCwxMi42ODMsNi41OTEsMTIuNjgzLDExLjkxNUM0NS4zNzgsNjAuNjExLDQyLjMyNyw2Ni44MjIsMzIuNjk2LDY2LjgyMiIvPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNzMuNDg3LDI1LjM1OUgxNDkuODM5Yy0xLjExMiwwLTIuMDE4LDAuOTA0LTIuMDE4LDIuMDA5djgwLjU0MmMwLDEuMTExLDAuOTA0LDIuMDEyLDIuMDE4LDIuMDEyaDU0LjkyOAoJCQljMS4xMTMsMCwyLjAxNC0wLjksMi4wMTQtMi4wMTJWOTQuMDY0YzAtMS4xMTMtMC44OTktMi4wMi0yLjAxNC0yLjAyaC0zNC4xMzNjLTAuNTU1LDAtMS4wMDUtMC40NDktMS4wMDUtMS4wMDhWNzcuNTg0CgkJCWMwLTAuNTU1LDAuNDUtMS4wMSwxLjAwNS0xLjAxaDI5LjE4OGMxLjExMSwwLDIuMDEzLTAuODk2LDIuMDEzLTIuMDFWNjAuNzE5YzAtMS4xMTMtMC45LTIuMDItMi4wMTMtMi4wMmgtMjkuMTg4CgkJCWMtMC41NTUsMC0xLjAwNS0wLjQ1LTEuMDA1LTEuMDA4VjQ0LjExNWMwLTAuNTU1LDAuNDUtMS4wMDYsMS4wMDUtMS4wMDZsNTcuNDUsMC4wNmMwLjU1OCwwLDEuMDE0LDAuNDUzLDEuMDE0LDEuMDA3djYzLjczMwoJCQljMCwxLjExLDAuOTAyLDIuMDEyLDIuMDA5LDIuMDEyaDE3Ljc4M2MxLjEwOSwwLDIuMDE0LTAuODk5LDIuMDE0LTIuMDEyVjQ0LjE3OGMwLTAuNTUzLDAuNDUtMS4wMDcsMS4wMDgtMS4wMDdoMjEuNTc2CgkJCWMxLjEwNCwwLDIuMDEzLTAuOTA1LDIuMDEzLTIuMDA5VjI3LjM2OEMyNzUuNDk5LDI2LjI2NCwyNzQuNTkyLDI1LjM1OSwyNzMuNDg3LDI1LjM1OSIvPgoJCTxwYXRoIGZpbGw9IiNGRUUxMDUiIGQ9Ik0xMjEuMzc0LDQ4LjE4NmMtMC44MDksMi41MDQtMS41NzIsNS4wMzktMi4yNjIsNy42MjVjLTAuMTQ0LDAuNTQzLTAuMjc3LDEuMDk4LTAuNDI2LDEuNjQ2CgkJCWMtNi40OCwyOC4wMDgtMi45NjcsNDYuMzEyLTEuNzQ2LDUyLjI3M2MwLjI5MywwLjEyNSwwLjU4NiwwLjE5MSwwLjg5MSwwLjE5MWgxNi40MzdjMS4xMTEsMCwyLjAyNC0wLjksMi4wMjQtMi4wMTJWNzIuNjQ4CgkJCUMxMzYuMjkxLDYwLjk2MywxMzAuOTkzLDUyLjE5MywxMjEuMzc0LDQ4LjE4NiIvPgoJCTxwYXRoIGZpbGw9IiNGRUUxMDUiIGQ9Ik05Ny40OTEsNDYuNTMzVjI0LjU4NWMwLTEuMTEyLTAuOTA3LTIuMDIxLTIuMDEyLTIuMDIxSDc3LjY5NGMtMS4xMTEsMC0yLjAxNiwwLjkwOC0yLjAxNiwyLjAyMXY4My4zMjYKCQkJYzAsMS4xMSwwLjkwNCwyLjAxMiwyLjAxNiwyLjAxMmgxMS4xODRjMC41MTUsMCwxLjAwMi0wLjE5MiwxLjQwNi0wLjQ5M2MzLjE1Ni0yNS4yNDgsMTIuNTg4LTQ3LjIwNywyMS44OTYtNjMuNDY3CgkJCWMtMS4yNjQtMC4xMjUtMi41NTgtMC4xODYtMy45MTYtMC4xODZDMTA0Ljg1LDQ1Ljc3NywxMDAuNTM0LDQ2LjAyMSw5Ny40OTEsNDYuNTMzIi8+CgkJPHBvbHlnb24gZmlsbD0iI0ZFRTEwNSIgcG9pbnRzPSIxMDcuNzExLDE3LjQyOCAxMjAuMTg1LDIxLjkzOCAxMzYuMjMzLDguNTcyIDEyMy44OCwyMy4xOTkgMTM3LjIyOCwyNy45MDQgMTQyLjA0LDEuMDYyIAkJIi8+CgkJPHBvbHlsaW5lIGZpbGw9IiNGMkU5MTYiIHBvaW50cz0iMTI1LjEwOCwzMC41ODggMTI0LjU4NywyNC42IDEyOS4xOTIsMjYuMjYgCQkiLz4KCTwvZz4KCTxnPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNTcuMzMzLDEwOS45MjJ2LTQuODUxaC0xLjgxMnYtMC42NDhoNC4zNnYwLjY0OGgtMS44MnY0Ljg1MUgyNTcuMzMzeiIvPgoJCTxwYXRoIGZpbGw9IiM2QUNFRjUiIGQ9Ik0yNjAuNjA0LDEwOS45MjJ2LTUuNDk5aDEuMDk4bDEuMzAyLDMuODk0YzAuMTIsMC4zNjMsMC4yMDgsMC42MzYsMC4yNjMsMC44MTUKCQkJYzAuMDYyLTAuMjAyLDAuMTYtMC40OTMsMC4yOTItMC44ODFsMS4zMTctMy44MjhoMC45Nzl2NS40OTloLTAuNzAxdi00LjYwMmwtMS41OTksNC42MDJoLTAuNjU2bC0xLjU5MS00LjY4MnY0LjY4MkgyNjAuNjA0eiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=">
<div id="progressBar"
     style="position:absolute;top:50%;left:50%;margin-left:-147px;margin-top:50px;width:273px;height:10px">
  <svg>
    <rect id="progressBarBackground" x="10" y="10" width="273" height="10" rx="3" ry="3"
          style="stroke: white;stroke-width:1"></rect>
    <rect id="progressBarForeground" x="10" y="10" width="0" height="10" rx="3" ry="3" style="fill:#6acef5;"></rect>
  </svg>
</div>
<script type="text/javascript">window.phet.chipper.mipmaps = {"BRAND/logo-on-white.png":[{width:273,height:108,url:"data:image/png;base64,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"},{width:137,height:54,url:"data:image/png;base64,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"},{width:69,height:27,url:"data:image/png;base64,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"},{width:35,height:14,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAOCAYAAACl66WxAAAAAklEQVR4AewaftIAAALnSURBVK3BT0jedQDH8ffn+/3p47SpUyTcVpMdokV/RFZBl6BiVzt0rYgdQpFgQREE3jp48FCkshFBtegwrDFqXYIOHVrNkgUDC2lSGYyVo/no4/T5fT89zmf6IK6J6/USd8AzscORQUvluL98jDuUsQP5TDhI0JsJjmAKyCf5H2RHf5pXXL6LDcvspp7hwzJV6UrsJfEgAi3xWQp6lMQBoi+S8wzi/MvfL8ihkZ0pcuLwbmeFPI47lJ7kJsEipcX+ycUpKRsa6a7/ykt+UbmeBewCc7GzPAZ8kP8ZXyFwLpTD57FOE3api51QvAA8ldluBtpYZRsDUpthnykf6psoPi2aQRYIMDfFvfk73JDT96P3AG0Yg7k1gRC2WacWKjI2WDGOCBVTSr3Y92PvDXVxgFq5jqTZ+JCcD7gcDoauNE0tMR9C9jaIzYxxyl8DGgjhUlD8mFXyLBUZVQKc0pejPU1n+ydLM8ZjgJx8D5C4waKsXkc+hfgCkaE0GwfCvvwUYNastC4XBt96TGz20rTVML/4KmZVcaS7MEiNjFpGR8/MU/EEa4woAo1UWSzIHrLUr0QH5pgnONUPYk3rXF3pSt/kIhgUdCkPDY8ff1jmNgJVpkKcrN8frtrpeUDACtIX1BLnwr3pPKYLLIsDHEJsCNjt2O3gdie3zUW2JbBBQAvQwpp5BY2NPrLrE9bJiNOs2UOFINBIrWKIcVhZNqwsGw5ZPMF1zDZkbLBCeA+4JvF3Xk7jY92Nv1DD8NfySjgOOYIGtrbc2lB4ve4+zKolmJv8lu3IqBLglE6P9TSd5RYkpncdXClTYUhiS61XS6U/uMC69uaej4A3uI2MNTYV5r/Y0q9UCa4BBswqA8JAcHIntUwrFXmeU2Uq+n4oPod4ADQ31tP0bhayOI50kYr8+vLPbMF1OkPO72T+mioHPiToO8Q/v03hUB/fB3WwmSEEvqGicyV6IctGDQXbs06ewr4MvpuKfwGZEj3EDvHM3gAAAABJRU5ErkJggg=="},{width:18,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAHCAYAAAAF1R1/AAAAAklEQVR4AewaftIAAAE2SURBVIXBsUvUcRzG8ffz+QXX+QukKAcRT2xSiNLjcslVnaLFfyAsEhr6B1wEcWwQuhtrEWlsbRDcUzBF3CxyiEyKIkrv+326uvWi10v8QzrSFaQlpKFiOM3zH1rc/tGyuSqRJDbXrl06V+KhL2iZzAym8vjkW9WmpBfxpTXZtxB2nhN5Grvu7KcfzlZuAg3ZDaW8XAynR9h3Rb4tck3kmsg14XsiT8geoiP4S/uEVhGV4/PxQbDcZtahV/l9PEEY6SuKI4ri+c/+smGRiHjdrJdzdAR/iDtkN4HjGxfXD0Em2MCMWExhBFwGXyd7gB6Crh0V8cBmooyXvwynZ+1YAyoC0fWZ0KGCKj2EQgeIt89uVV+06uWJpY+IrepoOyO2De8QewhjjwGjKSUkdoFPi2++36fjNxqpew9Z59GLAAAAAElFTkSuQmCC"}],"BRAND/logo.png":[{width:273,height:108,url:"data:image/png;base64,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"},{width:137,height:54,url:"data:image/png;base64,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"},{width:69,height:27,url:"data:image/png;base64,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"},{width:35,height:14,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAOCAYAAACl66WxAAAAAklEQVR4AewaftIAAALnSURBVK3BT0jedQDH8ffn+/3p47SpUyTcVpMdokV/RFZBl6BiVzt0rYgdQpFgQREE3jp48FCkshFBtegwrDFqXYIOHVrNkgUDC2lSGYyVo/no4/T5fT89zmf6IK6J6/USd8AzscORQUvluL98jDuUsQP5TDhI0JsJjmAKyCf5H2RHf5pXXL6LDcvspp7hwzJV6UrsJfEgAi3xWQp6lMQBoi+S8wzi/MvfL8ihkZ0pcuLwbmeFPI47lJ7kJsEipcX+ycUpKRsa6a7/ykt+UbmeBewCc7GzPAZ8kP8ZXyFwLpTD57FOE3api51QvAA8ldluBtpYZRsDUpthnykf6psoPi2aQRYIMDfFvfk73JDT96P3AG0Yg7k1gRC2WacWKjI2WDGOCBVTSr3Y92PvDXVxgFq5jqTZ+JCcD7gcDoauNE0tMR9C9jaIzYxxyl8DGgjhUlD8mFXyLBUZVQKc0pejPU1n+ydLM8ZjgJx8D5C4waKsXkc+hfgCkaE0GwfCvvwUYNastC4XBt96TGz20rTVML/4KmZVcaS7MEiNjFpGR8/MU/EEa4woAo1UWSzIHrLUr0QH5pgnONUPYk3rXF3pSt/kIhgUdCkPDY8ff1jmNgJVpkKcrN8frtrpeUDACtIX1BLnwr3pPKYLLIsDHEJsCNjt2O3gdie3zUW2JbBBQAvQwpp5BY2NPrLrE9bJiNOs2UOFINBIrWKIcVhZNqwsGw5ZPMF1zDZkbLBCeA+4JvF3Xk7jY92Nv1DD8NfySjgOOYIGtrbc2lB4ve4+zKolmJv8lu3IqBLglE6P9TSd5RYkpncdXClTYUhiS61XS6U/uMC69uaej4A3uI2MNTYV5r/Y0q9UCa4BBswqA8JAcHIntUwrFXmeU2Uq+n4oPod4ADQ31tP0bhayOI50kYr8+vLPbMF1OkPO72T+mioHPiToO8Q/v03hUB/fB3WwmSEEvqGicyV6IctGDQXbs06ewr4MvpuKfwGZEj3EDvHM3gAAAABJRU5ErkJggg=="},{width:18,height:7,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAHCAYAAAAF1R1/AAAAAklEQVR4AewaftIAAAE2SURBVIXBsUvUcRzG8ffz+QXX+QukKAcRT2xSiNLjcslVnaLFfyAsEhr6B1wEcWwQuhtrEWlsbRDcUzBF3CxyiEyKIkrv+326uvWi10v8QzrSFaQlpKFiOM3zH1rc/tGyuSqRJDbXrl06V+KhL2iZzAym8vjkW9WmpBfxpTXZtxB2nhN5Grvu7KcfzlZuAg3ZDaW8XAynR9h3Rb4tck3kmsg14XsiT8geoiP4S/uEVhGV4/PxQbDcZtahV/l9PEEY6SuKI4ri+c/+smGRiHjdrJdzdAR/iDtkN4HjGxfXD0Em2MCMWExhBFwGXyd7gB6Crh0V8cBmooyXvwynZ+1YAyoC0fWZ0KGCKj2EQgeIt89uVV+06uWJpY+IrepoOyO2De8QewhjjwGjKSUkdoFPi2++36fjNxqpew9Z59GLAAAAAElFTkSuQmCC"}],"JOIST/keyboard-icon-on-white.png":[{width:77,height:67,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAABDCAYAAADZA4jAAAAAAklEQVR4AewaftIAAAOrSURBVO3B4XXb5hUA0Ptw8J/YoNpA6ATiBmYmKDOBmAnCDcJswEwQeoLSG6AbWBtAE7yenDAHhJFS/iy5oi3cG5npLYiIFo0/9ZnZ+UK1t2OPW3/6gKUvVHk7br2QyqxY5Q2IiBsvqPI2tMZ6z1B5G5bGOs9Q+c5FRIO1sYNnqHz/tlgYPGRm5xkq37GI2OLe2N4z1b5DEbHCBnfGHrDzTLVvXES0uEGLFkssTD1ilZm9Z6p9QyLiBisscYNbn+cR68zsvIDaNyAiltjiTrkPWGfmRy+kdsUiosEO/1LmAUfsM/PohdWu2wF3LvuAj+jQocvM3ldUu1IRscOdqQ/Y45iZH72C2hWKiBvcG3vAOjOPXlntOm2NPaLNzN4VqFynlbFVZvauROXKRESLhcFDZh5dkcr1WRk7uDKRmf4SEQ022GBh9og9tpnZO6mMHfEzFmZ/WOAex4honFROImKLW7O/c4utk8pgbXbJ2kll8A+zSxZOahdkZnijIiL9D5VZscqsWGVWrFYoIjZoDA6Z2TkTEQ02xnaZ2TsTES1WBn1m7nwiIlZoDQ6Z2flERGzQGOwys3cmIhpsDPrM3ClQKxARS/xibImlsQ1+NrU1dsTCmYjoMvPoJCJa/G5sg8aZiNjgF2MtVsb2eOdMRMjMnc9UeV0LT2tMLUw1phpTjalGgcqsWGVWrFamw3s0BntTByyNHUz9iLVBj85Yh/doDDpTByyN7X0FtQKZ2WPlCZnZYekJmbnH3gWZ2WPlCZnZYen/oDIrVpkVq8yK1QpERIM9GpdtMrNzJiLWWBv0WGdm70xE7NAadJm5cSYiGuzRGOwzc+9MRLTYGWs9U61Mi3eetsPS2Bp3xlocjd0bu8PGWIt3pvbGVrjzwiqzYpVZscrX0fu29ArUCmTmMSJ+QuOynakNVgZ9Zh5N/YDWoPOJzDxGxE9oDA6mdp7WZ+ZOgVqhzNz5ApnZofOEzDzg4AmZufOEzOyx9cIqs2KVWbHKrFitQETcoMPC4NfM3DgTESv87vX9mpkbZyJih3uDRywzs/OZKmVusDDWmmpdh9ZUa2yBlQKVWbHKrFilTG+qN9W7Dp2p3lSnQK1AZnYR8U80Bp1PZOYuIjqvLDOPptZoDfrM7BSoFcrMzmfIzKMrlJk9jp6hMitWmRWrXRARS7OJ2mX/NpuoDP5jdsmDk8pgZ3bJ3knlJDP3+M3s7/yWmVsnlTOZucYPeI8Hb9sD3uPHzFw7E5lpVua/SRtMh53sI98AAAAASUVORK5CYII="},{width:39,height:34,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAiCAYAAADcbsCGAAAAAklEQVR4AewaftIAAAJ8SURBVM3BT2ibZRwA4Kdf34XCZFoYgx46WdWpRbfBQBEvIp2IOwiFYY8eVDyIHtpLh2ywKp4mogeLIsIC1lIHIj04DP4DEdQIBqHaaRQKK0xED4KhK+rgd/gM+WLqkjV7nkH9cRaTeMd/SPpjEms6yGy/O4VNHWS232PCBR1kttcEpoRPdZBcfYdwHx7EPdiFb3FKB0nvjWEOd+Am7NTsSzyKhg4G9NYTeB675X7EBfyKJbxli5LeGcYcduN7vIoz+M0VSnrnOexBHYfQ0KVM7xwUzqKhBwaEpzGDUf21iQ8wicagsIAb9V+GW7AL7ydhn/AzzuufI8LtLkuanccD+udv/5K09whKqGAdQzgmLKGBEUxgA4vCOA7jIs4J92IM66gIExhBHZ8pkBQ7gLeF05jBMZyRK+N1HBVWUMMruB+b2CG8iLvwE8aE17APX+BuBTLdKWk1ICS5TEhySci0kRRbxQsoYUGo4LRQEWZRwwZWhTfxNX6XewOfYM3/kBRr4Lhm65jRrIqqZmWUNZt3BZJiQziBktwPmBeewSi+QVl4FjfgYyxjCCdQwgKqGMG0sFMHSbH9mNVsDfPCNEbxEcrCnHAAy9iPWbkqJjBtizJbt+nq+EsbSbEaplCSW5d7HHtQl3sY16Mq1DCFEirCklZ1bSTtLWrvnFbvabWoWQNlW5QUG0YZJbyMZYzjJd2p40lhHmP4HCcVSIqN4qhQwzIO44jurMk9hFEM46QCmWKX5DaEDd37U25TuKSNpNgKxrEDq8IiVnTnD7kJXIdftJG0t6JVTe/UdZA0uxUfukYk4Tvchr3Yq/++ctmgcBE3YxhJ/6zjXTzlWvcPH1WKJsdV9HIAAAAASUVORK5CYII="},{width:20,height:17,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAklEQVR4AewaftIAAAFdSURBVJ3BsUtUcQAA4O/OH5QY6CAR1KBZRENNpZCI1ST5NyguEthqDg6BEESgf0GEUgQOtYRRLgqJgiAoBAUmiJglBmlxepxFevCC9zp8ovd9Fco3jNt4JyGrfJdwQong+FrRhcsYUCI4mkYM4Sry+IYHGFciOJrHOIk7mHaIDG7gPqqka8IH7DjYX4xiJKAXbViX7gfOSleDOowEnMI66nELc7ggsoRrmMR1bGEX5zCNZnzBE1xUFMTqMYG76BB5j36cx0t8wmd0oAZv8FxCEFtFN95iTWQBy1hFH75jG7MiGWQkBLFa9OAeXiOLHrRjDk9xE9UYxDwqlcj6Xw45FFDAjsg2fiOPPPaQwywWJWTFfmIK3dhAFZbwCDNoQAEbaEcLxvFRQhA7jX4soxMt0m3iIXrxTEIQW0Ed1jCGSun+iFzBFl75J+AXzmBF+arxVVHAAHZRq3x5vFC0DxfFVSqBrHvfAAAAAElFTkSuQmCC"},{width:10,height:9,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAACFSURBVIXBsQoBYQAA4M/1l8lJSnQyMolXsZq8gnfwKgZl9yIGTGcjg1GKjrqrS5Lv88dSIfjWxQJN7BUqmGGgNMINB6V1wBxbZHJXZOghQ4JOwAMXnFBFAzU80MIZUSQXYYxE7ogUfdy9BbmALSZKd2xQRzUgIEaMnU9tJEgrmGLotydWL90BGkUTJltKAAAAAElFTkSuQmCC"},{width:5,height:5,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAklEQVR4AewaftIAAAA8SURBVE3BMQqAIAAAwFOksSERfFj0rH7Q74KGwF1aass7gw27T8CBjoIbT0RBx4mMJWFCRUZDClgx+10v5PsJAW+Zqq4AAAAASUVORK5CYII="}],"JOIST/keyboard-icon.png":[{width:77,height:67,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAABDCAYAAADZA4jAAAAAAklEQVR4AewaftIAAAMNSURBVO3B0XHURgAA0MeO/k8d4A6sVGB1wKWCXCqwqCDXAaIDUQGigsgdbDrAHcgVOJnBGWVHcMdyJpZ9eu/V/f29M1Gh9MWI6AcVzkeHS1/coPaDgvNx6ZEEq2zBebjwiILzUEmNThCch1oqOkHw8pXYSfVOELx8e2xMbhGdIHjZ9riW6pyo8DJt0eBK6hatExWevwoXqFChxsbcHbYYnajwvFxgixoXuPR97rBD9AgKz0ONPa7ku8EOnz2SwrKVaPGbPLcY0GHwyArL1uPKYTf4jIiIiNFPVFiuFlfmbtBhwGdPoLBMF7iWusUOgydWWKa91B0qjBYgWKat1BajhQiWp8LG5BaDBQmWZyvVW5hCqkSDBhvLcI1rT+MOHfYYPSikBlxa/WuDa9SoMfpHMNnj0uprLrH3IJjsrA7ZeRBMXlsdsvGgcNgr5+veNwSrbMEqW7DKVsjXoDTpEaVKNFItRqkKW5MRrbktKpMe0VyD0qTFKFWiMRnRylDIU+OdVI1aqsEf5vZSAzZSEYNJhY9SDUqpBu+kKmylOrwx1/pOwdPaOK40tzFXmivNleZKGYJVtmCVrZAn4hNKk85cj1qqN/c7diYjolTEJ5Qm0VyPWqrzExTyjNg6LqJ2XIfOYSO2jouo/Q+CVbZglS1YZSvkKdGhdFiDKLXDzmTEDqNUi8okopEq0aE06dBJVWilKicq5KnwxnEtaqkdrqQqDFLXUldopCq8MddJbXHlkQWrbMEqW/BzjJ6XUYZCngFvUTqsNddgazJiMPcrKpNobsBblCa9udZxI1oZCvlaPyYiOq5H77jWcSP2HlmwyhassgWrbIU8F4jYmLxHI7XFR0/vPRqpFtcmd6gRfacgzwU2UpW5yjJU5iqpDbYyBKtswSpbkGc0N5obLUM0N5qLMhTyRPyC0iSaaxE9vcHcDpXJiChDIV/0fQbLNGJwgmCVLVhlKxxWW80UDvvTaiaY/GV1yK0HwaS1OqTzIJh0+GD1NR+w96CQ2qHHDhVeO1+3iOjR+Y/CXI/e6pv+Brsmp1sL3s1UAAAAAElFTkSuQmCC"},{width:39,height:34,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACcAAAAiCAYAAADcbsCGAAAAAklEQVR4AewaftIAAALgSURBVM3BTYiUdRwA4Oc3vQ2CUQkieFghAyspEzxFlw6r9HEIBMljh4pOFawXJfzIIjokUYcWI4JZSMW87SVc+oLoUFu0BJbWEiy4UEQdgoZ16dcL/8O7mzONuavj89xkCDLzzOHDh3cfOXLkA/+hMhy7MWeAlussM+9TLBqg5fp7SnHRAC3XUWaOYq/iMwNUrrHM3I6H8DAewK34Di8ZoLLKMnMzjuJe3Im1lvsST0ZE1wBhFWXmM3gF6zV+wkX8htMR8b4rVFklmbkOR7EeP+BtdCLid1epsnpexgbMYntEdK1Qy+q5X3EmIrpWQahl5nPYhxHDtYiz2B0R3ZbiBYwYvgqP4DW1SnGH4mdcMDw7FfeoVZa7EBG7DEnWLFHpIzOfQBtTETGfmWuwR3E6IrqZuRGjWIiIU2qZuRU78EtEfKiWmQ9iM+YjYkotM0exEbMR8bkeWnrIzG04iQ7GFHvQQQd7FO+gg5OZuU3xFjqY1DiGDo5rHEcHx/TRsjJtlwtFpdFSVBqVoqWPSm/n8SraOKGYwuuKKcV+zGAB5xXv4Wv8ofEuPsWc/6HSQ0R0ccASETGPfZaIiGlMWyIiJjBhiYgYdxUqPWTmGhxEW+PHiBhXy8znMYJvI2JCLTNfxO34JCImM3MNDqKNExExnZkbMaZYa4BKb1uw33JzGFeMYQQfY0JxVLENk9iC/RrTGMWYK9Ry5RZdG3/ro9JDRMxk5l60NeY1nsYGzGo8jtswrRYRM5m5F21MKU673Kw+Qi1rirMRscuQZE1xNiJ2VXrIzHWYQBtvRsRkZm7FG1ZmNiKeVcvMcWzGFxFxSA+V3kbwmGIGk9iBnVZmTuNRjGAdDumhpbdLGguKBSv3l8ai4pI+Kj1ExLnM3IqbcV4tIk5l5jkr86fGKG7Br/qo9BER5/xLRMxYJRExa4DKcndl5kduEJXie9yNTdhk+L5SaykO4ht0Ddc8JiLigBvdPzHj7bg5l7ABAAAAAElFTkSuQmCC"},{width:20,height:17,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAAAklEQVR4AewaftIAAAGGSURBVJ3Bz2vOARwA4Ofz+tasKUtLymUvBznYcaSW5SBxW3HapNVSLi7jsIP2lpKDf0DKIuXAbWIXByLLgVJTqLXWWFN+tR8N+Vi9q72WV9ueZ5MNyswbg4ODhyuVykM1SjZuDxqsUlinzDyE09iLilUKa5CZ7biKNizgIy5GxIhVCmtzBZtxLCKe+o/IzIM4jyb17cdrzPu337gTEUMF+nEU0+r7jJ3qa0YrhkrYgumIKKMXbehCF9rQGxFlnMQRdKI7IsroRideoMGSwrLMLOMRzqBH1WMMZOYu3MUbvEMPmnEft9QorJhEHx5gStUrjGMSF/AJcxhVFQg1Sla04CyG0Y4DuBYR1/Ec23AC5zCWmS/RaJWSv81iFotYxLyqOfzEAhaQmMUo3qpRsuIbnqAPM2jC+8y8jGfYjUXM4HhEdGAEY2oUVmzHAMZxCh3q+4JL6MdNNQrLImIiM1sxhWE0qu+Xqn34inuWFfiOHZk5YR0yU42t+GBJgQp+oMXGLeC2JX8AO/x2pDbtElkAAAAASUVORK5CYII="},{width:10,height:9,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAklEQVR4AewaftIAAACQSURBVH3BMWrCYBgA0NfwQyYjIpRKiqNO0l7FG/QKvUOXHqSD0L0XcVCnuCkOjhIIfAoJBAvte/4TEV86yS8R8YwPjLHVeYiIN8z1XnDBTu874R1rhNYZgSkCJSYJDU44IMcIAzR4xBFZppXhFaXWHhVmqN0krYQ1lno1fjBEnpBQoMDGvSeUqBI+sfC3Cqsry2kjUQBG7/AAAAAASUVORK5CYII="},{width:5,height:5,url:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAklEQVR4AewaftIAAAA/SURBVEXBMQpAYAAG0Ed/RgMpJ3MsJ+B2yqDsMnws8p5PkinJ7FUlWXFhwIG7xoALG3p0BQ1G9DhRCha0fvsDCxoSQzqXcdgAAAAASUVORK5CYII="}]};</script>
<script type="text/javascript">
!function(e,t){"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){function n(e){var t=e.length,n=ee.type(e);return"function"!==n&&!ee.isWindow(e)&&(!(1!==e.nodeType||!t)||("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e))}function r(e,t,n){if(ee.isFunction(t))return ee.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return ee.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(ae.test(t))return ee.filter(t,e,n);t=ee.filter(t,e)}return ee.grep(e,function(e){return U.call(t,e)>=0!==n})}function i(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function o(e){var t=he[e]={};return ee.each(e.match(de)||[],function(e,n){t[n]=!0}),t}function s(){K.removeEventListener("DOMContentLoaded",s,!1),e.removeEventListener("load",s,!1),ee.ready()}function a(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=ee.expando+Math.random()}function u(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(be,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n||"false"!==n&&("null"===n?null:+n+""===n?+n:xe.test(n)?ee.parseJSON(n):n)}catch(e){}ye.set(e,t,n)}else n=void 0;return n}function l(){return!0}function c(){return!1}function f(){try{return K.activeElement}catch(e){}}function p(e,t){return ee.nodeName(e,"table")&&ee.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function d(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function h(e){var t=Pe.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function g(e,t){for(var n=0,r=e.length;n<r;n++)ve.set(e[n],"globalEval",!t||ve.get(t[n],"globalEval"))}function m(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(ve.hasData(e)&&(o=ve.access(e),s=ve.set(t,o),l=o.events)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;n<r;n++)ee.event.add(t,i,l[i][n])}ye.hasData(e)&&(a=ye.access(e),u=ee.extend({},a),ye.set(t,u))}}function v(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return void 0===t||t&&ee.nodeName(e,t)?ee.merge([e],n):n}function y(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Ne.test(e.type)?t.checked=e.checked:"input"!==n&&"textarea"!==n||(t.defaultValue=e.defaultValue)}function x(t,n){var r=ee(n.createElement(t)).appendTo(n.body),i=e.getDefaultComputedStyle?e.getDefaultComputedStyle(r[0]).display:ee.css(r[0],"display");return r.detach(),i}function b(e){var t=K,n=$e[e];return n||(n=x(e,t),"none"!==n&&n||(We=(We||ee("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement),t=We[0].contentDocument,t.write(),t.close(),n=x(e,t),We.detach()),$e[e]=n),n}function w(e,t,n){var r,i,o,s,a=e.style;return n=n||_e(e),n&&(s=n.getPropertyValue(t)||n[t]),n&&(""!==s||ee.contains(e.ownerDocument,e)||(s=ee.style(e,t)),Ie.test(s)&&Be.test(t)&&(r=a.width,i=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=s,s=n.width,a.width=r,a.minWidth=i,a.maxWidth=o)),void 0!==s?s+"":s}function T(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function C(e,t){if(t in e)return t;for(var n=t[0].toUpperCase()+t.slice(1),r=t,i=Ge.length;i--;)if(t=Ge[i]+n,t in e)return t;return r}function N(e,t,n){var r=ze.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function k(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;o<4;o+=2)"margin"===n&&(s+=ee.css(e,n+Te[o],!0,i)),r?("content"===n&&(s-=ee.css(e,"padding"+Te[o],!0,i)),"margin"!==n&&(s-=ee.css(e,"border"+Te[o]+"Width",!0,i))):(s+=ee.css(e,"padding"+Te[o],!0,i),"padding"!==n&&(s+=ee.css(e,"border"+Te[o]+"Width",!0,i)));return s}function E(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=_e(e),s="border-box"===ee.css(e,"boxSizing",!1,o);if(i<=0||null==i){if(i=w(e,t,o),(i<0||null==i)&&(i=e.style[t]),Ie.test(i))return i;r=s&&(J.boxSizingReliable()||i===e.style[t]),i=parseFloat(i)||0}return i+k(e,t,n||(s?"border":"content"),r,o)+"px"}function D(e,t){for(var n,r,i,o=[],s=0,a=e.length;s<a;s++)r=e[s],r.style&&(o[s]=ve.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&Ce(r)&&(o[s]=ve.access(r,"olddisplay",b(r.nodeName)))):o[s]||(i=Ce(r),(n&&"none"!==n||!i)&&ve.set(r,"olddisplay",i?n:ee.css(r,"display"))));for(s=0;s<a;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}function j(e,t,n,r,i){return new j.prototype.init(e,t,n,r,i)}function S(){return setTimeout(function(){Qe=void 0}),Qe=ee.now()}function A(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)n=Te[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function L(e,t,n){for(var r,i=(nt[t]||[]).concat(nt["*"]),o=0,s=i.length;o<s;o++)if(r=i[o].call(n,t,e))return r}function q(e,t,n){var r,i,o,s,a,u,l,c=this,f={},p=e.style,d=e.nodeType&&Ce(e),h=ve.get(e,"fxshow");n.queue||(a=ee._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,u=a.empty.fire,a.empty.fire=function(){a.unqueued||u()}),a.unqueued++,c.always(function(){c.always(function(){a.unqueued--,ee.queue(e,"fx").length||a.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],l=ee.css(e,"display"),"none"===l&&(l=b(e.nodeName)),"inline"===l&&"none"===ee.css(e,"float")&&(p.display="inline-block")),n.overflow&&(p.overflow="hidden",c.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Ke.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(d?"hide":"show")){if("show"!==i||!h||void 0===h[r])continue;d=!0}f[r]=h&&h[r]||ee.style(e,r)}if(!ee.isEmptyObject(f)){h?"hidden"in h&&(d=h.hidden):h=ve.access(e,"fxshow",{}),o&&(h.hidden=!d),d?ee(e).show():c.done(function(){ee(e).hide()}),c.done(function(){var t;ve.remove(e,"fxshow");for(t in f)ee.style(e,t,f[t])});for(r in f)s=L(d?h[r]:0,r,c),r in h||(h[r]=s.start,d&&(s.end=s.start,s.start="width"===r||"height"===r?1:0))}}function H(e,t){var n,r,i,o,s;for(n in e)if(r=ee.camelCase(n),i=t[r],o=e[n],ee.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=ee.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function O(e,t,n){var r,i,o=0,s=tt.length,a=ee.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=Qe||S(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;s<u;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),o<1&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:ee.extend({},t),opts:ee.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Qe||S(),duration:n.duration,tweens:[],createTween:function(t,n){var r=ee.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(H(c,l.opts.specialEasing);o<s;o++)if(r=tt[o].call(l,e,c,l.opts))return r;return ee.map(c,L,l),ee.isFunction(l.opts.start)&&l.opts.start.call(e,l),ee.fx.timer(ee.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function F(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(de)||[];if(ee.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function P(e,t,n,r){function i(a){var u;return o[a]=!0,ee.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||s||o[l]?s?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},s=e===wt;return i(t.dataTypes[0])||!o["*"]&&i("*")}function M(e,t){var n,r,i=ee.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&ee.extend(!0,e,r),e}function R(e,t,n){for(var r,i,o,s,a=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}if(o)return o!==u[0]&&u.unshift(o),n[o]}function W(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e.throws)t=s(t);else try{t=s(t)}catch(e){return{state:"parsererror",error:s?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}function $(e,t,n,r){var i;if(ee.isArray(t))ee.each(t,function(t,i){n||Nt.test(e)?r(e,i):$(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==ee.type(t))r(e,t);else for(i in t)$(e+"["+i+"]",t[i],n,r)}function B(e){return ee.isWindow(e)?e:9===e.nodeType&&e.defaultView}var I=[],_=I.slice,X=I.concat,z=I.push,U=I.indexOf,V={},Y=V.toString,G=V.hasOwnProperty,Q="".trim,J={},K=e.document,Z="2.1.0",ee=function(e,t){return new ee.fn.init(e,t)},te=/^-ms-/,ne=/-([\da-z])/gi,re=function(e,t){return t.toUpperCase()};ee.fn=ee.prototype={jquery:Z,constructor:ee,selector:"",length:0,toArray:function(){return _.call(this)},get:function(e){return null!=e?e<0?this[e+this.length]:this[e]:_.call(this)},pushStack:function(e){var t=ee.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return ee.each(this,e,t)},map:function(e){return this.pushStack(ee.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(_.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:z,sort:I.sort,splice:I.splice},ee.extend=ee.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[a]||{},a++),"object"==typeof s||ee.isFunction(s)||(s={}),a===u&&(s=this,a--);a<u;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(ee.isPlainObject(r)||(i=ee.isArray(r)))?(i?(i=!1,o=n&&ee.isArray(n)?n:[]):o=n&&ee.isPlainObject(n)?n:{},s[t]=ee.extend(l,o,r)):void 0!==r&&(s[t]=r));return s},ee.extend({expando:"jQuery"+(Z+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===ee.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return e-parseFloat(e)>=0},isPlainObject:function(e){if("object"!==ee.type(e)||e.nodeType||ee.isWindow(e))return!1;try{if(e.constructor&&!G.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(e){return!1}return!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?V[Y.call(e)]||"object":typeof e},globalEval:function(e){var t,n=eval;e=ee.trim(e),e&&(1===e.indexOf("use strict")?(t=K.createElement("script"),t.text=e,K.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(te,"ms-").replace(ne,re)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,r){var i,o=0,s=e.length,a=n(e);if(r){if(a)for(;o<s&&(i=t.apply(e[o],r),i!==!1);o++);else for(o in e)if(i=t.apply(e[o],r),i===!1)break}else if(a)for(;o<s&&(i=t.call(e[o],o,e[o]),i!==!1);o++);else for(o in e)if(i=t.call(e[o],o,e[o]),i===!1)break;return e},trim:function(e){return null==e?"":Q.call(e)},makeArray:function(e,t){var r=t||[];return null!=e&&(n(Object(e))?ee.merge(r,"string"==typeof e?[e]:e):z.call(r,e)),r},inArray:function(e,t,n){return null==t?-1:U.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,s=e.length,a=!n;o<s;o++)r=!t(e[o],o),r!==a&&i.push(e[o]);return i},map:function(e,t,r){var i,o=0,s=e.length,a=n(e),u=[];if(a)for(;o<s;o++)i=t(e[o],o,r),null!=i&&u.push(i);else for(o in e)i=t(e[o],o,r),null!=i&&u.push(i);return X.apply([],u)},guid:1,proxy:function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),ee.isFunction(e))return r=_.call(arguments,2),i=function(){return e.apply(t||this,r.concat(_.call(arguments)))},i.guid=e.guid=e.guid||ee.guid++,i},now:Date.now,support:J}),ee.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){V["[object "+t+"]"]=t.toLowerCase()});var ie=function(e){function t(e,t,n,r){var i,o,s,a,u,l,f,h,g,m;if((t?t.ownerDocument||t:$)!==q&&L(t),t=t||q,n=n||[],!e||"string"!=typeof e)return n;if(1!==(a=t.nodeType)&&9!==a)return[];if(O&&!r){if(i=ye.exec(e))if(s=i[1]){if(9===a){if(o=t.getElementById(s),!o||!o.parentNode)return n;if(o.id===s)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(s))&&R(t,o)&&o.id===s)return n.push(o),n}else{if(i[2])return Z.apply(n,t.getElementsByTagName(e)),n;if((s=i[3])&&C.getElementsByClassName&&t.getElementsByClassName)return Z.apply(n,t.getElementsByClassName(s)),n}if(C.qsa&&(!F||!F.test(e))){if(h=f=W,g=t,m=9===a&&e,1===a&&"object"!==t.nodeName.toLowerCase()){for(l=p(e),(f=t.getAttribute("id"))?h=f.replace(be,"\\$&"):t.setAttribute("id",h),h="[id='"+h+"'] ",u=l.length;u--;)l[u]=h+d(l[u]);g=xe.test(e)&&c(t.parentNode)||t,m=l.join(",")}if(m)try{return Z.apply(n,g.querySelectorAll(m)),n}catch(e){}finally{f||t.removeAttribute("id")}}}return w(e.replace(ue,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>N.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=q.createElement("div");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=e.length;r--;)N.attrHandle[n[r]]=t}function s(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||Y)-(~e.sourceIndex||Y);if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function a(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),s=o.length;s--;)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}function c(e){return e&&typeof e.getElementsByTagName!==V&&e}function f(){}function p(e,n){var r,i,o,s,a,u,l,c=X[e+" "];if(c)return n?0:c.slice(0);for(a=e,u=[],l=N.preFilter;a;){r&&!(i=le.exec(a))||(i&&(a=a.slice(i[0].length)||a),u.push(o=[])),r=!1,(i=ce.exec(a))&&(r=i.shift(),o.push({value:r,type:i[0].replace(ue," ")}),a=a.slice(r.length));for(s in N.filter)!(i=he[s].exec(a))||l[s]&&!(i=l[s](i))||(r=i.shift(),o.push({value:r,type:s,matches:i}),a=a.slice(r.length));if(!r)break}return n?a.length:a?t.error(e):X(e,u).slice(0)}function d(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function h(e,t,n){var r=t.dir,i=n&&"parentNode"===r,o=I++;return t.first?function(t,n,o){for(;t=t[r];)if(1===t.nodeType||i)return e(t,n,o)}:function(t,n,s){var a,u,l=[B,o];if(s){for(;t=t[r];)if((1===t.nodeType||i)&&e(t,n,s))return!0}else for(;t=t[r];)if(1===t.nodeType||i){if(u=t[W]||(t[W]={}),(a=u[r])&&a[0]===B&&a[1]===o)return l[2]=a[2];if(u[r]=l,l[2]=e(t,n,s))return!0}}}function g(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function m(e,t,n,r,i){for(var o,s=[],a=0,u=e.length,l=null!=t;a<u;a++)(o=e[a])&&(n&&!n(o,r,i)||(s.push(o),l&&t.push(a)));return s}function v(e,t,n,i,o,s){return i&&!i[W]&&(i=v(i)),o&&!o[W]&&(o=v(o,s)),r(function(r,s,a,u){var l,c,f,p=[],d=[],h=s.length,g=r||b(t||"*",a.nodeType?[a]:a,[]),v=!e||!r&&t?g:m(g,p,e,a,u),y=n?o||(r?e:h||i)?[]:s:v;if(n&&n(v,y,a,u),i)for(l=m(y,d),i(l,[],a,u),c=l.length;c--;)(f=l[c])&&(y[d[c]]=!(v[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=y.length;c--;)(f=y[c])&&l.push(v[c]=f);o(null,y=[],l,u)}for(c=y.length;c--;)(f=y[c])&&(l=o?te.call(r,f):p[c])>-1&&(r[l]=!(s[l]=f))}}else y=m(y===s?y.splice(h,y.length):y),o?o(null,s,y,u):Z.apply(s,y)})}function y(e){for(var t,n,r,i=e.length,o=N.relative[e[0].type],s=o||N.relative[" "],a=o?1:0,u=h(function(e){return e===t},s,!0),l=h(function(e){return te.call(t,e)>-1},s,!0),c=[function(e,n,r){return!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r))}];a<i;a++)if(n=N.relative[e[a].type])c=[h(g(c),n)];else{if(n=N.filter[e[a].type].apply(null,e[a].matches),n[W]){for(r=++a;r<i&&!N.relative[e[r].type];r++);return v(a>1&&g(c),a>1&&d(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(ue,"$1"),n,a<r&&y(e.slice(a,r)),r<i&&y(e=e.slice(r)),r<i&&d(e))}c.push(n)}return g(c)}function x(e,n){var i=n.length>0,o=e.length>0,s=function(r,s,a,u,l){var c,f,p,d=0,h="0",g=r&&[],v=[],y=j,x=r||o&&N.find.TAG("*",l),b=B+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=s!==q&&s);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0;p=e[f++];)if(p(c,s,a)){u.push(c);break}l&&(B=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,v,s,a);if(r){if(d>0)for(;h--;)g[h]||v[h]||(v[h]=J.call(u));v=m(v)}Z.apply(u,v),l&&!r&&v.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&(B=b,j=y),g};return i?r(s):s}function b(e,n,r){for(var i=0,o=n.length;i<o;i++)t(e,n[i],r);return r}function w(e,t,n,r){var i,o,s,a,u,l=p(e);if(!r&&1===l.length){if(o=l[0]=l[0].slice(0),o.length>2&&"ID"===(s=o[0]).type&&C.getById&&9===t.nodeType&&O&&N.relative[o[1].type]){if(t=(N.find.ID(s.matches[0].replace(we,Te),t)||[])[0],!t)return n;e=e.slice(o.shift().value.length)}for(i=he.needsContext.test(e)?0:o.length;i--&&(s=o[i],!N.relative[a=s.type]);)if((u=N.find[a])&&(r=u(s.matches[0].replace(we,Te),xe.test(o[0].type)&&c(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&d(o),!e)return Z.apply(n,r),n;break}}return D(e,l)(r,t,!O,n,xe.test(e)&&c(t.parentNode)||t),n}var T,C,N,k,E,D,j,S,A,L,q,H,O,F,P,M,R,W="sizzle"+-new Date,$=e.document,B=0,I=0,_=n(),X=n(),z=n(),U=function(e,t){return e===t&&(A=!0),0},V="undefined",Y=1<<31,G={}.hasOwnProperty,Q=[],J=Q.pop,K=Q.push,Z=Q.push,ee=Q.slice,te=Q.indexOf||function(e){for(var t=0,n=this.length;t<n;t++)if(this[t]===e)return t;return-1},ne="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",re="[\\x20\\t\\r\\n\\f]",ie="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",oe=ie.replace("w","w#"),se="\\["+re+"*("+ie+")"+re+"*(?:([*^$|!~]?=)"+re+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+oe+")|)|)"+re+"*\\]",ae=":("+ie+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+se.replace(3,8)+")*)|.*)\\)|)",ue=new RegExp("^"+re+"+|((?:^|[^\\\\])(?:\\\\.)*)"+re+"+$","g"),le=new RegExp("^"+re+"*,"+re+"*"),ce=new RegExp("^"+re+"*([>+~]|"+re+")"+re+"*"),fe=new RegExp("="+re+"*([^\\]'\"]*?)"+re+"*\\]","g"),pe=new RegExp(ae),de=new RegExp("^"+oe+"$"),he={ID:new RegExp("^#("+ie+")"),CLASS:new RegExp("^\\.("+ie+")"),TAG:new RegExp("^("+ie.replace("w","w*")+")"),ATTR:new RegExp("^"+se),PSEUDO:new RegExp("^"+ae),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+re+"*(even|odd|(([+-]|)(\\d*)n|)"+re+"*(?:([+-]|)"+re+"*(\\d+)|))"+re+"*\\)|)","i"),bool:new RegExp("^(?:"+ne+")$","i"),needsContext:new RegExp("^"+re+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+re+"*((?:-\\d)?\\d*)"+re+"*\\)|)(?=[^-]|$)","i")},ge=/^(?:input|select|textarea|button)$/i,me=/^h\d$/i,ve=/^[^{]+\{\s*\[native \w/,ye=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,xe=/[+~]/,be=/'|\\/g,we=new RegExp("\\\\([\\da-f]{1,6}"+re+"?|("+re+")|.)","ig"),Te=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)};try{Z.apply(Q=ee.call($.childNodes),$.childNodes),Q[$.childNodes.length].nodeType}catch(e){Z={apply:Q.length?function(e,t){K.apply(e,ee.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}C=t.support={},E=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},L=t.setDocument=function(e){var t,n=e?e.ownerDocument||e:$,r=n.defaultView;return n!==q&&9===n.nodeType&&n.documentElement?(q=n,H=n.documentElement,O=!E(n),r&&r!==r.top&&(r.addEventListener?r.addEventListener("unload",function(){L()},!1):r.attachEvent&&r.attachEvent("onunload",function(){L()})),C.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),C.getElementsByTagName=i(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),C.getElementsByClassName=ve.test(n.getElementsByClassName)&&i(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),C.getById=i(function(e){return H.appendChild(e).id=W,!n.getElementsByName||!n.getElementsByName(W).length}),C.getById?(N.find.ID=function(e,t){if(typeof t.getElementById!==V&&O){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},N.filter.ID=function(e){var t=e.replace(we,Te);return function(e){return e.getAttribute("id")===t}}):(delete N.find.ID,N.filter.ID=function(e){var t=e.replace(we,Te);return function(e){var n=typeof e.getAttributeNode!==V&&e.getAttributeNode("id");return n&&n.value===t}}),N.find.TAG=C.getElementsByTagName?function(e,t){if(typeof t.getElementsByTagName!==V)return t.getElementsByTagName(e)}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},N.find.CLASS=C.getElementsByClassName&&function(e,t){if(typeof t.getElementsByClassName!==V&&O)return t.getElementsByClassName(e)},P=[],F=[],(C.qsa=ve.test(n.querySelectorAll))&&(i(function(e){e.innerHTML="<select t=''><option selected=''></option></select>",e.querySelectorAll("[t^='']").length&&F.push("[*^$]="+re+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||F.push("\\["+re+"*(?:value|"+ne+")"),e.querySelectorAll(":checked").length||F.push(":checked")}),i(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&F.push("name"+re+"*[*^$|!~]?="),e.querySelectorAll(":enabled").length||F.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),F.push(",.*:")})),(C.matchesSelector=ve.test(M=H.webkitMatchesSelector||H.mozMatchesSelector||H.oMatchesSelector||H.msMatchesSelector))&&i(function(e){C.disconnectedMatch=M.call(e,"div"),M.call(e,"[s!='']:x"),P.push("!=",ae)}),F=F.length&&new RegExp(F.join("|")),P=P.length&&new RegExp(P.join("|")),t=ve.test(H.compareDocumentPosition),R=t||ve.test(H.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},U=t?function(e,t){if(e===t)return A=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r?r:(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&r||!C.sortDetached&&t.compareDocumentPosition(e)===r?e===n||e.ownerDocument===$&&R($,e)?-1:t===n||t.ownerDocument===$&&R($,t)?1:S?te.call(S,e)-te.call(S,t):0:4&r?-1:1)}:function(e,t){if(e===t)return A=!0,0;var r,i=0,o=e.parentNode,a=t.parentNode,u=[e],l=[t];if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:S?te.call(S,e)-te.call(S,t):0;if(o===a)return s(e,t);for(r=e;r=r.parentNode;)u.unshift(r);for(r=t;r=r.parentNode;)l.unshift(r);for(;u[i]===l[i];)i++;return i?s(u[i],l[i]):u[i]===$?-1:l[i]===$?1:0},n):q},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==q&&L(e),n=n.replace(fe,"='$1']"),C.matchesSelector&&O&&(!P||!P.test(n))&&(!F||!F.test(n)))try{var r=M.call(e,n);if(r||C.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return t(n,q,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==q&&L(e),R(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==q&&L(e);var n=N.attrHandle[t.toLowerCase()],r=n&&G.call(N.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:C.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(A=!C.detectDuplicates,S=!C.sortStable&&e.slice(0),e.sort(U),A){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return S=null,e},k=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=k(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=k(t);return n},N=t.selectors={cacheLength:50,createPseudo:r,match:he,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(we,Te),e[3]=(e[4]||e[5]||"").replace(we,Te),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return he.CHILD.test(e[0])?null:(e[3]&&void 0!==e[4]?e[2]=e[4]:n&&pe.test(n)&&(t=p(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(we,Te).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=_[e+" "];return t||(t=new RegExp("(^|"+re+")"+e+"("+re+"|$)"))&&_(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==V&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:!n||(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o+" ").indexOf(r)>-1:"|="===n&&(o===r||o.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,v=a&&t.nodeName.toLowerCase(),y=!u&&!a;if(m){if(o){for(;g;){for(f=t;f=f[g];)if(a?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[s?m.firstChild:m.lastChild],s&&y){for(c=m[W]||(m[W]={}),l=c[e]||[],d=l[0]===B&&l[1],p=l[0]===B&&l[2],f=d&&m.childNodes[d];f=++d&&f&&f[g]||(p=d=0)||h.pop();)if(1===f.nodeType&&++p&&f===t){c[e]=[B,d,p];break}}else if(y&&(l=(t[W]||(t[W]={}))[e])&&l[0]===B)p=l[1];else for(;(f=++d&&f&&f[g]||(p=d=0)||h.pop())&&((a?f.nodeName.toLowerCase()!==v:1!==f.nodeType)||!++p||(y&&((f[W]||(f[W]={}))[e]=[B,p]),f!==t)););return p-=i,p===r||p%r===0&&p/r>=0}}},PSEUDO:function(e,n){var i,o=N.pseudos[e]||N.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],N.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),s=i.length;s--;)r=te.call(e,i[s]),e[r]=!(t[r]=i[s])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=D(e.replace(ue,"$1"));return i[W]?r(function(e,t,n,r){for(var o,s=i(e,null,r,[]),a=e.length;a--;)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return function(t){return(t.textContent||t.innerText||k(t)).indexOf(e)>-1}}),lang:r(function(e){return de.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(we,Te).toLowerCase(),function(t){var n;do if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===H},focus:function(e){return e===q.activeElement&&(!q.hasFocus||q.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!N.pseudos.empty(e)},header:function(e){return me.test(e.nodeName)},input:function(e){return ge.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:l(function(){return[0]}),last:l(function(e,t){return[t-1]}),eq:l(function(e,t,n){return[n<0?n+t:n]}),even:l(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:l(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:l(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:l(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},N.pseudos.nth=N.pseudos.eq;for(T in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})N.pseudos[T]=a(T);for(T in{submit:!0,reset:!0})N.pseudos[T]=u(T);return f.prototype=N.filters=N.pseudos,N.setFilters=new f,D=t.compile=function(e,t){var n,r=[],i=[],o=z[e+" "];if(!o){for(t||(t=p(e)),n=t.length;n--;)o=y(t[n]),o[W]?r.push(o):i.push(o);o=z(e,x(i,r))}return o},C.sortStable=W.split("").sort(U).join("")===W,C.detectDuplicates=!!A,L(),C.sortDetached=i(function(e){return 1&e.compareDocumentPosition(q.createElement("div"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),C.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(ne,function(e,t,n){var r;if(!n)return e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);ee.find=ie,ee.expr=ie.selectors,ee.expr[":"]=ee.expr.pseudos,ee.unique=ie.uniqueSort,ee.text=ie.getText,ee.isXMLDoc=ie.isXML,ee.contains=ie.contains;var oe=ee.expr.match.needsContext,se=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,ae=/^.[^:#\[\.,]*$/;ee.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?ee.find.matchesSelector(r,e)?[r]:[]:ee.find.matches(e,ee.grep(t,function(e){return 1===e.nodeType}))},ee.fn.extend({find:function(e){var t,n=this.length,r=[],i=this;if("string"!=typeof e)return this.pushStack(ee(e).filter(function(){for(t=0;t<n;t++)if(ee.contains(i[t],this))return!0}));for(t=0;t<n;t++)ee.find(e,i[t],r);return r=this.pushStack(n>1?ee.unique(r):r),r.selector=this.selector?this.selector+" "+e:e,r},filter:function(e){return this.pushStack(r(this,e||[],!1));
},not:function(e){return this.pushStack(r(this,e||[],!0))},is:function(e){return!!r(this,"string"==typeof e&&oe.test(e)?ee(e):e||[],!1).length}});var ue,le=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,ce=ee.fn.init=function(e,t){var n,r;if(!e)return this;if("string"==typeof e){if(n="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:le.exec(e),!n||!n[1]&&t)return!t||t.jquery?(t||ue).find(e):this.constructor(t).find(e);if(n[1]){if(t=t instanceof ee?t[0]:t,ee.merge(this,ee.parseHTML(n[1],t&&t.nodeType?t.ownerDocument||t:K,!0)),se.test(n[1])&&ee.isPlainObject(t))for(n in t)ee.isFunction(this[n])?this[n](t[n]):this.attr(n,t[n]);return this}return r=K.getElementById(n[2]),r&&r.parentNode&&(this.length=1,this[0]=r),this.context=K,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):ee.isFunction(e)?"undefined"!=typeof ue.ready?ue.ready(e):e(ee):(void 0!==e.selector&&(this.selector=e.selector,this.context=e.context),ee.makeArray(e,this))};ce.prototype=ee.fn,ue=ee(K);var fe=/^(?:parents|prev(?:Until|All))/,pe={children:!0,contents:!0,next:!0,prev:!0};ee.extend({dir:function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&ee(e).is(n))break;r.push(e)}return r},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}}),ee.fn.extend({has:function(e){var t=ee(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(ee.contains(this,t[e]))return!0})},closest:function(e,t){for(var n,r=0,i=this.length,o=[],s=oe.test(e)||"string"!=typeof e?ee(e,t||this.context):0;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(s?s.index(n)>-1:1===n.nodeType&&ee.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?ee.unique(o):o)},index:function(e){return e?"string"==typeof e?U.call(ee(e),this[0]):U.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(ee.unique(ee.merge(this.get(),ee(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),ee.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return ee.dir(e,"parentNode")},parentsUntil:function(e,t,n){return ee.dir(e,"parentNode",n)},next:function(e){return i(e,"nextSibling")},prev:function(e){return i(e,"previousSibling")},nextAll:function(e){return ee.dir(e,"nextSibling")},prevAll:function(e){return ee.dir(e,"previousSibling")},nextUntil:function(e,t,n){return ee.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return ee.dir(e,"previousSibling",n)},siblings:function(e){return ee.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return ee.sibling(e.firstChild)},contents:function(e){return e.contentDocument||ee.merge([],e.childNodes)}},function(e,t){ee.fn[e]=function(n,r){var i=ee.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=ee.filter(r,i)),this.length>1&&(pe[e]||ee.unique(i),fe.test(e)&&i.reverse()),this.pushStack(i)}});var de=/\S+/g,he={};ee.Callbacks=function(e){e="string"==typeof e?he[e]||o(e):ee.extend({},e);var t,n,r,i,s,a,u=[],l=!e.once&&[],c=function(o){for(t=e.memory&&o,n=!0,a=i||0,i=0,s=u.length,r=!0;u&&a<s;a++)if(u[a].apply(o[0],o[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,u&&(l?l.length&&c(l.shift()):t?u=[]:f.disable())},f={add:function(){if(u){var n=u.length;!function t(n){ee.each(n,function(n,r){var i=ee.type(r);"function"===i?e.unique&&f.has(r)||u.push(r):r&&r.length&&"string"!==i&&t(r)})}(arguments),r?s=u.length:t&&(i=n,c(t))}return this},remove:function(){return u&&ee.each(arguments,function(e,t){for(var n;(n=ee.inArray(t,u,n))>-1;)u.splice(n,1),r&&(n<=s&&s--,n<=a&&a--)}),this},has:function(e){return e?ee.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],s=0,this},disable:function(){return u=l=t=void 0,this},disabled:function(){return!u},lock:function(){return l=void 0,t||f.disable(),this},locked:function(){return!l},fireWith:function(e,t){return!u||n&&!l||(t=t||[],t=[e,t.slice?t.slice():t],r?l.push(t):c(t)),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!n}};return f},ee.extend({Deferred:function(e){var t=[["resolve","done",ee.Callbacks("once memory"),"resolved"],["reject","fail",ee.Callbacks("once memory"),"rejected"],["notify","progress",ee.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return ee.Deferred(function(n){ee.each(t,function(t,o){var s=ee.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&ee.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o[0]+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?ee.extend(e,r):r}},i={};return r.pipe=r.then,ee.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t,n,r,i=0,o=_.call(arguments),s=o.length,a=1!==s||e&&ee.isFunction(e.promise)?s:0,u=1===a?e:ee.Deferred(),l=function(e,n,r){return function(i){n[e]=this,r[e]=arguments.length>1?_.call(arguments):i,r===t?u.notifyWith(n,r):--a||u.resolveWith(n,r)}};if(s>1)for(t=new Array(s),n=new Array(s),r=new Array(s);i<s;i++)o[i]&&ee.isFunction(o[i].promise)?o[i].promise().done(l(i,r,o)).fail(u.reject).progress(l(i,n,t)):--a;return a||u.resolveWith(r,o),u.promise()}});var ge;ee.fn.ready=function(e){return ee.ready.promise().done(e),this},ee.extend({isReady:!1,readyWait:1,holdReady:function(e){e?ee.readyWait++:ee.ready(!0)},ready:function(e){(e===!0?--ee.readyWait:ee.isReady)||(ee.isReady=!0,e!==!0&&--ee.readyWait>0||(ge.resolveWith(K,[ee]),ee.fn.trigger&&ee(K).trigger("ready").off("ready")))}}),ee.ready.promise=function(t){return ge||(ge=ee.Deferred(),"complete"===K.readyState?setTimeout(ee.ready):(K.addEventListener("DOMContentLoaded",s,!1),e.addEventListener("load",s,!1))),ge.promise(t)},ee.ready.promise();var me=ee.access=function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===ee.type(n)){i=!0;for(a in n)ee.access(e,t,a,n[a],!0,o,s)}else if(void 0!==r&&(i=!0,ee.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(ee(e),n)})),t))for(;a<u;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o};ee.acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType},a.uid=1,a.accepts=ee.acceptData,a.prototype={key:function(e){if(!a.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=a.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,ee.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(ee.isEmptyObject(o))ee.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return void 0===t?n:n[t]},access:function(e,t,n){var r;return void 0===t||t&&"string"==typeof t&&void 0===n?(r=this.get(e,t),void 0!==r?r:this.get(e,ee.camelCase(t))):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),s=this.cache[o];if(void 0===t)this.cache[o]={};else{ee.isArray(t)?r=t.concat(t.map(ee.camelCase)):(i=ee.camelCase(t),t in s?r=[t,i]:(r=i,r=r in s?[r]:r.match(de)||[])),n=r.length;for(;n--;)delete s[r[n]]}},hasData:function(e){return!ee.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}};var ve=new a,ye=new a,xe=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,be=/([A-Z])/g;ee.extend({hasData:function(e){return ye.hasData(e)||ve.hasData(e)},data:function(e,t,n){return ye.access(e,t,n)},removeData:function(e,t){ye.remove(e,t)},_data:function(e,t,n){return ve.access(e,t,n)},_removeData:function(e,t){ve.remove(e,t)}}),ee.fn.extend({data:function(e,t){var n,r,i,o=this[0],s=o&&o.attributes;if(void 0===e){if(this.length&&(i=ye.get(o),1===o.nodeType&&!ve.get(o,"hasDataAttrs"))){for(n=s.length;n--;)r=s[n].name,0===r.indexOf("data-")&&(r=ee.camelCase(r.slice(5)),u(o,r,i[r]));ve.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){ye.set(this,e)}):me(this,function(t){var n,r=ee.camelCase(e);if(o&&void 0===t){if(n=ye.get(o,e),void 0!==n)return n;if(n=ye.get(o,r),void 0!==n)return n;if(n=u(o,r,void 0),void 0!==n)return n}else this.each(function(){var n=ye.get(this,r);ye.set(this,r,t),e.indexOf("-")!==-1&&void 0!==n&&ye.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){ye.remove(this,e)})}}),ee.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=ve.get(e,t),n&&(!r||ee.isArray(n)?r=ve.access(e,t,ee.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=ee.queue(e,t),r=n.length,i=n.shift(),o=ee._queueHooks(e,t),s=function(){ee.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return ve.get(e,n)||ve.access(e,n,{empty:ee.Callbacks("once memory").add(function(){ve.remove(e,[t+"queue",n])})})}}),ee.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?ee.queue(this[0],e):void 0===t?this:this.each(function(){var n=ee.queue(this,e,t);ee._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&ee.dequeue(this,e)})},dequeue:function(e){return this.each(function(){ee.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=ee.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";s--;)n=ve.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var we=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Te=["Top","Right","Bottom","Left"],Ce=function(e,t){return e=t||e,"none"===ee.css(e,"display")||!ee.contains(e.ownerDocument,e)},Ne=/^(?:checkbox|radio)$/i;!function(){var e=K.createDocumentFragment(),t=e.appendChild(K.createElement("div"));t.innerHTML="<input type='radio' checked='checked' name='t'/>",J.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",J.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var ke="undefined";J.focusinBubbles="onfocusin"in e;var Ee=/^key/,De=/^(?:mouse|contextmenu)|click/,je=/^(?:focusinfocus|focusoutblur)$/,Se=/^([^.]*)(?:\.(.+)|)$/;ee.event={global:{},add:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=ve.get(e);if(m)for(n.handler&&(o=n,n=o.handler,i=o.selector),n.guid||(n.guid=ee.guid++),(u=m.events)||(u=m.events={}),(s=m.handle)||(s=m.handle=function(t){return typeof ee!==ke&&ee.event.triggered!==t.type?ee.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(de)||[""],l=t.length;l--;)a=Se.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d&&(f=ee.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=ee.event.special[d]||{},c=ee.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&ee.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,s)!==!1||e.addEventListener&&e.addEventListener(d,s,!1)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),ee.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=ve.hasData(e)&&ve.get(e);if(m&&(u=m.events)){for(t=(t||"").match(de)||[""],l=t.length;l--;)if(a=Se.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d){for(f=ee.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],a=a[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));s&&!p.length&&(f.teardown&&f.teardown.call(e,h,m.handle)!==!1||ee.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)ee.event.remove(e,d+t[l],n,r,!0);ee.isEmptyObject(u)&&(delete m.handle,ve.remove(e,"events"))}},trigger:function(t,n,r,i){var o,s,a,u,l,c,f,p=[r||K],d=G.call(t,"type")?t.type:t,h=G.call(t,"namespace")?t.namespace.split("."):[];if(s=a=r=r||K,3!==r.nodeType&&8!==r.nodeType&&!je.test(d+ee.event.triggered)&&(d.indexOf(".")>=0&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[ee.expando]?t:new ee.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.namespace_re=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:ee.makeArray(n,[t]),f=ee.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!ee.isWindow(r)){for(u=f.delegateType||d,je.test(u+d)||(s=s.parentNode);s;s=s.parentNode)p.push(s),a=s;a===(r.ownerDocument||K)&&p.push(a.defaultView||a.parentWindow||e)}for(o=0;(s=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(ve.get(s,"events")||{})[t.type]&&ve.get(s,"handle"),c&&c.apply(s,n),c=l&&s[l],c&&c.apply&&ee.acceptData(s)&&(t.result=c.apply(s,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!ee.acceptData(r)||l&&ee.isFunction(r[d])&&!ee.isWindow(r)&&(a=r[l],a&&(r[l]=null),ee.event.triggered=d,r[d](),ee.event.triggered=void 0,a&&(r[l]=a)),t.result}},dispatch:function(e){e=ee.event.fix(e);var t,n,r,i,o,s=[],a=_.call(arguments),u=(ve.get(this,"events")||{})[e.type]||[],l=ee.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){for(s=ee.event.handlers.call(this,e,u),t=0;(i=s[t++])&&!e.isPropagationStopped();)for(e.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!e.isImmediatePropagationStopped();)e.namespace_re&&!e.namespace_re.test(o.namespace)||(e.handleObj=o,e.data=o.data,r=((ee.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),void 0!==r&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()));return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;n<a;n++)o=t[n],i=o.selector+" ",void 0===r[i]&&(r[i]=o.needsContext?ee(i,this).index(u)>=0:ee.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return a<t.length&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,o=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||K,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||void 0===o||(e.which=1&o?1:2&o?3:4&o?2:0),e}},fix:function(e){if(e[ee.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];for(s||(this.fixHooks[i]=s=De.test(i)?this.mouseHooks:Ee.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new ee.Event(o),t=r.length;t--;)n=r[t],e[n]=o[n];return e.target||(e.target=K),3===e.target.nodeType&&(e.target=e.target.parentNode),s.filter?s.filter(e,o):e},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==f()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===f()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&ee.nodeName(this,"input"))return this.click(),!1},_default:function(e){return ee.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=ee.extend(new ee.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?ee.event.trigger(i,null,t):ee.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},ee.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},ee.Event=function(e,t){return this instanceof ee.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.getPreventDefault&&e.getPreventDefault()?l:c):this.type=e,t&&ee.extend(this,t),this.timeStamp=e&&e.timeStamp||ee.now(),void(this[ee.expando]=!0)):new ee.Event(e,t)},ee.Event.prototype={isDefaultPrevented:c,isPropagationStopped:c,isImmediatePropagationStopped:c,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=l,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=l,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=l,this.stopPropagation()}},ee.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){ee.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return i&&(i===r||ee.contains(r,i))||(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),J.focusinBubbles||ee.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){ee.event.simulate(t,e.target,ee.event.fix(e),!0)};ee.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=ve.access(r,t);i||r.addEventListener(e,n,!0),ve.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=ve.access(r,t)-1;i?ve.access(r,t,i):(r.removeEventListener(e,n,!0),ve.remove(r,t))}}}),ee.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=void 0);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=void 0):null==r&&("string"==typeof t?(r=n,n=void 0):(r=n,n=t,t=void 0)),r===!1)r=c;else if(!r)return this;return 1===i&&(o=r,r=function(e){return ee().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=ee.guid++)),this.each(function(){ee.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,ee(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return t!==!1&&"function"!=typeof t||(n=t,t=void 0),n===!1&&(n=c),this.each(function(){ee.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){ee.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return ee.event.trigger(e,t,n,!0)}});var Ae=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,Le=/<([\w:]+)/,qe=/<|&#?\w+;/,He=/<(?:script|style|link)/i,Oe=/checked\s*(?:[^=]|=\s*.checked.)/i,Fe=/^$|\/(?:java|ecma)script/i,Pe=/^true\/(.*)/,Me=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Re={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Re.optgroup=Re.option,Re.tbody=Re.tfoot=Re.colgroup=Re.caption=Re.thead,Re.th=Re.td,ee.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=ee.contains(e.ownerDocument,e);if(!(J.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||ee.isXMLDoc(e)))for(s=v(a),o=v(e),r=0,i=o.length;r<i;r++)y(o[r],s[r]);if(t)if(n)for(o=o||v(e),s=s||v(a),r=0,i=o.length;r<i;r++)m(o[r],s[r]);else m(e,a);return s=v(a,"script"),s.length>0&&g(s,!u&&v(e,"script")),a},buildFragment:function(e,t,n,r){for(var i,o,s,a,u,l,c=t.createDocumentFragment(),f=[],p=0,d=e.length;p<d;p++)if(i=e[p],i||0===i)if("object"===ee.type(i))ee.merge(f,i.nodeType?[i]:i);else if(qe.test(i)){for(o=o||c.appendChild(t.createElement("div")),s=(Le.exec(i)||["",""])[1].toLowerCase(),a=Re[s]||Re._default,o.innerHTML=a[1]+i.replace(Ae,"<$1></$2>")+a[2],l=a[0];l--;)o=o.lastChild;ee.merge(f,o.childNodes),o=c.firstChild,o.textContent=""}else f.push(t.createTextNode(i));for(c.textContent="",p=0;i=f[p++];)if((!r||ee.inArray(i,r)===-1)&&(u=ee.contains(i.ownerDocument,i),o=v(c.appendChild(i),"script"),u&&g(o),n))for(l=0;i=o[l++];)Fe.test(i.type||"")&&n.push(i);return c},cleanData:function(e){for(var t,n,r,i,o,s,a=ee.event.special,u=0;void 0!==(n=e[u]);u++){if(ee.acceptData(n)&&(o=n[ve.expando],o&&(t=ve.cache[o]))){if(r=Object.keys(t.events||{}),r.length)for(s=0;void 0!==(i=r[s]);s++)a[i]?ee.event.remove(n,i):ee.removeEvent(n,i,t.handle);ve.cache[o]&&delete ve.cache[o]}delete ye.cache[n[ye.expando]]}}}),ee.fn.extend({text:function(e){return me(this,function(e){return void 0===e?ee.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){for(var n,r=e?ee.filter(e,this):this,i=0;null!=(n=r[i]);i++)t||1!==n.nodeType||ee.cleanData(v(n)),n.parentNode&&(t&&ee.contains(n.ownerDocument,n)&&g(v(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(ee.cleanData(v(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return ee.clone(this,e,t)})},html:function(e){return me(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!He.test(e)&&!Re[(Le.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(Ae,"<$1></$2>");try{for(;n<r;n++)t=this[n]||{},1===t.nodeType&&(ee.cleanData(v(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=arguments[0];return this.domManip(arguments,function(t){e=this.parentNode,ee.cleanData(v(this)),e&&e.replaceChild(t,this)}),e&&(e.length||e.nodeType)?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t){e=X.apply([],e);var n,r,i,o,s,a,u=0,l=this.length,c=this,f=l-1,p=e[0],g=ee.isFunction(p);if(g||l>1&&"string"==typeof p&&!J.checkClone&&Oe.test(p))return this.each(function(n){var r=c.eq(n);g&&(e[0]=p.call(this,n,r.html())),r.domManip(e,t)});if(l&&(n=ee.buildFragment(e,this[0].ownerDocument,!1,this),r=n.firstChild,1===n.childNodes.length&&(n=r),r)){for(i=ee.map(v(n,"script"),d),o=i.length;u<l;u++)s=n,u!==f&&(s=ee.clone(s,!0,!0),o&&ee.merge(i,v(s,"script"))),t.call(this[u],s,u);if(o)for(a=i[i.length-1].ownerDocument,ee.map(i,h),u=0;u<o;u++)s=i[u],Fe.test(s.type||"")&&!ve.access(s,"globalEval")&&ee.contains(a,s)&&(s.src?ee._evalUrl&&ee._evalUrl(s.src):ee.globalEval(s.textContent.replace(Me,"")))}return this}}),ee.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){ee.fn[e]=function(e){for(var n,r=[],i=ee(e),o=i.length-1,s=0;s<=o;s++)n=s===o?this:this.clone(!0),ee(i[s])[t](n),z.apply(r,n.get());return this.pushStack(r)}});var We,$e={},Be=/^margin/,Ie=new RegExp("^("+we+")(?!px)[a-z%]+$","i"),_e=function(e){return e.ownerDocument.defaultView.getComputedStyle(e,null)};!function(){function t(){a.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%",o.appendChild(s);var t=e.getComputedStyle(a,null);n="1%"!==t.top,r="4px"===t.width,o.removeChild(s)}var n,r,i="padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box",o=K.documentElement,s=K.createElement("div"),a=K.createElement("div");a.style.backgroundClip="content-box",a.cloneNode(!0).style.backgroundClip="",J.clearCloneStyle="content-box"===a.style.backgroundClip,s.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",s.appendChild(a),e.getComputedStyle&&ee.extend(J,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return null==r&&t(),r},reliableMarginRight:function(){var t,n=a.appendChild(K.createElement("div"));return n.style.cssText=a.style.cssText=i,n.style.marginRight=n.style.width="0",a.style.width="1px",o.appendChild(s),t=!parseFloat(e.getComputedStyle(n,null).marginRight),o.removeChild(s),a.innerHTML="",t}})}(),ee.swap=function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i};var Xe=/^(none|table(?!-c[ea]).+)/,ze=new RegExp("^("+we+")(.*)$","i"),Ue=new RegExp("^([+-])=("+we+")","i"),Ve={position:"absolute",visibility:"hidden",display:"block"},Ye={letterSpacing:0,fontWeight:400},Ge=["Webkit","O","Moz","ms"];ee.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=w(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{float:"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=ee.camelCase(t),u=e.style;return t=ee.cssProps[a]||(ee.cssProps[a]=C(u,a)),s=ee.cssHooks[t]||ee.cssHooks[a],void 0===n?s&&"get"in s&&void 0!==(i=s.get(e,!1,r))?i:u[t]:(o=typeof n,"string"===o&&(i=Ue.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(ee.css(e,t)),o="number"),null!=n&&n===n&&("number"!==o||ee.cssNumber[a]||(n+="px"),J.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&void 0===(n=s.set(e,n,r))||(u[t]="",u[t]=n)),void 0)}},css:function(e,t,n,r){var i,o,s,a=ee.camelCase(t);return t=ee.cssProps[a]||(ee.cssProps[a]=C(e.style,a)),s=ee.cssHooks[t]||ee.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),void 0===i&&(i=w(e,t,r)),"normal"===i&&t in Ye&&(i=Ye[t]),""===n||n?(o=parseFloat(i),n===!0||ee.isNumeric(o)?o||0:i):i}}),ee.each(["height","width"],function(e,t){ee.cssHooks[t]={get:function(e,n,r){if(n)return 0===e.offsetWidth&&Xe.test(ee.css(e,"display"))?ee.swap(e,Ve,function(){return E(e,t,r)}):E(e,t,r)},set:function(e,n,r){var i=r&&_e(e);return N(e,n,r?k(e,t,r,"border-box"===ee.css(e,"boxSizing",!1,i),i):0)}}}),ee.cssHooks.marginRight=T(J.reliableMarginRight,function(e,t){if(t)return ee.swap(e,{display:"inline-block"},w,[e,"marginRight"])}),ee.each({margin:"",padding:"",border:"Width"},function(e,t){ee.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+Te[r]+t]=o[r]||o[r-2]||o[0];return i}},Be.test(e)||(ee.cssHooks[e+t].set=N)}),ee.fn.extend({css:function(e,t){return me(this,function(e,t,n){var r,i,o={},s=0;if(ee.isArray(t)){for(r=_e(e),i=t.length;s<i;s++)o[t[s]]=ee.css(e,t[s],!1,r);return o}return void 0!==n?ee.style(e,t,n):ee.css(e,t)},e,t,arguments.length>1)},show:function(){return D(this,!0)},hide:function(){return D(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Ce(this)?ee(this).show():ee(this).hide()})}}),ee.Tween=j,j.prototype={constructor:j,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(ee.cssNumber[n]?"":"px")},cur:function(){var e=j.propHooks[this.prop];return e&&e.get?e.get(this):j.propHooks._default.get(this)},run:function(e){var t,n=j.propHooks[this.prop];return this.options.duration?this.pos=t=ee.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):j.propHooks._default.set(this),this}},j.prototype.init.prototype=j.prototype,j.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=ee.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){ee.fx.step[e.prop]?ee.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[ee.cssProps[e.prop]]||ee.cssHooks[e.prop])?ee.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},j.propHooks.scrollTop=j.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},ee.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},ee.fx=j.prototype.init,ee.fx.step={};var Qe,Je,Ke=/^(?:toggle|show|hide)$/,Ze=new RegExp("^(?:([+-])=|)("+we+")([a-z%]*)$","i"),et=/queueHooks$/,tt=[q],nt={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Ze.exec(t),o=i&&i[3]||(ee.cssNumber[e]?"":"px"),s=(ee.cssNumber[e]||"px"!==o&&+r)&&Ze.exec(ee.css(n.elem,e)),a=1,u=20;if(s&&s[3]!==o){o=o||s[3],i=i||[],s=+r||1;do a=a||".5",s/=a,ee.style(n.elem,e,s+o);while(a!==(a=n.cur()/r)&&1!==a&&--u)}return i&&(s=n.start=+s||+r||0,n.unit=o,n.end=i[1]?s+(i[1]+1)*i[2]:+i[2]),n}]};ee.Animation=ee.extend(O,{tweener:function(e,t){ee.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");for(var n,r=0,i=e.length;r<i;r++)n=e[r],nt[n]=nt[n]||[],nt[n].unshift(t)},prefilter:function(e,t){t?tt.unshift(e):tt.push(e)}}),ee.speed=function(e,t,n){var r=e&&"object"==typeof e?ee.extend({},e):{complete:n||!n&&t||ee.isFunction(e)&&e,duration:e,easing:n&&t||t&&!ee.isFunction(t)&&t};return r.duration=ee.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in ee.fx.speeds?ee.fx.speeds[r.duration]:ee.fx.speeds._default,null!=r.queue&&r.queue!==!0||(r.queue="fx"),r.old=r.complete,r.complete=function(){ee.isFunction(r.old)&&r.old.call(this),r.queue&&ee.dequeue(this,r.queue)},r},ee.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Ce).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=ee.isEmptyObject(e),o=ee.speed(t,n,r),s=function(){var t=O(this,ee.extend({},e),o);(i||ve.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=ee.timers,s=ve.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&et.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||ee.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=ve.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=ee.timers,s=r?r.length:0;for(n.finish=!0,ee.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<s;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),ee.each(["toggle","show","hide"],function(e,t){var n=ee.fn[t];ee.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(A(t,!0),e,r,i)}}),ee.each({
slideDown:A("show"),slideUp:A("hide"),slideToggle:A("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){ee.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),ee.timers=[],ee.fx.tick=function(){var e,t=0,n=ee.timers;for(Qe=ee.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||ee.fx.stop(),Qe=void 0},ee.fx.timer=function(e){ee.timers.push(e),e()?ee.fx.start():ee.timers.pop()},ee.fx.interval=13,ee.fx.start=function(){Je||(Je=setInterval(ee.fx.tick,ee.fx.interval))},ee.fx.stop=function(){clearInterval(Je),Je=null},ee.fx.speeds={slow:600,fast:200,_default:400},ee.fn.delay=function(e,t){return e=ee.fx?ee.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},function(){var e=K.createElement("input"),t=K.createElement("select"),n=t.appendChild(K.createElement("option"));e.type="checkbox",J.checkOn=""!==e.value,J.optSelected=n.selected,t.disabled=!0,J.optDisabled=!n.disabled,e=K.createElement("input"),e.value="t",e.type="radio",J.radioValue="t"===e.value}();var rt,it,ot=ee.expr.attrHandle;ee.fn.extend({attr:function(e,t){return me(this,ee.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){ee.removeAttr(this,e)})}}),ee.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(e&&3!==o&&8!==o&&2!==o)return typeof e.getAttribute===ke?ee.prop(e,t,n):(1===o&&ee.isXMLDoc(e)||(t=t.toLowerCase(),r=ee.attrHooks[t]||(ee.expr.match.bool.test(t)?it:rt)),void 0===n?r&&"get"in r&&null!==(i=r.get(e,t))?i:(i=ee.find.attr(e,t),null==i?void 0:i):null!==n?r&&"set"in r&&void 0!==(i=r.set(e,n,t))?i:(e.setAttribute(t,n+""),n):void ee.removeAttr(e,t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(de);if(o&&1===e.nodeType)for(;n=o[i++];)r=ee.propFix[n]||n,ee.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!J.radioValue&&"radio"===t&&ee.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}}}),it={set:function(e,t,n){return t===!1?ee.removeAttr(e,n):e.setAttribute(n,n),n}},ee.each(ee.expr.match.bool.source.match(/\w+/g),function(e,t){var n=ot[t]||ee.find.attr;ot[t]=function(e,t,r){var i,o;return r||(o=ot[t],ot[t]=i,i=null!=n(e,t,r)?t.toLowerCase():null,ot[t]=o),i}});var st=/^(?:input|select|textarea|button)$/i;ee.fn.extend({prop:function(e,t){return me(this,ee.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[ee.propFix[e]||e]})}}),ee.extend({propFix:{for:"htmlFor",class:"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return o=1!==s||!ee.isXMLDoc(e),o&&(t=ee.propFix[t]||t,i=ee.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||st.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),J.optSelected||(ee.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),ee.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){ee.propFix[this.toLowerCase()]=this});var at=/[\t\r\n\f]/g;ee.fn.extend({addClass:function(e){var t,n,r,i,o,s,a="string"==typeof e&&e,u=0,l=this.length;if(ee.isFunction(e))return this.each(function(t){ee(this).addClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(de)||[];u<l;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(at," "):" ")){for(o=0;i=t[o++];)r.indexOf(" "+i+" ")<0&&(r+=i+" ");s=ee.trim(r),n.className!==s&&(n.className=s)}return this},removeClass:function(e){var t,n,r,i,o,s,a=0===arguments.length||"string"==typeof e&&e,u=0,l=this.length;if(ee.isFunction(e))return this.each(function(t){ee(this).removeClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(de)||[];u<l;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(at," "):"")){for(o=0;i=t[o++];)for(;r.indexOf(" "+i+" ")>=0;)r=r.replace(" "+i+" "," ");s=e?ee.trim(r):"",n.className!==s&&(n.className=s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):ee.isFunction(e)?this.each(function(n){ee(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n)for(var t,r=0,i=ee(this),o=e.match(de)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else n!==ke&&"boolean"!==n||(this.className&&ve.set(this,"__className__",this.className),this.className=this.className||e===!1?"":ve.get(this,"__className__")||"")})},hasClass:function(e){for(var t=" "+e+" ",n=0,r=this.length;n<r;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(at," ").indexOf(t)>=0)return!0;return!1}});var ut=/\r/g;ee.fn.extend({val:function(e){var t,n,r,i=this[0];{if(arguments.length)return r=ee.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,ee(this).val()):e,null==i?i="":"number"==typeof i?i+="":ee.isArray(i)&&(i=ee.map(i,function(e){return null==e?"":e+""})),t=ee.valHooks[this.type]||ee.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))});if(i)return t=ee.valHooks[i.type]||ee.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(ut,""):null==n?"":n)}}}),ee.extend({valHooks:{select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||i<0,s=o?null:[],a=o?i+1:r.length,u=i<0?a:o?i:0;u<a;u++)if(n=r[u],(n.selected||u===i)&&(J.optDisabled?!n.disabled:null===n.getAttribute("disabled"))&&(!n.parentNode.disabled||!ee.nodeName(n.parentNode,"optgroup"))){if(t=ee(n).val(),o)return t;s.push(t)}return s},set:function(e,t){for(var n,r,i=e.options,o=ee.makeArray(t),s=i.length;s--;)r=i[s],(r.selected=ee.inArray(ee(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),ee.each(["radio","checkbox"],function(){ee.valHooks[this]={set:function(e,t){if(ee.isArray(t))return e.checked=ee.inArray(ee(e).val(),t)>=0}},J.checkOn||(ee.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),ee.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){ee.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),ee.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var lt=ee.now(),ct=/\?/;ee.parseJSON=function(e){return JSON.parse(e+"")},ee.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||ee.error("Invalid XML: "+e),t};var ft,pt,dt=/#.*$/,ht=/([?&])_=[^&]*/,gt=/^(.*?):[ \t]*([^\r\n]*)$/gm,mt=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,vt=/^(?:GET|HEAD)$/,yt=/^\/\//,xt=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,bt={},wt={},Tt="*/".concat("*");try{pt=location.href}catch(e){pt=K.createElement("a"),pt.href="",pt=pt.href}ft=xt.exec(pt.toLowerCase())||[],ee.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:pt,type:"GET",isLocal:mt.test(ft[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Tt,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":ee.parseJSON,"text xml":ee.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?M(M(e,ee.ajaxSettings),t):M(ee.ajaxSettings,e)},ajaxPrefilter:F(bt),ajaxTransport:F(wt),ajax:function(e,t){function n(e,t,n,s){var u,c,v,y,b,T=t;2!==x&&(x=2,a&&clearTimeout(a),r=void 0,o=s||"",w.readyState=e>0?4:0,u=e>=200&&e<300||304===e,n&&(y=R(f,w,n)),y=W(f,y,w,u),u?(f.ifModified&&(b=w.getResponseHeader("Last-Modified"),b&&(ee.lastModified[i]=b),b=w.getResponseHeader("etag"),b&&(ee.etag[i]=b)),204===e||"HEAD"===f.type?T="nocontent":304===e?T="notmodified":(T=y.state,c=y.data,v=y.error,u=!v)):(v=T,!e&&T||(T="error",e<0&&(e=0))),w.status=e,w.statusText=(t||T)+"",u?h.resolveWith(p,[c,T,w]):h.rejectWith(p,[w,T,v]),w.statusCode(m),m=void 0,l&&d.trigger(u?"ajaxSuccess":"ajaxError",[w,f,u?c:v]),g.fireWith(p,[w,T]),l&&(d.trigger("ajaxComplete",[w,f]),--ee.active||ee.event.trigger("ajaxStop")))}"object"==typeof e&&(t=e,e=void 0),t=t||{};var r,i,o,s,a,u,l,c,f=ee.ajaxSetup({},t),p=f.context||f,d=f.context&&(p.nodeType||p.jquery)?ee(p):ee.event,h=ee.Deferred(),g=ee.Callbacks("once memory"),m=f.statusCode||{},v={},y={},x=0,b="canceled",w={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!s)for(s={};t=gt.exec(o);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?o:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=y[n]=y[n]||e,v[e]=t),this},overrideMimeType:function(e){return x||(f.mimeType=e),this},statusCode:function(e){var t;if(e)if(x<2)for(t in e)m[t]=[m[t],e[t]];else w.always(e[w.status]);return this},abort:function(e){var t=e||b;return r&&r.abort(t),n(0,t),this}};if(h.promise(w).complete=g.add,w.success=w.done,w.error=w.fail,f.url=((e||f.url||pt)+"").replace(dt,"").replace(yt,ft[1]+"//"),f.type=t.method||t.type||f.method||f.type,f.dataTypes=ee.trim(f.dataType||"*").toLowerCase().match(de)||[""],null==f.crossDomain&&(u=xt.exec(f.url.toLowerCase()),f.crossDomain=!(!u||u[1]===ft[1]&&u[2]===ft[2]&&(u[3]||("http:"===u[1]?"80":"443"))===(ft[3]||("http:"===ft[1]?"80":"443")))),f.data&&f.processData&&"string"!=typeof f.data&&(f.data=ee.param(f.data,f.traditional)),P(bt,f,t,w),2===x)return w;l=f.global,l&&0===ee.active++&&ee.event.trigger("ajaxStart"),f.type=f.type.toUpperCase(),f.hasContent=!vt.test(f.type),i=f.url,f.hasContent||(f.data&&(i=f.url+=(ct.test(i)?"&":"?")+f.data,delete f.data),f.cache===!1&&(f.url=ht.test(i)?i.replace(ht,"$1_="+lt++):i+(ct.test(i)?"&":"?")+"_="+lt++)),f.ifModified&&(ee.lastModified[i]&&w.setRequestHeader("If-Modified-Since",ee.lastModified[i]),ee.etag[i]&&w.setRequestHeader("If-None-Match",ee.etag[i])),(f.data&&f.hasContent&&f.contentType!==!1||t.contentType)&&w.setRequestHeader("Content-Type",f.contentType),w.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+Tt+"; q=0.01":""):f.accepts["*"]);for(c in f.headers)w.setRequestHeader(c,f.headers[c]);if(f.beforeSend&&(f.beforeSend.call(p,w,f)===!1||2===x))return w.abort();b="abort";for(c in{success:1,error:1,complete:1})w[c](f[c]);if(r=P(wt,f,t,w)){w.readyState=1,l&&d.trigger("ajaxSend",[w,f]),f.async&&f.timeout>0&&(a=setTimeout(function(){w.abort("timeout")},f.timeout));try{x=1,r.send(v,n)}catch(e){if(!(x<2))throw e;n(-1,e)}}else n(-1,"No Transport");return w},getJSON:function(e,t,n){return ee.get(e,t,n,"json")},getScript:function(e,t){return ee.get(e,void 0,t,"script")}}),ee.each(["get","post"],function(e,t){ee[t]=function(e,n,r,i){return ee.isFunction(n)&&(i=i||r,r=n,n=void 0),ee.ajax({url:e,type:t,dataType:i,data:n,success:r})}}),ee.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){ee.fn[t]=function(e){return this.on(t,e)}}),ee._evalUrl=function(e){return ee.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,throws:!0})},ee.fn.extend({wrapAll:function(e){var t;return ee.isFunction(e)?this.each(function(t){ee(this).wrapAll(e.call(this,t))}):(this[0]&&(t=ee(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return ee.isFunction(e)?this.each(function(t){ee(this).wrapInner(e.call(this,t))}):this.each(function(){var t=ee(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=ee.isFunction(e);return this.each(function(n){ee(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){ee.nodeName(this,"body")||ee(this).replaceWith(this.childNodes)}).end()}}),ee.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},ee.expr.filters.visible=function(e){return!ee.expr.filters.hidden(e)};var Ct=/%20/g,Nt=/\[\]$/,kt=/\r?\n/g,Et=/^(?:submit|button|image|reset|file)$/i,Dt=/^(?:input|select|textarea|keygen)/i;ee.param=function(e,t){var n,r=[],i=function(e,t){t=ee.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(void 0===t&&(t=ee.ajaxSettings&&ee.ajaxSettings.traditional),ee.isArray(e)||e.jquery&&!ee.isPlainObject(e))ee.each(e,function(){i(this.name,this.value)});else for(n in e)$(n,e[n],t,i);return r.join("&").replace(Ct,"+")},ee.fn.extend({serialize:function(){return ee.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=ee.prop(this,"elements");return e?ee.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!ee(this).is(":disabled")&&Dt.test(this.nodeName)&&!Et.test(e)&&(this.checked||!Ne.test(e))}).map(function(e,t){var n=ee(this).val();return null==n?null:ee.isArray(n)?ee.map(n,function(e){return{name:t.name,value:e.replace(kt,"\r\n")}}):{name:t.name,value:n.replace(kt,"\r\n")}}).get()}}),ee.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var jt=0,St={},At={0:200,1223:204},Lt=ee.ajaxSettings.xhr();e.ActiveXObject&&ee(e).on("unload",function(){for(var e in St)St[e]()}),J.cors=!!Lt&&"withCredentials"in Lt,J.ajax=Lt=!!Lt,ee.ajaxTransport(function(e){var t;if(J.cors||Lt&&!e.crossDomain)return{send:function(n,r){var i,o=e.xhr(),s=++jt;if(o.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)o[i]=e.xhrFields[i];e.mimeType&&o.overrideMimeType&&o.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)o.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete St[s],t=o.onload=o.onerror=null,"abort"===e?o.abort():"error"===e?r(o.status,o.statusText):r(At[o.status]||o.status,o.statusText,"string"==typeof o.responseText?{text:o.responseText}:void 0,o.getAllResponseHeaders()))}},o.onload=t(),o.onerror=t("error"),t=St[s]=t("abort"),o.send(e.hasContent&&e.data||null)},abort:function(){t&&t()}}}),ee.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return ee.globalEval(e),e}}}),ee.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),ee.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=ee("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),K.head.appendChild(t[0])},abort:function(){n&&n()}}}});var qt=[],Ht=/(=)\?(?=&|$)|\?\?/;ee.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=qt.pop()||ee.expando+"_"+lt++;return this[e]=!0,e}}),ee.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(Ht.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ht.test(t.data)&&"data");if(a||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=ee.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(Ht,"$1"+i):t.jsonp!==!1&&(t.url+=(ct.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||ee.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,qt.push(i)),s&&ee.isFunction(o)&&o(s[0]),s=o=void 0}),"script"}),ee.parseHTML=function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||K;var r=se.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=ee.buildFragment([e],t,i),i&&i.length&&ee(i).remove(),ee.merge([],r.childNodes))};var Ot=ee.fn.load;ee.fn.load=function(e,t,n){if("string"!=typeof e&&Ot)return Ot.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=e.slice(a),e=e.slice(0,a)),ee.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),s.length>0&&ee.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?ee("<div>").append(ee.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},ee.expr.filters.animated=function(e){return ee.grep(ee.timers,function(t){return e===t.elem}).length};var Ft=e.document.documentElement;ee.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=ee.css(e,"position"),f=ee(e),p={};"static"===c&&(e.style.position="relative"),a=f.offset(),o=ee.css(e,"top"),u=ee.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),ee.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(p.top=t.top-a.top+s),null!=t.left&&(p.left=t.left-a.left+i),"using"in t?t.using.call(e,p):f.css(p)}},ee.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){ee.offset.setOffset(this,e,t)});var t,n,r=this[0],i={top:0,left:0},o=r&&r.ownerDocument;if(o)return t=o.documentElement,ee.contains(t,r)?(typeof r.getBoundingClientRect!==ke&&(i=r.getBoundingClientRect()),n=B(o),{top:i.top+n.pageYOffset-t.clientTop,left:i.left+n.pageXOffset-t.clientLeft}):i},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===ee.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),ee.nodeName(e[0],"html")||(r=e.offset()),r.top+=ee.css(e[0],"borderTopWidth",!0),r.left+=ee.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-ee.css(n,"marginTop",!0),left:t.left-r.left-ee.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||Ft;e&&!ee.nodeName(e,"html")&&"static"===ee.css(e,"position");)e=e.offsetParent;return e||Ft})}}),ee.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;ee.fn[t]=function(i){return me(this,function(t,i,o){var s=B(t);return void 0===o?s?s[n]:t[i]:void(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o)},t,i,arguments.length,null)}}),ee.each(["top","left"],function(e,t){ee.cssHooks[t]=T(J.pixelPosition,function(e,n){if(n)return n=w(e,t),Ie.test(n)?ee(e).position()[t]+"px":n})}),ee.each({Height:"height",Width:"width"},function(e,t){ee.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){ee.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return me(this,function(t,n,r){var i;return ee.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):void 0===r?ee.css(t,n,s):ee.style(t,n,r,s)},t,o?r:void 0,o,null)}})}),ee.fn.size=function(){return this.length},ee.fn.andSelf=ee.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return ee});var Pt=e.jQuery,Mt=e.$;return ee.noConflict=function(t){return e.$===ee&&(e.$=Mt),t&&e.jQuery===ee&&(e.jQuery=Pt),ee},typeof t===ke&&(e.jQuery=e.$=ee),ee});
</script>
<script type="text/javascript">
(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function i(n,t){for(var r=null==n?0:n.length;r--&&t(n[r],r,n)!==!1;);return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return!1;return!0}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function a(n,t){var r=null==n?0:n.length;return!!r&&b(n,t,0)>-1}function c(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return!0;return!1}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function v(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function _(n){return n.split("")}function g(n){return n.match(Dt)||[]}function y(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,!1}),e}function d(n,t,r,e){for(var u=n.length,i=r+(e?1:-1);e?i--:++i<u;)if(t(n[i],i,n))return i;return-1}function b(n,t,r){return t===t?K(n,t,r):d(n,m,r)}function w(n,t,r,e){for(var u=r-1,i=n.length;++u<i;)if(e(n[u],t))return u;return-1}function m(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?I(n,t)/r:Ln}function j(n){return function(t){return null==t?X:t[n]}}function A(n){return function(t){return null==n?X:n[t]}}function k(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function O(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function I(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==X&&(r=r===X?i:r+i)}return r}function R(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function z(n,t){return l(t,function(t){return[t,n[t]]})}function E(n){return function(t){return n(t)}}function S(n,t){return l(t,function(t){return n[t]})}function W(n,t){return n.has(t)}function L(n,t){for(var r=-1,e=n.length;++r<e&&b(t,n[r],0)>-1;);return r}function C(n,t){for(var r=n.length;r--&&b(t,n[r],0)>-1;);return r}function U(n,t){for(var r=n.length,e=0;r--;)n[r]===t&&++e;return e}function B(n){return"\\"+Yr[n]}function T(n,t){return null==n?X:n[t]}function $(n){return Nr.test(n)}function D(n){return Pr.test(n)}function M(n){for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}function F(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function N(n,t){return function(r){return n(t(r))}}function P(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&o!==fn||(n[r]=fn,i[u++]=r)}return i}function q(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function Z(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function K(n,t,r){for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function V(n,t,r){for(var e=r+1;e--;)if(n[e]===t)return e;return e}function G(n){return $(n)?J(n):ve(n)}function H(n){return $(n)?Y(n):_(n)}function J(n){for(var t=Mr.lastIndex=0;Mr.test(n);)++t;return t}function Y(n){return n.match(Mr)||[]}function Q(n){return n.match(Fr)||[]}var X,nn="4.17.4",tn=200,rn="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",en="Expected a function",un="__lodash_hash_undefined__",on=500,fn="__lodash_placeholder__",an=1,cn=2,ln=4,sn=1,hn=2,pn=1,vn=2,_n=4,gn=8,yn=16,dn=32,bn=64,wn=128,mn=256,xn=512,jn=30,An="...",kn=800,On=16,In=1,Rn=2,zn=3,En=1/0,Sn=9007199254740991,Wn=1.7976931348623157e308,Ln=NaN,Cn=4294967295,Un=Cn-1,Bn=Cn>>>1,Tn=[["ary",wn],["bind",pn],["bindKey",vn],["curry",gn],["curryRight",yn],["flip",xn],["partial",dn],["partialRight",bn],["rearg",mn]],$n="[object Arguments]",Dn="[object Array]",Mn="[object AsyncFunction]",Fn="[object Boolean]",Nn="[object Date]",Pn="[object DOMException]",qn="[object Error]",Zn="[object Function]",Kn="[object GeneratorFunction]",Vn="[object Map]",Gn="[object Number]",Hn="[object Null]",Jn="[object Object]",Yn="[object Promise]",Qn="[object Proxy]",Xn="[object RegExp]",nt="[object Set]",tt="[object String]",rt="[object Symbol]",et="[object Undefined]",ut="[object WeakMap]",it="[object WeakSet]",ot="[object ArrayBuffer]",ft="[object DataView]",at="[object Float32Array]",ct="[object Float64Array]",lt="[object Int8Array]",st="[object Int16Array]",ht="[object Int32Array]",pt="[object Uint8Array]",vt="[object Uint8ClampedArray]",_t="[object Uint16Array]",gt="[object Uint32Array]",yt=/\b__p \+= '';/g,dt=/\b(__p \+=) '' \+/g,bt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,wt=/&(?:amp|lt|gt|quot|#39);/g,mt=/[&<>"']/g,xt=RegExp(wt.source),jt=RegExp(mt.source),At=/<%-([\s\S]+?)%>/g,kt=/<%([\s\S]+?)%>/g,Ot=/<%=([\s\S]+?)%>/g,It=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Rt=/^\w*$/,zt=/^\./,Et=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,St=/[\\^$.*+?()[\]{}|]/g,Wt=RegExp(St.source),Lt=/^\s+|\s+$/g,Ct=/^\s+/,Ut=/\s+$/,Bt=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Tt=/\{\n\/\* \[wrapped with (.+)\] \*/,$t=/,? & /,Dt=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Mt=/\\(\\)?/g,Ft=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Nt=/\w*$/,Pt=/^[-+]0x[0-9a-f]+$/i,qt=/^0b[01]+$/i,Zt=/^\[object .+?Constructor\]$/,Kt=/^0o[0-7]+$/i,Vt=/^(?:0|[1-9]\d*)$/,Gt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ht=/($^)/,Jt=/['\n\r\u2028\u2029\\]/g,Yt="\\ud800-\\udfff",Qt="\\u0300-\\u036f",Xt="\\ufe20-\\ufe2f",nr="\\u20d0-\\u20ff",tr=Qt+Xt+nr,rr="\\u2700-\\u27bf",er="a-z\\xdf-\\xf6\\xf8-\\xff",ur="\\xac\\xb1\\xd7\\xf7",ir="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",or="\\u2000-\\u206f",fr=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",ar="A-Z\\xc0-\\xd6\\xd8-\\xde",cr="\\ufe0e\\ufe0f",lr=ur+ir+or+fr,sr="['’]",hr="["+Yt+"]",pr="["+lr+"]",vr="["+tr+"]",_r="\\d+",gr="["+rr+"]",yr="["+er+"]",dr="[^"+Yt+lr+_r+rr+er+ar+"]",br="\\ud83c[\\udffb-\\udfff]",wr="(?:"+vr+"|"+br+")",mr="[^"+Yt+"]",xr="(?:\\ud83c[\\udde6-\\uddff]){2}",jr="[\\ud800-\\udbff][\\udc00-\\udfff]",Ar="["+ar+"]",kr="\\u200d",Or="(?:"+yr+"|"+dr+")",Ir="(?:"+Ar+"|"+dr+")",Rr="(?:"+sr+"(?:d|ll|m|re|s|t|ve))?",zr="(?:"+sr+"(?:D|LL|M|RE|S|T|VE))?",Er=wr+"?",Sr="["+cr+"]?",Wr="(?:"+kr+"(?:"+[mr,xr,jr].join("|")+")"+Sr+Er+")*",Lr="\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)",Cr="\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)",Ur=Sr+Er+Wr,Br="(?:"+[gr,xr,jr].join("|")+")"+Ur,Tr="(?:"+[mr+vr+"?",vr,xr,jr,hr].join("|")+")",$r=RegExp(sr,"g"),Dr=RegExp(vr,"g"),Mr=RegExp(br+"(?="+br+")|"+Tr+Ur,"g"),Fr=RegExp([Ar+"?"+yr+"+"+Rr+"(?="+[pr,Ar,"$"].join("|")+")",Ir+"+"+zr+"(?="+[pr,Ar+Or,"$"].join("|")+")",Ar+"?"+Or+"+"+Rr,Ar+"+"+zr,Cr,Lr,_r,Br].join("|"),"g"),Nr=RegExp("["+kr+Yt+tr+cr+"]"),Pr=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,qr=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Zr=-1,Kr={};Kr[at]=Kr[ct]=Kr[lt]=Kr[st]=Kr[ht]=Kr[pt]=Kr[vt]=Kr[_t]=Kr[gt]=!0,Kr[$n]=Kr[Dn]=Kr[ot]=Kr[Fn]=Kr[ft]=Kr[Nn]=Kr[qn]=Kr[Zn]=Kr[Vn]=Kr[Gn]=Kr[Jn]=Kr[Xn]=Kr[nt]=Kr[tt]=Kr[ut]=!1;var Vr={};Vr[$n]=Vr[Dn]=Vr[ot]=Vr[ft]=Vr[Fn]=Vr[Nn]=Vr[at]=Vr[ct]=Vr[lt]=Vr[st]=Vr[ht]=Vr[Vn]=Vr[Gn]=Vr[Jn]=Vr[Xn]=Vr[nt]=Vr[tt]=Vr[rt]=Vr[pt]=Vr[vt]=Vr[_t]=Vr[gt]=!0,Vr[qn]=Vr[Zn]=Vr[ut]=!1;var Gr={"À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","Ç":"C","ç":"c","Ð":"D","ð":"d","È":"E","É":"E","Ê":"E","Ë":"E","è":"e","é":"e","ê":"e","ë":"e","Ì":"I","Í":"I","Î":"I","Ï":"I","ì":"i","í":"i","î":"i","ï":"i","Ñ":"N","ñ":"n","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","Ù":"U","Ú":"U","Û":"U","Ü":"U","ù":"u","ú":"u","û":"u","ü":"u","Ý":"Y","ý":"y","ÿ":"y","Æ":"Ae","æ":"ae","Þ":"Th","þ":"th","ß":"ss","Ā":"A","Ă":"A","Ą":"A","ā":"a","ă":"a","ą":"a","Ć":"C","Ĉ":"C","Ċ":"C","Č":"C","ć":"c","ĉ":"c","ċ":"c","č":"c","Ď":"D","Đ":"D","ď":"d","đ":"d","Ē":"E","Ĕ":"E","Ė":"E","Ę":"E","Ě":"E","ē":"e","ĕ":"e","ė":"e","ę":"e","ě":"e","Ĝ":"G","Ğ":"G","Ġ":"G","Ģ":"G","ĝ":"g","ğ":"g","ġ":"g","ģ":"g","Ĥ":"H","Ħ":"H","ĥ":"h","ħ":"h","Ĩ":"I","Ī":"I","Ĭ":"I","Į":"I","İ":"I","ĩ":"i","ī":"i","ĭ":"i","į":"i","ı":"i","Ĵ":"J","ĵ":"j","Ķ":"K","ķ":"k","ĸ":"k","Ĺ":"L","Ļ":"L","Ľ":"L","Ŀ":"L","Ł":"L","ĺ":"l","ļ":"l","ľ":"l","ŀ":"l","ł":"l","Ń":"N","Ņ":"N","Ň":"N","Ŋ":"N","ń":"n","ņ":"n","ň":"n","ŋ":"n","Ō":"O","Ŏ":"O","Ő":"O","ō":"o","ŏ":"o","ő":"o","Ŕ":"R","Ŗ":"R","Ř":"R","ŕ":"r","ŗ":"r","ř":"r","Ś":"S","Ŝ":"S","Ş":"S","Š":"S","ś":"s","ŝ":"s","ş":"s","š":"s","Ţ":"T","Ť":"T","Ŧ":"T","ţ":"t","ť":"t","ŧ":"t","Ũ":"U","Ū":"U","Ŭ":"U","Ů":"U","Ű":"U","Ų":"U","ũ":"u","ū":"u","ŭ":"u","ů":"u","ű":"u","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","Ż":"Z","Ž":"Z","ź":"z","ż":"z","ž":"z","Ĳ":"IJ","ĳ":"ij","Œ":"Oe","œ":"oe","ŉ":"'n","ſ":"s"},Hr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Jr={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Yr={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Qr=parseFloat,Xr=parseInt,ne="object"==typeof global&&global&&global.Object===Object&&global,te="object"==typeof self&&self&&self.Object===Object&&self,re=ne||te||Function("return this")(),ee="object"==typeof exports&&exports&&!exports.nodeType&&exports,ue=ee&&"object"==typeof module&&module&&!module.nodeType&&module,ie=ue&&ue.exports===ee,oe=ie&&ne.process,fe=function(){try{return oe&&oe.binding&&oe.binding("util")}catch(n){}}(),ae=fe&&fe.isArrayBuffer,ce=fe&&fe.isDate,le=fe&&fe.isMap,se=fe&&fe.isRegExp,he=fe&&fe.isSet,pe=fe&&fe.isTypedArray,ve=j("length"),_e=A(Gr),ge=A(Hr),ye=A(Jr),de=function _(A){function K(n){if(la(n)&&!mh(n)&&!(n instanceof Dt)){if(n instanceof Y)return n;if(ml.call(n,"__wrapped__"))return io(n)}return new Y(n)}function J(){}function Y(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=X}function Dt(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Cn,this.__views__=[]}function Yt(){var n=new Dt(this.__wrapped__);return n.__actions__=Mu(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mu(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mu(this.__views__),n}function Qt(){if(this.__filtered__){var n=new Dt(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Xt(){var n=this.__wrapped__.value(),t=this.__dir__,r=mh(n),e=t<0,u=r?n.length:0,i=zi(0,u,this.__views__),o=i.start,f=i.end,a=f-o,c=e?f:o-1,l=this.__iteratees__,s=l.length,h=0,p=Yl(a,this.__takeCount__);if(!r||!e&&u==a&&p==a)return mu(n,this.__actions__);var v=[];n:for(;a--&&h<p;){c+=t;for(var _=-1,g=n[c];++_<s;){var y=l[_],d=y.iteratee,b=y.type,w=d(g);if(b==Rn)g=w;else if(!w){if(b==In)continue n;break n}}v[h++]=g}return v}function nr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function tr(){this.__data__=fs?fs(null):{},this.size=0}function rr(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function er(n){var t=this.__data__;if(fs){var r=t[n];return r===un?X:r}return ml.call(t,n)?t[n]:X}function ur(n){var t=this.__data__;return fs?t[n]!==X:ml.call(t,n)}function ir(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=fs&&t===X?un:t,this}function or(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function fr(){this.__data__=[],this.size=0}function ar(n){var t=this.__data__,r=Lr(t,n);if(r<0)return!1;var e=t.length-1;return r==e?t.pop():Ul.call(t,r,1),--this.size,!0}function cr(n){var t=this.__data__,r=Lr(t,n);return r<0?X:t[r][1]}function lr(n){return Lr(this.__data__,n)>-1}function sr(n,t){var r=this.__data__,e=Lr(r,n);return e<0?(++this.size,r.push([n,t])):r[e][1]=t,this}function hr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function pr(){this.size=0,this.__data__={hash:new nr,map:new(es||or),string:new nr}}function vr(n){var t=ki(this,n).delete(n);return this.size-=t?1:0,t}function _r(n){return ki(this,n).get(n)}function gr(n){return ki(this,n).has(n)}function yr(n,t){var r=ki(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this}function dr(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new hr;++t<r;)this.add(n[t])}function br(n){return this.__data__.set(n,un),this}function wr(n){return this.__data__.has(n)}function mr(n){var t=this.__data__=new or(n);this.size=t.size}function xr(){this.__data__=new or,this.size=0}function jr(n){var t=this.__data__,r=t.delete(n);return this.size=t.size,r}function Ar(n){return this.__data__.get(n)}function kr(n){return this.__data__.has(n)}function Or(n,t){var r=this.__data__;if(r instanceof or){var e=r.__data__;if(!es||e.length<tn-1)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new hr(e)}return r.set(n,t),this.size=r.size,this}function Ir(n,t){var r=mh(n),e=!r&&wh(n),u=!r&&!e&&jh(n),i=!r&&!e&&!u&&Rh(n),o=r||e||u||i,f=o?R(n.length,vl):[],a=f.length;for(var c in n)!t&&!ml.call(n,c)||o&&("length"==c||u&&("offset"==c||"parent"==c)||i&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||Ti(c,a))||f.push(c);return f}function Rr(n){var t=n.length;return t?n[ru(0,t-1)]:X}function zr(n,t){return to(Mu(n),Fr(t,0,n.length))}function Er(n){return to(Mu(n))}function Sr(n,t,r){(r===X||Jf(n[t],r))&&(r!==X||t in n)||Tr(n,t,r)}function Wr(n,t,r){var e=n[t];ml.call(n,t)&&Jf(e,r)&&(r!==X||t in n)||Tr(n,t,r)}function Lr(n,t){for(var r=n.length;r--;)if(Jf(n[r][0],t))return r;return-1}function Cr(n,t,r,e){return bs(n,function(n,u,i){t(e,n,r(n),i)}),e}function Ur(n,t){return n&&Fu(t,Za(t),n)}function Br(n,t){return n&&Fu(t,Ka(t),n)}function Tr(n,t,r){"__proto__"==t&&Dl?Dl(n,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):n[t]=r}function Mr(n,t){for(var r=-1,e=t.length,u=fl(e),i=null==n;++r<e;)u[r]=i?X:Na(n,t[r]);return u}function Fr(n,t,r){return n===n&&(r!==X&&(n=n<=r?n:r),t!==X&&(n=n>=t?n:t)),n}function Nr(n,t,r,e,i,o){var f,a=t&an,c=t&cn,l=t&ln;if(r&&(f=i?r(n,e,i,o):r(n)),f!==X)return f;if(!ca(n))return n;var s=mh(n);if(s){if(f=Wi(n),!a)return Mu(n,f)}else{var h=Ss(n),p=h==Zn||h==Kn;if(jh(n))return Ru(n,a);if(h==Jn||h==$n||p&&!i){if(f=c||p?{}:Li(n),!a)return c?Pu(n,Br(f,n)):Nu(n,Ur(f,n))}else{if(!Vr[h])return i?n:{};f=Ci(n,h,Nr,a)}}o||(o=new mr);var v=o.get(n);if(v)return v;o.set(n,f);var _=l?c?mi:wi:c?Ka:Za,g=s?X:_(n);return u(g||n,function(e,u){g&&(u=e,e=n[u]),Wr(f,u,Nr(e,t,r,u,n,o))}),f}function Pr(n){var t=Za(n);return function(r){return Gr(r,n,t)}}function Gr(n,t,r){var e=r.length;if(null==n)return!e;for(n=hl(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===X&&!(u in n)||!i(o))return!1}return!0}function Hr(n,t,r){if("function"!=typeof n)throw new _l(en);return Cs(function(){n.apply(X,r)},t)}function Jr(n,t,r,e){var u=-1,i=a,o=!0,f=n.length,s=[],h=t.length;if(!f)return s;r&&(t=l(t,E(r))),e?(i=c,o=!1):t.length>=tn&&(i=W,o=!1,t=new dr(t));n:for(;++u<f;){var p=n[u],v=null==r?p:r(p);if(p=e||0!==p?p:0,o&&v===v){for(var _=h;_--;)if(t[_]===v)continue n;s.push(p)}else i(t,v,e)||s.push(p)}return s}function Yr(n,t){var r=!0;return bs(n,function(n,e,u){return r=!!t(n,e,u)}),r}function ne(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===X?o===o&&!ma(o):r(o,f)))var f=o,a=i}return a}function te(n,t,r,e){var u=n.length;for(r=Ia(r),r<0&&(r=-r>u?0:u+r),e=e===X||e>u?u:Ia(e),e<0&&(e+=u),e=r>e?0:Ra(e);r<e;)n[r++]=t;return n}function ee(n,t){var r=[];return bs(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function ue(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Bi),u||(u=[]);++i<o;){var f=n[i];t>0&&r(f)?t>1?ue(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function oe(n,t){return n&&ms(n,t,Za)}function fe(n,t){return n&&xs(n,t,Za)}function ve(n,t){return f(t,function(t){return oa(n[t])})}function de(n,t){t=Ou(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[ro(t[r++])];return r&&r==e?n:X}function we(n,t,r){var e=t(n);return mh(n)?e:s(e,r(n))}function me(n){return null==n?n===X?et:Hn:$l&&$l in hl(n)?Ri(n):Hi(n)}function xe(n,t){return n>t}function je(n,t){return null!=n&&ml.call(n,t)}function Ae(n,t){return null!=n&&t in hl(n)}function ke(n,t,r){return n>=Yl(t,r)&&n<Jl(t,r)}function Oe(n,t,r){for(var e=r?c:a,u=n[0].length,i=n.length,o=i,f=fl(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,E(t))),s=Yl(p.length,s),f[o]=!r&&(t||u>=120&&p.length>=120)?new dr(o&&p):X}p=n[0];var v=-1,_=f[0];n:for(;++v<u&&h.length<s;){var g=p[v],y=t?t(g):g;if(g=r||0!==g?g:0,!(_?W(_,y):e(h,y,r))){for(o=i;--o;){var d=f[o];if(!(d?W(d,y):e(n[o],y,r)))continue n}_&&_.push(y),h.push(g)}}return h}function Ie(n,t,r,e){return oe(n,function(n,u,i){t(e,r(n),u,i)}),e}function Re(n,t,e){t=Ou(t,n),n=Yi(n,t);var u=null==n?n:n[ro(ko(t))];return null==u?X:r(u,n,e)}function ze(n){return la(n)&&me(n)==$n}function Ee(n){return la(n)&&me(n)==ot}function Se(n){return la(n)&&me(n)==Nn}function We(n,t,r,e,u){return n===t||(null==n||null==t||!la(n)&&!la(t)?n!==n&&t!==t:Le(n,t,r,e,We,u))}function Le(n,t,r,e,u,i){var o=mh(n),f=mh(t),a=o?Dn:Ss(n),c=f?Dn:Ss(t);a=a==$n?Jn:a,c=c==$n?Jn:c;var l=a==Jn,s=c==Jn,h=a==c;if(h&&jh(n)){if(!jh(t))return!1;o=!0,l=!1}if(h&&!l)return i||(i=new mr),o||Rh(n)?gi(n,t,r,e,u,i):yi(n,t,a,r,e,u,i);if(!(r&sn)){var p=l&&ml.call(n,"__wrapped__"),v=s&&ml.call(t,"__wrapped__");if(p||v){var _=p?n.value():n,g=v?t.value():t;return i||(i=new mr),u(_,g,r,e,i)}}return!!h&&(i||(i=new mr),di(n,t,r,e,u,i))}function Ce(n){return la(n)&&Ss(n)==Vn}function Ue(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=hl(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return!1}for(;++u<i;){f=r[u];var a=f[0],c=n[a],l=f[1];if(o&&f[2]){if(c===X&&!(a in n))return!1}else{var s=new mr;if(e)var h=e(c,l,a,n,t,s);if(!(h===X?We(l,c,sn|hn,e,s):h))return!1}}return!0}function Be(n){if(!ca(n)||Ni(n))return!1;var t=oa(n)?Il:Zt;return t.test(eo(n))}function Te(n){return la(n)&&me(n)==Xn}function $e(n){return la(n)&&Ss(n)==nt}function De(n){return la(n)&&aa(n.length)&&!!Kr[me(n)]}function Me(n){return"function"==typeof n?n:null==n?Uc:"object"==typeof n?mh(n)?Ke(n[0],n[1]):Ze(n):Pc(n)}function Fe(n){if(!Pi(n))return Hl(n);var t=[];for(var r in hl(n))ml.call(n,r)&&"constructor"!=r&&t.push(r);return t}function Ne(n){if(!ca(n))return Gi(n);var t=Pi(n),r=[];for(var e in n)("constructor"!=e||!t&&ml.call(n,e))&&r.push(e);return r}function Pe(n,t){return n<t}function qe(n,t){var r=-1,e=Yf(n)?fl(n.length):[];return bs(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Ze(n){var t=Oi(n);return 1==t.length&&t[0][2]?Zi(t[0][0],t[0][1]):function(r){return r===n||Ue(r,n,t)}}function Ke(n,t){return Di(n)&&qi(t)?Zi(ro(n),t):function(r){var e=Na(r,n);return e===X&&e===t?qa(r,n):We(t,e,sn|hn)}}function Ve(n,t,r,e,u){n!==t&&ms(t,function(i,o){if(ca(i))u||(u=new mr),Ge(n,t,o,r,Ve,e,u);else{var f=e?e(n[o],i,o+"",n,t,u):X;f===X&&(f=i),Sr(n,o,f)}},Ka)}function Ge(n,t,r,e,u,i,o){var f=n[r],a=t[r],c=o.get(a);if(c)return void Sr(n,r,c);var l=i?i(f,a,r+"",n,t,o):X,s=l===X;if(s){var h=mh(a),p=!h&&jh(a),v=!h&&!p&&Rh(a);l=a,h||p||v?mh(f)?l=f:Qf(f)?l=Mu(f):p?(s=!1,l=Ru(a,!0)):v?(s=!1,l=Uu(a,!0)):l=[]:da(a)||wh(a)?(l=f,wh(f)?l=Ea(f):(!ca(f)||e&&oa(f))&&(l=Li(a))):s=!1}s&&(o.set(a,l),u(l,a,e,i,o),o.delete(a)),Sr(n,r,l)}function He(n,t){var r=n.length;if(r)return t+=t<0?r:0,Ti(t,r)?n[t]:X}function Je(n,t,r){var e=-1;t=l(t.length?t:[Uc],E(Ai()));var u=qe(n,function(n,r,u){var i=l(t,function(t){return t(n)});return{criteria:i,index:++e,value:n}});return O(u,function(n,t){return Tu(n,t,r)})}function Ye(n,t){return Qe(n,t,function(t,r){return qa(n,r)})}function Qe(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=de(n,o);r(f,o)&&au(i,Ou(o,n),f)}return i}function Xe(n){return function(t){return de(t,n)}}function nu(n,t,r,e){var u=e?w:b,i=-1,o=t.length,f=n;for(n===t&&(t=Mu(t)),r&&(f=l(n,E(r)));++i<o;)for(var a=0,c=t[i],s=r?r(c):c;(a=u(f,s,a,e))>-1;)f!==n&&Ul.call(f,a,1),Ul.call(n,a,1);return n}function tu(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];if(r==e||u!==i){var i=u;Ti(u)?Ul.call(n,u,1):du(n,u)}}return n}function ru(n,t){return n+ql(ns()*(t-n+1))}function eu(n,t,r,e){for(var u=-1,i=Jl(Pl((t-n)/(r||1)),0),o=fl(i);i--;)o[e?i:++u]=n,n+=r;return o}function uu(n,t){var r="";if(!n||t<1||t>Sn)return r;do t%2&&(r+=n),t=ql(t/2),t&&(n+=n);while(t);return r}function iu(n,t){return Us(Ji(n,t,Uc),n+"")}function ou(n){return Rr(uc(n))}function fu(n,t){var r=uc(n);return to(r,Fr(t,0,r.length))}function au(n,t,r,e){if(!ca(n))return n;t=Ou(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var a=ro(t[u]),c=r;if(u!=o){var l=f[a];c=e?e(l,a,f):X,c===X&&(c=ca(l)?l:Ti(t[u+1])?[]:{})}Wr(f,a,c),f=f[a]}return n}function cu(n){return to(uc(n))}function lu(n,t,r){var e=-1,u=n.length;t<0&&(t=-t>u?0:u+t),r=r>u?u:r,r<0&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=fl(u);++e<u;)i[e]=n[e+t];return i}function su(n,t){var r;return bs(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function hu(n,t,r){var e=0,u=null==n?e:n.length;if("number"==typeof t&&t===t&&u<=Bn){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!ma(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return pu(n,t,Uc,r)}function pu(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,a=ma(t),c=t===X;u<i;){var l=ql((u+i)/2),s=r(n[l]),h=s!==X,p=null===s,v=s===s,_=ma(s);if(o)var g=e||v;else g=c?v&&(e||h):f?v&&h&&(e||!p):a?v&&h&&!p&&(e||!_):!p&&!_&&(e?s<=t:s<t);g?u=l+1:i=l}return Yl(i,Un)}function vu(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!Jf(f,a)){var a=f;i[u++]=0===o?0:o}}return i}function _u(n){return"number"==typeof n?n:ma(n)?Ln:+n}function gu(n){if("string"==typeof n)return n;if(mh(n))return l(n,gu)+"";if(ma(n))return ys?ys.call(n):"";var t=n+"";return"0"==t&&1/n==-En?"-0":t}function yu(n,t,r){var e=-1,u=a,i=n.length,o=!0,f=[],l=f;if(r)o=!1,u=c;else if(i>=tn){var s=t?null:Is(n);if(s)return q(s);o=!1,u=W,l=new dr}else l=t?[]:f;n:for(;++e<i;){var h=n[e],p=t?t(h):h;if(h=r||0!==h?h:0,o&&p===p){for(var v=l.length;v--;)if(l[v]===p)continue n;t&&l.push(p),f.push(h)}else u(l,p,r)||(l!==f&&l.push(p),f.push(h))}return f}function du(n,t){return t=Ou(t,n),n=Yi(n,t),null==n||delete n[ro(ko(t))]}function bu(n,t,r,e){return au(n,t,r(de(n,t)),e)}function wu(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?lu(n,e?0:i,e?i+1:u):lu(n,e?i+1:0,e?u:i)}function mu(n,t){var r=n;return r instanceof Dt&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function xu(n,t,r){var e=n.length;if(e<2)return e?yu(n[0]):[];for(var u=-1,i=fl(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=Jr(i[u]||o,n[f],t,r));return yu(ue(i,1),t,r)}function ju(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;){var f=e<i?t[e]:X;r(o,n[e],f)}return o}function Au(n){return Qf(n)?n:[]}function ku(n){return"function"==typeof n?n:Uc}function Ou(n,t){return mh(n)?n:Di(n,t)?[n]:Bs(Wa(n))}function Iu(n,t,r){var e=n.length;return r=r===X?e:r,!t&&r>=e?n:lu(n,t,r)}function Ru(n,t){if(t)return n.slice();var r=n.length,e=Sl?Sl(r):new n.constructor(r);return n.copy(e),e}function zu(n){var t=new n.constructor(n.byteLength);return new El(t).set(new El(n)),t}function Eu(n,t){var r=t?zu(n.buffer):n.buffer;return new n.constructor(r,n.byteOffset,n.byteLength)}function Su(t,r,e){var u=r?e(F(t),an):F(t);return h(u,n,new t.constructor)}function Wu(n){var t=new n.constructor(n.source,Nt.exec(n));return t.lastIndex=n.lastIndex,t}function Lu(n,r,e){var u=r?e(q(n),an):q(n);return h(u,t,new n.constructor)}function Cu(n){return gs?hl(gs.call(n)):{}}function Uu(n,t){var r=t?zu(n.buffer):n.buffer;return new n.constructor(r,n.byteOffset,n.length)}function Bu(n,t){if(n!==t){var r=n!==X,e=null===n,u=n===n,i=ma(n),o=t!==X,f=null===t,a=t===t,c=ma(t);if(!f&&!c&&!i&&n>t||i&&o&&a&&!f&&!c||e&&o&&a||!r&&a||!u)return 1;if(!e&&!i&&!c&&n<t||c&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!a)return-1}return 0}function Tu(n,t,r){for(var e=-1,u=n.criteria,i=t.criteria,o=u.length,f=r.length;++e<o;){var a=Bu(u[e],i[e]);if(a){if(e>=f)return a;var c=r[e];return a*("desc"==c?-1:1)}}return n.index-t.index}function $u(n,t,r,e){for(var u=-1,i=n.length,o=r.length,f=-1,a=t.length,c=Jl(i-o,0),l=fl(a+c),s=!e;++f<a;)l[f]=t[f];for(;++u<o;)(s||u<i)&&(l[r[u]]=n[u]);for(;c--;)l[f++]=n[u++];return l}function Du(n,t,r,e){for(var u=-1,i=n.length,o=-1,f=r.length,a=-1,c=t.length,l=Jl(i-f,0),s=fl(l+c),h=!e;++u<l;)s[u]=n[u];for(var p=u;++a<c;)s[p+a]=t[a];for(;++o<f;)(h||u<i)&&(s[p+r[o]]=n[u++]);return s}function Mu(n,t){var r=-1,e=n.length;for(t||(t=fl(e));++r<e;)t[r]=n[r];return t}function Fu(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],a=e?e(r[f],n[f],f,r,n):X;a===X&&(a=n[f]),u?Tr(r,f,a):Wr(r,f,a)}return r}function Nu(n,t){return Fu(n,zs(n),t)}function Pu(n,t){return Fu(n,Es(n),t)}function qu(n,t){return function(r,u){var i=mh(r)?e:Cr,o=t?t():{};return i(r,n,Ai(u,2),o)}}function Zu(n){return iu(function(t,r){var e=-1,u=r.length,i=u>1?r[u-1]:X,o=u>2?r[2]:X;for(i=n.length>3&&"function"==typeof i?(u--,i):X,o&&$i(r[0],r[1],o)&&(i=u<3?X:i,u=1),t=hl(t);++e<u;){var f=r[e];f&&n(t,f,e,i)}return t})}function Ku(n,t){return function(r,e){if(null==r)return r;if(!Yf(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=hl(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function Vu(n){return function(t,r,e){for(var u=-1,i=hl(t),o=e(t),f=o.length;f--;){var a=o[n?f:++u];if(r(i[a],a,i)===!1)break}return t}}function Gu(n,t,r){function e(){var t=this&&this!==re&&this instanceof e?i:n;return t.apply(u?r:this,arguments)}var u=t&pn,i=Yu(n);return e}function Hu(n){return function(t){t=Wa(t);var r=$(t)?H(t):X,e=r?r[0]:t.charAt(0),u=r?Iu(r,1).join(""):t.slice(1);return e[n]()+u}}function Ju(n){return function(t){return h(Ec(lc(t).replace($r,"")),n,"")}}function Yu(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=ds(n.prototype),e=n.apply(r,t);return ca(e)?e:r}}function Qu(n,t,e){function u(){for(var o=arguments.length,f=fl(o),a=o,c=ji(u);a--;)f[a]=arguments[a];var l=o<3&&f[0]!==c&&f[o-1]!==c?[]:P(f,c);if(o-=l.length,o<e)return ci(n,t,ti,u.placeholder,X,f,l,X,X,e-o);var s=this&&this!==re&&this instanceof u?i:n;return r(s,this,f)}var i=Yu(n);return u}function Xu(n){return function(t,r,e){var u=hl(t);if(!Yf(t)){var i=Ai(r,3);t=Za(t),r=function(n){return i(u[n],n,u)}}var o=n(t,r,e);return o>-1?u[i?t[o]:o]:X}}function ni(n){return bi(function(t){var r=t.length,e=r,u=Y.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if("function"!=typeof i)throw new _l(en);if(u&&!o&&"wrapper"==xi(i))var o=new Y([],!0)}for(e=o?e:r;++e<r;){i=t[e];var f=xi(i),a="wrapper"==f?Rs(i):X;o=a&&Fi(a[0])&&a[1]==(wn|gn|dn|mn)&&!a[4].length&&1==a[9]?o[xi(a[0])].apply(o,a[3]):1==i.length&&Fi(i)?o[f]():o.thru(i)}return function(){var n=arguments,e=n[0];if(o&&1==n.length&&mh(e))return o.plant(e).value();for(var u=0,i=r?t[u].apply(this,n):e;++u<r;)i=t[u].call(this,i);return i}})}function ti(n,t,r,e,u,i,o,f,a,c){function l(){for(var y=arguments.length,d=fl(y),b=y;b--;)d[b]=arguments[b];if(v)var w=ji(l),m=U(d,w);if(e&&(d=$u(d,e,u,v)),i&&(d=Du(d,i,o,v)),y-=m,v&&y<c){var x=P(d,w);return ci(n,t,ti,l.placeholder,r,d,x,f,a,c-y)}var j=h?r:this,A=p?j[n]:n;return y=d.length,f?d=Qi(d,f):_&&y>1&&d.reverse(),s&&a<y&&(d.length=a),this&&this!==re&&this instanceof l&&(A=g||Yu(A)),A.apply(j,d)}var s=t&wn,h=t&pn,p=t&vn,v=t&(gn|yn),_=t&xn,g=p?X:Yu(n);return l}function ri(n,t){return function(r,e){return Ie(r,n,t(e),{})}}function ei(n,t){return function(r,e){var u;if(r===X&&e===X)return t;if(r!==X&&(u=r),e!==X){if(u===X)return e;"string"==typeof r||"string"==typeof e?(r=gu(r),e=gu(e)):(r=_u(r),e=_u(e)),u=n(r,e)}return u}}function ui(n){return bi(function(t){return t=l(t,E(Ai())),iu(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ii(n,t){t=t===X?" ":gu(t);var r=t.length;if(r<2)return r?uu(t,n):t;var e=uu(t,Pl(n/G(t)));return $(t)?Iu(H(e),0,n).join(""):e.slice(0,n)}function oi(n,t,e,u){function i(){for(var t=-1,a=arguments.length,c=-1,l=u.length,s=fl(l+a),h=this&&this!==re&&this instanceof i?f:n;++c<l;)s[c]=u[c];for(;a--;)s[c++]=arguments[++t];return r(h,o?e:this,s)}var o=t&pn,f=Yu(n);return i}function fi(n){return function(t,r,e){return e&&"number"!=typeof e&&$i(t,r,e)&&(r=e=X),t=Oa(t),r===X?(r=t,t=0):r=Oa(r),e=e===X?t<r?1:-1:Oa(e),eu(t,r,e,n)}}function ai(n){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=za(t),r=za(r)),n(t,r)}}function ci(n,t,r,e,u,i,o,f,a,c){var l=t&gn,s=l?o:X,h=l?X:o,p=l?i:X,v=l?X:i;t|=l?dn:bn,t&=~(l?bn:dn),t&_n||(t&=~(pn|vn));var _=[n,t,u,p,s,v,h,f,a,c],g=r.apply(X,_);return Fi(n)&&Ls(g,_),g.placeholder=e,Xi(g,n,t)}function li(n){var t=sl[n];return function(n,r){if(n=za(n),r=null==r?0:Yl(Ia(r),292)){var e=(Wa(n)+"e").split("e"),u=t(e[0]+"e"+(+e[1]+r));return e=(Wa(u)+"e").split("e"),+(e[0]+"e"+(+e[1]-r))}return t(n)}}function si(n){return function(t){var r=Ss(t);return r==Vn?F(t):r==nt?Z(t):z(t,n(t))}}function hi(n,t,r,e,u,i,o,f){var a=t&vn;if(!a&&"function"!=typeof n)throw new _l(en);var c=e?e.length:0;if(c||(t&=~(dn|bn),e=u=X),o=o===X?o:Jl(Ia(o),0),f=f===X?f:Ia(f),c-=u?u.length:0,t&bn){var l=e,s=u;e=u=X}var h=a?X:Rs(n),p=[n,t,r,e,u,l,s,i,o,f];if(h&&Vi(p,h),n=p[0],t=p[1],r=p[2],e=p[3],u=p[4],f=p[9]=p[9]===X?a?0:n.length:Jl(p[9]-c,0),!f&&t&(gn|yn)&&(t&=~(gn|yn)),t&&t!=pn)v=t==gn||t==yn?Qu(n,t,f):t!=dn&&t!=(pn|dn)||u.length?ti.apply(X,p):oi(n,t,r,e);else var v=Gu(n,t,r);var _=h?js:Ls;return Xi(_(v,p),n,t)}function pi(n,t,r,e){return n===X||Jf(n,dl[r])&&!ml.call(e,r)?t:n}function vi(n,t,r,e,u,i){return ca(n)&&ca(t)&&(i.set(t,n),Ve(n,t,X,vi,i),i.delete(t)),n}function _i(n){return da(n)?X:n}function gi(n,t,r,e,u,i){var o=r&sn,f=n.length,a=t.length;if(f!=a&&!(o&&a>f))return!1;var c=i.get(n);if(c&&i.get(t))return c==t;var l=-1,s=!0,h=r&hn?new dr:X;for(i.set(n,t),i.set(t,n);++l<f;){var p=n[l],_=t[l];if(e)var g=o?e(_,p,l,t,n,i):e(p,_,l,n,t,i);if(g!==X){if(g)continue;s=!1;break}if(h){if(!v(t,function(n,t){if(!W(h,t)&&(p===n||u(p,n,r,e,i)))return h.push(t)})){s=!1;break}}else if(p!==_&&!u(p,_,r,e,i)){s=!1;break}}return i.delete(n),i.delete(t),s}function yi(n,t,r,e,u,i,o){switch(r){case ft:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;n=n.buffer,t=t.buffer;case ot:return!(n.byteLength!=t.byteLength||!i(new El(n),new El(t)));case Fn:case Nn:case Gn:return Jf(+n,+t);case qn:return n.name==t.name&&n.message==t.message;case Xn:case tt:return n==t+"";case Vn:var f=F;case nt:var a=e&sn;if(f||(f=q),n.size!=t.size&&!a)return!1;var c=o.get(n);if(c)return c==t;e|=hn,o.set(n,t);var l=gi(f(n),f(t),e,u,i,o);return o.delete(n),l;case rt:if(gs)return gs.call(n)==gs.call(t)}return!1}function di(n,t,r,e,u,i){var o=r&sn,f=wi(n),a=f.length,c=wi(t),l=c.length;if(a!=l&&!o)return!1;for(var s=a;s--;){var h=f[s];if(!(o?h in t:ml.call(t,h)))return!1}var p=i.get(n);if(p&&i.get(t))return p==t;var v=!0;i.set(n,t),i.set(t,n);for(var _=o;++s<a;){h=f[s];var g=n[h],y=t[h];if(e)var d=o?e(y,g,h,t,n,i):e(g,y,h,n,t,i);if(!(d===X?g===y||u(g,y,r,e,i):d)){v=!1;break}_||(_="constructor"==h)}if(v&&!_){var b=n.constructor,w=t.constructor;b!=w&&"constructor"in n&&"constructor"in t&&!("function"==typeof b&&b instanceof b&&"function"==typeof w&&w instanceof w)&&(v=!1);
}return i.delete(n),i.delete(t),v}function bi(n){return Us(Ji(n,X,go),n+"")}function wi(n){return we(n,Za,zs)}function mi(n){return we(n,Ka,Es)}function xi(n){for(var t=n.name+"",r=cs[t],e=ml.call(cs,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function ji(n){var t=ml.call(K,"placeholder")?K:n;return t.placeholder}function Ai(){var n=K.iteratee||Bc;return n=n===Bc?Me:n,arguments.length?n(arguments[0],arguments[1]):n}function ki(n,t){var r=n.__data__;return Mi(t)?r["string"==typeof t?"string":"hash"]:r.map}function Oi(n){for(var t=Za(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,qi(u)]}return t}function Ii(n,t){var r=T(n,t);return Be(r)?r:X}function Ri(n){var t=ml.call(n,$l),r=n[$l];try{n[$l]=X;var e=!0}catch(n){}var u=Al.call(n);return e&&(t?n[$l]=r:delete n[$l]),u}function zi(n,t,r){for(var e=-1,u=r.length;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Yl(t,n+o);break;case"takeRight":n=Jl(n,t-o)}}return{start:n,end:t}}function Ei(n){var t=n.match(Tt);return t?t[1].split($t):[]}function Si(n,t,r){t=Ou(t,n);for(var e=-1,u=t.length,i=!1;++e<u;){var o=ro(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&aa(u)&&Ti(o,u)&&(mh(n)||wh(n)))}function Wi(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ml.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Li(n){return"function"!=typeof n.constructor||Pi(n)?{}:ds(Wl(n))}function Ci(n,t,r,e){var u=n.constructor;switch(t){case ot:return zu(n);case Fn:case Nn:return new u(+n);case ft:return Eu(n,e);case at:case ct:case lt:case st:case ht:case pt:case vt:case _t:case gt:return Uu(n,e);case Vn:return Su(n,e,r);case Gn:case tt:return new u(n);case Xn:return Wu(n);case nt:return Lu(n,e,r);case rt:return Cu(n)}}function Ui(n,t){var r=t.length;if(!r)return n;var e=r-1;return t[e]=(r>1?"& ":"")+t[e],t=t.join(r>2?", ":" "),n.replace(Bt,"{\n\n")}function Bi(n){return mh(n)||wh(n)||!!(Bl&&n&&n[Bl])}function Ti(n,t){return t=null==t?Sn:t,!!t&&("number"==typeof n||Vt.test(n))&&n>-1&&n%1==0&&n<t}function $i(n,t,r){if(!ca(r))return!1;var e=typeof t;return!!("number"==e?Yf(r)&&Ti(t,r.length):"string"==e&&t in r)&&Jf(r[t],n)}function Di(n,t){if(mh(n))return!1;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!ma(n))||(Rt.test(n)||!It.test(n)||null!=t&&n in hl(t))}function Mi(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}function Fi(n){var t=xi(n),r=K[t];if("function"!=typeof r||!(t in Dt.prototype))return!1;if(n===r)return!0;var e=Rs(r);return!!e&&n===e[0]}function Ni(n){return!!jl&&jl in n}function Pi(n){var t=n&&n.constructor,r="function"==typeof t&&t.prototype||dl;return n===r}function qi(n){return n===n&&!ca(n)}function Zi(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==X||n in hl(r)))}}function Ki(n){var t=Bf(n,function(n){return r.size===on&&r.clear(),n}),r=t.cache;return t}function Vi(n,t){var r=n[1],e=t[1],u=r|e,i=u<(pn|vn|wn),o=e==wn&&r==gn||e==wn&&r==mn&&n[7].length<=t[8]||e==(wn|mn)&&t[7].length<=t[8]&&r==gn;if(!i&&!o)return n;e&pn&&(n[2]=t[2],u|=r&pn?0:_n);var f=t[3];if(f){var a=n[3];n[3]=a?$u(a,f,t[4]):f,n[4]=a?P(n[3],fn):t[4]}return f=t[5],f&&(a=n[5],n[5]=a?Du(a,f,t[6]):f,n[6]=a?P(n[5],fn):t[6]),f=t[7],f&&(n[7]=f),e&wn&&(n[8]=null==n[8]?t[8]:Yl(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Gi(n){var t=[];if(null!=n)for(var r in hl(n))t.push(r);return t}function Hi(n){return Al.call(n)}function Ji(n,t,e){return t=Jl(t===X?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Jl(u.length-t,0),f=fl(o);++i<o;)f[i]=u[t+i];i=-1;for(var a=fl(t+1);++i<t;)a[i]=u[i];return a[t]=e(f),r(n,this,a)}}function Yi(n,t){return t.length<2?n:de(n,lu(t,0,-1))}function Qi(n,t){for(var r=n.length,e=Yl(t.length,r),u=Mu(n);e--;){var i=t[e];n[e]=Ti(i,r)?u[i]:X}return n}function Xi(n,t,r){var e=t+"";return Us(n,Ui(e,uo(Ei(e),r)))}function no(n){var t=0,r=0;return function(){var e=Ql(),u=On-(e-r);if(r=e,u>0){if(++t>=kn)return arguments[0]}else t=0;return n.apply(X,arguments)}}function to(n,t){var r=-1,e=n.length,u=e-1;for(t=t===X?e:t;++r<t;){var i=ru(r,u),o=n[i];n[i]=n[r],n[r]=o}return n.length=t,n}function ro(n){if("string"==typeof n||ma(n))return n;var t=n+"";return"0"==t&&1/n==-En?"-0":t}function eo(n){if(null!=n){try{return wl.call(n)}catch(n){}try{return n+""}catch(n){}}return""}function uo(n,t){return u(Tn,function(r){var e="_."+r[0];t&r[1]&&!a(n,e)&&n.push(e)}),n.sort()}function io(n){if(n instanceof Dt)return n.clone();var t=new Y(n.__wrapped__,n.__chain__);return t.__actions__=Mu(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function oo(n,t,r){t=(r?$i(n,t,r):t===X)?1:Jl(Ia(t),0);var e=null==n?0:n.length;if(!e||t<1)return[];for(var u=0,i=0,o=fl(Pl(e/t));u<e;)o[i++]=lu(n,u,u+=t);return o}function fo(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u}function ao(){var n=arguments.length;if(!n)return[];for(var t=fl(n-1),r=arguments[0],e=n;e--;)t[e-1]=arguments[e];return s(mh(r)?Mu(r):[r],ue(t,1))}function co(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),lu(n,t<0?0:t,e)):[]}function lo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),t=e-t,lu(n,0,t<0?0:t)):[]}function so(n,t){return n&&n.length?wu(n,Ai(t,3),!0,!0):[]}function ho(n,t){return n&&n.length?wu(n,Ai(t,3),!0):[]}function po(n,t,r,e){var u=null==n?0:n.length;return u?(r&&"number"!=typeof r&&$i(n,t,r)&&(r=0,e=u),te(n,t,r,e)):[]}function vo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:Ia(r);return u<0&&(u=Jl(e+u,0)),d(n,Ai(t,3),u)}function _o(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==X&&(u=Ia(r),u=r<0?Jl(e+u,0):Yl(u,e-1)),d(n,Ai(t,3),u,!0)}function go(n){var t=null==n?0:n.length;return t?ue(n,1):[]}function yo(n){var t=null==n?0:n.length;return t?ue(n,En):[]}function bo(n,t){var r=null==n?0:n.length;return r?(t=t===X?1:Ia(t),ue(n,t)):[]}function wo(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e}function mo(n){return n&&n.length?n[0]:X}function xo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:Ia(r);return u<0&&(u=Jl(e+u,0)),b(n,t,u)}function jo(n){var t=null==n?0:n.length;return t?lu(n,0,-1):[]}function Ao(n,t){return null==n?"":Gl.call(n,t)}function ko(n){var t=null==n?0:n.length;return t?n[t-1]:X}function Oo(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;return r!==X&&(u=Ia(r),u=u<0?Jl(e+u,0):Yl(u,e-1)),t===t?V(n,t,u):d(n,m,u,!0)}function Io(n,t){return n&&n.length?He(n,Ia(t)):X}function Ro(n,t){return n&&n.length&&t&&t.length?nu(n,t):n}function zo(n,t,r){return n&&n.length&&t&&t.length?nu(n,t,Ai(r,2)):n}function Eo(n,t,r){return n&&n.length&&t&&t.length?nu(n,t,X,r):n}function So(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=Ai(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return tu(n,u),r}function Wo(n){return null==n?n:ts.call(n)}function Lo(n,t,r){var e=null==n?0:n.length;return e?(r&&"number"!=typeof r&&$i(n,t,r)?(t=0,r=e):(t=null==t?0:Ia(t),r=r===X?e:Ia(r)),lu(n,t,r)):[]}function Co(n,t){return hu(n,t)}function Uo(n,t,r){return pu(n,t,Ai(r,2))}function Bo(n,t){var r=null==n?0:n.length;if(r){var e=hu(n,t);if(e<r&&Jf(n[e],t))return e}return-1}function To(n,t){return hu(n,t,!0)}function $o(n,t,r){return pu(n,t,Ai(r,2),!0)}function Do(n,t){var r=null==n?0:n.length;if(r){var e=hu(n,t,!0)-1;if(Jf(n[e],t))return e}return-1}function Mo(n){return n&&n.length?vu(n):[]}function Fo(n,t){return n&&n.length?vu(n,Ai(t,2)):[]}function No(n){var t=null==n?0:n.length;return t?lu(n,1,t):[]}function Po(n,t,r){return n&&n.length?(t=r||t===X?1:Ia(t),lu(n,0,t<0?0:t)):[]}function qo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:Ia(t),t=e-t,lu(n,t<0?0:t,e)):[]}function Zo(n,t){return n&&n.length?wu(n,Ai(t,3),!1,!0):[]}function Ko(n,t){return n&&n.length?wu(n,Ai(t,3)):[]}function Vo(n){return n&&n.length?yu(n):[]}function Go(n,t){return n&&n.length?yu(n,Ai(t,2)):[]}function Ho(n,t){return t="function"==typeof t?t:X,n&&n.length?yu(n,X,t):[]}function Jo(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(Qf(n))return t=Jl(n.length,t),!0}),R(t,function(t){return l(n,j(t))})}function Yo(n,t){if(!n||!n.length)return[];var e=Jo(n);return null==t?e:l(e,function(n){return r(t,X,n)})}function Qo(n,t){return ju(n||[],t||[],Wr)}function Xo(n,t){return ju(n||[],t||[],au)}function nf(n){var t=K(n);return t.__chain__=!0,t}function tf(n,t){return t(n),n}function rf(n,t){return t(n)}function ef(){return nf(this)}function uf(){return new Y(this.value(),this.__chain__)}function of(){this.__values__===X&&(this.__values__=ka(this.value()));var n=this.__index__>=this.__values__.length,t=n?X:this.__values__[this.__index__++];return{done:n,value:t}}function ff(){return this}function af(n){for(var t,r=this;r instanceof J;){var e=io(r);e.__index__=0,e.__values__=X,t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function cf(){var n=this.__wrapped__;if(n instanceof Dt){var t=n;return this.__actions__.length&&(t=new Dt(this)),t=t.reverse(),t.__actions__.push({func:rf,args:[Wo],thisArg:X}),new Y(t,this.__chain__)}return this.thru(Wo)}function lf(){return mu(this.__wrapped__,this.__actions__)}function sf(n,t,r){var e=mh(n)?o:Yr;return r&&$i(n,t,r)&&(t=X),e(n,Ai(t,3))}function hf(n,t){var r=mh(n)?f:ee;return r(n,Ai(t,3))}function pf(n,t){return ue(bf(n,t),1)}function vf(n,t){return ue(bf(n,t),En)}function _f(n,t,r){return r=r===X?1:Ia(r),ue(bf(n,t),r)}function gf(n,t){var r=mh(n)?u:bs;return r(n,Ai(t,3))}function yf(n,t){var r=mh(n)?i:ws;return r(n,Ai(t,3))}function df(n,t,r,e){n=Yf(n)?n:uc(n),r=r&&!e?Ia(r):0;var u=n.length;return r<0&&(r=Jl(u+r,0)),wa(n)?r<=u&&n.indexOf(t,r)>-1:!!u&&b(n,t,r)>-1}function bf(n,t){var r=mh(n)?l:qe;return r(n,Ai(t,3))}function wf(n,t,r,e){return null==n?[]:(mh(t)||(t=null==t?[]:[t]),r=e?X:r,mh(r)||(r=null==r?[]:[r]),Je(n,t,r))}function mf(n,t,r){var e=mh(n)?h:k,u=arguments.length<3;return e(n,Ai(t,4),r,u,bs)}function xf(n,t,r){var e=mh(n)?p:k,u=arguments.length<3;return e(n,Ai(t,4),r,u,ws)}function jf(n,t){var r=mh(n)?f:ee;return r(n,Tf(Ai(t,3)))}function Af(n){var t=mh(n)?Rr:ou;return t(n)}function kf(n,t,r){t=(r?$i(n,t,r):t===X)?1:Ia(t);var e=mh(n)?zr:fu;return e(n,t)}function Of(n){var t=mh(n)?Er:cu;return t(n)}function If(n){if(null==n)return 0;if(Yf(n))return wa(n)?G(n):n.length;var t=Ss(n);return t==Vn||t==nt?n.size:Fe(n).length}function Rf(n,t,r){var e=mh(n)?v:su;return r&&$i(n,t,r)&&(t=X),e(n,Ai(t,3))}function zf(n,t){if("function"!=typeof t)throw new _l(en);return n=Ia(n),function(){if(--n<1)return t.apply(this,arguments)}}function Ef(n,t,r){return t=r?X:t,t=n&&null==t?n.length:t,hi(n,wn,X,X,X,X,t)}function Sf(n,t){var r;if("function"!=typeof t)throw new _l(en);return n=Ia(n),function(){return--n>0&&(r=t.apply(this,arguments)),n<=1&&(t=X),r}}function Wf(n,t,r){t=r?X:t;var e=hi(n,gn,X,X,X,X,X,t);return e.placeholder=Wf.placeholder,e}function Lf(n,t,r){t=r?X:t;var e=hi(n,yn,X,X,X,X,X,t);return e.placeholder=Lf.placeholder,e}function Cf(n,t,r){function e(t){var r=h,e=p;return h=p=X,d=t,_=n.apply(e,r)}function u(n){return d=n,g=Cs(f,t),b?e(n):_}function i(n){var r=n-y,e=n-d,u=t-r;return w?Yl(u,v-e):u}function o(n){var r=n-y,e=n-d;return y===X||r>=t||r<0||w&&e>=v}function f(){var n=ch();return o(n)?a(n):void(g=Cs(f,i(n)))}function a(n){return g=X,m&&h?e(n):(h=p=X,_)}function c(){g!==X&&Os(g),d=0,h=y=p=g=X}function l(){return g===X?_:a(ch())}function s(){var n=ch(),r=o(n);if(h=arguments,p=this,y=n,r){if(g===X)return u(y);if(w)return g=Cs(f,t),e(y)}return g===X&&(g=Cs(f,t)),_}var h,p,v,_,g,y,d=0,b=!1,w=!1,m=!0;if("function"!=typeof n)throw new _l(en);return t=za(t)||0,ca(r)&&(b=!!r.leading,w="maxWait"in r,v=w?Jl(za(r.maxWait)||0,t):v,m="trailing"in r?!!r.trailing:m),s.cancel=c,s.flush=l,s}function Uf(n){return hi(n,xn)}function Bf(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new _l(en);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o)||i,o};return r.cache=new(Bf.Cache||hr),r}function Tf(n){if("function"!=typeof n)throw new _l(en);return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function $f(n){return Sf(2,n)}function Df(n,t){if("function"!=typeof n)throw new _l(en);return t=t===X?t:Ia(t),iu(n,t)}function Mf(n,t){if("function"!=typeof n)throw new _l(en);return t=null==t?0:Jl(Ia(t),0),iu(function(e){var u=e[t],i=Iu(e,0,t);return u&&s(i,u),r(n,this,i)})}function Ff(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new _l(en);return ca(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),Cf(n,t,{leading:e,maxWait:t,trailing:u})}function Nf(n){return Ef(n,1)}function Pf(n,t){return _h(ku(t),n)}function qf(){if(!arguments.length)return[];var n=arguments[0];return mh(n)?n:[n]}function Zf(n){return Nr(n,ln)}function Kf(n,t){return t="function"==typeof t?t:X,Nr(n,ln,t)}function Vf(n){return Nr(n,an|ln)}function Gf(n,t){return t="function"==typeof t?t:X,Nr(n,an|ln,t)}function Hf(n,t){return null==t||Gr(n,t,Za(t))}function Jf(n,t){return n===t||n!==n&&t!==t}function Yf(n){return null!=n&&aa(n.length)&&!oa(n)}function Qf(n){return la(n)&&Yf(n)}function Xf(n){return n===!0||n===!1||la(n)&&me(n)==Fn}function na(n){return la(n)&&1===n.nodeType&&!da(n)}function ta(n){if(null==n)return!0;if(Yf(n)&&(mh(n)||"string"==typeof n||"function"==typeof n.splice||jh(n)||Rh(n)||wh(n)))return!n.length;var t=Ss(n);if(t==Vn||t==nt)return!n.size;if(Pi(n))return!Fe(n).length;for(var r in n)if(ml.call(n,r))return!1;return!0}function ra(n,t){return We(n,t)}function ea(n,t,r){r="function"==typeof r?r:X;var e=r?r(n,t):X;return e===X?We(n,t,X,r):!!e}function ua(n){if(!la(n))return!1;var t=me(n);return t==qn||t==Pn||"string"==typeof n.message&&"string"==typeof n.name&&!da(n)}function ia(n){return"number"==typeof n&&Vl(n)}function oa(n){if(!ca(n))return!1;var t=me(n);return t==Zn||t==Kn||t==Mn||t==Qn}function fa(n){return"number"==typeof n&&n==Ia(n)}function aa(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=Sn}function ca(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function la(n){return null!=n&&"object"==typeof n}function sa(n,t){return n===t||Ue(n,t,Oi(t))}function ha(n,t,r){return r="function"==typeof r?r:X,Ue(n,t,Oi(t),r)}function pa(n){return ya(n)&&n!=+n}function va(n){if(Ws(n))throw new cl(rn);return Be(n)}function _a(n){return null===n}function ga(n){return null==n}function ya(n){return"number"==typeof n||la(n)&&me(n)==Gn}function da(n){if(!la(n)||me(n)!=Jn)return!1;var t=Wl(n);if(null===t)return!0;var r=ml.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&wl.call(r)==kl}function ba(n){return fa(n)&&n>=-Sn&&n<=Sn}function wa(n){return"string"==typeof n||!mh(n)&&la(n)&&me(n)==tt}function ma(n){return"symbol"==typeof n||la(n)&&me(n)==rt}function xa(n){return n===X}function ja(n){return la(n)&&Ss(n)==ut}function Aa(n){return la(n)&&me(n)==it}function ka(n){if(!n)return[];if(Yf(n))return wa(n)?H(n):Mu(n);if(Tl&&n[Tl])return M(n[Tl]());var t=Ss(n),r=t==Vn?F:t==nt?q:uc;return r(n)}function Oa(n){if(!n)return 0===n?n:0;if(n=za(n),n===En||n===-En){var t=n<0?-1:1;return t*Wn}return n===n?n:0}function Ia(n){var t=Oa(n),r=t%1;return t===t?r?t-r:t:0}function Ra(n){return n?Fr(Ia(n),0,Cn):0}function za(n){if("number"==typeof n)return n;if(ma(n))return Ln;if(ca(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=ca(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(Lt,"");var r=qt.test(n);return r||Kt.test(n)?Xr(n.slice(2),r?2:8):Pt.test(n)?Ln:+n}function Ea(n){return Fu(n,Ka(n))}function Sa(n){return n?Fr(Ia(n),-Sn,Sn):0===n?n:0}function Wa(n){return null==n?"":gu(n)}function La(n,t){var r=ds(n);return null==t?r:Ur(r,t)}function Ca(n,t){return y(n,Ai(t,3),oe)}function Ua(n,t){return y(n,Ai(t,3),fe)}function Ba(n,t){return null==n?n:ms(n,Ai(t,3),Ka)}function Ta(n,t){return null==n?n:xs(n,Ai(t,3),Ka)}function $a(n,t){return n&&oe(n,Ai(t,3))}function Da(n,t){return n&&fe(n,Ai(t,3))}function Ma(n){return null==n?[]:ve(n,Za(n))}function Fa(n){return null==n?[]:ve(n,Ka(n))}function Na(n,t,r){var e=null==n?X:de(n,t);return e===X?r:e}function Pa(n,t){return null!=n&&Si(n,t,je)}function qa(n,t){return null!=n&&Si(n,t,Ae)}function Za(n){return Yf(n)?Ir(n):Fe(n)}function Ka(n){return Yf(n)?Ir(n,!0):Ne(n)}function Va(n,t){var r={};return t=Ai(t,3),oe(n,function(n,e,u){Tr(r,t(n,e,u),n)}),r}function Ga(n,t){var r={};return t=Ai(t,3),oe(n,function(n,e,u){Tr(r,e,t(n,e,u))}),r}function Ha(n,t){return Ja(n,Tf(Ai(t)))}function Ja(n,t){if(null==n)return{};var r=l(mi(n),function(n){return[n]});return t=Ai(t),Qe(n,r,function(n,r){return t(n,r[0])})}function Ya(n,t,r){t=Ou(t,n);var e=-1,u=t.length;for(u||(u=1,n=X);++e<u;){var i=null==n?X:n[ro(t[e])];i===X&&(e=u,i=r),n=oa(i)?i.call(n):i}return n}function Qa(n,t,r){return null==n?n:au(n,t,r)}function Xa(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:au(n,t,r,e)}function nc(n,t,r){var e=mh(n),i=e||jh(n)||Rh(n);if(t=Ai(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:ca(n)&&oa(o)?ds(Wl(n)):{}}return(i?u:oe)(n,function(n,e,u){return t(r,n,e,u)}),r}function tc(n,t){return null==n||du(n,t)}function rc(n,t,r){return null==n?n:bu(n,t,ku(r))}function ec(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:bu(n,t,ku(r),e)}function uc(n){return null==n?[]:S(n,Za(n))}function ic(n){return null==n?[]:S(n,Ka(n))}function oc(n,t,r){return r===X&&(r=t,t=X),r!==X&&(r=za(r),r=r===r?r:0),t!==X&&(t=za(t),t=t===t?t:0),Fr(za(n),t,r)}function fc(n,t,r){return t=Oa(t),r===X?(r=t,t=0):r=Oa(r),n=za(n),ke(n,t,r)}function ac(n,t,r){if(r&&"boolean"!=typeof r&&$i(n,t,r)&&(t=r=X),r===X&&("boolean"==typeof t?(r=t,t=X):"boolean"==typeof n&&(r=n,n=X)),n===X&&t===X?(n=0,t=1):(n=Oa(n),t===X?(t=n,n=0):t=Oa(t)),n>t){var e=n;n=t,t=e}if(r||n%1||t%1){var u=ns();return Yl(n+u*(t-n+Qr("1e-"+((u+"").length-1))),t)}return ru(n,t)}function cc(n){return np(Wa(n).toLowerCase())}function lc(n){return n=Wa(n),n&&n.replace(Gt,_e).replace(Dr,"")}function sc(n,t,r){n=Wa(n),t=gu(t);var e=n.length;r=r===X?e:Fr(Ia(r),0,e);var u=r;return r-=t.length,r>=0&&n.slice(r,u)==t}function hc(n){return n=Wa(n),n&&jt.test(n)?n.replace(mt,ge):n}function pc(n){return n=Wa(n),n&&Wt.test(n)?n.replace(St,"\\$&"):n}function vc(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;if(!t||e>=t)return n;var u=(t-e)/2;return ii(ql(u),r)+n+ii(Pl(u),r)}function _c(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;return t&&e<t?n+ii(t-e,r):n}function gc(n,t,r){n=Wa(n),t=Ia(t);var e=t?G(n):0;return t&&e<t?ii(t-e,r)+n:n}function yc(n,t,r){return r||null==t?t=0:t&&(t=+t),Xl(Wa(n).replace(Ct,""),t||0)}function dc(n,t,r){return t=(r?$i(n,t,r):t===X)?1:Ia(t),uu(Wa(n),t)}function bc(){var n=arguments,t=Wa(n[0]);return n.length<3?t:t.replace(n[1],n[2])}function wc(n,t,r){return r&&"number"!=typeof r&&$i(n,t,r)&&(t=r=X),(r=r===X?Cn:r>>>0)?(n=Wa(n),n&&("string"==typeof t||null!=t&&!Oh(t))&&(t=gu(t),!t&&$(n))?Iu(H(n),0,r):n.split(t,r)):[]}function mc(n,t,r){return n=Wa(n),r=null==r?0:Fr(Ia(r),0,n.length),t=gu(t),n.slice(r,r+t.length)==t}function xc(n,t,r){var e=K.templateSettings;r&&$i(n,t,r)&&(t=X),n=Wa(n),t=Lh({},t,e,pi);var u,i,o=Lh({},t.imports,e.imports,pi),f=Za(o),a=S(o,f),c=0,l=t.interpolate||Ht,s="__p += '",h=pl((t.escape||Ht).source+"|"+l.source+"|"+(l===Ot?Ft:Ht).source+"|"+(t.evaluate||Ht).source+"|$","g"),p="//# sourceURL="+("sourceURL"in t?t.sourceURL:"lodash.templateSources["+ ++Zr+"]")+"\n";n.replace(h,function(t,r,e,o,f,a){return e||(e=o),s+=n.slice(c,a).replace(Jt,B),r&&(u=!0,s+="' +\n__e("+r+") +\n'"),f&&(i=!0,s+="';\n"+f+";\n__p += '"),e&&(s+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),c=a+t.length,t}),s+="';\n";var v=t.variable;v||(s="with (obj) {\n"+s+"\n}\n"),s=(i?s.replace(yt,""):s).replace(dt,"$1").replace(bt,"$1;"),s="function("+(v||"obj")+") {\n"+(v?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(u?", __e = _.escape":"")+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+s+"return __p\n}";var _=tp(function(){return ll(f,p+"return "+s).apply(X,a)});if(_.source=s,ua(_))throw _;return _}function jc(n){return Wa(n).toLowerCase()}function Ac(n){return Wa(n).toUpperCase()}function kc(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Lt,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=H(t),i=L(e,u),o=C(e,u)+1;return Iu(e,i,o).join("")}function Oc(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Ut,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=C(e,H(t))+1;return Iu(e,0,u).join("")}function Ic(n,t,r){if(n=Wa(n),n&&(r||t===X))return n.replace(Ct,"");if(!n||!(t=gu(t)))return n;var e=H(n),u=L(e,H(t));return Iu(e,u).join("")}function Rc(n,t){var r=jn,e=An;if(ca(t)){var u="separator"in t?t.separator:u;r="length"in t?Ia(t.length):r,e="omission"in t?gu(t.omission):e}n=Wa(n);var i=n.length;if($(n)){var o=H(n);i=o.length}if(r>=i)return n;var f=r-G(e);if(f<1)return e;var a=o?Iu(o,0,f).join(""):n.slice(0,f);if(u===X)return a+e;if(o&&(f+=a.length-f),Oh(u)){if(n.slice(f).search(u)){var c,l=a;for(u.global||(u=pl(u.source,Wa(Nt.exec(u))+"g")),u.lastIndex=0;c=u.exec(l);)var s=c.index;a=a.slice(0,s===X?f:s)}}else if(n.indexOf(gu(u),f)!=f){var h=a.lastIndexOf(u);h>-1&&(a=a.slice(0,h))}return a+e}function zc(n){return n=Wa(n),n&&xt.test(n)?n.replace(wt,ye):n}function Ec(n,t,r){return n=Wa(n),t=r?X:t,t===X?D(n)?Q(n):g(n):n.match(t)||[]}function Sc(n){var t=null==n?0:n.length,e=Ai();return n=t?l(n,function(n){if("function"!=typeof n[1])throw new _l(en);return[e(n[0]),n[1]]}):[],iu(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})}function Wc(n){return Pr(Nr(n,an))}function Lc(n){return function(){return n}}function Cc(n,t){return null==n||n!==n?t:n}function Uc(n){return n}function Bc(n){return Me("function"==typeof n?n:Nr(n,an))}function Tc(n){return Ze(Nr(n,an))}function $c(n,t){return Ke(n,Nr(t,an))}function Dc(n,t,r){var e=Za(t),i=ve(t,e);null!=r||ca(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=ve(t,Za(t)));var o=!(ca(r)&&"chain"in r&&!r.chain),f=oa(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__),u=r.__actions__=Mu(this.__actions__);return u.push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function Mc(){return re._===this&&(re._=Ol),this}function Fc(){}function Nc(n){return n=Ia(n),iu(function(t){return He(t,n)})}function Pc(n){return Di(n)?j(ro(n)):Xe(n)}function qc(n){return function(t){return null==n?X:de(n,t)}}function Zc(){return[]}function Kc(){return!1}function Vc(){return{}}function Gc(){return""}function Hc(){return!0}function Jc(n,t){if(n=Ia(n),n<1||n>Sn)return[];var r=Cn,e=Yl(n,Cn);t=Ai(t),n-=Cn;for(var u=R(e,t);++r<n;)t(r);return u}function Yc(n){return mh(n)?l(n,ro):ma(n)?[n]:Mu(Bs(Wa(n)))}function Qc(n){var t=++xl;return Wa(n)+t}function Xc(n){return n&&n.length?ne(n,Uc,xe):X}function nl(n,t){return n&&n.length?ne(n,Ai(t,2),xe):X}function tl(n){return x(n,Uc)}function rl(n,t){return x(n,Ai(t,2))}function el(n){return n&&n.length?ne(n,Uc,Pe):X}function ul(n,t){return n&&n.length?ne(n,Ai(t,2),Pe):X}function il(n){return n&&n.length?I(n,Uc):0}function ol(n,t){return n&&n.length?I(n,Ai(t,2)):0}A=null==A?re:be.defaults(re.Object(),A,be.pick(re,qr));var fl=A.Array,al=A.Date,cl=A.Error,ll=A.Function,sl=A.Math,hl=A.Object,pl=A.RegExp,vl=A.String,_l=A.TypeError,gl=fl.prototype,yl=ll.prototype,dl=hl.prototype,bl=A["__core-js_shared__"],wl=yl.toString,ml=dl.hasOwnProperty,xl=0,jl=function(){var n=/[^.]+$/.exec(bl&&bl.keys&&bl.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),Al=dl.toString,kl=wl.call(hl),Ol=re._,Il=pl("^"+wl.call(ml).replace(St,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Rl=ie?A.Buffer:X,zl=A.Symbol,El=A.Uint8Array,Sl=Rl?Rl.allocUnsafe:X,Wl=N(hl.getPrototypeOf,hl),Ll=hl.create,Cl=dl.propertyIsEnumerable,Ul=gl.splice,Bl=zl?zl.isConcatSpreadable:X,Tl=zl?zl.iterator:X,$l=zl?zl.toStringTag:X,Dl=function(){try{var n=Ii(hl,"defineProperty");return n({},"",{}),n}catch(n){}}(),Ml=A.clearTimeout!==re.clearTimeout&&A.clearTimeout,Fl=al&&al.now!==re.Date.now&&al.now,Nl=A.setTimeout!==re.setTimeout&&A.setTimeout,Pl=sl.ceil,ql=sl.floor,Zl=hl.getOwnPropertySymbols,Kl=Rl?Rl.isBuffer:X,Vl=A.isFinite,Gl=gl.join,Hl=N(hl.keys,hl),Jl=sl.max,Yl=sl.min,Ql=al.now,Xl=A.parseInt,ns=sl.random,ts=gl.reverse,rs=Ii(A,"DataView"),es=Ii(A,"Map"),us=Ii(A,"Promise"),is=Ii(A,"Set"),os=Ii(A,"WeakMap"),fs=Ii(hl,"create"),as=os&&new os,cs={},ls=eo(rs),ss=eo(es),hs=eo(us),ps=eo(is),vs=eo(os),_s=zl?zl.prototype:X,gs=_s?_s.valueOf:X,ys=_s?_s.toString:X,ds=function(){function n(){}return function(t){if(!ca(t))return{};if(Ll)return Ll(t);n.prototype=t;var r=new n;return n.prototype=X,r}}();K.templateSettings={escape:At,evaluate:kt,interpolate:Ot,variable:"",imports:{_:K}},K.prototype=J.prototype,K.prototype.constructor=K,Y.prototype=ds(J.prototype),Y.prototype.constructor=Y,Dt.prototype=ds(J.prototype),Dt.prototype.constructor=Dt,nr.prototype.clear=tr,nr.prototype.delete=rr,nr.prototype.get=er,nr.prototype.has=ur,nr.prototype.set=ir,or.prototype.clear=fr,or.prototype.delete=ar,or.prototype.get=cr,or.prototype.has=lr,or.prototype.set=sr,hr.prototype.clear=pr,hr.prototype.delete=vr,hr.prototype.get=_r,hr.prototype.has=gr,hr.prototype.set=yr,dr.prototype.add=dr.prototype.push=br,dr.prototype.has=wr,mr.prototype.clear=xr,mr.prototype.delete=jr,mr.prototype.get=Ar,mr.prototype.has=kr,mr.prototype.set=Or;var bs=Ku(oe),ws=Ku(fe,!0),ms=Vu(),xs=Vu(!0),js=as?function(n,t){return as.set(n,t),n}:Uc,As=Dl?function(n,t){return Dl(n,"toString",{configurable:!0,enumerable:!1,value:Lc(t),writable:!0})}:Uc,ks=iu,Os=Ml||function(n){return re.clearTimeout(n)},Is=is&&1/q(new is([,-0]))[1]==En?function(n){return new is(n)}:Fc,Rs=as?function(n){return as.get(n)}:Fc,zs=Zl?function(n){return null==n?[]:(n=hl(n),f(Zl(n),function(t){return Cl.call(n,t)}))}:Zc,Es=Zl?function(n){for(var t=[];n;)s(t,zs(n)),n=Wl(n);return t}:Zc,Ss=me;(rs&&Ss(new rs(new ArrayBuffer(1)))!=ft||es&&Ss(new es)!=Vn||us&&Ss(us.resolve())!=Yn||is&&Ss(new is)!=nt||os&&Ss(new os)!=ut)&&(Ss=function(n){var t=me(n),r=t==Jn?n.constructor:X,e=r?eo(r):"";if(e)switch(e){case ls:return ft;case ss:return Vn;case hs:return Yn;case ps:return nt;case vs:return ut}return t});var Ws=bl?oa:Kc,Ls=no(js),Cs=Nl||function(n,t){return re.setTimeout(n,t)},Us=no(As),Bs=Ki(function(n){var t=[];return zt.test(n)&&t.push(""),n.replace(Et,function(n,r,e,u){t.push(e?u.replace(Mt,"$1"):r||n)}),t}),Ts=iu(function(n,t){return Qf(n)?Jr(n,ue(t,1,Qf,!0)):[]}),$s=iu(function(n,t){var r=ko(t);return Qf(r)&&(r=X),Qf(n)?Jr(n,ue(t,1,Qf,!0),Ai(r,2)):[]}),Ds=iu(function(n,t){var r=ko(t);return Qf(r)&&(r=X),Qf(n)?Jr(n,ue(t,1,Qf,!0),X,r):[]}),Ms=iu(function(n){var t=l(n,Au);return t.length&&t[0]===n[0]?Oe(t):[]}),Fs=iu(function(n){var t=ko(n),r=l(n,Au);return t===ko(r)?t=X:r.pop(),r.length&&r[0]===n[0]?Oe(r,Ai(t,2)):[]}),Ns=iu(function(n){var t=ko(n),r=l(n,Au);return t="function"==typeof t?t:X,t&&r.pop(),r.length&&r[0]===n[0]?Oe(r,X,t):[]}),Ps=iu(Ro),qs=bi(function(n,t){var r=null==n?0:n.length,e=Mr(n,t);return tu(n,l(t,function(n){return Ti(n,r)?+n:n}).sort(Bu)),e}),Zs=iu(function(n){return yu(ue(n,1,Qf,!0))}),Ks=iu(function(n){var t=ko(n);return Qf(t)&&(t=X),yu(ue(n,1,Qf,!0),Ai(t,2))}),Vs=iu(function(n){var t=ko(n);return t="function"==typeof t?t:X,yu(ue(n,1,Qf,!0),X,t)}),Gs=iu(function(n,t){return Qf(n)?Jr(n,t):[]}),Hs=iu(function(n){return xu(f(n,Qf))}),Js=iu(function(n){var t=ko(n);return Qf(t)&&(t=X),xu(f(n,Qf),Ai(t,2))}),Ys=iu(function(n){var t=ko(n);return t="function"==typeof t?t:X,xu(f(n,Qf),X,t)}),Qs=iu(Jo),Xs=iu(function(n){var t=n.length,r=t>1?n[t-1]:X;return r="function"==typeof r?(n.pop(),r):X,Yo(n,r)}),nh=bi(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return Mr(t,n)};return!(t>1||this.__actions__.length)&&e instanceof Dt&&Ti(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:rf,args:[u],thisArg:X}),new Y(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(X),n})):this.thru(u)}),th=qu(function(n,t,r){ml.call(n,r)?++n[r]:Tr(n,r,1)}),rh=Xu(vo),eh=Xu(_o),uh=qu(function(n,t,r){ml.call(n,r)?n[r].push(t):Tr(n,r,[t])}),ih=iu(function(n,t,e){var u=-1,i="function"==typeof t,o=Yf(n)?fl(n.length):[];return bs(n,function(n){o[++u]=i?r(t,n,e):Re(n,t,e)}),o}),oh=qu(function(n,t,r){Tr(n,r,t)}),fh=qu(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),ah=iu(function(n,t){if(null==n)return[];var r=t.length;return r>1&&$i(n,t[0],t[1])?t=[]:r>2&&$i(t[0],t[1],t[2])&&(t=[t[0]]),Je(n,ue(t,1),[])}),ch=Fl||function(){return re.Date.now()},lh=iu(function(n,t,r){var e=pn;if(r.length){var u=P(r,ji(lh));e|=dn}return hi(n,e,t,r,u)}),sh=iu(function(n,t,r){var e=pn|vn;if(r.length){var u=P(r,ji(sh));e|=dn}return hi(t,e,n,r,u)}),hh=iu(function(n,t){return Hr(n,1,t)}),ph=iu(function(n,t,r){return Hr(n,za(t)||0,r)});Bf.Cache=hr;var vh=ks(function(n,t){t=1==t.length&&mh(t[0])?l(t[0],E(Ai())):l(ue(t,1),E(Ai()));var e=t.length;return iu(function(u){for(var i=-1,o=Yl(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);return r(n,this,u)})}),_h=iu(function(n,t){var r=P(t,ji(_h));return hi(n,dn,X,t,r)}),gh=iu(function(n,t){var r=P(t,ji(gh));return hi(n,bn,X,t,r)}),yh=bi(function(n,t){return hi(n,mn,X,X,X,t)}),dh=ai(xe),bh=ai(function(n,t){return n>=t}),wh=ze(function(){return arguments}())?ze:function(n){return la(n)&&ml.call(n,"callee")&&!Cl.call(n,"callee")},mh=fl.isArray,xh=ae?E(ae):Ee,jh=Kl||Kc,Ah=ce?E(ce):Se,kh=le?E(le):Ce,Oh=se?E(se):Te,Ih=he?E(he):$e,Rh=pe?E(pe):De,zh=ai(Pe),Eh=ai(function(n,t){return n<=t}),Sh=Zu(function(n,t){if(Pi(t)||Yf(t))return void Fu(t,Za(t),n);for(var r in t)ml.call(t,r)&&Wr(n,r,t[r])}),Wh=Zu(function(n,t){Fu(t,Ka(t),n)}),Lh=Zu(function(n,t,r,e){Fu(t,Ka(t),n,e)}),Ch=Zu(function(n,t,r,e){Fu(t,Za(t),n,e)}),Uh=bi(Mr),Bh=iu(function(n){return n.push(X,pi),r(Lh,X,n)}),Th=iu(function(n){return n.push(X,vi),r(Nh,X,n)}),$h=ri(function(n,t,r){n[t]=r},Lc(Uc)),Dh=ri(function(n,t,r){ml.call(n,t)?n[t].push(r):n[t]=[r]},Ai),Mh=iu(Re),Fh=Zu(function(n,t,r){Ve(n,t,r)}),Nh=Zu(function(n,t,r,e){Ve(n,t,r,e)}),Ph=bi(function(n,t){var r={};if(null==n)return r;var e=!1;t=l(t,function(t){return t=Ou(t,n),e||(e=t.length>1),t}),Fu(n,mi(n),r),e&&(r=Nr(r,an|cn|ln,_i));for(var u=t.length;u--;)du(r,t[u]);return r}),qh=bi(function(n,t){return null==n?{}:Ye(n,t)}),Zh=si(Za),Kh=si(Ka),Vh=Ju(function(n,t,r){return t=t.toLowerCase(),n+(r?cc(t):t)}),Gh=Ju(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Hh=Ju(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Jh=Hu("toLowerCase"),Yh=Ju(function(n,t,r){return n+(r?"_":"")+t.toLowerCase()}),Qh=Ju(function(n,t,r){return n+(r?" ":"")+np(t)}),Xh=Ju(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),np=Hu("toUpperCase"),tp=iu(function(n,t){try{return r(n,X,t)}catch(n){return ua(n)?n:new cl(n)}}),rp=bi(function(n,t){return u(t,function(t){t=ro(t),Tr(n,t,lh(n[t],n))}),n}),ep=ni(),up=ni(!0),ip=iu(function(n,t){return function(r){return Re(r,n,t)}}),op=iu(function(n,t){return function(r){return Re(n,r,t)}}),fp=ui(l),ap=ui(o),cp=ui(v),lp=fi(),sp=fi(!0),hp=ei(function(n,t){return n+t},0),pp=li("ceil"),vp=ei(function(n,t){return n/t},1),_p=li("floor"),gp=ei(function(n,t){return n*t},1),yp=li("round"),dp=ei(function(n,t){return n-t},0);return K.after=zf,K.ary=Ef,K.assign=Sh,K.assignIn=Wh,K.assignInWith=Lh,K.assignWith=Ch,K.at=Uh,K.before=Sf,K.bind=lh,K.bindAll=rp,K.bindKey=sh,K.castArray=qf,K.chain=nf,K.chunk=oo,K.compact=fo,K.concat=ao,K.cond=Sc,K.conforms=Wc,K.constant=Lc,K.countBy=th,K.create=La,K.curry=Wf,K.curryRight=Lf,K.debounce=Cf,K.defaults=Bh,K.defaultsDeep=Th,K.defer=hh,K.delay=ph,K.difference=Ts,K.differenceBy=$s,K.differenceWith=Ds,K.drop=co,
K.dropRight=lo,K.dropRightWhile=so,K.dropWhile=ho,K.fill=po,K.filter=hf,K.flatMap=pf,K.flatMapDeep=vf,K.flatMapDepth=_f,K.flatten=go,K.flattenDeep=yo,K.flattenDepth=bo,K.flip=Uf,K.flow=ep,K.flowRight=up,K.fromPairs=wo,K.functions=Ma,K.functionsIn=Fa,K.groupBy=uh,K.initial=jo,K.intersection=Ms,K.intersectionBy=Fs,K.intersectionWith=Ns,K.invert=$h,K.invertBy=Dh,K.invokeMap=ih,K.iteratee=Bc,K.keyBy=oh,K.keys=Za,K.keysIn=Ka,K.map=bf,K.mapKeys=Va,K.mapValues=Ga,K.matches=Tc,K.matchesProperty=$c,K.memoize=Bf,K.merge=Fh,K.mergeWith=Nh,K.method=ip,K.methodOf=op,K.mixin=Dc,K.negate=Tf,K.nthArg=Nc,K.omit=Ph,K.omitBy=Ha,K.once=$f,K.orderBy=wf,K.over=fp,K.overArgs=vh,K.overEvery=ap,K.overSome=cp,K.partial=_h,K.partialRight=gh,K.partition=fh,K.pick=qh,K.pickBy=Ja,K.property=Pc,K.propertyOf=qc,K.pull=Ps,K.pullAll=Ro,K.pullAllBy=zo,K.pullAllWith=Eo,K.pullAt=qs,K.range=lp,K.rangeRight=sp,K.rearg=yh,K.reject=jf,K.remove=So,K.rest=Df,K.reverse=Wo,K.sampleSize=kf,K.set=Qa,K.setWith=Xa,K.shuffle=Of,K.slice=Lo,K.sortBy=ah,K.sortedUniq=Mo,K.sortedUniqBy=Fo,K.split=wc,K.spread=Mf,K.tail=No,K.take=Po,K.takeRight=qo,K.takeRightWhile=Zo,K.takeWhile=Ko,K.tap=tf,K.throttle=Ff,K.thru=rf,K.toArray=ka,K.toPairs=Zh,K.toPairsIn=Kh,K.toPath=Yc,K.toPlainObject=Ea,K.transform=nc,K.unary=Nf,K.union=Zs,K.unionBy=Ks,K.unionWith=Vs,K.uniq=Vo,K.uniqBy=Go,K.uniqWith=Ho,K.unset=tc,K.unzip=Jo,K.unzipWith=Yo,K.update=rc,K.updateWith=ec,K.values=uc,K.valuesIn=ic,K.without=Gs,K.words=Ec,K.wrap=Pf,K.xor=Hs,K.xorBy=Js,K.xorWith=Ys,K.zip=Qs,K.zipObject=Qo,K.zipObjectDeep=Xo,K.zipWith=Xs,K.entries=Zh,K.entriesIn=Kh,K.extend=Wh,K.extendWith=Lh,Dc(K,K),K.add=hp,K.attempt=tp,K.camelCase=Vh,K.capitalize=cc,K.ceil=pp,K.clamp=oc,K.clone=Zf,K.cloneDeep=Vf,K.cloneDeepWith=Gf,K.cloneWith=Kf,K.conformsTo=Hf,K.deburr=lc,K.defaultTo=Cc,K.divide=vp,K.endsWith=sc,K.eq=Jf,K.escape=hc,K.escapeRegExp=pc,K.every=sf,K.find=rh,K.findIndex=vo,K.findKey=Ca,K.findLast=eh,K.findLastIndex=_o,K.findLastKey=Ua,K.floor=_p,K.forEach=gf,K.forEachRight=yf,K.forIn=Ba,K.forInRight=Ta,K.forOwn=$a,K.forOwnRight=Da,K.get=Na,K.gt=dh,K.gte=bh,K.has=Pa,K.hasIn=qa,K.head=mo,K.identity=Uc,K.includes=df,K.indexOf=xo,K.inRange=fc,K.invoke=Mh,K.isArguments=wh,K.isArray=mh,K.isArrayBuffer=xh,K.isArrayLike=Yf,K.isArrayLikeObject=Qf,K.isBoolean=Xf,K.isBuffer=jh,K.isDate=Ah,K.isElement=na,K.isEmpty=ta,K.isEqual=ra,K.isEqualWith=ea,K.isError=ua,K.isFinite=ia,K.isFunction=oa,K.isInteger=fa,K.isLength=aa,K.isMap=kh,K.isMatch=sa,K.isMatchWith=ha,K.isNaN=pa,K.isNative=va,K.isNil=ga,K.isNull=_a,K.isNumber=ya,K.isObject=ca,K.isObjectLike=la,K.isPlainObject=da,K.isRegExp=Oh,K.isSafeInteger=ba,K.isSet=Ih,K.isString=wa,K.isSymbol=ma,K.isTypedArray=Rh,K.isUndefined=xa,K.isWeakMap=ja,K.isWeakSet=Aa,K.join=Ao,K.kebabCase=Gh,K.last=ko,K.lastIndexOf=Oo,K.lowerCase=Hh,K.lowerFirst=Jh,K.lt=zh,K.lte=Eh,K.max=Xc,K.maxBy=nl,K.mean=tl,K.meanBy=rl,K.min=el,K.minBy=ul,K.stubArray=Zc,K.stubFalse=Kc,K.stubObject=Vc,K.stubString=Gc,K.stubTrue=Hc,K.multiply=gp,K.nth=Io,K.noConflict=Mc,K.noop=Fc,K.now=ch,K.pad=vc,K.padEnd=_c,K.padStart=gc,K.parseInt=yc,K.random=ac,K.reduce=mf,K.reduceRight=xf,K.repeat=dc,K.replace=bc,K.result=Ya,K.round=yp,K.runInContext=_,K.sample=Af,K.size=If,K.snakeCase=Yh,K.some=Rf,K.sortedIndex=Co,K.sortedIndexBy=Uo,K.sortedIndexOf=Bo,K.sortedLastIndex=To,K.sortedLastIndexBy=$o,K.sortedLastIndexOf=Do,K.startCase=Qh,K.startsWith=mc,K.subtract=dp,K.sum=il,K.sumBy=ol,K.template=xc,K.times=Jc,K.toFinite=Oa,K.toInteger=Ia,K.toLength=Ra,K.toLower=jc,K.toNumber=za,K.toSafeInteger=Sa,K.toString=Wa,K.toUpper=Ac,K.trim=kc,K.trimEnd=Oc,K.trimStart=Ic,K.truncate=Rc,K.unescape=zc,K.uniqueId=Qc,K.upperCase=Xh,K.upperFirst=np,K.each=gf,K.eachRight=yf,K.first=mo,Dc(K,function(){var n={};return oe(K,function(t,r){ml.call(K.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),K.VERSION=nn,u(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){K[n].placeholder=K}),u(["drop","take"],function(n,t){Dt.prototype[n]=function(r){r=r===X?1:Jl(Ia(r),0);var e=this.__filtered__&&!t?new Dt(this):this.clone();return e.__filtered__?e.__takeCount__=Yl(r,e.__takeCount__):e.__views__.push({size:Yl(r,Cn),type:n+(e.__dir__<0?"Right":"")}),e},Dt.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=r==In||r==zn;Dt.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:Ai(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Dt.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Dt.prototype[n]=function(){return this.__filtered__?new Dt(this):this[r](1)}}),Dt.prototype.compact=function(){return this.filter(Uc)},Dt.prototype.find=function(n){return this.filter(n).head()},Dt.prototype.findLast=function(n){return this.reverse().find(n)},Dt.prototype.invokeMap=iu(function(n,t){return"function"==typeof n?new Dt(this):this.map(function(r){return Re(r,n,t)})}),Dt.prototype.reject=function(n){return this.filter(Tf(Ai(n)))},Dt.prototype.slice=function(n,t){n=Ia(n);var r=this;return r.__filtered__&&(n>0||t<0)?new Dt(r):(n<0?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==X&&(t=Ia(t),r=t<0?r.dropRight(-t):r.take(t-n)),r)},Dt.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Dt.prototype.toArray=function(){return this.take(Cn)},oe(Dt.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=K[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(K.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Dt,a=o[0],c=f||mh(t),l=function(n){var t=u.apply(K,s([n],o));return e&&h?t[0]:t};c&&r&&"function"==typeof a&&1!=a.length&&(f=c=!1);var h=this.__chain__,p=!!this.__actions__.length,v=i&&!h,_=f&&!p;if(!i&&c){t=_?t:new Dt(this);var g=n.apply(t,o);return g.__actions__.push({func:rf,args:[l],thisArg:X}),new Y(g,h)}return v&&_?n.apply(this,o):(g=this.thru(l),v?e?g.value()[0]:g.value():g)})}),u(["pop","push","shift","sort","splice","unshift"],function(n){var t=gl[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);K.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(mh(u)?u:[],n)}return this[r](function(r){return t.apply(mh(r)?r:[],n)})}}),oe(Dt.prototype,function(n,t){var r=K[t];if(r){var e=r.name+"",u=cs[e]||(cs[e]=[]);u.push({name:t,func:r})}}),cs[ti(X,vn).name]=[{name:"wrapper",func:X}],Dt.prototype.clone=Yt,Dt.prototype.reverse=Qt,Dt.prototype.value=Xt,K.prototype.at=nh,K.prototype.chain=ef,K.prototype.commit=uf,K.prototype.next=of,K.prototype.plant=af,K.prototype.reverse=cf,K.prototype.toJSON=K.prototype.valueOf=K.prototype.value=lf,K.prototype.first=K.prototype.head,Tl&&(K.prototype[Tl]=ff),K},be=de();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(re._=be,define(function(){return be})):ue?((ue.exports=be)._=be,ee._=be):re._=be}).call(this);
</script>
<script type="text/javascript">
var saveAs=saveAs||"undefined"!=typeof navigator&&navigator.msSaveOrOpenBlob&&navigator.msSaveOrOpenBlob.bind(navigator)||function(e){"use strict";if("undefined"==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)){var t=e.document,n=function(){return e.URL||e.webkitURL||e},o=t.createElementNS("http://www.w3.org/1999/xhtml","a"),r=!e.externalHost&&"download"in o,i=function(n){var o=t.createEvent("MouseEvents");o.initMouseEvent("click",!0,!1,e,0,0,0,0,0,!1,!1,!1,!1,0,null),n.dispatchEvent(o)},a=e.webkitRequestFileSystem,u=e.requestFileSystem||a||e.mozRequestFileSystem,c=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},d="application/octet-stream",f=0,s=[],l=function(){for(var e=s.length;e--;){var t=s[e];"string"==typeof t?n().revokeObjectURL(t):t.remove()}s.length=0},v=function(e,t,n){t=[].concat(t);for(var o=t.length;o--;){var r=e["on"+t[o]];if("function"==typeof r)try{r.call(e,n||e)}catch(e){c(e)}}},w=function(t,c){var l,w,p,y=this,m=t.type,h=!1,E=function(){var e=n().createObjectURL(t);return s.push(e),e},g=function(){v(y,"writestart progress write writeend".split(" "))},O=function(){!h&&l||(l=E(t)),w?w.location.href=l:window.open(l,"_blank"),y.readyState=y.DONE,g()},S=function(e){return function(){if(y.readyState!==y.DONE)return e.apply(this,arguments)}},R={create:!0,exclusive:!1};return y.readyState=y.INIT,c||(c="download"),r?(l=E(t),o.href=l,o.download=c,i(o),y.readyState=y.DONE,void g()):(e.chrome&&m&&m!==d&&(p=t.slice||t.webkitSlice,t=p.call(t,0,t.size,d),h=!0),a&&"download"!==c&&(c+=".download"),(m===d||a)&&(w=e),u?(f+=t.size,void u(e.TEMPORARY,f,S(function(e){e.root.getDirectory("saved",R,S(function(e){var n=function(){e.getFile(c,R,S(function(e){e.createWriter(S(function(n){n.onwriteend=function(t){w.location.href=e.toURL(),s.push(e),y.readyState=y.DONE,v(y,"writeend",t)},n.onerror=function(){var e=n.error;e.code!==e.ABORT_ERR&&O()},"writestart progress write abort".split(" ").forEach(function(e){n["on"+e]=y["on"+e]}),n.write(t),y.abort=function(){n.abort(),y.readyState=y.DONE},y.readyState=y.WRITING}),O)}),O)};e.getFile(c,{create:!1},S(function(e){e.remove(),n()}),S(function(e){e.code===e.NOT_FOUND_ERR?n():O()}))}),O)}),O)):void O())},p=w.prototype,y=function(e,t){return new w(e,t)};return p.abort=function(){var e=this;e.readyState=e.DONE,v(e,"abort")},p.readyState=p.INIT=0,p.WRITING=1,p.DONE=2,p.error=p.onwritestart=p.onprogress=p.onwrite=p.onabort=p.onerror=p.onwriteend=null,e.addEventListener("unload",l,!1),y.unload=function(){l(),e.removeEventListener("unload",l,!1)},y}}("undefined"!=typeof self&&self||"undefined"!=typeof window&&window||this.content);"undefined"!=typeof module&&null!==module?module.exports=saveAs:"undefined"!=typeof define&&null!==define&&null!=define.amd&&define([],function(){return saveAs});
</script>
<script type="text/javascript">
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.himalaya=t()}}(function(){return function t(e,r,n){function a(s,i){if(!r[s]){if(!e[s]){var u="function"==typeof require&&require;if(!i&&u)return u(s,!0);if(o)return o(s,!0);var c=new Error("Cannot find module '"+s+"'");throw c.code="MODULE_NOT_FOUND",c}var f=r[s]={exports:{}};e[s][0].call(f.exports,function(t){var r=e[s][1][t];return a(r?r:t)},f,f.exports,t,e,r,n)}return r[s].exports}for(var o="function"==typeof require&&require,s=0;s<n.length;s++)a(n[s]);return a}({1:[function(t,e,r){"use strict";function n(t,e,r){return t.substr(r||0,e.length)===e}function a(t,e,r){var n=(r||t.length)-e.length,a=t.lastIndexOf(e,n);return a!==-1&&a===n}function o(t,e,r){return t.indexOf(e,r||0)!==-1}function s(t){return"number"==typeof t&&isNaN(t)}function i(t,e,r){var n=t.length;if(0===n)return!1;for(var a=0|r,o=s(e),i=a>=0?a:n+a;i<n;){var u=t[i++];if(u===e)return!0;if(o&&s(u))return!0}return!1}Object.defineProperty(r,"__esModule",{value:!0}),r.startsWith=n,r.endsWith=a,r.stringIncludes=o,r.isRealNaN=s,r.arrayIncludes=i},{}],2:[function(t,e,r){"use strict";function n(t){return t.map(function(t){var e=a(t.type);if("Element"===e){var r=t.tagName.toLowerCase(),o=c(t.attributes),s=n(t.children);return{type:e,tagName:r,attributes:o,children:s}}return{type:e,content:t.content}})}function a(t){return t.charAt(0).toUpperCase()+t.slice(1)}function o(t){return t.split("-").reduce(function(t,e){return t+e.charAt(0).toUpperCase()+e.slice(1)})}function s(t){if("string"!=typeof t)return t;if(""===t)return t;var e=+t;return isNaN(e)?t:e}function i(t){var e=t.charAt(0),r=t.length-1;return'"'===e||"'"===e&&e===t.charAt(r)?t.slice(1,r):t}function u(t,e){var r=t.indexOf(e);return r===-1?[t]:[t.slice(0,r),t.slice(r+e.length)]}function c(t){return t.reduce(function(t,e){var r=u(e.trim(),"="),n=l(r,2),a=n[0],c=n[1];if(c=c?i(c):a,"class"===a)t.className=c.split(" ");else if("style"===a)t.style=f(c);else if((0,p.startsWith)(a,"data-")){t.dataset=t.dataset||{};var v=o(a.slice(5));t.dataset[v]=s(c)}else t[o(a)]=s(c);return t},{})}function f(t){return t.trim().split(";").map(function(t){return t.trim().split(":")}).reduce(function(t,e){var r=l(e,2),n=r[0],a=r[1];if(a){var i=o(n.trim()),u=s(a.trim());t[i]=u}return t},{})}Object.defineProperty(r,"__esModule",{value:!0});var l=function(){function t(t,e){var r=[],n=!0,a=!1,o=void 0;try{for(var s,i=t[Symbol.iterator]();!(n=(s=i.next()).done)&&(r.push(s.value),!e||r.length!==e);n=!0);}catch(t){a=!0,o=t}finally{try{!n&&i.return&&i.return()}finally{if(a)throw o}}return r}return function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();r.default=n,r.capitialize=a,r.camelCase=o,r.castValue=s,r.unquote=i,r.splitHead=u,r.formatAttributes=c,r.formatStyles=f;var p=t("../compat")},{"../compat":1}],3:[function(t,e,r){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function a(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d,r=(0,s.default)(t,e),n=(0,u.default)(r,e);return(0,f.default)(n,e)}Object.defineProperty(r,"__esModule",{value:!0}),r.parseDefaults=void 0,r.parse=a;var o=t("./lexer"),s=n(o),i=t("./parser"),u=n(i),c=t("./formats/v0"),f=n(c),l=["style","script","template"],p=["html","head","body","p","dt","dd","li","option","thead","th","tbody","tr","td","tfoot","colgroup"],v=["!doctype","area","base","br","col","command","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"],d=r.parseDefaults={voidTags:v,closingTags:p,childlessTags:l,format:f.default};r.default={parse:a,parseDefaults:d}},{"./formats/v0":2,"./lexer":4,"./parser":5}],4:[function(t,e,r){"use strict";function n(t){if(Array.isArray(t)){for(var e=0,r=Array(t.length);e<t.length;e++)r[e]=t[e];return r}return Array.from(t)}function a(t,e){var r={str:t,options:e,cursor:0,tokens:[]};return o(r),r.tokens}function o(t){for(var e=t.str,r=e.length;t.cursor<r;){var n="<"!==e.charAt(t.cursor);if(n)s(t);else{var a=(0,p.startsWith)(e,"!--",t.cursor+1);if(a)i(t);else{var o=u(t);if(o){var c=o.toLowerCase(),f=t.options.childlessTags;(0,p.arrayIncludes)(f,c)&&l(o,t)}}}}}function s(t){var e=t.str,r=t.cursor,n=e.indexOf("<",r),a="text";if(n===-1){var o=e.slice(r);return t.cursor=e.length,void t.tokens.push({type:a,content:o})}if(n!==r){var s=e.slice(r,n);t.cursor=n,t.tokens.push({type:a,content:s})}}function i(t){t.cursor+=4;var e=t.str,r=t.cursor,n=e.indexOf("--\x3e",r),a="comment";if(n===-1){var o=e.slice(r);return t.cursor=e.length,void t.tokens.push({type:a,content:o})}var s=e.slice(r,n);t.cursor=n+3,t.tokens.push({type:a,content:s})}function u(t){var e=t.str,r=e.charAt(t.cursor+1),n="/"===r;t.tokens.push({type:"tag-start",close:n}),t.cursor+=n?2:1;var a=c(t);f(t);var o=e.charAt(t.cursor),s="/"===o;return t.tokens.push({type:"tag-end",close:s}),t.cursor+=s?2:1,a}function c(t){for(var e=t.str,r=t.cursor,n=e.length,a=r;a<n;){var o=e.charAt(a),s=!(" "===o||"/"===o||">"===o);if(s)break;a++}for(var i=a+1;i<n;){var u=e.charAt(i),c=!(" "===u||"/"===u||">"===u);if(!c)break;i++}t.cursor=i;var f=e.slice(a,i);return t.tokens.push({type:"tag",content:f}),f}function f(t){for(var e=t.str,r=t.tokens,n=t.cursor,a=null,o=n,s=[],i=e.length;n<i;){var u=e.charAt(n);if(a){var c=u===a;c&&(a=null),n++}else{var f="/"===u||">"===u;if(f){n!==o&&s.push(e.slice(o,n));break}var l=" "===u;if(l)n!==o&&s.push(e.slice(o,n)),o=n+1,n++;else{var v="'"===u||'"'===u;v?(a=u,n++):n++}}}t.cursor=n;for(var d=s.length,h="attribute",y=0;y<d;y++){var g=s[y];if(g&&g.length){var m=g.indexOf("=")===-1;if(m){var b=s[y+1];if(b&&(0,p.startsWith)(b,"=")){if(b.length>1){var k=g+b;r.push({type:h,content:k}),y+=1;continue}var x=s[y+2];if(y+=1,x){var A=g+"="+x;r.push({type:h,content:A}),y+=1;continue}}}if((0,p.endsWith)(g,"=")){var N=s[y+1];if(N&&!(0,p.stringIncludes)(N,"=")){var O=g+N;r.push({type:h,content:O}),y+=1;continue}var w=g.slice(0,-1);r.push({type:h,content:w})}else r.push({type:h,content:g})}}}function l(t,e){for(var r=e.str,a=e.cursor,o=e.tokens,i=r.length,u=a;u<i;){var l=r.indexOf("</",u);if(l===-1){s(e);break}var p={str:r,cursor:l+2,tokens:[]},v=c(p),d=t.toLowerCase();if(d===v.toLowerCase()){var h=r.slice(a,l);o.push({type:"text",content:h});var y={type:"tag-start",close:!0},g={type:"tag-end",close:!1};f(p),o.push.apply(o,[y].concat(n(p.tokens),[g])),e.cursor=p.cursor+1;break}u=p.cursor}}Object.defineProperty(r,"__esModule",{value:!0}),r.default=a,r.lex=o,r.lexText=s,r.lexComment=i,r.lexTag=u,r.lexTagName=c,r.lexTagAttributes=f,r.lexSkipTag=l;var p=t("./compat")},{"./compat":1}],5:[function(t,e,r){"use strict";function n(t,e){var r={tagName:null,children:[]},n={tokens:t,options:e,cursor:0,stack:[r]};return a(n),r.children}function a(t){for(var e=t.tokens,r=t.options,n=t.stack,s=n[n.length-1].children,i=e.length,u=t.cursor;u<i;){var c=e[u];if("tag-start"===c.type){var f=e[++u];u++;var l=f.content.toLowerCase();if(c.close){for(var p=void 0;(p=n.pop())&&l!==p.tagName;);for(;u<i;){var v=e[u];if("tag-end"!==v.type)break;u++}break}if((0,o.arrayIncludes)(r.closingTags,l))for(var d=n.length-1;d>0;){if(l===n[d].tagName){n=n.slice(0,d);var h=d-1;s=n[h].children;break}d-=1}for(var y=[],g=void 0;u<i&&(g=e[u],"tag-end"!==g.type);)y.push(g.content),u++;u++;var m=[];s.push({type:"element",tagName:f.content,attributes:y,children:m});var b=!(g.close||(0,o.arrayIncludes)(r.voidTags,l));if(b){n.push({tagName:l,children:m});var k={tokens:e,options:r,cursor:u,stack:n};a(k),u=k.cursor}}else s.push(c),u++}t.cursor=u}Object.defineProperty(r,"__esModule",{value:!0}),r.default=n,r.parse=a;var o=t("./compat")},{"./compat":1}]},{},[3])(3)});
</script>
<script type="text/javascript">
!function(){"use strict";window.assertions=window.assertions||{},window.assertions.assertFunction=window.assertions.assertFunction||function(o,n){if(!o){if(window.navigator&&"Microsoft Internet Explorer"===window.navigator.appName)try{throw new Error}catch(o){n=n+", stack=\n"+o.stack}throw console&&console.log&&console.log("Assertion failed: "+n),new Error("Assertion failed: "+n)}},window.assert=window.assert||null,window.assertSlow=window.assertSlow||null,window.assertions.enableAssert=function(){window.assert=window.assertions.assertFunction,window.console&&window.console.log&&window.console.log("enabling assert")},window.assertions.disableAssert=function(){window.assert=null,window.console&&window.console.log&&window.console.log("disabling assert")},window.assertions.enableAssertSlow=function(){window.assertSlow=window.assertions.assertFunction,window.console&&window.console.log&&window.console.log("enabling assertSlow")},window.assertions.disableAssertSlow=function(){window.assertSlow=null,window.console&&window.console.log&&window.console.log("disabling assertSlow")}}();
</script>
<script type="text/javascript">
!function(e,a){"use strict";"function"==typeof define&&define.amd?define([],a):"object"==typeof module&&module.exports?module.exports=a():e.QueryStringMachine=a()}(this,function(){"use strict";var e=",";return function(){var a={get:function(e,a){return this.getForString(e,a,window.location.search)},getAll:function(e){return this.getAllForString(e,window.location.search)},getForString:function(e,a,n){if(0!==n.length&&0!==n.indexOf("?"))throw new Error('Query strings should be either the empty string or start with a "?": '+n);r(e,a);var i=c(e,a,t(e,n));return l(e,a,i),i},getAllForString:function(e,a){var t={};for(var r in e)e.hasOwnProperty(r)&&(t[r]=this.getForString(r,e[r],a));return t},containsKey:function(e){return this.containsKeyForString(window.location.search,e)},containsKeyForString:function(e,a){var r=t(a,e);return r.length>0},deepEquals:function(e,t){if(typeof e!=typeof t)return!1;if("string"==typeof e)return e===t;if(null===e&&null===t)return!0;if(void 0===e&&void 0===t)return!0;if(null===e&&void 0===t)return!1;if(void 0===e&&null===t)return!1;var r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return!1;if(0===r.length)return e===t;for(var i=0;i<r.length;i++){if(r[i]!==n[i])return!1;var l=e[r[i]],u=t[r[i]];if(!a.deepEquals(l,u))return!1}return!0}},t=function(e,a){for(var t=[],r=a.slice(1).split("&"),n=0;n<r.length;n++){var i=r[n].split("=");i[0]===e&&(i[1]?t.push(decodeURIComponent(i[1])):t.push(null))}return t},r=function(e,a){O(a.hasOwnProperty("type"),e,"type field is required"),O(b.hasOwnProperty(a.type),e,"invalid type: "+a.type),a.hasOwnProperty("parse")&&O("function"==typeof a.parse,e,"parse must be a function"),O(!(a.hasOwnProperty("validValues")&&a.hasOwnProperty("isValidValue")),e,"validValues and isValidValue are mutually exclusive"),a.hasOwnProperty("validValues")&&O(a.validValues instanceof Array,e,"isValidValue must be a function"),a.hasOwnProperty("isValidValue")&&O("function"==typeof a.isValidValue,e,"isValidValue must be a function"),a.hasOwnProperty("defaultValue")&&b[a.type].validateValue(e,a,a.defaultValue),a.hasOwnProperty("validValues")&&a.validValues.forEach(function(t){b[a.type].validateValue(e,a,t)}),a.hasOwnProperty("defaultValue")&&a.hasOwnProperty("validValues")&&O(w(a.defaultValue,a.validValues),e,"defaultValue must be a member of validValues"),i(e,a,b[a.type].required,b[a.type].optional),b[a.type].validateSchema&&b[a.type].validateSchema(e,a)},n=function(e,a){a.hasOwnProperty("separator")&&O("string"==typeof a.separator&&1===a.separator.length,e,"invalid separator: "+a.separator),r(e+".element",a.elementSchema)},i=function(e,a,t,r){var n=Object.getOwnPropertyNames(a);t.forEach(function(a){O(n.indexOf(a)!==-1,e,"missing required property: "+a)});var i=t.concat(r);n.forEach(function(a){O("type"===a||i.indexOf(a)!==-1,e,"unsupported property: "+a)})},l=function(e,a,t){a.hasOwnProperty("validValues")&&O(w(t,a.validValues),e,"value must be a member of validValues: "+t),a.hasOwnProperty("isValidValue")&&O(a.isValidValue(t),e,"invalid value: "+t),b[a.type].validateValue(e,a,t)},u=function(e,a,t){return o(e,a,t)},o=function(e,a,t){O(t===!0||t===!1,e,"invalid value: "+t)},s=function(e,a,t){O("number"==typeof t&&!isNaN(t),e,"invalid value: "+t)},d=function(e,a,t){O(null===t||"string"==typeof t,e,"invalid value: "+t)},f=function(e,a,t){O(t instanceof Array||null===t,e,"invalid value: "+t)},p=function(e,a,t){},c=function(e,a,t){var r;return O(t.length<=1,e,"query parameter cannot occur multiple times"),"flag"===a.type?r=v(e,a,t[0]):(O(void 0!==t[0]||a.hasOwnProperty("defaultValue"),e,"missing required query parameter"),r=void 0===t[0]?a.defaultValue:b[a.type].parse(e,a,t[0])),r},v=function(e,a,t){return O(void 0===t||null===t,e,"flag type does not support a value: "+t),void 0!==t},V=function(e,a,t){return O("true"===t||"false"===t,e,"invalid value: "+t),"true"===t},y=function(e,a,t){var r=Number(t);return O(!isNaN(r),e,"value must be a number: "+t),r},h=function(e,a,t){return t},m=function(a,t,r){var n;return n=null===r?[]:r.split(t.separator||e).map(function(e){return c(a,t.elementSchema,[e])})},g=function(e,a,t){return a.parse(t)},w=function(e,t){for(var r=!1,n=0;n<t.length&&!r;n++)r=a.deepEquals(t[n],e);return r},O=function(e,a,t){if(!e)throw console&&console.log&&console.log(S(a,t)),new Error("Assertion failed: "+t)},S=function(e,a){return'Error for query parameter "'+e+'": '+a},b={flag:{required:[],optional:[],validateSchema:null,parse:v,validateValue:u},boolean:{required:[],optional:["defaultValue"],validateSchema:null,parse:V,validateValue:o},number:{required:[],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:y,validateValue:s},string:{required:[],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:h,validateValue:d},array:{required:["elementSchema"],optional:["defaultValue","validValues","isValidValue","separator","validValues"],validateSchema:n,parse:m,validateValue:f},custom:{required:["parse"],optional:["defaultValue","validValues","isValidValue"],validateSchema:null,parse:g,validateValue:p}};return a}()});
</script>
<script type="text/javascript">
!function(){"use strict";var e={accessibility:{type:"flag"},allowLinks:{type:"boolean",defaultValue:!0},audioVolume:{type:"number",defaultValue:1,isValidValue:function(e){return e>=0}},brand:{type:"string",defaultValue:"adapted-from-phet",validValues:["phet","phet-io","adapted-from-phet"]},buildCompatible:{type:"flag"},cacheBuster:{type:"boolean",defaultValue:!0},colorProfile:{type:"string",defaultValue:"default"},dev:{type:"flag"},ea:{type:"flag"},eall:{type:"flag"},fuzzMouse:{type:"flag"},fuzzRate:{type:"number",defaultValue:100,isValidValue:function(e){return e>0}},"phet-app":{type:"flag"},"phet-android-app":{type:"flag"},ga:{type:"string",defaultValue:null},ga4:{type:"string",defaultValue:null},gameUp:{type:"flag"},gameUpLogging:{type:"flag"},gaPage:{type:"string",defaultValue:null},homeScreen:{type:"boolean",defaultValue:!0},initialScreen:{type:"number",defaultValue:0},legendsOfLearning:{type:"flag"},locale:{type:"string",defaultValue:"en"},playbackInputEventLog:{type:"flag"},postMessageOnBeforeUnload:{type:"flag"},postMessageOnError:{type:"flag"},postMessageOnLoad:{type:"flag"},profiler:{type:"flag"},qrCode:{type:"flag"},recordInputEventLog:{type:"flag"},rootRenderer:{type:"string",defaultValue:null,validValues:[null,"canvas","svg","dom","webgl"]},sceneryLog:{type:"array",elementSchema:{type:"string"},defaultValue:null},sceneryStringLog:{type:"flag"},screenIndex:{type:"number",defaultValue:1},screens:{type:"array",elementSchema:{type:"number"},defaultValue:null},showCanvasNodeBounds:{type:"flag"},showFittedBlockBounds:{type:"flag"},showHomeScreen:{type:"boolean",defaultValue:!0},showPointerAreas:{type:"flag"},showPointers:{type:"flag"},showVisibleBounds:{type:"flag"},strings:{type:"string",defaultValue:null},stringTest:{type:"string",defaultValue:null},webgl:{type:"boolean",defaultValue:!0},yotta:{type:"boolean",defaultValue:!0}};!function(){window.phet=window.phet||{},window.phet.chipper=window.phet.chipper||{},window.phet.chipper.queryParameters=QueryStringMachine.getAll(e),window.phet.chipper.getCacheBusterArgs=function(){return phet.chipper.queryParameters.cacheBuster?"bust="+Date.now():""},window.phet.chipper.brand=window.phet.chipper.brand||phet.chipper.queryParameters.brand||"adapted-from-phet",window.phet.chipper.mapString=function(e,a){return null===a?e:"double"===a?e+":"+e:"long"===a?"12345678901234567890123456789012345678901234567890":"rtl"===a?"‫تست (زبان)‬":"xss"===a?e+'<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />':"none"===a?e:a},phet.chipper.checkAndRemapLocale=function(){if(phet.chipper.localeData&&phet.chipper.locale){var e=phet.chipper.locale;if(e){if(e.length<5)e=e.toLowerCase();else{e=e.replace(/-/,"_");var a=e.split("_");2===a.length&&(e=a[0].toLowerCase()+"_"+a[1].toUpperCase())}if(3===e.length)for(var t=Object.keys(phet.chipper.localeData),l=0;l<t.length;l++){var r=t[l];if(phet.chipper.localeData[r].locale3===e){e=r;break}}}phet.chipper.localeData[e]||(e="en"),phet.chipper.locale=e,document.documentElement.lang=phet.chipper.localeData[e].bcp47}},QueryStringMachine.containsKey("locale")&&(phet.chipper.locale=phet.chipper.queryParameters.locale,phet.chipper.checkAndRemapLocale())}(),window.phet.chipper.randomSeed=Math.random(),function(){var e="production"===$("meta[name=phet-sim-level]").attr("content"),a=!e&&phet.chipper.queryParameters.eall,t=a||!e&&phet.chipper.queryParameters.ea;t&&window.assertions.enableAssert(),a&&window.assertions.enableAssertSlow(),phet.chipper.queryParameters.postMessageOnError&&window.addEventListener("error",function(e,a,t,l,r){var p="",n="";e&&e.message&&(p=e.message),e&&e.error&&e.error.stack&&(n=e.error.stack),window.parent&&window.parent.postMessage(JSON.stringify({type:"error",url:window.location.href,message:p,stack:n}),"*")}),phet.chipper.queryParameters.postMessageOnBeforeUnload&&window.addEventListener("beforeunload",function(e){window.parent&&window.parent.postMessage(JSON.stringify({type:"beforeUnload"}),"*")})}()}();
</script>
<script type="text/javascript">
!function(e,t){"use strict";"function"==typeof define&&define.amd?define([],t):"object"==typeof module&&module.exports?module.exports=t():e.getVersionForBrand=t()}(this,function(){"use strict";return function(e,t){if("phet-io"===e){var n=t.indexOf("-");return n>=0?t.substring(0,n+1)+"phetio"+t.substring(n+1):t+"-phetio"}return t}});
</script>
<script type="text/javascript">
!function(){"use strict";function e(){function e(e){var t=document.createElement("img");t.src=e}function t(){ga4DataLayer.push(arguments)}function a(){window.dataLayer.push(arguments)}var o=!1;window.addEventListener("error",function(e){e&&e.target&&e.target.src&&e.target.src.indexOf&&e.target.src.indexOf("google-analytics")>=0&&(o=!0)},!0);var r="pingver=3&project="+encodeURIComponent(phet.chipper.project)+"&brand="+encodeURIComponent(phet.chipper.brand)+"&version="+encodeURIComponent(phet.chipper.version)+"&locale="+encodeURIComponent(phet.chipper.locale)+"&buildTimestamp="+encodeURIComponent(phet.chipper.buildTimestamp)+"&domain="+encodeURIComponent(document.domain)+"&href="+encodeURIComponent(window.location.href)+"&type=html&timestamp="+encodeURIComponent(Date.now())+"&loadType="+encodeURIComponent(n)+"&ref="+encodeURIComponent(document.referrer);if(new URLSearchParams(window.location.search).forEach(function(e,t){t.startsWith("yotta")&&(r+="&"+encodeURIComponent(t)+"="+encodeURIComponent(e))}),e("https://phet.colorado.edu/yotta/immediate.gif?"+r),window.addEventListener("load",function(t){e("https://phet.colorado.edu/yotta/sanity.gif?"+r+"&gaError="+encodeURIComponent(o)+"&gaLoaded="+encodeURIComponent(!1))},!1),phet.chipper.queryParameters.ga4){window.ga4DataLayer=window.ga4DataLayer||[],t("js",new Date),t("consent","default",{ad_storage:"denied",analytics_storage:"granted"}),t("consent","default",{ad_storage:"denied",analytics_storage:"denied",region:["BE","BG","CZ","DK","CY","LV","LT","LU","ES","FR","HR","IT","PL","PT","RO","SI","HU","MT","NL","AT","IS","LI","NO","SK","FI","SE","DE","EE","IE","EL","GB","CH"]}),t("config",phet.chipper.queryParameters.ga4);var p=document.getElementsByTagName("script")[0],i=document.createElement("script");i.async=!0,i.src="https://www.googletagmanager.com/gtag/js?id="+phet.chipper.queryParameters.ga4+"&l=ga4DataLayer",p.parentNode.insertBefore(i,p)}window.dataLayer=window.dataLayer||[],a("consent","default",{ad_storage:"denied",analytics_storage:"granted"}),a("consent","default",{ad_storage:"denied",analytics_storage:"denied",region:["BE","BG","CZ","DK","CY","LV","LT","LU","ES","FR","HR","IT","PL","PT","RO","SI","HU","MT","NL","AT","IS","LI","NO","SK","FI","SE","DE","EE","IE","EL","GB","CH"]}),window.dataLayer.push({simBrand:phet.chipper.brand,simName:phet.chipper.project,simVersion:phet.chipper.version,simLocale:phet.chipper.locale,simBuildTimestamp:phet.chipper.buildTimestamp,simLoadType:n,documentReferrer:document.referrer}),function(e,t,a,n,o){e[n]=e[n]||[],e[n].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var r=t.getElementsByTagName(a)[0],p=t.createElement(a),i="dataLayer"!=n?"&l="+n:"";p.async=!0,p.src="https://www.googletagmanager.com/gtm.js?id="+o+i,r.parentNode.insertBefore(p,r)}(window,document,"script","dataLayer","GTM-WLNGBXD")}if(phet.chipper.queryParameters.yotta){var t=navigator.userAgent,a=!!(t.match(/MSIE/)||t.match(/Trident\//)||t.match(/Edge\//));if(!("file:"===window.location.protocol&&a||"phet"!==phet.chipper.brand&&"phet-io"!==phet.chipper.brand)){var n;n=phet.chipper.queryParameters["phet-app"]?"phet-app":phet.chipper.queryParameters["phet-android-app"]?"phet-android-app":top!==self?"embedded":"default","phet-app"===n?window.addEventListener("load",function(){setTimeout(e,0)},!1):e()}}}();
</script>
<script type="text/javascript">
!function(n,r){function t(t,c,s){var d=[];c=1==c?{entropy:!0}:c||{};var m=u(i(c.entropy?[t,a(n)]:null==t?f():t,3),d),j=new e(d),S=function(){for(var n=j.g(p),r=y,t=0;n<h;)n=(n+t)*l,r*=l,t=j.g(1);for(;n>=v;)n/=2,r/=2,t>>>=1;return(n+t)/r};return S.int32=function(){return 0|j.g(4)},S.quick=function(){return j.g(4)/4294967296},S.double=S,u(a(j.S),n),(c.pass||s||function(n,t,e,i){return i&&(i.S&&o(i,j),n.state=function(){return o(j,{})}),e?(r[g]=n,t):n})(S,m,"global"in c?c.global:this==r,c.state)}function e(n){var r,t=n.length,e=this,o=0,i=e.i=e.j=0,u=e.S=[];for(t||(n=[t++]);o<l;)u[o]=o++;for(o=0;o<l;o++)u[o]=u[i=m&i+n[o%t]+(r=u[o])],u[i]=r;(e.g=function(n){for(var r,t=0,o=e.i,i=e.j,u=e.S;n--;)r=u[o=m&o+1],t=t*l+u[m&(u[o]=u[i=m&i+r])+(u[i]=r)];return e.i=o,e.j=i,t})(l)}function o(n,r){return r.i=n.i,r.j=n.j,r.S=n.S.slice(),r}function i(n,r){var t,e=[],o=typeof n;if(r&&"object"==o)for(t in n)try{e.push(i(n[t],r-1))}catch(n){}return e.length?e:"string"==o?n:n+"\0"}function u(n,r){for(var t,e=n+"",o=0;o<e.length;)r[m&o]=m&(t^=19*r[m&o])+e.charCodeAt(o++);return a(r)}function f(){try{if(c)return a(c.randomBytes(l));var r=new Uint8Array(l);return(s.crypto||s.msCrypto).getRandomValues(r),a(r)}catch(r){var t=s.navigator,e=t&&t.plugins;return[+new Date,s,e,s.screen,a(n)]}}function a(n){return String.fromCharCode.apply(0,n)}var c,s=this,l=256,p=6,d=52,g="random",y=r.pow(l,p),h=r.pow(2,d),v=2*h,m=l-1;if(r["seed"+g]=t,u(r.random(),n),"object"==typeof module&&module.exports){module.exports=t;try{c=require("crypto")}catch(n){}}else"function"==typeof define&&define.amd&&define(function(){return t})}([],Math);
</script>
<script type="text/javascript">
!function(){"use strict";var e=window.phet.chipper.queryParameters.gameUpLogging,a=window.phet.chipper.queryParameters.gameUp,t=function(a){e&&console.log(a)};if(a){t("Enabled Game Up Camera");var n=".brainpop.com",i=!1,o=0,r=function(){!i&&o<10&&(parent.postMessage("captureReady","*"),o++,t("Posted captureReady, number of checks: "+o),setTimeout(r,1e3))},s=function(e){if(e.origin.indexOf(n,e.origin.length-n.length)!==-1)if("captureImage"===e.data){var a=window.phet.joist.ScreenshotGenerator.generateScreenshot(window.phet.joist.sim,"image/jpeg");p(a,e.origin,e.source),t("Sent image")}else"GameUpCaptureReady"===e.data&&(t("GameUpCaptureReady"),i=!0)},p=function(e,a,t){e=e.replace("data:image/jpeg;base64,",""),t.postMessage(e,a)};window.addEventListener?window.addEventListener("message",s,!1):window.attachEvent&&window.attachEvent("onmessage",s),r()}}();
</script>
<script type="text/javascript">
!function(){"use strict";function r(r){var t=r.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===r[t-2]?2:"="===r[t-1]?1:0}function t(t){return 3*t.length/4-r(t)}function n(t){var n,e,o,a,h,u,d=t.length;h=r(t),u=new i(3*d/4-h),o=h>0?d-4:d;var A=0;for(n=0,e=0;n<o;n+=4,e+=3)a=c[t.charCodeAt(n)]<<18|c[t.charCodeAt(n+1)]<<12|c[t.charCodeAt(n+2)]<<6|c[t.charCodeAt(n+3)],u[A++]=a>>16&255,u[A++]=a>>8&255,u[A++]=255&a;return 2===h?(a=c[t.charCodeAt(n)]<<2|c[t.charCodeAt(n+1)]>>4,u[A++]=255&a):1===h&&(a=c[t.charCodeAt(n)]<<10|c[t.charCodeAt(n+1)]<<4|c[t.charCodeAt(n+2)]>>2,u[A++]=a>>8&255,u[A++]=255&a),u}function e(r){return h[r>>18&63]+h[r>>12&63]+h[r>>6&63]+h[63&r]}function o(r,t,n){for(var o,a=[],h=t;h<n;h+=3)o=(r[h]<<16)+(r[h+1]<<8)+r[h+2],a.push(e(o));return a.join("")}function a(r){for(var t,n=r.length,e=n%3,a="",c=[],i=16383,u=0,d=n-e;u<d;u+=i)c.push(o(r,u,u+i>d?d:u+i));return 1===e?(t=r[n-1],a+=h[t>>2],a+=h[t<<4&63],a+="=="):2===e&&(t=(r[n-2]<<8)+r[n-1],a+=h[t>>10],a+=h[t>>4&63],a+=h[t<<2&63],a+="="),c.push(a),c.join("")}window.byteLength=t,window.toByteArray=n,window.fromByteArray=a;for(var h=[],c=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",d=0,A=u.length;d<A;++d)h[d]=u[d],c[u.charCodeAt(d)]=d;c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63}();
</script>
<script type="text/javascript">
function TextEncoderLite(){}function TextDecoderLite(){}!function(){"use strict";function e(e,n){n=n||1/0;for(var t,r=e.length,i=null,o=[],u=0;u<r;u++){if(t=e.charCodeAt(u),t>55295&&t<57344){if(!i){if(t>56319){(n-=3)>-1&&o.push(239,191,189);continue}if(u+1===r){(n-=3)>-1&&o.push(239,191,189);continue}i=t;continue}if(t<56320){(n-=3)>-1&&o.push(239,191,189),i=t;continue}t=i-55296<<10|t-56320|65536,i=null}else i&&((n-=3)>-1&&o.push(239,191,189),i=null);if(t<128){if((n-=1)<0)break;o.push(t)}else if(t<2048){if((n-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<2097152))throw new Error("Invalid code point");if((n-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function n(e,n,r){var i="",o="";r=Math.min(e.length,r||1/0),n=n||0;for(var u=n;u<r;u++)e[u]<=127?(i+=t(o)+String.fromCharCode(e[u]),o=""):o+="%"+e[u].toString(16);return i+t(o)}function t(e){try{return decodeURIComponent(e)}catch(e){return String.fromCharCode(65533)}}TextEncoderLite.prototype.encode=function(n){var t;return t="undefined"==typeof Uint8Array?e(n):new Uint8Array(e(n))},TextDecoderLite.prototype.decode=function(e){return n(e,0,e.length)}}();
</script>
<script type="text/javascript">
  (function() {
    var stringOverrides = JSON.parse( phet.chipper.queryParameters.strings || '{}' );
    var stringTest = ( typeof window !== 'undefined' && window.phet.chipper.queryParameters.stringTest ) ?
                     window.phet.chipper.queryParameters.stringTest :
                     null;
    window.phet.chipper.strings.get = function( key ) {
      var fallbackLocales = [ phet.chipper.locale ];
      var specificLocaleData = phet.chipper.localeData[ phet.chipper.locale ];
      if ( specificLocaleData && specificLocaleData.fallbackLocales ) {
        specificLocaleData.fallbackLocales.forEach( function( fallbackLocale ) { fallbackLocales.push( fallbackLocale ) } );
       }
      fallbackLocales.push( 'en' );
      var localeStrings = null;
      for ( var locale of fallbackLocales ) {
        localeStrings = phet.chipper.strings[ locale ];
        if ( localeStrings ) {
          break;
        }
      }
      return stringOverrides[ key ] || window.phet.chipper.mapString( localeStrings[ key ], stringTest );
    };
  })();
</script>
<script type="text/javascript">(function () {
var requirejs, require, define;
(function (undef) {
  var main, req, makeMap, handlers,
    defined = {},
    waiting = {},
    config = {},
    defining = {},
    hasOwn = Object.prototype.hasOwnProperty,
    aps = [].slice,
    jsSuffixRegExp = /\.js$/;
  function hasProp(obj, prop) {
    return hasOwn.call(obj, prop);
  }
  function normalize(name, baseName) {
    var nameParts, nameSegment, mapValue, foundMap, lastIndex,
      foundI, foundStarMap, starI, i, j, part,
      baseParts = baseName && baseName.split("/"),
      map = config.map,
      starMap = (map && map['*']) || {};
    if (name && name.charAt(0) === ".") {
      if (baseName) {
        baseParts = baseParts.slice(0, baseParts.length - 1);
        name = name.split('/');
        lastIndex = name.length - 1;
        if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
          name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
        }
        name = baseParts.concat(name);
        for (i = 0; i < name.length; i += 1) {
          part = name[i];
          if (part === ".") {
            name.splice(i, 1);
            i -= 1;
          } else if (part === "..") {
            if (i === 1 && (name[2] === '..' || name[0] === '..')) {
              break;
            } else if (i > 0) {
              name.splice(i - 1, 2);
              i -= 2;
            }
          }
        }
        name = name.join("/");
      } else if (name.indexOf('./') === 0) {
        name = name.substring(2);
      }
    }
    if ((baseParts || starMap) && map) {
      nameParts = name.split('/');
      for (i = nameParts.length; i > 0; i -= 1) {
        nameSegment = nameParts.slice(0, i).join("/");
        if (baseParts) {
          for (j = baseParts.length; j > 0; j -= 1) {
            mapValue = map[baseParts.slice(0, j).join('/')];
            if (mapValue) {
              mapValue = mapValue[nameSegment];
              if (mapValue) {
                foundMap = mapValue;
                foundI = i;
                break;
              }
            }
          }
        }
        if (foundMap) {
          break;
        }
        if (!foundStarMap && starMap && starMap[nameSegment]) {
          foundStarMap = starMap[nameSegment];
          starI = i;
        }
      }
      if (!foundMap && foundStarMap) {
        foundMap = foundStarMap;
        foundI = starI;
      }
      if (foundMap) {
        nameParts.splice(0, foundI, foundMap);
        name = nameParts.join('/');
      }
    }
    return name;
  }
  function makeRequire(relName, forceSync) {
    return function () {
      return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
    };
  }
  function makeNormalize(relName) {
    return function (name) {
      return normalize(name, relName);
    };
  }
  function makeLoad(depName) {
    return function (value) {
      defined[depName] = value;
    };
  }
  function callDep(name) {
    if (hasProp(waiting, name)) {
      var args = waiting[name];
      delete waiting[name];
      defining[name] = true;
      main.apply(undef, args);
    }
    if (!hasProp(defined, name) && !hasProp(defining, name)) {
      throw new Error('No ' + name);
    }
    return defined[name];
  }
  function splitPrefix(name) {
    var prefix,
      index = name ? name.indexOf('!') : -1;
    if (index > -1) {
      prefix = name.substring(0, index);
      name = name.substring(index + 1, name.length);
    }
    return [prefix, name];
  }
  makeMap = function (name, relName) {
    var plugin,
      parts = splitPrefix(name),
      prefix = parts[0];
    name = parts[1];
    if (prefix) {
      prefix = normalize(prefix, relName);
      plugin = callDep(prefix);
    }
    if (prefix) {
      if (plugin && plugin.normalize) {
        name = plugin.normalize(name, makeNormalize(relName));
      } else {
        name = normalize(name, relName);
      }
    } else {
      name = normalize(name, relName);
      parts = splitPrefix(name);
      prefix = parts[0];
      name = parts[1];
      if (prefix) {
        plugin = callDep(prefix);
      }
    }
    return {
      f: prefix ? prefix + '!' + name : name, //fullName
      n: name,
      pr: prefix,
      p: plugin
    };
  };
  function makeConfig(name) {
    return function () {
      return (config && config.config && config.config[name]) || {};
    };
  }
  handlers = {
    require: function (name) {
      return makeRequire(name);
    },
    exports: function (name) {
      var e = defined[name];
      if (typeof e !== 'undefined') {
        return e;
      } else {
        return (defined[name] = {});
      }
    },
    module: function (name) {
      return {
        id: name,
        uri: '',
        exports: defined[name],
        config: makeConfig(name)
      };
    }
  };
  main = function (name, deps, callback, relName) {
    var cjsModule, depName, ret, map, i,
      args = [],
      callbackType = typeof callback,
      usingExports;
    relName = relName || name;
    if (callbackType === 'undefined' || callbackType === 'function') {
      deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
      for (i = 0; i < deps.length; i += 1) {
        map = makeMap(deps[i], relName);
        depName = map.f;
        if (depName === "require") {
          args[i] = handlers.require(name);
        } else if (depName === "exports") {
          args[i] = handlers.exports(name);
          usingExports = true;
        } else if (depName === "module") {
          cjsModule = args[i] = handlers.module(name);
        } else if (hasProp(defined, depName) ||
                   hasProp(waiting, depName) ||
                   hasProp(defining, depName)) {
          args[i] = callDep(depName);
        } else if (map.p) {
          map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
          args[i] = defined[depName];
        } else {
          throw new Error(name + ' missing ' + depName);
        }
      }
      ret = callback ? callback.apply(defined[name], args) : undefined;
      if (name) {
        if (cjsModule && cjsModule.exports !== undef &&
            cjsModule.exports !== defined[name]) {
          defined[name] = cjsModule.exports;
        } else if (ret !== undef || !usingExports) {
          defined[name] = ret;
        }
      }
    } else if (name) {
      defined[name] = callback;
    }
  };
  requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
    if (typeof deps === "string") {
      if (handlers[deps]) {
        return handlers[deps](callback);
      }
      return callDep(makeMap(deps, callback).f);
    } else if (!deps.splice) {
      config = deps;
      if (config.deps) {
        req(config.deps, config.callback);
      }
      if (!callback) {
        return;
      }
      if (callback.splice) {
        deps = callback;
        callback = relName;
        relName = null;
      } else {
        deps = undef;
      }
    }
    callback = callback || function () {};
    if (typeof relName === 'function') {
      relName = forceSync;
      forceSync = alt;
    }
    if (forceSync) {
      main(undef, deps, callback, relName);
    } else {
      setTimeout(function () {
        main(undef, deps, callback, relName);
      }, 4);
    }
    return req;
  };
  req.config = function (cfg) {
    return req(cfg);
  };
  requirejs._defined = defined;
  define = function (name, deps, callback) {
    if (!deps.splice) {
      callback = deps;
      deps = [];
    }
    if (!hasProp(defined, name) && !hasProp(waiting, name)) {
      waiting[name] = [name, deps, callback];
    }
  };
  define.amd = {
    jQuery: true
  };
}());
define("almond", function(){});
define( 'PHET_CORE/Namespace',['require'],function( require ) {
  'use strict';
  function Namespace( name ) {
    this.name = name; // @public (read-only)
    if ( window.phet ) {
      assert && assert( !window.phet[ name ], 'namespace ' + name + ' already exists' );
      window.phet[ name ] = this;
    }
  }
  Namespace.prototype = {
    constructor: Namespace,
    register: function( key, value ) {
      if ( key.indexOf( '.' ) < 0 ) {
        assert && assert( !this[ key ], key + ' is already registered for namespace ' + this.name );
        this[ key ] = value;
      }
      else {
        var keys = key.split( '.' ); // e.g. [ 'A', 'B', 'C' ]
        var parent = this; // eslint-disable-line consistent-this
        for ( var i = 0; i < keys.length - 1; i++ ) { // for all but the last key
          assert && assert( !!parent[ keys[ i ] ],
            [ this.name ].concat( keys.slice( 0, i + 1 ) ).join( '.' ) + ' needs to be defined to register ' + key );
          parent = parent[ keys[ i ] ];
        }
        var lastKey = keys[ keys.length - 1 ];
        assert && assert( !parent[ lastKey ], key + ' is already registered for namespace ' + this.name );
        parent[ lastKey ] = value;
      }
      return value;
    }
  };
  return Namespace;
} );
define( 'BUILD_AN_ATOM/buildAnAtom',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'buildAnAtom' );
} );
define( 'SHRED/shred',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'shred' );
} );
define( 'PHET_CORE/phetCore',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  var phetCore = new Namespace( 'phetCore' );
  phetCore.register( 'Namespace', Namespace );
  return phetCore;
} );
define( 'PHET_CORE/phetAllocation',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  window.phetAllocationRecord = function() {
    console.log( 'ready, set...' );
    setTimeout( function() {
      console.log( 'go!' );
      window.alloc = {};
      setTimeout( function() {
        window.recordedAllocations = window.alloc;
        delete window.alloc;
        console.log( 'after ' + window.recordedAllocations.loop.count + ' loops: window.recordedAllocations = ' );
        console.log( window.recordedAllocations );
      }, 1000 );
    }, 2000 );
  };
  function phetAllocation( name ) {
    if ( window.alloc ) {
      var stack;
      try { throw new Error(); }
      catch( e ) { stack = e.stack; }
      if ( !window.alloc[ name ] ) {
        window.alloc[ name ] = { count: 0, stacks: {} };
      }
      var log = window.alloc[ name ];
      log.count++;
      if ( !log.stacks[ stack ] ) {
        log.stacks[ stack ] = 1;
      }
      else {
        log.stacks[ stack ] += 1;
      }
      log.report = function() {
        var stacks = Object.keys( log.stacks );
        stacks = _.sortBy( stacks, function( key ) { return log.stacks[ key ]; } );
        _.each( stacks, function( stack ) {
          console.log( log.stacks[ stack ] + ' occurrences for this stack: ' + stack );
        } );
      };
    }
  }
  phetCore.register( 'phetAllocation', phetAllocation );
  return phetAllocation;
} );
define( 'DOT/dot',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  var dot = new Namespace( 'dot' );
  dot.register( 'v2', function( x, y ) { return new dot.Vector2( x, y ); } );
  dot.register( 'v3', function( x, y, z ) { return new dot.Vector3( x, y, z ); } );
  dot.register( 'v4', function( x, y, z, w ) { return new dot.Vector4( x, y, z, w ); } );
  dot.register( 'FastArray', window.Float64Array ? window.Float64Array : window.Array );
  return dot;
} );
define( 'DOT/Util',['require','DOT/dot'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var EPSILON = Number.MIN_VALUE;
  var TWO_PI = 2 * Math.PI;
  var generate;
  var z0;
  var z1;
  var Util = {
    clamp: function( value, min, max ) {
      if ( value < min ) {
        return min;
      }
      else if ( value > max ) {
        return max;
      }
      else {
        return value;
      }
    },
    moduloBetweenDown: function( value, min, max ) {
      assert && assert( max > min, 'max > min required for moduloBetween' );
      var divisor = max - min;
      var partial = ( value - min ) % divisor;
      if ( partial < 0 ) {
        partial += divisor;
      }
      return partial + min; // add back in the minimum value
    },
    moduloBetweenUp: function( value, min, max ) {
      return -Util.moduloBetweenDown( -value, -max, -min );
    },
    rangeInclusive: function( a, b ) {
      if ( b < a ) {
        return [];
      }
      var result = new Array( b - a + 1 );
      for ( var i = a; i <= b; i++ ) {
        result[ i - a ] = i;
      }
      return result;
    },
    rangeExclusive: function( a, b ) {
      return Util.rangeInclusive( a + 1, b - 1 );
    },
    toRadians: function( degrees ) {
      return Math.PI * degrees / 180;
    },
    toDegrees: function( radians ) {
      return 180 * radians / Math.PI;
    },
    gcd: function( a, b ) {
      return b === 0 ? a : this.gcd( b, a % b );
    },
    lineLineIntersection: function( p1, p2, p3, p4 ) {
      var epsilon = 1e-5;
      if ( p1.equals( p2 ) || p3.equals( p4 ) ) {
        return null;
      }
      var x12 = p1.x - p2.x;
      var x34 = p3.x - p4.x;
      var y12 = p1.y - p2.y;
      var y34 = p3.y - p4.y;
      var denom = x12 * y34 - y12 * x34;
      if ( Math.abs( denom ) < epsilon ) {
        return null;
      }
      var a = p1.x * p2.y - p1.y * p2.x;
      var b = p3.x * p4.y - p3.y * p4.x;
      return new dot.Vector2(
        ( a * x34 - x12 * b ) / denom,
        ( a * y34 - y12 * b ) / denom
      );
    },
    sphereRayIntersection: function( radius, ray, epsilon ) {
      epsilon = epsilon === undefined ? 1e-5 : epsilon;
      var center = new dot.Vector3();
      var rayDir = ray.direction;
      var pos = ray.position;
      var centerToRay = pos.minus( center );
      var tmp = rayDir.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var det = 4 * tmp * tmp - 4 * ( centerToRayDistSq - radius * radius );
      if ( det < epsilon ) {
        return null;
      }
      var base = rayDir.dot( center ) - rayDir.dot( pos );
      var sqt = Math.sqrt( det ) / 2;
      var ta = base - sqt;
      var tb = base + sqt;
      if ( tb < epsilon ) {
        return null;
      }
      var hitPositionB = ray.pointAtDistance( tb );
      var normalB = hitPositionB.minus( center ).normalized();
      if ( ta < epsilon ) {
        return {
          distance: tb,
          hitPoint: hitPositionB,
          normal: normalB.negated(),
          fromOutside: false
        };
      }
      else {
        var hitPositionA = ray.pointAtDistance( ta );
        var normalA = hitPositionA.minus( center ).normalized();
        return {
          distance: ta,
          hitPoint: hitPositionA,
          normal: normalA,
          fromOutside: true
        };
      }
    },
    solveQuadraticRootsReal: function( a, b, c ) {
      var epsilon = 1E7;
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon ) {
        return [ -c / b ];
      }
      var discriminant = b * b - 4 * a * c;
      if ( discriminant < 0 ) {
        return [];
      }
      var sqrt = Math.sqrt( discriminant );
      return [
        ( -b - sqrt ) / ( 2 * a ),
        ( -b + sqrt ) / ( 2 * a )
      ];
    },
    solveCubicRootsReal: function( a, b, c, d ) {
      var epsilon = 1E7;
      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {
        return Util.solveQuadraticRootsReal( b, c, d );
      }
      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {
        return Util.solveQuadraticRootsReal( a, b, c );
      }
      b /= a;
      c /= a;
      d /= a;
      var q = ( 3.0 * c - ( b * b ) ) / 9;
      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;
      var discriminant = q * q * q + r * r;
      var b3 = b / 3;
      if ( discriminant > 0 ) {
        var dsqrt = Math.sqrt( discriminant );
        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];
      }
      if ( discriminant === 0 ) {
        var rsqrt = Util.cubeRoot( r );
        var doubleRoot = b3 - rsqrt;
        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];
      }
      else {
        var qX = -q * q * q;
        qX = Math.acos( r / Math.sqrt( qX ) );
        var rr = 2 * Math.sqrt( -q );
        return [
          -b3 + rr * Math.cos( qX / 3 ),
          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),
          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )
        ];
      }
    },
    cubeRoot: function( x ) {
      return x >= 0 ? Math.pow( x, 1 / 3 ) : -Math.pow( -x, 1 / 3 );
    },
    linear: function( a1, a2, b1, b2, a3 ) {
      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;
    },
    roundSymmetric: function( value ) {
      return ( ( value < 0 ) ? -1 : 1 ) * Math.round( Math.abs( value ) );
    },
    toFixed: function( value, decimalPlaces ) {
      var multiplier = Math.pow( 10, decimalPlaces );
      var newValue = Util.roundSymmetric( value * multiplier ) / multiplier;
      return newValue.toFixed( decimalPlaces );
    },
    toFixedNumber: function( value, decimalPlaces ) {
      return parseFloat( Util.toFixed( value, decimalPlaces ) );
    },
    isInteger: function( n ) {
      assert && assert( typeof n === 'number', 'isInteger requires its argument to be a number: ' + n );
      return n % 1 === 0;
    },
    lineSegmentIntersection: function( x1, y1, x2, y2, x3, y3, x4, y4 ) {
      var ccw = function( a, b, c, d, e, f ) {
        return (f - b) * (c - a) - (d - b) * (e - a);
      };
      if ( ccw( x1, y1, x3, y3, x4, y4 ) * ccw( x2, y2, x3, y3, x4, y4 ) > 0 ||
           ccw( x3, y3, x1, y1, x2, y2 ) * ccw( x4, y4, x1, y1, x2, y2 ) > 0
      ) {
        return null;
      }
      var denom = ( x1 - x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 - x4 );
      if ( denom === 0 ) {
        return null;
      }
      var intersectionX = ( ( x1 * y2 - y1 * x2 ) * ( x3 - x4 ) - ( x1 - x2 ) * ( x3 * y4 - y3 * x4 ) ) / denom;
      var intersectionY = ( ( x1 * y2 - y1 * x2 ) * ( y3 - y4 ) - ( y1 - y2 ) * ( x3 * y4 - y3 * x4 ) ) / denom;
      return new dot.Vector2( intersectionX, intersectionY );
    },
    distToSegmentSquared: function( point, a, b ) {
      var segmentSquaredLength = a.distanceSquared( b );
      if ( segmentSquaredLength === 0 ) { return point.distanceSquared( a ); }
      var t = ((point.x - a.x) * (b.x - a.x) + (point.y - a.y) * (b.y - a.y)) / segmentSquaredLength;
      var distanceSquared;
      if ( t < 0 ) {
        distanceSquared = point.distanceSquared( a );
      }
      else if ( t > 1 ) {
        distanceSquared = point.distanceSquared( b );
      }
      else {
        distanceSquared = point.distanceSquared( new dot.Vector2( a.x + t * (b.x - a.x), a.y + t * (b.y - a.y) ) );
      }
      return distanceSquared;
    },
    distToSegment: function( point, a, b ) { return Math.sqrt( this.distToSegmentSquared( point, a, b ) ); },
    arePointsCollinear: function( a, b, c, epsilon ) {
      if ( epsilon === undefined ) {
        epsilon = 0;
      }
      return Util.triangleArea( a, b, c ) <= epsilon;
    },
    triangleArea: function( a, b, c ) {
      return Math.abs( Util.triangleAreaSigned( a, b, c ) );
    },
    triangleAreaSigned: function( a, b, c ) {
      return a.x * ( b.y - c.y ) + b.x * ( c.y - a.y ) + c.x * ( a.y - b.y );
    },
    cosh: function( value ) {
      return (Math.exp( value ) + Math.exp( -value )) / 2;
    },
    sinh: function( value ) {
      return (Math.exp( value ) - Math.exp( -value )) / 2;
    },
    log10: function( val ) {
      return Math.log( val ) / Math.LN10;
    },
    boxMullerTransform: function( mu, sigma, random ) {
      generate = !generate;
      if ( !generate ) {
        return z1 * sigma + mu;
      }
      var u1;
      var u2;
      do {
        u1 = random.nextDouble();
        u2 = random.nextDouble();
      }
      while ( u1 <= EPSILON );
      z0 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.cos( TWO_PI * u2 );
      z1 = Math.sqrt( -2.0 * Math.log( u1 ) ) * Math.sin( TWO_PI * u2 );
      return z0 * sigma + mu;
    }
  };
  dot.register( 'Util', Util );
  dot.clamp = Util.clamp;
  dot.moduloBetweenDown = Util.moduloBetweenDown;
  dot.moduloBetweenUp = Util.moduloBetweenUp;
  dot.rangeInclusive = Util.rangeInclusive;
  dot.rangeExclusive = Util.rangeExclusive;
  dot.toRadians = Util.toRadians;
  dot.toDegrees = Util.toDegrees;
  dot.lineLineIntersection = Util.lineLineIntersection;
  dot.lineSegmentIntersection = Util.lineSegmentIntersection;
  dot.sphereRayIntersection = Util.sphereRayIntersection;
  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  dot.solveCubicRootsReal = Util.solveCubicRootsReal;
  dot.cubeRoot = Util.cubeRoot;
  dot.linear = Util.linear;
  dot.boxMullerTransform = Util.boxMullerTransform;
  return Util;
} );
;(function(){function n(n,t){return n.set(t[0],t[1]),n}function t(n,t){return n.add(t),n}function r(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function e(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&false!==t(n[r],r,n););return n}function i(n,t){for(var r=null==n?0:n.length;r--&&false!==t(n[r],r,n););
  return n}function o(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return false;return true}function f(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function c(n,t){return!(null==n||!n.length)&&-1<d(n,t,0)}function a(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return true;return false}function l(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function s(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];
  return n}function h(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);return r}function p(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function _(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return true;return false}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,false}),e}function g(n,t,r,e){var u=n.length;for(r+=e?1:-1;e?r--:++r<u;)if(t(n[r],r,n))return r;return-1}function d(n,t,r){if(t===t)n:{
  --r;for(var e=n.length;++r<e;)if(n[r]===t){n=r;break n}n=-1}else n=g(n,b,r);return n}function y(n,t,r,e){--r;for(var u=n.length;++r<u;)if(e(n[r],t))return r;return-1}function b(n){return n!==n}function x(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:P}function j(n){return function(t){return null==t?F:t[n]}}function w(n){return function(t){return null==n?F:n[t]}}function m(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=false,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].c;
  return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function O(n,t){return l(t,function(t){return[t,n[t]]})}function S(n){return function(t){return n(t)}}function I(n,t){return l(t,function(t){return n[t]})}function R(n,t){return n.has(t)}function z(n,t){for(var r=-1,e=n.length;++r<e&&-1<d(t,n[r],0););return r}function W(n,t){for(var r=n.length;r--&&-1<d(t,n[r],0););return r}function B(n){
  return"\\"+Tn[n]}function L(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function U(n,t){return function(r){return n(t(r))}}function C(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&"__lodash_placeholder__"!==o||(n[r]="__lodash_placeholder__",i[u++]=r)}return i}function D(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=n}),r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function T(n){if(Bn.test(n)){
  for(var t=zn.lastIndex=0;zn.test(n);)++t;n=t}else n=tt(n);return n}function $(n){return Bn.test(n)?n.match(zn)||[]:n.split("")}var F,N=1/0,P=NaN,Z=[["ary",128],["bind",1],["bindKey",2],["curry",8],["curryRight",16],["flip",512],["partial",32],["partialRight",64],["rearg",256]],q=/\b__p\+='';/g,V=/\b(__p\+=)''\+/g,K=/(__e\(.*?\)|\b__t\))\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,H=/[&<>"']/g,J=RegExp(G.source),Y=RegExp(H.source),Q=/<%-([\s\S]+?)%>/g,X=/<%([\s\S]+?)%>/g,nn=/<%=([\s\S]+?)%>/g,tn=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,rn=/^\w*$/,en=/^\./,un=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,on=/[\\^$.*+?()[\]{}|]/g,fn=RegExp(on.source),cn=/^\s+|\s+$/g,an=/^\s+/,ln=/\s+$/,sn=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,hn=/\{\n\/\* \[wrapped with (.+)\] \*/,pn=/,? & /,_n=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,vn=/\\(\\)?/g,gn=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,dn=/\w*$/,yn=/^[-+]0x[0-9a-f]+$/i,bn=/^0b[01]+$/i,xn=/^\[object .+?Constructor\]$/,jn=/^0o[0-7]+$/i,wn=/^(?:0|[1-9]\d*)$/,mn=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,An=/($^)/,kn=/['\n\r\u2028\u2029\\]/g,En="[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*",On="(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])"+En,Sn="(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])",In=RegExp("['\u2019]","g"),Rn=RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]","g"),zn=RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|"+Sn+En,"g"),Wn=RegExp(["[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['\u2019](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+",On].join("|"),"g"),Bn=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"),Ln=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Un="Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "),Cn={};
  Cn["[object Float32Array]"]=Cn["[object Float64Array]"]=Cn["[object Int8Array]"]=Cn["[object Int16Array]"]=Cn["[object Int32Array]"]=Cn["[object Uint8Array]"]=Cn["[object Uint8ClampedArray]"]=Cn["[object Uint16Array]"]=Cn["[object Uint32Array]"]=true,Cn["[object Arguments]"]=Cn["[object Array]"]=Cn["[object ArrayBuffer]"]=Cn["[object Boolean]"]=Cn["[object DataView]"]=Cn["[object Date]"]=Cn["[object Error]"]=Cn["[object Function]"]=Cn["[object Map]"]=Cn["[object Number]"]=Cn["[object Object]"]=Cn["[object RegExp]"]=Cn["[object Set]"]=Cn["[object String]"]=Cn["[object WeakMap]"]=false;
  var Dn={};Dn["[object Arguments]"]=Dn["[object Array]"]=Dn["[object ArrayBuffer]"]=Dn["[object DataView]"]=Dn["[object Boolean]"]=Dn["[object Date]"]=Dn["[object Float32Array]"]=Dn["[object Float64Array]"]=Dn["[object Int8Array]"]=Dn["[object Int16Array]"]=Dn["[object Int32Array]"]=Dn["[object Map]"]=Dn["[object Number]"]=Dn["[object Object]"]=Dn["[object RegExp]"]=Dn["[object Set]"]=Dn["[object String]"]=Dn["[object Symbol]"]=Dn["[object Uint8Array]"]=Dn["[object Uint8ClampedArray]"]=Dn["[object Uint16Array]"]=Dn["[object Uint32Array]"]=true,
    Dn["[object Error]"]=Dn["[object Function]"]=Dn["[object WeakMap]"]=false;var Mn,Tn={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},$n=parseFloat,Fn=parseInt,Nn=typeof global=="object"&&global&&global.Object===Object&&global,Pn=typeof self=="object"&&self&&self.Object===Object&&self,Zn=Nn||Pn||Function("return this")(),qn=typeof exports=="object"&&exports&&!exports.nodeType&&exports,Vn=qn&&typeof module=="object"&&module&&!module.nodeType&&module,Kn=Vn&&Vn.exports===qn,Gn=Kn&&Nn.process;
  n:{try{Mn=Gn&&Gn.binding&&Gn.binding("util");break n}catch(n){}Mn=void 0}var Hn=Mn&&Mn.isArrayBuffer,Jn=Mn&&Mn.isDate,Yn=Mn&&Mn.isMap,Qn=Mn&&Mn.isRegExp,Xn=Mn&&Mn.isSet,nt=Mn&&Mn.isTypedArray,tt=j("length"),rt=w({"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I",
    "\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae","\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C",
    "\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g","\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i",
    "\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O","\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S",
    "\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe",
    "\u0149":"'n","\u017f":"s"}),et=w({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}),ut=w({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"}),it=function w(En){function On(n){if(xu(n)&&!af(n)&&!(n instanceof Mn)){if(n instanceof zn)return n;if(ci.call(n,"__wrapped__"))return Pe(n)}return new zn(n)}function Sn(){}function zn(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,this.__index__=0,this.__values__=F}function Mn(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,
    this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Tn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Nn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function Pn(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function qn(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new Pn;++t<r;)this.add(n[t])}function Vn(n){
    this.size=(this.__data__=new Nn(n)).size}function Gn(n,t){var r,e=af(n),u=!e&&cf(n),i=!e&&!u&&sf(n),o=!e&&!u&&!i&&gf(n),u=(e=e||u||i||o)?E(n.length,ri):[],f=u.length;for(r in n)!t&&!ci.call(n,r)||e&&("length"==r||i&&("offset"==r||"parent"==r)||o&&("buffer"==r||"byteLength"==r||"byteOffset"==r)||Re(r,f))||u.push(r);return u}function tt(n){var t=n.length;return t?n[cr(0,t-1)]:F}function ot(n,t){return Te(Mr(n),gt(t,0,n.length))}function ft(n){return Te(Mr(n))}function ct(n,t,r){(r===F||hu(n[t],r))&&(r!==F||t in n)||_t(n,t,r);
  }function at(n,t,r){var e=n[t];ci.call(n,t)&&hu(e,r)&&(r!==F||t in n)||_t(n,t,r)}function lt(n,t){for(var r=n.length;r--;)if(hu(n[r][0],t))return r;return-1}function st(n,t,r,e){return oo(n,function(n,u,i){t(e,n,r(n),i)}),e}function ht(n,t){return n&&Tr(t,Lu(t),n)}function pt(n,t){return n&&Tr(t,Uu(t),n)}function _t(n,t,r){"__proto__"==t&&Ei?Ei(n,t,{configurable:true,enumerable:true,value:r,writable:true}):n[t]=r}function vt(n,t){for(var r=-1,e=t.length,u=Hu(e),i=null==n;++r<e;)u[r]=i?F:Wu(n,t[r]);return u;
  }function gt(n,t,r){return n===n&&(r!==F&&(n=n<=r?n:r),t!==F&&(n=n>=t?n:t)),n}function dt(n,t,r,e,i,o){var f,c=1&t,a=2&t,l=4&t;if(r&&(f=i?r(n,e,i,o):r(n)),f!==F)return f;if(!bu(n))return n;if(e=af(n)){if(f=Ee(n),!c)return Mr(n,f)}else{var s=yo(n),h="[object Function]"==s||"[object GeneratorFunction]"==s;if(sf(n))return Wr(n,c);if("[object Object]"==s||"[object Arguments]"==s||h&&!i){if(f=a||h?{}:Oe(n),!c)return a?Fr(n,pt(f,n)):$r(n,ht(f,n))}else{if(!Dn[s])return i?n:{};f=Se(n,s,dt,c)}}if(o||(o=new Vn),
      i=o.get(n))return i;o.set(n,f);var a=l?a?ye:de:a?Uu:Lu,p=e?F:a(n);return u(p||n,function(e,u){p&&(u=e,e=n[u]),at(f,u,dt(e,t,r,u,n,o))}),f}function yt(n){var t=Lu(n);return function(r){return bt(r,n,t)}}function bt(n,t,r){var e=r.length;if(null==n)return!e;for(n=ni(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===F&&!(u in n)||!i(o))return false}return true}function xt(n,t,r){if(typeof n!="function")throw new ei("Expected a function");return jo(function(){n.apply(F,r)},t)}function jt(n,t,r,e){var u=-1,i=c,o=true,f=n.length,s=[],h=t.length;
    if(!f)return s;r&&(t=l(t,S(r))),e?(i=a,o=false):200<=t.length&&(i=R,o=false,t=new qn(t));n:for(;++u<f;){var p=n[u],_=null==r?p:r(p),p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function wt(n,t){var r=true;return oo(n,function(n,e,u){return r=!!t(n,e,u)}),r}function mt(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===F?o===o&&!Au(o):r(o,f)))var f=o,c=i}return c}function At(n,t){var r=[];return oo(n,function(n,e,u){
    t(n,e,u)&&r.push(n)}),r}function kt(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Ie),u||(u=[]);++i<o;){var f=n[i];0<t&&r(f)?1<t?kt(f,t-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function Et(n,t){return n&&co(n,t,Lu)}function Ot(n,t){return n&&ao(n,t,Lu)}function St(n,t){return f(t,function(t){return gu(n[t])})}function It(n,t){t=Rr(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[$e(t[r++])];return r&&r==e?n:F}function Rt(n,t,r){return t=t(n),af(n)?t:s(t,r(n))}function zt(n){if(null==n)n=n===F?"[object Undefined]":"[object Null]";else if(ki&&ki in ni(n)){
    var t=ci.call(n,ki),r=n[ki];try{n[ki]=F;var e=true}catch(n){}var u=si.call(n);e&&(t?n[ki]=r:delete n[ki]),n=u}else n=si.call(n);return n}function Wt(n,t){return n>t}function Bt(n,t){return null!=n&&ci.call(n,t)}function Lt(n,t){return null!=n&&t in ni(n)}function Ut(n,t,r){for(var e=r?a:c,u=n[0].length,i=n.length,o=i,f=Hu(i),s=1/0,h=[];o--;){var p=n[o];o&&t&&(p=l(p,S(t))),s=Mi(p.length,s),f[o]=!r&&(t||120<=u&&120<=p.length)?new qn(o&&p):F}var p=n[0],_=-1,v=f[0];n:for(;++_<u&&h.length<s;){var g=p[_],d=t?t(g):g,g=r||0!==g?g:0;
    if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(n[o],d,r))continue n}v&&v.push(d),h.push(g)}}return h}function Ct(n,t,r){var e={};return Et(n,function(n,u,i){t(e,r(n),u,i)}),e}function Dt(n,t,e){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),t=null==n?n:n[$e(Ge(t))],null==t?F:r(t,n,e)}function Mt(n){return xu(n)&&"[object Arguments]"==zt(n)}function Tt(n){return xu(n)&&"[object ArrayBuffer]"==zt(n)}function $t(n){return xu(n)&&"[object Date]"==zt(n)}function Ft(n,t,r,e,u){if(n===t)t=true;else if(null==n||null==t||!xu(n)&&!xu(t))t=n!==n&&t!==t;else n:{
    var i=af(n),o=af(t),f=i?"[object Array]":yo(n),c=o?"[object Array]":yo(t),f="[object Arguments]"==f?"[object Object]":f,c="[object Arguments]"==c?"[object Object]":c,a="[object Object]"==f,o="[object Object]"==c;if((c=f==c)&&sf(n)){if(!sf(t)){t=false;break n}i=true,a=false}if(c&&!a)u||(u=new Vn),t=i||gf(n)?_e(n,t,r,e,Ft,u):ve(n,t,f,r,e,Ft,u);else{if(!(1&r)&&(i=a&&ci.call(n,"__wrapped__"),f=o&&ci.call(t,"__wrapped__"),i||f)){n=i?n.value():n,t=f?t.value():t,u||(u=new Vn),t=Ft(n,t,r,e,u);break n}if(c)t:if(u||(u=new Vn),
        i=1&r,f=de(n),o=f.length,c=de(t).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in t:ci.call(t,l))){t=false;break t}}if((c=u.get(n))&&u.get(t))t=c==t;else{c=true,u.set(n,t),u.set(t,n);for(var s=i;++a<o;){var l=f[a],h=n[l],p=t[l];if(e)var _=i?e(p,h,l,t,n,u):e(h,p,l,n,t,u);if(_===F?h!==p&&!Ft(h,p,r,e,u):!_){c=false;break}s||(s="constructor"==l)}c&&!s&&(r=n.constructor,e=t.constructor,r!=e&&"constructor"in n&&"constructor"in t&&!(typeof r=="function"&&r instanceof r&&typeof e=="function"&&e instanceof e)&&(c=false)),
      u.delete(n),u.delete(t),t=c}}else t=false;else t=false}}return t}function Nt(n){return xu(n)&&"[object Map]"==yo(n)}function Pt(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ni(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return false}for(;++u<i;){var f=r[u],c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in n))return false}else{if(f=new Vn,e)var s=e(a,l,c,n,t,f);if(s===F?!Ft(l,a,3,e,f):!s)return false}}return true}function Zt(n){return!(!bu(n)||li&&li in n)&&(gu(n)?_i:xn).test(Fe(n))}function qt(n){
    return xu(n)&&"[object RegExp]"==zt(n)}function Vt(n){return xu(n)&&"[object Set]"==yo(n)}function Kt(n){return xu(n)&&yu(n.length)&&!!Cn[zt(n)]}function Gt(n){return typeof n=="function"?n:null==n?Nu:typeof n=="object"?af(n)?Xt(n[0],n[1]):Qt(n):Vu(n)}function Ht(n){if(!Le(n))return Ci(n);var t,r=[];for(t in ni(n))ci.call(n,t)&&"constructor"!=t&&r.push(t);return r}function Jt(n,t){return n<t}function Yt(n,t){var r=-1,e=pu(n)?Hu(n.length):[];return oo(n,function(n,u,i){e[++r]=t(n,u,i)}),e}function Qt(n){
    var t=me(n);return 1==t.length&&t[0][2]?Ue(t[0][0],t[0][1]):function(r){return r===n||Pt(r,n,t)}}function Xt(n,t){return We(n)&&t===t&&!bu(t)?Ue($e(n),t):function(r){var e=Wu(r,n);return e===F&&e===t?Bu(r,n):Ft(t,e,3)}}function nr(n,t,r,e,u){n!==t&&co(t,function(i,o){if(bu(i)){u||(u=new Vn);var f=u,c=n[o],a=t[o],l=f.get(a);if(l)ct(n,o,l);else{var l=e?e(c,a,o+"",n,t,f):F,s=l===F;if(s){var h=af(a),p=!h&&sf(a),_=!h&&!p&&gf(a),l=a;h||p||_?af(c)?l=c:_u(c)?l=Mr(c):p?(s=false,l=Wr(a,true)):_?(s=false,l=Lr(a,true)):l=[]:wu(a)||cf(a)?(l=c,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        cf(c)?l=Ru(c):(!bu(c)||r&&gu(c))&&(l=Oe(a))):s=false}s&&(f.set(a,l),nr(l,a,r,e,f),f.delete(a)),ct(n,o,l)}}else f=e?e(n[o],i,o+"",n,t,u):F,f===F&&(f=i),ct(n,o,f)},Uu)}function tr(n,t){var r=n.length;if(r)return t+=0>t?r:0,Re(t,r)?n[t]:F}function rr(n,t,r){var e=-1;return t=l(t.length?t:[Nu],S(je())),n=Yt(n,function(n){return{a:l(t,function(t){return t(n)}),b:++e,c:n}}),A(n,function(n,t){var e;n:{e=-1;for(var u=n.a,i=t.a,o=u.length,f=r.length;++e<o;){var c=Ur(u[e],i[e]);if(c){e=e>=f?c:c*("desc"==r[e]?-1:1);
    break n}}e=n.b-t.b}return e})}function er(n,t){return ur(n,t,function(t,r){return Bu(n,r)})}function ur(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=It(n,o);r(f,o)&&pr(i,Rr(o,n),f)}return i}function ir(n){return function(t){return It(t,n)}}function or(n,t,r,e){var u=e?y:d,i=-1,o=t.length,f=n;for(n===t&&(t=Mr(t)),r&&(f=l(n,S(r)));++i<o;)for(var c=0,a=t[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==n&&wi.call(f,c,1),wi.call(n,c,1);return n}function fr(n,t){for(var r=n?t.length:0,e=r-1;r--;){var u=t[r];
    if(r==e||u!==i){var i=u;Re(u)?wi.call(n,u,1):mr(n,u)}}}function cr(n,t){return n+zi(Fi()*(t-n+1))}function ar(n,t){var r="";if(!n||1>t||9007199254740991<t)return r;do t%2&&(r+=n),(t=zi(t/2))&&(n+=n);while(t);return r}function lr(n,t){return wo(Ce(n,t,Nu),n+"")}function sr(n){return tt(Du(n))}function hr(n,t){var r=Du(n);return Te(r,gt(t,0,r.length))}function pr(n,t,r,e){if(!bu(n))return n;t=Rr(t,n);for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=$e(t[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;
    a===F&&(a=bu(l)?l:Re(t[u+1])?[]:{})}at(f,c,a),f=f[c]}return n}function _r(n){return Te(Du(n))}function vr(n,t,r){var e=-1,u=n.length;for(0>t&&(t=-t>u?0:u+t),r=r>u?u:r,0>r&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0,r=Hu(u);++e<u;)r[e]=n[e+t];return r}function gr(n,t){var r;return oo(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function dr(n,t,r){var e=0,u=null==n?e:n.length;if(typeof t=="number"&&t===t&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!Au(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return yr(n,t,Nu,r);
  }function yr(n,t,r,e){t=r(t);for(var u=0,i=null==n?0:n.length,o=t!==t,f=null===t,c=Au(t),a=t===F;u<i;){var l=zi((u+i)/2),s=r(n[l]),h=s!==F,p=null===s,_=s===s,v=Au(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=t:s<t)?u=l+1:i=l}return Mi(i,4294967294)}function br(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r],f=t?t(o):o;if(!r||!hu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(n){return typeof n=="number"?n:Au(n)?P:+n}function jr(n){if(typeof n=="string")return n;
    if(af(n))return l(n,jr)+"";if(Au(n))return uo?uo.call(n):"";var t=n+"";return"0"==t&&1/n==-N?"-0":t}function wr(n,t,r){var e=-1,u=c,i=n.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=t?null:po(n))return D(u);o=false,u=R,l=new qn}else l=t?[]:f;n:for(;++e<i;){var s=n[e],h=t?t(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue n;t&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(n,t){return t=Rr(t,n),n=2>t.length?n:It(n,vr(t,0,-1)),
  null==n||delete n[$e(Ge(t))]}function Ar(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?vr(n,e?0:i,e?i+1:u):vr(n,e?i+1:0,e?u:i)}function kr(n,t){var r=n;return r instanceof Mn&&(r=r.value()),h(t,function(n,t){return t.func.apply(t.thisArg,s([n],t.args))},r)}function Er(n,t,r){var e=n.length;if(2>e)return e?wr(n[0]):[];for(var u=-1,i=Hu(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=jt(i[u]||o,n[f],t,r));return wr(kt(i,1),t,r)}function Or(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;)r(o,n[e],e<i?t[e]:F);
    return o}function Sr(n){return _u(n)?n:[]}function Ir(n){return typeof n=="function"?n:Nu}function Rr(n,t){return af(n)?n:We(n,t)?[n]:mo(zu(n))}function zr(n,t,r){var e=n.length;return r=r===F?e:r,!t&&r>=e?n:vr(n,t,r)}function Wr(n,t){if(t)return n.slice();var r=n.length,r=yi?yi(r):new n.constructor(r);return n.copy(r),r}function Br(n){var t=new n.constructor(n.byteLength);return new di(t).set(new di(n)),t}function Lr(n,t){return new n.constructor(t?Br(n.buffer):n.buffer,n.byteOffset,n.length)}function Ur(n,t){
    if(n!==t){var r=n!==F,e=null===n,u=n===n,i=Au(n),o=t!==F,f=null===t,c=t===t,a=Au(t);if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cr(n,t,r,e){var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Di(i-o,0),l=Hu(c+a);for(e=!e;++f<c;)l[f]=t[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l}function Dr(n,t,r,e){var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Di(i-f,0),s=Hu(l+a);
    for(e=!e;++u<l;)s[u]=n[u];for(l=u;++c<a;)s[l+c]=t[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=n[u++]);return s}function Mr(n,t){var r=-1,e=n.length;for(t||(t=Hu(e));++r<e;)t[r]=n[r];return t}function Tr(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):F;c===F&&(c=n[f]),u?_t(r,f,c):at(r,f,c)}return r}function $r(n,t){return Tr(n,vo(n),t)}function Fr(n,t){return Tr(n,go(n),t)}function Nr(n,t){return function(r,u){var i=af(r)?e:st,o=t?t():{};return i(r,n,je(u,2),o);
  }}function Pr(n){return lr(function(t,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<n.length&&typeof i=="function"?(u--,i):F;for(o&&ze(r[0],r[1],o)&&(i=3>u?F:i,u=1),t=ni(t);++e<u;)(o=r[e])&&n(t,o,e,i);return t})}function Zr(n,t){return function(r,e){if(null==r)return r;if(!pu(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ni(r);(t?i--:++i<u)&&false!==e(o[i],i,o););return r}}function qr(n){return function(t,r,e){var u=-1,i=ni(t);e=e(t);for(var o=e.length;o--;){var f=e[n?o:++u];if(false===r(i[f],f,i))break;
  }return t}}function Vr(n,t,r){function e(){return(this&&this!==Zn&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=1&t,i=Hr(n);return e}function Kr(n){return function(t){t=zu(t);var r=Bn.test(t)?$(t):F,e=r?r[0]:t.charAt(0);return t=r?zr(r,1).join(""):t.slice(1),e[n]()+t}}function Gr(n){return function(t){return h($u(Tu(t).replace(In,"")),n,"")}}function Hr(n){return function(){var t=arguments;switch(t.length){case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:
    return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=io(n.prototype),t=n.apply(r,t);return bu(t)?t:r}}function Jr(n,t,e){function u(){for(var o=arguments.length,f=Hu(o),c=o,a=xe(u);c--;)f[c]=arguments[c];return c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?fe(n,t,Xr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Zn&&this instanceof u?i:n,this,f);
  }var i=Hr(n);return u}function Yr(n){return function(t,r,e){var u=ni(t);if(!pu(t)){var i=je(r,3);t=Lu(t),r=function(n){return i(u[n],n,u)}}return r=n(t,r,e),-1<r?u[i?t[r]:r]:F}}function Qr(n){return ge(function(t){var r=t.length,e=r,u=zn.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if(typeof i!="function")throw new ei("Expected a function");if(u&&!o&&"wrapper"==be(i))var o=new zn([],true)}for(e=o?e:r;++e<r;)var i=t[e],u=be(i),f="wrapper"==u?_o(i):F,o=f&&Be(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[be(f[0])].apply(o,f[3]):1==i.length&&Be(i)?o[u]():o.thru(i);
    return function(){var n=arguments,e=n[0];if(o&&1==n.length&&af(e))return o.plant(e).value();for(var u=0,n=r?t[u].apply(this,n):e;++u<r;)n=t[u].call(this,n);return n}})}function Xr(n,t,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Hu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=xe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x}if(e&&(y=Cr(y,e,u,_)),i&&(y=Dr(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),fe(n,t,Xr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[n]:n,d=y.length,f){x=y.length;for(var w=Mi(f.length,x),m=Mr(y);w--;){
    var A=f[w];y[w]=Re(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Zn&&this instanceof l&&(b=g||Hr(b)),b.apply(j,y)}var s=128&t,h=1&t,p=2&t,_=24&t,v=512&t,g=p?F:Hr(n);return l}function ne(n,t){return function(r,e){return Ct(r,n,t(e))}}function te(n,t){return function(r,e){var u;if(r===F&&e===F)return t;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r=="string"||typeof e=="string"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=n(r,e)}return u}}function re(n){return ge(function(t){
    return t=l(t,S(je())),lr(function(e){var u=this;return n(t,function(n){return r(n,u,e)})})})}function ee(n,t){t=t===F?" ":jr(t);var r=t.length;return 2>r?r?ar(t,n):t:(r=ar(t,Ri(n/T(t))),Bn.test(t)?zr($(r),0,n).join(""):r.slice(0,n))}function ue(n,t,e,u){function i(){for(var t=-1,c=arguments.length,a=-1,l=u.length,s=Hu(l+c),h=this&&this!==Zn&&this instanceof i?f:n;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++t];return r(h,o?e:this,s)}var o=1&t,f=Hr(n);return i}function ie(n){return function(t,r,e){
    e&&typeof e!="number"&&ze(t,r,e)&&(r=e=F),t=Eu(t),r===F?(r=t,t=0):r=Eu(r),e=e===F?t<r?1:-1:Eu(e);var u=-1;r=Di(Ri((r-t)/(e||1)),0);for(var i=Hu(r);r--;)i[n?r:++u]=t,t+=e;return i}}function oe(n){return function(t,r){return typeof t=="string"&&typeof r=="string"||(t=Iu(t),r=Iu(r)),n(t,r)}}function fe(n,t,r,e,u,i,o,f,c,a){var l=8&t,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,t=(t|(l?32:64))&~(l?64:32),4&t||(t&=-4),u=[n,t,u,h,s,i,o,f,c,a],r=r.apply(F,u),Be(n)&&xo(r,u),r.placeholder=e,De(r,n,t)}function ce(n){
    var t=Xu[n];return function(n,r){if(n=Iu(n),r=null==r?0:Mi(Ou(r),292)){var e=(zu(n)+"e").split("e"),e=t(e[0]+"e"+(+e[1]+r)),e=(zu(e)+"e").split("e");return+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ae(n){return function(t){var r=yo(t);return"[object Map]"==r?L(t):"[object Set]"==r?M(t):O(t,n(t))}}function le(n,t,r,e,u,i,o,f){var c=2&t;if(!c&&typeof n!="function")throw new ei("Expected a function");var a=e?e.length:0;if(a||(t&=-97,e=u=F),o=o===F?o:Di(Ou(o),0),f=f===F?f:Ou(f),a-=u?u.length:0,64&t){
    var l=e,s=u;e=u=F}var h=c?F:_o(n);return i=[n,t,r,e,u,l,s,i,o,f],h&&(r=i[1],n=h[1],t=r|n,e=128==n&&8==r||128==n&&256==r&&i[7].length<=h[8]||384==n&&h[7].length<=h[8]&&8==r,131>t||e)&&(1&n&&(i[2]=h[2],t|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Cr(e,r,h[4]):r,i[4]=e?C(i[3],"__lodash_placeholder__"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Dr(e,r,h[6]):r,i[6]=e?C(i[5],"__lodash_placeholder__"):h[6]),(r=h[7])&&(i[7]=r),128&n&&(i[8]=null==i[8]?h[8]:Mi(i[8],h[8])),null==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=t),n=i[0],t=i[1],
    r=i[2],e=i[3],u=i[4],f=i[9]=i[9]===F?c?0:n.length:Di(i[9]-a,0),!f&&24&t&&(t&=-25),De((h?lo:xo)(t&&1!=t?8==t||16==t?Jr(n,t,f):32!=t&&33!=t||u.length?Xr.apply(F,i):ue(n,t,r,e):Vr(n,t,r),i),n,t)}function se(n,t,r,e){return n===F||hu(n,ii[r])&&!ci.call(e,r)?t:n}function he(n,t,r,e,u,i){return bu(n)&&bu(t)&&(i.set(t,n),nr(n,t,F,he,i),i.delete(t)),n}function pe(n){return wu(n)?F:n}function _e(n,t,r,e,u,i){var o=1&r,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(n))&&i.get(t))return c==t;var c=-1,a=true,l=2&r?new qn:F;
    for(i.set(n,t),i.set(t,n);++c<f;){var s=n[c],h=t[c];if(e)var p=o?e(h,s,c,t,n,i):e(s,h,c,n,t,i);if(p!==F){if(p)continue;a=false;break}if(l){if(!_(t,function(n,t){if(!R(l,t)&&(s===n||u(s,n,r,e,i)))return l.push(t)})){a=false;break}}else if(s!==h&&!u(s,h,r,e,i)){a=false;break}}return i.delete(n),i.delete(t),a}function ve(n,t,r,e,u,i,o){switch(r){case"[object DataView]":if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)break;n=n.buffer,t=t.buffer;case"[object ArrayBuffer]":if(n.byteLength!=t.byteLength||!i(new di(n),new di(t)))break;
    return true;case"[object Boolean]":case"[object Date]":case"[object Number]":return hu(+n,+t);case"[object Error]":return n.name==t.name&&n.message==t.message;case"[object RegExp]":case"[object String]":return n==t+"";case"[object Map]":var f=L;case"[object Set]":if(f||(f=D),n.size!=t.size&&!(1&e))break;return(r=o.get(n))?r==t:(e|=2,o.set(n,t),t=_e(f(n),f(t),e,u,i,o),o.delete(n),t);case"[object Symbol]":if(eo)return eo.call(n)==eo.call(t)}return false}function ge(n){return wo(Ce(n,F,Ve),n+"")}function de(n){
    return Rt(n,Lu,vo)}function ye(n){return Rt(n,Uu,go)}function be(n){for(var t=n.name+"",r=Ji[t],e=ci.call(Ji,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function xe(n){return(ci.call(On,"placeholder")?On:n).placeholder}function je(){var n=On.iteratee||Pu,n=n===Pu?Gt:n;return arguments.length?n(arguments[0],arguments[1]):n}function we(n,t){var r=n.__data__,e=typeof t;return("string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t)?r[typeof t=="string"?"string":"hash"]:r.map;
  }function me(n){for(var t=Lu(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,u===u&&!bu(u)]}return t}function Ae(n,t){var r=null==n?F:n[t];return Zt(r)?r:F}function ke(n,t,r){t=Rr(t,n);for(var e=-1,u=t.length,i=false;++e<u;){var o=$e(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&yu(u)&&Re(o,u)&&(af(n)||cf(n)))}function Ee(n){var t=n.length,r=n.constructor(t);return t&&"string"==typeof n[0]&&ci.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Oe(n){
    return typeof n.constructor!="function"||Le(n)?{}:io(bi(n))}function Se(r,e,u,i){var o=r.constructor;switch(e){case"[object ArrayBuffer]":return Br(r);case"[object Boolean]":case"[object Date]":return new o(+r);case"[object DataView]":return e=i?Br(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case"[object Float32Array]":case"[object Float64Array]":case"[object Int8Array]":case"[object Int16Array]":case"[object Int32Array]":case"[object Uint8Array]":case"[object Uint8ClampedArray]":
    case"[object Uint16Array]":case"[object Uint32Array]":return Lr(r,i);case"[object Map]":return e=i?u(L(r),1):L(r),h(e,n,new r.constructor);case"[object Number]":case"[object String]":return new o(r);case"[object RegExp]":return e=new r.constructor(r.source,dn.exec(r)),e.lastIndex=r.lastIndex,e;case"[object Set]":return e=i?u(D(r),1):D(r),h(e,t,new r.constructor);case"[object Symbol]":return eo?ni(eo.call(r)):{}}}function Ie(n){return af(n)||cf(n)||!!(mi&&n&&n[mi])}function Re(n,t){return t=null==t?9007199254740991:t,
  !!t&&(typeof n=="number"||wn.test(n))&&-1<n&&0==n%1&&n<t}function ze(n,t,r){if(!bu(r))return false;var e=typeof t;return!!("number"==e?pu(r)&&Re(t,r.length):"string"==e&&t in r)&&hu(r[t],n)}function We(n,t){if(af(n))return false;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!Au(n))||(rn.test(n)||!tn.test(n)||null!=t&&n in ni(t))}function Be(n){var t=be(n),r=On[t];return typeof r=="function"&&t in Mn.prototype&&(n===r||(t=_o(r),!!t&&n===t[0]))}function Le(n){var t=n&&n.constructor;
    return n===(typeof t=="function"&&t.prototype||ii)}function Ue(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==F||n in ni(r)))}}function Ce(n,t,e){return t=Di(t===F?n.length-1:t,0),function(){for(var u=arguments,i=-1,o=Di(u.length-t,0),f=Hu(o);++i<o;)f[i]=u[t+i];for(i=-1,o=Hu(t+1);++i<t;)o[i]=u[i];return o[t]=e(f),r(n,this,o)}}function De(n,t,r){var e=t+"";t=wo;var u,i=Ne;return u=(u=e.match(hn))?u[1].split(pn):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?"& ":"")+r[u],r=r.join(2<i?", ":" "),
    e=e.replace(sn,"{\n\n")),t(n,e)}function Me(n){var t=0,r=0;return function(){var e=Ti(),u=16-(e-r);if(r=e,0<u){if(800<=++t)return arguments[0]}else t=0;return n.apply(F,arguments)}}function Te(n,t){var r=-1,e=n.length,u=e-1;for(t=t===F?e:t;++r<t;){var e=cr(r,u),i=n[e];n[e]=n[r],n[r]=i}return n.length=t,n}function $e(n){if(typeof n=="string"||Au(n))return n;var t=n+"";return"0"==t&&1/n==-N?"-0":t}function Fe(n){if(null!=n){try{return fi.call(n)}catch(n){}return n+""}return"";
  }function Ne(n,t){return u(Z,function(r){var e="_."+r[0];t&r[1]&&!c(n,e)&&n.push(e)}),n.sort()}function Pe(n){if(n instanceof Mn)return n.clone();var t=new zn(n.__wrapped__,n.__chain__);return t.__actions__=Mr(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function Ze(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),g(n,je(t,3),r)):-1}function qe(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==F&&(u=Ou(r),u=0>r?Di(e+u,0):Mi(u,e-1)),
    g(n,je(t,3),u,true)}function Ve(n){return(null==n?0:n.length)?kt(n,1):[]}function Ke(n){return n&&n.length?n[0]:F}function Ge(n){var t=null==n?0:n.length;return t?n[t-1]:F}function He(n,t){return n&&n.length&&t&&t.length?or(n,t):n}function Je(n){return null==n?n:Ni.call(n)}function Ye(n){if(!n||!n.length)return[];var t=0;return n=f(n,function(n){if(_u(n))return t=Di(n.length,t),true}),E(t,function(t){return l(n,j(t))})}function Qe(n,t){if(!n||!n.length)return[];var e=Ye(n);return null==t?e:l(e,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  return r(t,F,n)})}function Xe(n){return n=On(n),n.__chain__=true,n}function nu(n,t){return t(n)}function tu(){return this}function ru(n,t){return(af(n)?u:oo)(n,je(t,3))}function eu(n,t){return(af(n)?i:fo)(n,je(t,3))}function uu(n,t){return(af(n)?l:Yt)(n,je(t,3))}function iu(n,t,r){return t=r?F:t,t=n&&null==t?n.length:t,le(n,128,F,F,F,F,t)}function ou(n,t){var r;if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){return 0<--n&&(r=t.apply(this,arguments)),1>=n&&(t=F),
    r}}function fu(n,t,r){return t=r?F:t,n=le(n,8,F,F,F,F,F,t),n.placeholder=fu.placeholder,n}function cu(n,t,r){return t=r?F:t,n=le(n,16,F,F,F,F,F,t),n.placeholder=cu.placeholder,n}function au(n,t,r){function e(t){var r=c,e=a;return c=a=F,_=t,s=n.apply(e,r)}function u(n){var r=n-p;return n-=_,p===F||r>=t||0>r||g&&n>=l}function i(){var n=Jo();if(u(n))return o(n);var r,e=jo;r=n-_,n=t-(n-p),r=g?Mi(n,l-r):n,h=e(i,r)}function o(n){return h=F,d&&c?e(n):(c=a=F,s)}function f(){var n=Jo(),r=u(n);if(c=arguments,
      a=this,p=n,r){if(h===F)return _=n=p,h=jo(i,t),v?e(n):s;if(g)return h=jo(i,t),e(p)}return h===F&&(h=jo(i,t)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof n!="function")throw new ei("Expected a function");return t=Iu(t)||0,bu(r)&&(v=!!r.leading,l=(g="maxWait"in r)?Di(Iu(r.maxWait)||0,t):l,d="trailing"in r?!!r.trailing:d),f.cancel=function(){h!==F&&ho(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Jo())},f}function lu(n,t){function r(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=n.apply(this,e),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                r.cache=i.set(u,e)||i,e)}if(typeof n!="function"||null!=t&&typeof t!="function")throw new ei("Expected a function");return r.cache=new(lu.Cache||Pn),r}function su(n){if(typeof n!="function")throw new ei("Expected a function");return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function hu(n,t){return n===t||n!==n&&t!==t}function pu(n){return null!=n&&yu(n.length)&&!gu(n);
  }function _u(n){return xu(n)&&pu(n)}function vu(n){if(!xu(n))return false;var t=zt(n);return"[object Error]"==t||"[object DOMException]"==t||typeof n.message=="string"&&typeof n.name=="string"&&!wu(n)}function gu(n){return!!bu(n)&&(n=zt(n),"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n)}function du(n){return typeof n=="number"&&n==Ou(n)}function yu(n){return typeof n=="number"&&-1<n&&0==n%1&&9007199254740991>=n}function bu(n){var t=typeof n;return null!=n&&("object"==t||"function"==t);
  }function xu(n){return null!=n&&typeof n=="object"}function ju(n){return typeof n=="number"||xu(n)&&"[object Number]"==zt(n)}function wu(n){return!(!xu(n)||"[object Object]"!=zt(n))&&(n=bi(n),null===n||(n=ci.call(n,"constructor")&&n.constructor,typeof n=="function"&&n instanceof n&&fi.call(n)==hi))}function mu(n){return typeof n=="string"||!af(n)&&xu(n)&&"[object String]"==zt(n)}function Au(n){return typeof n=="symbol"||xu(n)&&"[object Symbol]"==zt(n)}function ku(n){if(!n)return[];if(pu(n))return mu(n)?$(n):Mr(n);
    if(Ai&&n[Ai]){n=n[Ai]();for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}return t=yo(n),("[object Map]"==t?L:"[object Set]"==t?D:Du)(n)}function Eu(n){return n?(n=Iu(n),n===N||n===-N?1.7976931348623157e308*(0>n?-1:1):n===n?n:0):0===n?n:0}function Ou(n){n=Eu(n);var t=n%1;return n===n?t?n-t:n:0}function Su(n){return n?gt(Ou(n),0,4294967295):0}function Iu(n){if(typeof n=="number")return n;if(Au(n))return P;if(bu(n)&&(n=typeof n.valueOf=="function"?n.valueOf():n,n=bu(n)?n+"":n),typeof n!="string")return 0===n?n:+n;
    n=n.replace(cn,"");var t=bn.test(n);return t||jn.test(n)?Fn(n.slice(2),t?2:8):yn.test(n)?P:+n}function Ru(n){return Tr(n,Uu(n))}function zu(n){return null==n?"":jr(n)}function Wu(n,t,r){return n=null==n?F:It(n,t),n===F?r:n}function Bu(n,t){return null!=n&&ke(n,t,Lt)}function Lu(n){return pu(n)?Gn(n):Ht(n)}function Uu(n){if(pu(n))n=Gn(n,true);else if(bu(n)){var t,r=Le(n),e=[];for(t in n)("constructor"!=t||!r&&ci.call(n,t))&&e.push(t);n=e}else{if(t=[],null!=n)for(r in ni(n))t.push(r);n=t}return n}function Cu(n,t){
    if(null==n)return{};var r=l(ye(n),function(n){return[n]});return t=je(t),ur(n,r,function(n,r){return t(n,r[0])})}function Du(n){return null==n?[]:I(n,Lu(n))}function Mu(n){return Nf(zu(n).toLowerCase())}function Tu(n){return(n=zu(n))&&n.replace(mn,rt).replace(Rn,"")}function $u(n,t,r){return n=zu(n),t=r?F:t,t===F?Ln.test(n)?n.match(Wn)||[]:n.match(_n)||[]:n.match(t)||[]}function Fu(n){return function(){return n}}function Nu(n){return n}function Pu(n){return Gt(typeof n=="function"?n:dt(n,1))}function Zu(n,t,r){
    var e=Lu(t),i=St(t,e);null!=r||bu(t)&&(i.length||!e.length)||(r=t,t=n,n=this,i=St(t,Lu(t)));var o=!(bu(r)&&"chain"in r&&!r.chain),f=gu(n);return u(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Mr(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,s([this.value()],arguments))})}),n}function qu(){}function Vu(n){return We(n)?j($e(n)):ir(n)}function Ku(){return[]}function Gu(){
    return false}En=null==En?Zn:it.defaults(Zn.Object(),En,it.pick(Zn,Un));var Hu=En.Array,Ju=En.Date,Yu=En.Error,Qu=En.Function,Xu=En.Math,ni=En.Object,ti=En.RegExp,ri=En.String,ei=En.TypeError,ui=Hu.prototype,ii=ni.prototype,oi=En["__core-js_shared__"],fi=Qu.prototype.toString,ci=ii.hasOwnProperty,ai=0,li=function(){var n=/[^.]+$/.exec(oi&&oi.keys&&oi.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),si=ii.toString,hi=fi.call(ni),pi=Zn._,_i=ti("^"+fi.call(ci).replace(on,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),vi=Kn?En.Buffer:F,gi=En.Symbol,di=En.Uint8Array,yi=vi?vi.f:F,bi=U(ni.getPrototypeOf,ni),xi=ni.create,ji=ii.propertyIsEnumerable,wi=ui.splice,mi=gi?gi.isConcatSpreadable:F,Ai=gi?gi.iterator:F,ki=gi?gi.toStringTag:F,Ei=function(){
    try{var n=Ae(ni,"defineProperty");return n({},"",{}),n}catch(n){}}(),Oi=En.clearTimeout!==Zn.clearTimeout&&En.clearTimeout,Si=Ju&&Ju.now!==Zn.Date.now&&Ju.now,Ii=En.setTimeout!==Zn.setTimeout&&En.setTimeout,Ri=Xu.ceil,zi=Xu.floor,Wi=ni.getOwnPropertySymbols,Bi=vi?vi.isBuffer:F,Li=En.isFinite,Ui=ui.join,Ci=U(ni.keys,ni),Di=Xu.max,Mi=Xu.min,Ti=Ju.now,$i=En.parseInt,Fi=Xu.random,Ni=ui.reverse,Pi=Ae(En,"DataView"),Zi=Ae(En,"Map"),qi=Ae(En,"Promise"),Vi=Ae(En,"Set"),Ki=Ae(En,"WeakMap"),Gi=Ae(ni,"create"),Hi=Ki&&new Ki,Ji={},Yi=Fe(Pi),Qi=Fe(Zi),Xi=Fe(qi),no=Fe(Vi),to=Fe(Ki),ro=gi?gi.prototype:F,eo=ro?ro.valueOf:F,uo=ro?ro.toString:F,io=function(){
    function n(){}return function(t){return bu(t)?xi?xi(t):(n.prototype=t,t=new n,n.prototype=F,t):{}}}();On.templateSettings={escape:Q,evaluate:X,interpolate:nn,variable:"",imports:{_:On}},On.prototype=Sn.prototype,On.prototype.constructor=On,zn.prototype=io(Sn.prototype),zn.prototype.constructor=zn,Mn.prototype=io(Sn.prototype),Mn.prototype.constructor=Mn,Tn.prototype.clear=function(){this.__data__=Gi?Gi(null):{},this.size=0},Tn.prototype.delete=function(n){return n=this.has(n)&&delete this.__data__[n],
    this.size-=n?1:0,n},Tn.prototype.get=function(n){var t=this.__data__;return Gi?(n=t[n],"__lodash_hash_undefined__"===n?F:n):ci.call(t,n)?t[n]:F},Tn.prototype.has=function(n){var t=this.__data__;return Gi?t[n]!==F:ci.call(t,n)},Tn.prototype.set=function(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=Gi&&t===F?"__lodash_hash_undefined__":t,this},Nn.prototype.clear=function(){this.__data__=[],this.size=0},Nn.prototype.delete=function(n){var t=this.__data__;return n=lt(t,n),!(0>n)&&(n==t.length-1?t.pop():wi.call(t,n,1),
    --this.size,true)},Nn.prototype.get=function(n){var t=this.__data__;return n=lt(t,n),0>n?F:t[n][1]},Nn.prototype.has=function(n){return-1<lt(this.__data__,n)},Nn.prototype.set=function(n,t){var r=this.__data__,e=lt(r,n);return 0>e?(++this.size,r.push([n,t])):r[e][1]=t,this},Pn.prototype.clear=function(){this.size=0,this.__data__={hash:new Tn,map:new(Zi||Nn),string:new Tn}},Pn.prototype.delete=function(n){return n=we(this,n).delete(n),this.size-=n?1:0,n},Pn.prototype.get=function(n){return we(this,n).get(n);
  },Pn.prototype.has=function(n){return we(this,n).has(n)},Pn.prototype.set=function(n,t){var r=we(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this},qn.prototype.add=qn.prototype.push=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this},qn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.clear=function(){this.__data__=new Nn,this.size=0},Vn.prototype.delete=function(n){var t=this.__data__;return n=t.delete(n),this.size=t.size,n},Vn.prototype.get=function(n){
    return this.__data__.get(n)},Vn.prototype.has=function(n){return this.__data__.has(n)},Vn.prototype.set=function(n,t){var r=this.__data__;if(r instanceof Nn){var e=r.__data__;if(!Zi||199>e.length)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new Pn(e)}return r.set(n,t),this.size=r.size,this};var oo=Zr(Et),fo=Zr(Ot,true),co=qr(),ao=qr(true),lo=Hi?function(n,t){return Hi.set(n,t),n}:Nu,so=Ei?function(n,t){return Ei(n,"toString",{configurable:true,enumerable:false,value:Fu(t),writable:true})}:Nu,ho=Oi||function(n){
      return Zn.clearTimeout(n)},po=Vi&&1/D(new Vi([,-0]))[1]==N?function(n){return new Vi(n)}:qu,_o=Hi?function(n){return Hi.get(n)}:qu,vo=Wi?function(n){return null==n?[]:(n=ni(n),f(Wi(n),function(t){return ji.call(n,t)}))}:Ku,go=Wi?function(n){for(var t=[];n;)s(t,vo(n)),n=bi(n);return t}:Ku,yo=zt;(Pi&&"[object DataView]"!=yo(new Pi(new ArrayBuffer(1)))||Zi&&"[object Map]"!=yo(new Zi)||qi&&"[object Promise]"!=yo(qi.resolve())||Vi&&"[object Set]"!=yo(new Vi)||Ki&&"[object WeakMap]"!=yo(new Ki))&&(yo=function(n){
    var t=zt(n);if(n=(n="[object Object]"==t?n.constructor:F)?Fe(n):"")switch(n){case Yi:return"[object DataView]";case Qi:return"[object Map]";case Xi:return"[object Promise]";case no:return"[object Set]";case to:return"[object WeakMap]"}return t});var bo=oi?gu:Gu,xo=Me(lo),jo=Ii||function(n,t){return Zn.setTimeout(n,t)},wo=Me(so),mo=function(n){n=lu(n,function(n){return 500===t.size&&t.clear(),n});var t=n.cache;return n}(function(n){var t=[];return en.test(n)&&t.push(""),n.replace(un,function(n,r,e,u){
    t.push(e?u.replace(vn,"$1"):r||n)}),t}),Ao=lr(function(n,t){return _u(n)?jt(n,kt(t,1,_u,true)):[]}),ko=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),je(r,2)):[]}),Eo=lr(function(n,t){var r=Ge(t);return _u(r)&&(r=F),_u(n)?jt(n,kt(t,1,_u,true),F,r):[]}),Oo=lr(function(n){var t=l(n,Sr);return t.length&&t[0]===n[0]?Ut(t):[]}),So=lr(function(n){var t=Ge(n),r=l(n,Sr);return t===Ge(r)?t=F:r.pop(),r.length&&r[0]===n[0]?Ut(r,je(t,2)):[]}),Io=lr(function(n){var t=Ge(n),r=l(n,Sr);return(t=typeof t=="function"?t:F)&&r.pop(),
    r.length&&r[0]===n[0]?Ut(r,F,t):[]}),Ro=lr(He),zo=ge(function(n,t){var r=null==n?0:n.length,e=vt(n,t);return fr(n,l(t,function(n){return Re(n,r)?+n:n}).sort(Ur)),e}),Wo=lr(function(n){return wr(kt(n,1,_u,true))}),Bo=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),wr(kt(n,1,_u,true),je(t,2))}),Lo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return wr(kt(n,1,_u,true),F,t)}),Uo=lr(function(n,t){return _u(n)?jt(n,t):[]}),Co=lr(function(n){return Er(f(n,_u))}),Do=lr(function(n){var t=Ge(n);return _u(t)&&(t=F),
    Er(f(n,_u),je(t,2))}),Mo=lr(function(n){var t=Ge(n),t=typeof t=="function"?t:F;return Er(f(n,_u),F,t)}),To=lr(Ye),$o=lr(function(n){var t=n.length,t=1<t?n[t-1]:F,t=typeof t=="function"?(n.pop(),t):F;return Qe(n,t)}),Fo=ge(function(n){function t(t){return vt(t,n)}var r=n.length,e=r?n[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Mn&&Re(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(u,this.__chain__).thru(function(n){return r&&!n.length&&n.push(F),
                                                                                                                                                                                                                                                                                                                                                                                       n})):this.thru(t)}),No=Nr(function(n,t,r){ci.call(n,r)?++n[r]:_t(n,r,1)}),Po=Yr(Ze),Zo=Yr(qe),qo=Nr(function(n,t,r){ci.call(n,r)?n[r].push(t):_t(n,r,[t])}),Vo=lr(function(n,t,e){var u=-1,i=typeof t=="function",o=pu(n)?Hu(n.length):[];return oo(n,function(n){o[++u]=i?r(t,n,e):Dt(n,t,e)}),o}),Ko=Nr(function(n,t,r){_t(n,r,t)}),Go=Nr(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),Ho=lr(function(n,t){if(null==n)return[];var r=t.length;return 1<r&&ze(n,t[0],t[1])?t=[]:2<r&&ze(t[0],t[1],t[2])&&(t=[t[0]]),
    rr(n,kt(t,1),[])}),Jo=Si||function(){return Zn.Date.now()},Yo=lr(function(n,t,r){var e=1;if(r.length)var u=C(r,xe(Yo)),e=32|e;return le(n,e,t,r,u)}),Qo=lr(function(n,t,r){var e=3;if(r.length)var u=C(r,xe(Qo)),e=32|e;return le(t,e,n,r,u)}),Xo=lr(function(n,t){return xt(n,1,t)}),nf=lr(function(n,t,r){return xt(n,Iu(t)||0,r)});lu.Cache=Pn;var tf=lr(function(n,t){t=1==t.length&&af(t[0])?l(t[0],S(je())):l(kt(t,1),S(je()));var e=t.length;return lr(function(u){for(var i=-1,o=Mi(u.length,e);++i<o;)u[i]=t[i].call(this,u[i]);
    return r(n,this,u)})}),rf=lr(function(n,t){return le(n,32,F,t,C(t,xe(rf)))}),ef=lr(function(n,t){return le(n,64,F,t,C(t,xe(ef)))}),uf=ge(function(n,t){return le(n,256,F,F,F,t)}),of=oe(Wt),ff=oe(function(n,t){return n>=t}),cf=Mt(function(){return arguments}())?Mt:function(n){return xu(n)&&ci.call(n,"callee")&&!ji.call(n,"callee")},af=Hu.isArray,lf=Hn?S(Hn):Tt,sf=Bi||Gu,hf=Jn?S(Jn):$t,pf=Yn?S(Yn):Nt,_f=Qn?S(Qn):qt,vf=Xn?S(Xn):Vt,gf=nt?S(nt):Kt,df=oe(Jt),yf=oe(function(n,t){return n<=t}),bf=Pr(function(n,t){
    if(Le(t)||pu(t))Tr(t,Lu(t),n);else for(var r in t)ci.call(t,r)&&at(n,r,t[r])}),xf=Pr(function(n,t){Tr(t,Uu(t),n)}),jf=Pr(function(n,t,r,e){Tr(t,Uu(t),n,e)}),wf=Pr(function(n,t,r,e){Tr(t,Lu(t),n,e)}),mf=ge(vt),Af=lr(function(n){return n.push(F,se),r(jf,F,n)}),kf=lr(function(n){return n.push(F,he),r(Rf,F,n)}),Ef=ne(function(n,t,r){n[t]=r},Fu(Nu)),Of=ne(function(n,t,r){ci.call(n,t)?n[t].push(r):n[t]=[r]},je),Sf=lr(Dt),If=Pr(function(n,t,r){nr(n,t,r)}),Rf=Pr(function(n,t,r,e){nr(n,t,r,e)}),zf=ge(function(n,t){
    var r={};if(null==n)return r;var e=false;t=l(t,function(t){return t=Rr(t,n),e||(e=1<t.length),t}),Tr(n,ye(n),r),e&&(r=dt(r,7,pe));for(var u=t.length;u--;)mr(r,t[u]);return r}),Wf=ge(function(n,t){return null==n?{}:er(n,t)}),Bf=ae(Lu),Lf=ae(Uu),Uf=Gr(function(n,t,r){return t=t.toLowerCase(),n+(r?Mu(t):t)}),Cf=Gr(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Df=Gr(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Mf=Kr("toLowerCase"),Tf=Gr(function(n,t,r){return n+(r?"_":"")+t.toLowerCase();
  }),$f=Gr(function(n,t,r){return n+(r?" ":"")+Nf(t)}),Ff=Gr(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Nf=Kr("toUpperCase"),Pf=lr(function(n,t){try{return r(n,F,t)}catch(n){return vu(n)?n:new Yu(n)}}),Zf=ge(function(n,t){return u(t,function(t){t=$e(t),_t(n,t,Yo(n[t],n))}),n}),qf=Qr(),Vf=Qr(true),Kf=lr(function(n,t){return function(r){return Dt(r,n,t)}}),Gf=lr(function(n,t){return function(r){return Dt(n,r,t)}}),Hf=re(l),Jf=re(o),Yf=re(_),Qf=ie(),Xf=ie(true),nc=te(function(n,t){return n+t},0),tc=ce("ceil"),rc=te(function(n,t){
    return n/t},1),ec=ce("floor"),uc=te(function(n,t){return n*t},1),ic=ce("round"),oc=te(function(n,t){return n-t},0);return On.after=function(n,t){if(typeof t!="function")throw new ei("Expected a function");return n=Ou(n),function(){if(1>--n)return t.apply(this,arguments)}},On.ary=iu,On.assign=bf,On.assignIn=xf,On.assignInWith=jf,On.assignWith=wf,On.at=mf,On.before=ou,On.bind=Yo,On.bindAll=Zf,On.bindKey=Qo,On.castArray=function(){if(!arguments.length)return[];var n=arguments[0];return af(n)?n:[n]},
    On.chain=Xe,On.chunk=function(n,t,r){if(t=(r?ze(n,t,r):t===F)?1:Di(Ou(t),0),r=null==n?0:n.length,!r||1>t)return[];for(var e=0,u=0,i=Hu(Ri(r/t));e<r;)i[u++]=vr(n,e,e+=t);return i},On.compact=function(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u},On.concat=function(){var n=arguments.length;if(!n)return[];for(var t=Hu(n-1),r=arguments[0];n--;)t[n-1]=arguments[n];return s(af(r)?Mr(r):[r],kt(t,1))},On.cond=function(n){var t=null==n?0:n.length,e=je();return n=t?l(n,function(n){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if("function"!=typeof n[1])throw new ei("Expected a function");return[e(n[0]),n[1]]}):[],lr(function(e){for(var u=-1;++u<t;){var i=n[u];if(r(i[0],this,e))return r(i[1],this,e)}})},On.conforms=function(n){return yt(dt(n,1))},On.constant=Fu,On.countBy=No,On.create=function(n,t){var r=io(n);return null==t?r:ht(r,t)},On.curry=fu,On.curryRight=cu,On.debounce=au,On.defaults=Af,On.defaultsDeep=kf,On.defer=Xo,On.delay=nf,On.difference=Ao,On.differenceBy=ko,On.differenceWith=Eo,On.drop=function(n,t,r){var e=null==n?0:n.length;
    return e?(t=r||t===F?1:Ou(t),vr(n,0>t?0:t,e)):[]},On.dropRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0,0>t?0:t)):[]},On.dropRightWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true,true):[]},On.dropWhile=function(n,t){return n&&n.length?Ar(n,je(t,3),true):[]},On.fill=function(n,t,r,e){var u=null==n?0:n.length;if(!u)return[];for(r&&typeof r!="number"&&ze(n,t,r)&&(r=0,e=u),u=n.length,r=Ou(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:Ou(e),0>e&&(e+=u),e=r>e?0:Su(e);r<e;)n[r++]=t;
    return n},On.filter=function(n,t){return(af(n)?f:At)(n,je(t,3))},On.flatMap=function(n,t){return kt(uu(n,t),1)},On.flatMapDeep=function(n,t){return kt(uu(n,t),N)},On.flatMapDepth=function(n,t,r){return r=r===F?1:Ou(r),kt(uu(n,t),r)},On.flatten=Ve,On.flattenDeep=function(n){return(null==n?0:n.length)?kt(n,N):[]},On.flattenDepth=function(n,t){return null!=n&&n.length?(t=t===F?1:Ou(t),kt(n,t)):[]},On.flip=function(n){return le(n,512)},On.flow=qf,On.flowRight=Vf,On.fromPairs=function(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){
    var u=n[t];e[u[0]]=u[1]}return e},On.functions=function(n){return null==n?[]:St(n,Lu(n))},On.functionsIn=function(n){return null==n?[]:St(n,Uu(n))},On.groupBy=qo,On.initial=function(n){return(null==n?0:n.length)?vr(n,0,-1):[]},On.intersection=Oo,On.intersectionBy=So,On.intersectionWith=Io,On.invert=Ef,On.invertBy=Of,On.invokeMap=Vo,On.iteratee=Pu,On.keyBy=Ko,On.keys=Lu,On.keysIn=Uu,On.map=uu,On.mapKeys=function(n,t){var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,t(n,e,u),n)}),r},On.mapValues=function(n,t){
    var r={};return t=je(t,3),Et(n,function(n,e,u){_t(r,e,t(n,e,u))}),r},On.matches=function(n){return Qt(dt(n,1))},On.matchesProperty=function(n,t){return Xt(n,dt(t,1))},On.memoize=lu,On.merge=If,On.mergeWith=Rf,On.method=Kf,On.methodOf=Gf,On.mixin=Zu,On.negate=su,On.nthArg=function(n){return n=Ou(n),lr(function(t){return tr(t,n)})},On.omit=zf,On.omitBy=function(n,t){return Cu(n,su(je(t)))},On.once=function(n){return ou(2,n)},On.orderBy=function(n,t,r,e){return null==n?[]:(af(t)||(t=null==t?[]:[t]),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            r=e?F:r,af(r)||(r=null==r?[]:[r]),rr(n,t,r))},On.over=Hf,On.overArgs=tf,On.overEvery=Jf,On.overSome=Yf,On.partial=rf,On.partialRight=ef,On.partition=Go,On.pick=Wf,On.pickBy=Cu,On.property=Vu,On.propertyOf=function(n){return function(t){return null==n?F:It(n,t)}},On.pull=Ro,On.pullAll=He,On.pullAllBy=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,je(r,2)):n},On.pullAllWith=function(n,t,r){return n&&n.length&&t&&t.length?or(n,t,F,r):n},On.pullAt=zo,On.range=Qf,On.rangeRight=Xf,On.rearg=uf,On.reject=function(n,t){
    return(af(n)?f:At)(n,su(je(t,3)))},On.remove=function(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=je(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return fr(n,u),r},On.rest=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=t===F?t:Ou(t),lr(n,t)},On.reverse=Je,On.sampleSize=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),(af(n)?ot:hr)(n,t)},On.set=function(n,t,r){return null==n?n:pr(n,t,r)},On.setWith=function(n,t,r,e){return e=typeof e=="function"?e:F,
    null==n?n:pr(n,t,r,e)},On.shuffle=function(n){return(af(n)?ft:_r)(n)},On.slice=function(n,t,r){var e=null==n?0:n.length;return e?(r&&typeof r!="number"&&ze(n,t,r)?(t=0,r=e):(t=null==t?0:Ou(t),r=r===F?e:Ou(r)),vr(n,t,r)):[]},On.sortBy=Ho,On.sortedUniq=function(n){return n&&n.length?br(n):[]},On.sortedUniqBy=function(n,t){return n&&n.length?br(n,je(t,2)):[]},On.split=function(n,t,r){return r&&typeof r!="number"&&ze(n,t,r)&&(t=r=F),r=r===F?4294967295:r>>>0,r?(n=zu(n))&&(typeof t=="string"||null!=t&&!_f(t))&&(t=jr(t),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                !t&&Bn.test(n))?zr($(n),0,r):n.split(t,r):[]},On.spread=function(n,t){if(typeof n!="function")throw new ei("Expected a function");return t=null==t?0:Di(Ou(t),0),lr(function(e){var u=e[t];return e=zr(e,0,t),u&&s(e,u),r(n,this,e)})},On.tail=function(n){var t=null==n?0:n.length;return t?vr(n,1,t):[]},On.take=function(n,t,r){return n&&n.length?(t=r||t===F?1:Ou(t),vr(n,0,0>t?0:t)):[]},On.takeRight=function(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===F?1:Ou(t),t=e-t,vr(n,0>t?0:t,e)):[]},On.takeRightWhile=function(n,t){
    return n&&n.length?Ar(n,je(t,3),false,true):[]},On.takeWhile=function(n,t){return n&&n.length?Ar(n,je(t,3)):[]},On.tap=function(n,t){return t(n),n},On.throttle=function(n,t,r){var e=true,u=true;if(typeof n!="function")throw new ei("Expected a function");return bu(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),au(n,t,{leading:e,maxWait:t,trailing:u})},On.thru=nu,On.toArray=ku,On.toPairs=Bf,On.toPairsIn=Lf,On.toPath=function(n){return af(n)?l(n,$e):Au(n)?[n]:Mr(mo(zu(n)))},On.toPlainObject=Ru,
    On.transform=function(n,t,r){var e=af(n),i=e||sf(n)||gf(n);if(t=je(t,4),null==r){var o=n&&n.constructor;r=i?e?new o:[]:bu(n)&&gu(o)?io(bi(n)):{}}return(i?u:Et)(n,function(n,e,u){return t(r,n,e,u)}),r},On.unary=function(n){return iu(n,1)},On.union=Wo,On.unionBy=Bo,On.unionWith=Lo,On.uniq=function(n){return n&&n.length?wr(n):[]},On.uniqBy=function(n,t){return n&&n.length?wr(n,je(t,2)):[]},On.uniqWith=function(n,t){return t=typeof t=="function"?t:F,n&&n.length?wr(n,F,t):[]},On.unset=function(n,t){return null==n||mr(n,t);
    },On.unzip=Ye,On.unzipWith=Qe,On.update=function(n,t,r){return null==n?n:pr(n,t,Ir(r)(It(n,t)),void 0)},On.updateWith=function(n,t,r,e){return e=typeof e=="function"?e:F,null!=n&&(n=pr(n,t,Ir(r)(It(n,t)),e)),n},On.values=Du,On.valuesIn=function(n){return null==n?[]:I(n,Uu(n))},On.without=Uo,On.words=$u,On.wrap=function(n,t){return rf(Ir(t),n)},On.xor=Co,On.xorBy=Do,On.xorWith=Mo,On.zip=To,On.zipObject=function(n,t){return Or(n||[],t||[],at)},On.zipObjectDeep=function(n,t){return Or(n||[],t||[],pr);
    },On.zipWith=$o,On.entries=Bf,On.entriesIn=Lf,On.extend=xf,On.extendWith=jf,Zu(On,On),On.add=nc,On.attempt=Pf,On.camelCase=Uf,On.capitalize=Mu,On.ceil=tc,On.clamp=function(n,t,r){return r===F&&(r=t,t=F),r!==F&&(r=Iu(r),r=r===r?r:0),t!==F&&(t=Iu(t),t=t===t?t:0),gt(Iu(n),t,r)},On.clone=function(n){return dt(n,4)},On.cloneDeep=function(n){return dt(n,5)},On.cloneDeepWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,5,t)},On.cloneWith=function(n,t){return t=typeof t=="function"?t:F,dt(n,4,t)},
    On.conformsTo=function(n,t){return null==t||bt(n,t,Lu(t))},On.deburr=Tu,On.defaultTo=function(n,t){return null==n||n!==n?t:n},On.divide=rc,On.endsWith=function(n,t,r){n=zu(n),t=jr(t);var e=n.length,e=r=r===F?e:gt(Ou(r),0,e);return r-=t.length,0<=r&&n.slice(r,e)==t},On.eq=hu,On.escape=function(n){return(n=zu(n))&&Y.test(n)?n.replace(H,et):n},On.escapeRegExp=function(n){return(n=zu(n))&&fn.test(n)?n.replace(on,"\\$&"):n},On.every=function(n,t,r){var e=af(n)?o:wt;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3));
    },On.find=Po,On.findIndex=Ze,On.findKey=function(n,t){return v(n,je(t,3),Et)},On.findLast=Zo,On.findLastIndex=qe,On.findLastKey=function(n,t){return v(n,je(t,3),Ot)},On.floor=ec,On.forEach=ru,On.forEachRight=eu,On.forIn=function(n,t){return null==n?n:co(n,je(t,3),Uu)},On.forInRight=function(n,t){return null==n?n:ao(n,je(t,3),Uu)},On.forOwn=function(n,t){return n&&Et(n,je(t,3))},On.forOwnRight=function(n,t){return n&&Ot(n,je(t,3))},On.get=Wu,On.gt=of,On.gte=ff,On.has=function(n,t){return null!=n&&ke(n,t,Bt);
    },On.hasIn=Bu,On.head=Ke,On.identity=Nu,On.includes=function(n,t,r,e){return n=pu(n)?n:Du(n),r=r&&!e?Ou(r):0,e=n.length,0>r&&(r=Di(e+r,0)),mu(n)?r<=e&&-1<n.indexOf(t,r):!!e&&-1<d(n,t,r)},On.indexOf=function(n,t,r){var e=null==n?0:n.length;return e?(r=null==r?0:Ou(r),0>r&&(r=Di(e+r,0)),d(n,t,r)):-1},On.inRange=function(n,t,r){return t=Eu(t),r===F?(r=t,t=0):r=Eu(r),n=Iu(n),n>=Mi(t,r)&&n<Di(t,r)},On.invoke=Sf,On.isArguments=cf,On.isArray=af,On.isArrayBuffer=lf,On.isArrayLike=pu,On.isArrayLikeObject=_u,
    On.isBoolean=function(n){return true===n||false===n||xu(n)&&"[object Boolean]"==zt(n)},On.isBuffer=sf,On.isDate=hf,On.isElement=function(n){return xu(n)&&1===n.nodeType&&!wu(n)},On.isEmpty=function(n){if(null==n)return true;if(pu(n)&&(af(n)||typeof n=="string"||typeof n.splice=="function"||sf(n)||gf(n)||cf(n)))return!n.length;var t=yo(n);if("[object Map]"==t||"[object Set]"==t)return!n.size;if(Le(n))return!Ht(n).length;for(var r in n)if(ci.call(n,r))return false;return true},On.isEqual=function(n,t){return Ft(n,t);
    },On.isEqualWith=function(n,t,r){var e=(r=typeof r=="function"?r:F)?r(n,t):F;return e===F?Ft(n,t,F,r):!!e},On.isError=vu,On.isFinite=function(n){return typeof n=="number"&&Li(n)},On.isFunction=gu,On.isInteger=du,On.isLength=yu,On.isMap=pf,On.isMatch=function(n,t){return n===t||Pt(n,t,me(t))},On.isMatchWith=function(n,t,r){return r=typeof r=="function"?r:F,Pt(n,t,me(t),r)},On.isNaN=function(n){return ju(n)&&n!=+n},On.isNative=function(n){if(bo(n))throw new Yu("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
      return Zt(n)},On.isNil=function(n){return null==n},On.isNull=function(n){return null===n},On.isNumber=ju,On.isObject=bu,On.isObjectLike=xu,On.isPlainObject=wu,On.isRegExp=_f,On.isSafeInteger=function(n){return du(n)&&-9007199254740991<=n&&9007199254740991>=n},On.isSet=vf,On.isString=mu,On.isSymbol=Au,On.isTypedArray=gf,On.isUndefined=function(n){return n===F},On.isWeakMap=function(n){return xu(n)&&"[object WeakMap]"==yo(n)},On.isWeakSet=function(n){return xu(n)&&"[object WeakSet]"==zt(n)},On.join=function(n,t){
      return null==n?"":Ui.call(n,t)},On.kebabCase=Cf,On.last=Ge,On.lastIndexOf=function(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;if(r!==F&&(u=Ou(r),u=0>u?Di(e+u,0):Mi(u,e-1)),t===t){for(r=u+1;r--&&n[r]!==t;);n=r}else n=g(n,b,u,true);return n},On.lowerCase=Df,On.lowerFirst=Mf,On.lt=df,On.lte=yf,On.max=function(n){return n&&n.length?mt(n,Nu,Wt):F},On.maxBy=function(n,t){return n&&n.length?mt(n,je(t,2),Wt):F},On.mean=function(n){return x(n,Nu)},On.meanBy=function(n,t){return x(n,je(t,2))},On.min=function(n){
      return n&&n.length?mt(n,Nu,Jt):F},On.minBy=function(n,t){return n&&n.length?mt(n,je(t,2),Jt):F},On.stubArray=Ku,On.stubFalse=Gu,On.stubObject=function(){return{}},On.stubString=function(){return""},On.stubTrue=function(){return true},On.multiply=uc,On.nth=function(n,t){return n&&n.length?tr(n,Ou(t)):F},On.noConflict=function(){return Zn._===this&&(Zn._=pi),this},On.noop=qu,On.now=Jo,On.pad=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return!t||e>=t?n:(t=(t-e)/2,ee(zi(t),r)+n+ee(Ri(t),r))},On.padEnd=function(n,t,r){
      n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?n+ee(t-e,r):n},On.padStart=function(n,t,r){n=zu(n);var e=(t=Ou(t))?T(n):0;return t&&e<t?ee(t-e,r)+n:n},On.parseInt=function(n,t,r){return r||null==t?t=0:t&&(t=+t),$i(zu(n).replace(an,""),t||0)},On.random=function(n,t,r){if(r&&typeof r!="boolean"&&ze(n,t,r)&&(t=r=F),r===F&&(typeof t=="boolean"?(r=t,t=F):typeof n=="boolean"&&(r=n,n=F)),n===F&&t===F?(n=0,t=1):(n=Eu(n),t===F?(t=n,n=0):t=Eu(t)),n>t){var e=n;n=t,t=e}return r||n%1||t%1?(r=Fi(),Mi(n+r*(t-n+$n("1e-"+((r+"").length-1))),t)):cr(n,t);
    },On.reduce=function(n,t,r){var e=af(n)?h:m,u=3>arguments.length;return e(n,je(t,4),r,u,oo)},On.reduceRight=function(n,t,r){var e=af(n)?p:m,u=3>arguments.length;return e(n,je(t,4),r,u,fo)},On.repeat=function(n,t,r){return t=(r?ze(n,t,r):t===F)?1:Ou(t),ar(zu(n),t)},On.replace=function(){var n=arguments,t=zu(n[0]);return 3>n.length?t:t.replace(n[1],n[2])},On.result=function(n,t,r){t=Rr(t,n);var e=-1,u=t.length;for(u||(u=1,n=F);++e<u;){var i=null==n?F:n[$e(t[e])];i===F&&(e=u,i=r),n=gu(i)?i.call(n):i;
    }return n},On.round=ic,On.runInContext=w,On.sample=function(n){return(af(n)?tt:sr)(n)},On.size=function(n){if(null==n)return 0;if(pu(n))return mu(n)?T(n):n.length;var t=yo(n);return"[object Map]"==t||"[object Set]"==t?n.size:Ht(n).length},On.snakeCase=Tf,On.some=function(n,t,r){var e=af(n)?_:gr;return r&&ze(n,t,r)&&(t=F),e(n,je(t,3))},On.sortedIndex=function(n,t){return dr(n,t)},On.sortedIndexBy=function(n,t,r){return yr(n,t,je(r,2))},On.sortedIndexOf=function(n,t){var r=null==n?0:n.length;if(r){
      var e=dr(n,t);if(e<r&&hu(n[e],t))return e}return-1},On.sortedLastIndex=function(n,t){return dr(n,t,true)},On.sortedLastIndexBy=function(n,t,r){return yr(n,t,je(r,2),true)},On.sortedLastIndexOf=function(n,t){if(null==n?0:n.length){var r=dr(n,t,true)-1;if(hu(n[r],t))return r}return-1},On.startCase=$f,On.startsWith=function(n,t,r){return n=zu(n),r=null==r?0:gt(Ou(r),0,n.length),t=jr(t),n.slice(r,r+t.length)==t},On.subtract=oc,On.sum=function(n){return n&&n.length?k(n,Nu):0},On.sumBy=function(n,t){return n&&n.length?k(n,je(t,2)):0;
    },On.template=function(n,t,r){var e=On.templateSettings;r&&ze(n,t,r)&&(t=F),n=zu(n),t=jf({},t,e,se),r=jf({},t.imports,e.imports,se);var u,i,o=Lu(r),f=I(r,o),c=0;r=t.interpolate||An;var a="__p+='";r=ti((t.escape||An).source+"|"+r.source+"|"+(r===nn?gn:An).source+"|"+(t.evaluate||An).source+"|$","g");var l="sourceURL"in t?"//# sourceURL="+t.sourceURL+"\n":"";if(n.replace(r,function(t,r,e,o,f,l){return e||(e=o),a+=n.slice(c,l).replace(kn,B),r&&(u=true,a+="'+__e("+r+")+'"),f&&(i=true,a+="';"+f+";\n__p+='"),
      e&&(a+="'+((__t=("+e+"))==null?'':__t)+'"),c=l+t.length,t}),a+="';",(t=t.variable)||(a="with(obj){"+a+"}"),a=(i?a.replace(q,""):a).replace(V,"$1").replace(K,"$1;"),a="function("+(t||"obj")+"){"+(t?"":"obj||(obj={});")+"var __t,__p=''"+(u?",__e=_.escape":"")+(i?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}":";")+a+"return __p}",t=Pf(function(){return Qu(o,l+"return "+a).apply(F,f)}),t.source=a,vu(t))throw t;return t},On.times=function(n,t){if(n=Ou(n),1>n||9007199254740991<n)return[];
      var r=4294967295,e=Mi(n,4294967295);for(t=je(t),n-=4294967295,e=E(e,t);++r<n;)t(r);return e},On.toFinite=Eu,On.toInteger=Ou,On.toLength=Su,On.toLower=function(n){return zu(n).toLowerCase()},On.toNumber=Iu,On.toSafeInteger=function(n){return n?gt(Ou(n),-9007199254740991,9007199254740991):0===n?n:0},On.toString=zu,On.toUpper=function(n){return zu(n).toUpperCase()},On.trim=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(cn,""):n&&(t=jr(t))?(n=$(n),r=$(t),t=z(n,r),r=W(n,r)+1,zr(n,t,r).join("")):n;
    },On.trimEnd=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(ln,""):n&&(t=jr(t))?(n=$(n),t=W(n,$(t))+1,zr(n,0,t).join("")):n},On.trimStart=function(n,t,r){return(n=zu(n))&&(r||t===F)?n.replace(an,""):n&&(t=jr(t))?(n=$(n),t=z(n,$(t)),zr(n,t).join("")):n},On.truncate=function(n,t){var r=30,e="...";if(bu(t))var u="separator"in t?t.separator:u,r="length"in t?Ou(t.length):r,e="omission"in t?jr(t.omission):e;n=zu(n);var i=n.length;if(Bn.test(n))var o=$(n),i=o.length;if(r>=i)return n;if(i=r-T(e),1>i)return e;
      if(r=o?zr(o,0,i).join(""):n.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),_f(u)){if(n.slice(i).search(u)){var f=r;for(u.global||(u=ti(u.source,zu(dn.exec(u))+"g")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else n.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},On.unescape=function(n){return(n=zu(n))&&J.test(n)?n.replace(G,ut):n},On.uniqueId=function(n){var t=++ai;return zu(n)+t},On.upperCase=Ff,On.upperFirst=Nf,On.each=ru,On.eachRight=eu,On.first=Ke,
    Zu(On,function(){var n={};return Et(On,function(t,r){ci.call(On.prototype,r)||(n[r]=t)}),n}(),{chain:false}),On.VERSION="4.17.4",u("bind bindKey curry curryRight partial partialRight".split(" "),function(n){On[n].placeholder=On}),u(["drop","take"],function(n,t){Mn.prototype[n]=function(r){r=r===F?1:Di(Ou(r),0);var e=this.__filtered__&&!t?new Mn(this):this.clone();return e.__filtered__?e.__takeCount__=Mi(r,e.__takeCount__):e.__views__.push({size:Mi(r,4294967295),type:n+(0>e.__dir__?"Right":"")}),e},Mn.prototype[n+"Right"]=function(t){
      return this.reverse()[n](t).reverse()}}),u(["filter","map","takeWhile"],function(n,t){var r=t+1,e=1==r||3==r;Mn.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:je(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),u(["head","last"],function(n,t){var r="take"+(t?"Right":"");Mn.prototype[n]=function(){return this[r](1).value()[0]}}),u(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Mn.prototype[n]=function(){return this.__filtered__?new Mn(this):this[r](1);
    }}),Mn.prototype.compact=function(){return this.filter(Nu)},Mn.prototype.find=function(n){return this.filter(n).head()},Mn.prototype.findLast=function(n){return this.reverse().find(n)},Mn.prototype.invokeMap=lr(function(n,t){return typeof n=="function"?new Mn(this):this.map(function(r){return Dt(r,n,t)})}),Mn.prototype.reject=function(n){return this.filter(su(je(n)))},Mn.prototype.slice=function(n,t){n=Ou(n);var r=this;return r.__filtered__&&(0<n||0>t)?new Mn(r):(0>n?r=r.takeRight(-n):n&&(r=r.drop(n)),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            t!==F&&(t=Ou(t),r=0>t?r.dropRight(-t):r.take(t-n)),r)},Mn.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Mn.prototype.toArray=function(){return this.take(4294967295)},Et(Mn.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=On[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);u&&(On.prototype[t]=function(){function t(n){return n=u.apply(On,s([n],f)),e&&h?n[0]:n}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Mn,a=f[0],l=c||af(o);
      l&&r&&typeof a=="function"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Mn(this),o=n.apply(o,f),o.__actions__.push({func:nu,args:[t],thisArg:F}),new zn(o,h)):a&&c?n.apply(this,f):(o=this.thru(t),a?e?o.value()[0]:o.value():o)})}),u("pop push shift sort splice unshift".split(" "),function(n){var t=ui[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);On.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){
      var u=this.value();return t.apply(af(u)?u:[],n)}return this[r](function(r){return t.apply(af(r)?r:[],n)})}}),Et(Mn.prototype,function(n,t){var r=On[t];if(r){var e=r.name+"";(Ji[e]||(Ji[e]=[])).push({name:t,func:r})}}),Ji[Xr(F,2).name]=[{name:"wrapper",func:F}],Mn.prototype.clone=function(){var n=new Mn(this.__wrapped__);return n.__actions__=Mr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Mr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Mr(this.__views__),
      n},Mn.prototype.reverse=function(){if(this.__filtered__){var n=new Mn(this);n.__dir__=-1,n.__filtered__=true}else n=this.clone(),n.__dir__*=-1;return n},Mn.prototype.value=function(){var n,t=this.__wrapped__.value(),r=this.__dir__,e=af(t),u=0>r,i=e?t.length:0;n=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case"drop":f+=s;break;case"dropRight":n-=s;break;case"take":n=Mi(n,f+s);break;case"takeRight":f=Di(f,n-s)}}if(n={start:f,end:n},o=n.start,f=n.end,n=f-o,
        o=u?f:o-1,f=this.__iteratees__,c=f.length,a=0,l=Mi(n,this.__takeCount__),!e||!u&&i==n&&l==n)return kr(t,this.__actions__);e=[];n:for(;n--&&a<l;){for(o+=r,u=-1,i=t[o];++u<c;){var h=f[u],s=h.type,h=(0,h.iteratee)(i);if(2==s)i=h;else if(!h){if(1==s)continue n;break n}}e[a++]=i}return e},On.prototype.at=Fo,On.prototype.chain=function(){return Xe(this)},On.prototype.commit=function(){return new zn(this.value(),this.__chain__)},On.prototype.next=function(){this.__values__===F&&(this.__values__=ku(this.value()));
      var n=this.__index__>=this.__values__.length;return{done:n,value:n?F:this.__values__[this.__index__++]}},On.prototype.plant=function(n){for(var t,r=this;r instanceof Sn;){var e=Pe(r);e.__index__=0,e.__values__=F,t?u.__wrapped__=e:t=e;var u=e,r=r.__wrapped__}return u.__wrapped__=n,t},On.prototype.reverse=function(){var n=this.__wrapped__;return n instanceof Mn?(this.__actions__.length&&(n=new Mn(this)),n=n.reverse(),n.__actions__.push({func:nu,args:[Je],thisArg:F}),new zn(n,this.__chain__)):this.thru(Je);
    },On.prototype.toJSON=On.prototype.valueOf=On.prototype.value=function(){return kr(this.__wrapped__,this.__actions__)},On.prototype.first=On.prototype.head,Ai&&(On.prototype[Ai]=tu),On}();typeof define=="function"&&typeof define.amd=="object"&&define.amd?(Zn._=it, define('../../sherpa/lib/lodash-4.17.4.min',[],function(){return it})):Vn?((Vn.exports=it)._=it,qn._=it):Zn._=it}).call(this);
define('text',['module'], function (module) {
  'use strict';
  var text, fs, Cc, Ci, xpcIsWindows,
    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
    xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
    bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
    hasLocation = typeof location !== 'undefined' && location.href,
    defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
    defaultHostName = hasLocation && location.hostname,
    defaultPort = hasLocation && (location.port || undefined),
    buildMap = {},
    masterConfig = (module.config && module.config()) || {};
  text = {
    version: '2.0.12',
    strip: function (content) {
      if (content) {
        content = content.replace(xmlRegExp, "");
        var matches = content.match(bodyRegExp);
        if (matches) {
          content = matches[1];
        }
      } else {
        content = "";
      }
      return content;
    },
    jsEscape: function (content) {
      return content.replace(/(['\\])/g, '\\$1')
        .replace(/[\f]/g, "\\f")
        .replace(/[\b]/g, "\\b")
        .replace(/[\n]/g, "\\n")
        .replace(/[\t]/g, "\\t")
        .replace(/[\r]/g, "\\r")
        .replace(/[\u2028]/g, "\\u2028")
        .replace(/[\u2029]/g, "\\u2029");
    },
    createXhr: masterConfig.createXhr || function () {
      var xhr, i, progId;
      if (typeof XMLHttpRequest !== "undefined") {
        return new XMLHttpRequest();
      } else if (typeof ActiveXObject !== "undefined") {
        for (i = 0; i < 3; i += 1) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          } catch (e) {}
          if (xhr) {
            progIds = [progId];  // so faster next time
            break;
          }
        }
      }
      return xhr;
    },
    parseName: function (name) {
      var modName, ext, temp,
        strip = false,
        index = name.indexOf("."),
        isRelative = name.indexOf('./') === 0 ||
                     name.indexOf('../') === 0;
      if (index !== -1 && (!isRelative || index > 1)) {
        modName = name.substring(0, index);
        ext = name.substring(index + 1, name.length);
      } else {
        modName = name;
      }
      temp = ext || modName;
      index = temp.indexOf("!");
      if (index !== -1) {
        strip = temp.substring(index + 1) === "strip";
        temp = temp.substring(0, index);
        if (ext) {
          ext = temp;
        } else {
          modName = temp;
        }
      }
      return {
        moduleName: modName,
        ext: ext,
        strip: strip
      };
    },
    xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
    useXhr: function (url, protocol, hostname, port) {
      var uProtocol, uHostName, uPort,
        match = text.xdRegExp.exec(url);
      if (!match) {
        return true;
      }
      uProtocol = match[2];
      uHostName = match[3];
      uHostName = uHostName.split(':');
      uPort = uHostName[1];
      uHostName = uHostName[0];
      return (!uProtocol || uProtocol === protocol) &&
             (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
             ((!uPort && !uHostName) || uPort === port);
    },
    finishLoad: function (name, strip, content, onLoad) {
      content = strip ? text.strip(content) : content;
      if (masterConfig.isBuild) {
        buildMap[name] = content;
      }
      onLoad(content);
    },
    load: function (name, req, onLoad, config) {
      if (config && config.isBuild && !config.inlineText) {
        onLoad();
        return;
      }
      masterConfig.isBuild = config && config.isBuild;
      var parsed = text.parseName(name),
        nonStripName = parsed.moduleName +
                       (parsed.ext ? '.' + parsed.ext : ''),
        url = req.toUrl(nonStripName),
        useXhr = (masterConfig.useXhr) ||
                 text.useXhr;
      if (url.indexOf('empty:') === 0) {
        onLoad();
        return;
      }
      if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
        text.get(url, function (content) {
          text.finishLoad(name, parsed.strip, content, onLoad);
        }, function (err) {
          if (onLoad.error) {
            onLoad.error(err);
          }
        });
      } else {
        req([nonStripName], function (content) {
          text.finishLoad(parsed.moduleName + '.' + parsed.ext,
            parsed.strip, content, onLoad);
        });
      }
    },
    write: function (pluginName, moduleName, write, config) {
      if (buildMap.hasOwnProperty(moduleName)) {
        var content = text.jsEscape(buildMap[moduleName]);
        write.asModule(pluginName + "!" + moduleName,
            "define(function () { return '" +
            content +
            "';});\n");
      }
    },
    writeFile: function (pluginName, moduleName, req, write, config) {
      var parsed = text.parseName(moduleName),
        extPart = parsed.ext ? '.' + parsed.ext : '',
        nonStripName = parsed.moduleName + extPart,
        fileName = req.toUrl(parsed.moduleName + extPart) + '.js';
      text.load(nonStripName, req, function (value) {
        var textWrite = function (contents) {
          return write(fileName, contents);
        };
        textWrite.asModule = function (moduleName, contents) {
          return write.asModule(moduleName, fileName, contents);
        };
        text.write(pluginName, nonStripName, textWrite, config);
      }, config);
    }
  };
  if (masterConfig.env === 'node' || (!masterConfig.env &&
                                      typeof process !== "undefined" &&
                                      process.versions &&
                                      !!process.versions.node &&
                                      !process.versions['node-webkit'])) {
    fs = require.nodeRequire('fs');
    text.get = function (url, callback, errback) {
      try {
        var file = fs.readFileSync(url, 'utf8');
        if (file.indexOf('\uFEFF') === 0) {
          file = file.substring(1);
        }
        callback(file);
      } catch (e) {
        if (errback) {
          errback(e);
        }
      }
    };
  } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
                                            text.createXhr())) {
    text.get = function (url, callback, errback, headers) {
      var xhr = text.createXhr(), header;
      xhr.open('GET', url, true);
      if (headers) {
        for (header in headers) {
          if (headers.hasOwnProperty(header)) {
            xhr.setRequestHeader(header.toLowerCase(), headers[header]);
          }
        }
      }
      if (masterConfig.onXhr) {
        masterConfig.onXhr(xhr, url);
      }
      xhr.onreadystatechange = function (evt) {
        var status, err;
        if (xhr.readyState === 4) {
          status = xhr.status || 0;
          if (status > 399 && status < 600) {
            err = new Error(url + ' HTTP status: ' + status);
            err.xhr = xhr;
            if (errback) {
              errback(err);
            }
          } else {
            callback(xhr.responseText);
          }
          if (masterConfig.onXhrComplete) {
            masterConfig.onXhrComplete(xhr, url);
          }
        }
      };
      xhr.send(null);
    };
  } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
                                              typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
    text.get = function (url, callback) {
      var stringBuffer, line,
        encoding = "utf-8",
        file = new java.io.File(url),
        lineSeparator = java.lang.System.getProperty("line.separator"),
        input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
        content = '';
      try {
        stringBuffer = new java.lang.StringBuffer();
        line = input.readLine();
        if (line && line.length() && line.charAt(0) === 0xfeff) {
          line = line.substring(1);
        }
        if (line !== null) {
          stringBuffer.append(line);
        }
        while ((line = input.readLine()) !== null) {
          stringBuffer.append(lineSeparator);
          stringBuffer.append(line);
        }
        content = String(stringBuffer.toString()); //String
      } finally {
        input.close();
      }
      callback(content);
    };
  } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
                                                  typeof Components !== 'undefined' && Components.classes &&
                                                  Components.interfaces)) {
    Cc = Components.classes;
    Ci = Components.interfaces;
    Components.utils['import']('resource://gre/modules/FileUtils.jsm');
    xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);
    text.get = function (url, callback) {
      var inStream, convertStream, fileObj,
        readData = {};
      if (xpcIsWindows) {
        url = url.replace(/\//g, '\\');
      }
      fileObj = new FileUtils.File(url);
      try {
        inStream = Cc['@mozilla.org/network/file-input-stream;1']
          .createInstance(Ci.nsIFileInputStream);
        inStream.init(fileObj, 1, 0, false);
        convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
          .createInstance(Ci.nsIConverterInputStream);
        convertStream.init(inStream, "utf-8", inStream.available(),
          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
        convertStream.readString(inStream.available(), readData);
        convertStream.close();
        inStream.close();
        callback(readData.value);
      } catch (e) {
        throw new Error((fileObj && fileObj.path || '') + ': ' + e);
      }
    };
  }
  return text;
});
(function() {
  var ChipperConstants = {
    FALLBACK_LOCALE: 'en',
    MEDIA_TYPES: [ 'audio', 'images' ],
    START_THIRD_PARTY_LICENSE_ENTRIES: '### START THIRD PARTY LICENSE ENTRIES ###',
    END_THIRD_PARTY_LICENSE_ENTRIES: '### END THIRD PARTY LICENSE ENTRIES ###',
    BUILD_DIR: 'build'
  };
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/ChipperConstants',[],function() {
      return ChipperConstants;
    } );
  }
  if ( typeof module !== 'undefined' ) {
    module.exports = ChipperConstants;
  }
})();
(function() {
  var ChipperStringUtils = {
    addDirectionalFormatting: function( str, isRTL ) {
      if ( str.length > 0 ) {
        return ( isRTL ? '\u202b' : '\u202a' ) + str + '\u202c';
      }
      else {
        return str;
      }
    },
    toCamelCase: function( str ) {
      return str.toLowerCase().replace( /-(.)/g, function( match, group1 ) {
        return group1.toUpperCase();
      } );
    },
    toTitle: function toTitle( simName ) {
      var tmpString = simName.replace( /-(.)/g, function( match, group1 ) {
        return ' ' + group1.toUpperCase();
      } );
      return tmpString.substring( 0, 1 ).toUpperCase() + tmpString.substring( 1 );
    },
    padString: function( str, n ) {
      while ( str.length < n ) {
        str += ' ';
      }
      return str;
    },
    replaceAll: function( str, find, replaceWith ) {
      return str.replace( new RegExp( find.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' ), 'g' ), replaceWith );
    },
    replaceFirst: function( str, find, replaceWith ) {
      var idx = str.indexOf( find );
      if ( str.indexOf( find ) !== -1 ) {
        return str.slice( 0, idx ) + replaceWith + str.slice( idx + find.length );
      }
      else {
        return str;
      }
    },
    endsWith: function( string, suffix ) {
      return string.indexOf( suffix, string.length - suffix.length ) !== -1;
    },
    firstLineThatContains: function( string, find ) {
      var findRE = '.*' + find.replace( /[-\/\\^$*+?.()|[\]{}]/g, '\\$&' ) + '.*';
      var theReturn = string.match( new RegExp( findRE, 'g' ) );
      return theReturn ? theReturn[ 0 ] : null;
    }
  };
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/ChipperStringUtils',[],function() {
      return ChipperStringUtils;
    } );
  }
  if ( typeof module !== 'undefined' ) {
    module.exports = ChipperStringUtils;
  }
})();
define('string',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define("string!SHRED/hydrogen",function(){return window.phet.chipper.strings.get("SHRED/hydrogen");});
define("string!SHRED/helium",function(){return window.phet.chipper.strings.get("SHRED/helium");});
define("string!SHRED/lithium",function(){return window.phet.chipper.strings.get("SHRED/lithium");});
define("string!SHRED/beryllium",function(){return window.phet.chipper.strings.get("SHRED/beryllium");});
define("string!SHRED/boron",function(){return window.phet.chipper.strings.get("SHRED/boron");});
define("string!SHRED/carbon",function(){return window.phet.chipper.strings.get("SHRED/carbon");});
define("string!SHRED/nitrogen",function(){return window.phet.chipper.strings.get("SHRED/nitrogen");});
define("string!SHRED/oxygen",function(){return window.phet.chipper.strings.get("SHRED/oxygen");});
define("string!SHRED/fluorine",function(){return window.phet.chipper.strings.get("SHRED/fluorine");});
define("string!SHRED/neon",function(){return window.phet.chipper.strings.get("SHRED/neon");});
define("string!SHRED/sodium",function(){return window.phet.chipper.strings.get("SHRED/sodium");});
define("string!SHRED/magnesium",function(){return window.phet.chipper.strings.get("SHRED/magnesium");});
define("string!SHRED/aluminum",function(){return window.phet.chipper.strings.get("SHRED/aluminum");});
define("string!SHRED/silicon",function(){return window.phet.chipper.strings.get("SHRED/silicon");});
define("string!SHRED/phosphorus",function(){return window.phet.chipper.strings.get("SHRED/phosphorus");});
define("string!SHRED/sulfur",function(){return window.phet.chipper.strings.get("SHRED/sulfur");});
define("string!SHRED/chlorine",function(){return window.phet.chipper.strings.get("SHRED/chlorine");});
define("string!SHRED/argon",function(){return window.phet.chipper.strings.get("SHRED/argon");});
define("string!SHRED/potassium",function(){return window.phet.chipper.strings.get("SHRED/potassium");});
define("string!SHRED/calcium",function(){return window.phet.chipper.strings.get("SHRED/calcium");});
define("string!SHRED/scandium",function(){return window.phet.chipper.strings.get("SHRED/scandium");});
define("string!SHRED/titanium",function(){return window.phet.chipper.strings.get("SHRED/titanium");});
define("string!SHRED/vanadium",function(){return window.phet.chipper.strings.get("SHRED/vanadium");});
define("string!SHRED/chromium",function(){return window.phet.chipper.strings.get("SHRED/chromium");});
define("string!SHRED/manganese",function(){return window.phet.chipper.strings.get("SHRED/manganese");});
define("string!SHRED/iron",function(){return window.phet.chipper.strings.get("SHRED/iron");});
define("string!SHRED/cobalt",function(){return window.phet.chipper.strings.get("SHRED/cobalt");});
define("string!SHRED/nickel",function(){return window.phet.chipper.strings.get("SHRED/nickel");});
define("string!SHRED/copper",function(){return window.phet.chipper.strings.get("SHRED/copper");});
define("string!SHRED/zinc",function(){return window.phet.chipper.strings.get("SHRED/zinc");});
define("string!SHRED/gallium",function(){return window.phet.chipper.strings.get("SHRED/gallium");});
define("string!SHRED/germanium",function(){return window.phet.chipper.strings.get("SHRED/germanium");});
define("string!SHRED/arsenic",function(){return window.phet.chipper.strings.get("SHRED/arsenic");});
define("string!SHRED/selenium",function(){return window.phet.chipper.strings.get("SHRED/selenium");});
define("string!SHRED/bromine",function(){return window.phet.chipper.strings.get("SHRED/bromine");});
define("string!SHRED/krypton",function(){return window.phet.chipper.strings.get("SHRED/krypton");});
define("string!SHRED/rubidium",function(){return window.phet.chipper.strings.get("SHRED/rubidium");});
define("string!SHRED/strontium",function(){return window.phet.chipper.strings.get("SHRED/strontium");});
define("string!SHRED/yttrium",function(){return window.phet.chipper.strings.get("SHRED/yttrium");});
define("string!SHRED/zirconium",function(){return window.phet.chipper.strings.get("SHRED/zirconium");});
define("string!SHRED/niobium",function(){return window.phet.chipper.strings.get("SHRED/niobium");});
define("string!SHRED/molybdenum",function(){return window.phet.chipper.strings.get("SHRED/molybdenum");});
define("string!SHRED/technetium",function(){return window.phet.chipper.strings.get("SHRED/technetium");});
define("string!SHRED/ruthenium",function(){return window.phet.chipper.strings.get("SHRED/ruthenium");});
define("string!SHRED/rhodium",function(){return window.phet.chipper.strings.get("SHRED/rhodium");});
define("string!SHRED/palladium",function(){return window.phet.chipper.strings.get("SHRED/palladium");});
define("string!SHRED/silver",function(){return window.phet.chipper.strings.get("SHRED/silver");});
define("string!SHRED/cadmium",function(){return window.phet.chipper.strings.get("SHRED/cadmium");});
define("string!SHRED/indium",function(){return window.phet.chipper.strings.get("SHRED/indium");});
define("string!SHRED/tin",function(){return window.phet.chipper.strings.get("SHRED/tin");});
define("string!SHRED/antimony",function(){return window.phet.chipper.strings.get("SHRED/antimony");});
define("string!SHRED/tellurium",function(){return window.phet.chipper.strings.get("SHRED/tellurium");});
define("string!SHRED/iodine",function(){return window.phet.chipper.strings.get("SHRED/iodine");});
define("string!SHRED/xenon",function(){return window.phet.chipper.strings.get("SHRED/xenon");});
define("string!SHRED/cesium",function(){return window.phet.chipper.strings.get("SHRED/cesium");});
define("string!SHRED/barium",function(){return window.phet.chipper.strings.get("SHRED/barium");});
define("string!SHRED/lanthanum",function(){return window.phet.chipper.strings.get("SHRED/lanthanum");});
define("string!SHRED/cerium",function(){return window.phet.chipper.strings.get("SHRED/cerium");});
define("string!SHRED/praseodymium",function(){return window.phet.chipper.strings.get("SHRED/praseodymium");});
define("string!SHRED/neodymium",function(){return window.phet.chipper.strings.get("SHRED/neodymium");});
define("string!SHRED/promethium",function(){return window.phet.chipper.strings.get("SHRED/promethium");});
define("string!SHRED/samarium",function(){return window.phet.chipper.strings.get("SHRED/samarium");});
define("string!SHRED/europium",function(){return window.phet.chipper.strings.get("SHRED/europium");});
define("string!SHRED/gadolinium",function(){return window.phet.chipper.strings.get("SHRED/gadolinium");});
define("string!SHRED/terbium",function(){return window.phet.chipper.strings.get("SHRED/terbium");});
define("string!SHRED/dysprosium",function(){return window.phet.chipper.strings.get("SHRED/dysprosium");});
define("string!SHRED/holmium",function(){return window.phet.chipper.strings.get("SHRED/holmium");});
define("string!SHRED/erbium",function(){return window.phet.chipper.strings.get("SHRED/erbium");});
define("string!SHRED/thulium",function(){return window.phet.chipper.strings.get("SHRED/thulium");});
define("string!SHRED/ytterbium",function(){return window.phet.chipper.strings.get("SHRED/ytterbium");});
define("string!SHRED/lutetium",function(){return window.phet.chipper.strings.get("SHRED/lutetium");});
define("string!SHRED/hafnium",function(){return window.phet.chipper.strings.get("SHRED/hafnium");});
define("string!SHRED/tantalum",function(){return window.phet.chipper.strings.get("SHRED/tantalum");});
define("string!SHRED/tungsten",function(){return window.phet.chipper.strings.get("SHRED/tungsten");});
define("string!SHRED/rhenium",function(){return window.phet.chipper.strings.get("SHRED/rhenium");});
define("string!SHRED/osmium",function(){return window.phet.chipper.strings.get("SHRED/osmium");});
define("string!SHRED/iridium",function(){return window.phet.chipper.strings.get("SHRED/iridium");});
define("string!SHRED/platinum",function(){return window.phet.chipper.strings.get("SHRED/platinum");});
define("string!SHRED/gold",function(){return window.phet.chipper.strings.get("SHRED/gold");});
define("string!SHRED/mercury",function(){return window.phet.chipper.strings.get("SHRED/mercury");});
define("string!SHRED/thallium",function(){return window.phet.chipper.strings.get("SHRED/thallium");});
define("string!SHRED/lead",function(){return window.phet.chipper.strings.get("SHRED/lead");});
define("string!SHRED/bismuth",function(){return window.phet.chipper.strings.get("SHRED/bismuth");});
define("string!SHRED/polonium",function(){return window.phet.chipper.strings.get("SHRED/polonium");});
define("string!SHRED/astatine",function(){return window.phet.chipper.strings.get("SHRED/astatine");});
define("string!SHRED/radon",function(){return window.phet.chipper.strings.get("SHRED/radon");});
define("string!SHRED/francium",function(){return window.phet.chipper.strings.get("SHRED/francium");});
define("string!SHRED/radium",function(){return window.phet.chipper.strings.get("SHRED/radium");});
define("string!SHRED/actinium",function(){return window.phet.chipper.strings.get("SHRED/actinium");});
define("string!SHRED/thorium",function(){return window.phet.chipper.strings.get("SHRED/thorium");});
define("string!SHRED/protactinium",function(){return window.phet.chipper.strings.get("SHRED/protactinium");});
define("string!SHRED/uranium",function(){return window.phet.chipper.strings.get("SHRED/uranium");});
define("string!SHRED/neptunium",function(){return window.phet.chipper.strings.get("SHRED/neptunium");});
define("string!SHRED/plutonium",function(){return window.phet.chipper.strings.get("SHRED/plutonium");});
define("string!SHRED/americium",function(){return window.phet.chipper.strings.get("SHRED/americium");});
define("string!SHRED/curium",function(){return window.phet.chipper.strings.get("SHRED/curium");});
define("string!SHRED/berkelium",function(){return window.phet.chipper.strings.get("SHRED/berkelium");});
define("string!SHRED/californium",function(){return window.phet.chipper.strings.get("SHRED/californium");});
define("string!SHRED/einsteinium",function(){return window.phet.chipper.strings.get("SHRED/einsteinium");});
define("string!SHRED/fermium",function(){return window.phet.chipper.strings.get("SHRED/fermium");});
define("string!SHRED/mendelevium",function(){return window.phet.chipper.strings.get("SHRED/mendelevium");});
define("string!SHRED/nobelium",function(){return window.phet.chipper.strings.get("SHRED/nobelium");});
define("string!SHRED/lawrencium",function(){return window.phet.chipper.strings.get("SHRED/lawrencium");});
define("string!SHRED/rutherfordium",function(){return window.phet.chipper.strings.get("SHRED/rutherfordium");});
define("string!SHRED/dubnium",function(){return window.phet.chipper.strings.get("SHRED/dubnium");});
define("string!SHRED/seaborgium",function(){return window.phet.chipper.strings.get("SHRED/seaborgium");});
define("string!SHRED/bohrium",function(){return window.phet.chipper.strings.get("SHRED/bohrium");});
define("string!SHRED/hassium",function(){return window.phet.chipper.strings.get("SHRED/hassium");});
define("string!SHRED/meitnerium",function(){return window.phet.chipper.strings.get("SHRED/meitnerium");});
define("string!SHRED/darmstadtium",function(){return window.phet.chipper.strings.get("SHRED/darmstadtium");});
define("string!SHRED/roentgenium",function(){return window.phet.chipper.strings.get("SHRED/roentgenium");});
define("string!SHRED/ununbium",function(){return window.phet.chipper.strings.get("SHRED/ununbium");});
define("string!SHRED/ununtrium",function(){return window.phet.chipper.strings.get("SHRED/ununtrium");});
define("string!SHRED/flerovium",function(){return window.phet.chipper.strings.get("SHRED/flerovium");});
define("string!SHRED/ununpentium",function(){return window.phet.chipper.strings.get("SHRED/ununpentium");});
define("string!SHRED/livermorium",function(){return window.phet.chipper.strings.get("SHRED/livermorium");});
define("string!SHRED/ununseptium",function(){return window.phet.chipper.strings.get("SHRED/ununseptium");});
define("string!SHRED/ununoctium",function(){return window.phet.chipper.strings.get("SHRED/ununoctium");});
define( 'SHRED/AtomIdentifier',['require','SHRED/shred','DOT/Util','string!SHRED/hydrogen','string!SHRED/helium','string!SHRED/lithium','string!SHRED/beryllium','string!SHRED/boron','string!SHRED/carbon','string!SHRED/nitrogen','string!SHRED/oxygen','string!SHRED/fluorine','string!SHRED/neon','string!SHRED/sodium','string!SHRED/magnesium','string!SHRED/aluminum','string!SHRED/silicon','string!SHRED/phosphorus','string!SHRED/sulfur','string!SHRED/chlorine','string!SHRED/argon','string!SHRED/potassium','string!SHRED/calcium','string!SHRED/scandium','string!SHRED/titanium','string!SHRED/vanadium','string!SHRED/chromium','string!SHRED/manganese','string!SHRED/iron','string!SHRED/cobalt','string!SHRED/nickel','string!SHRED/copper','string!SHRED/zinc','string!SHRED/gallium','string!SHRED/germanium','string!SHRED/arsenic','string!SHRED/selenium','string!SHRED/bromine','string!SHRED/krypton','string!SHRED/rubidium','string!SHRED/strontium','string!SHRED/yttrium','string!SHRED/zirconium','string!SHRED/niobium','string!SHRED/molybdenum','string!SHRED/technetium','string!SHRED/ruthenium','string!SHRED/rhodium','string!SHRED/palladium','string!SHRED/silver','string!SHRED/cadmium','string!SHRED/indium','string!SHRED/tin','string!SHRED/antimony','string!SHRED/tellurium','string!SHRED/iodine','string!SHRED/xenon','string!SHRED/cesium','string!SHRED/barium','string!SHRED/lanthanum','string!SHRED/cerium','string!SHRED/praseodymium','string!SHRED/neodymium','string!SHRED/promethium','string!SHRED/samarium','string!SHRED/europium','string!SHRED/gadolinium','string!SHRED/terbium','string!SHRED/dysprosium','string!SHRED/holmium','string!SHRED/erbium','string!SHRED/thulium','string!SHRED/ytterbium','string!SHRED/lutetium','string!SHRED/hafnium','string!SHRED/tantalum','string!SHRED/tungsten','string!SHRED/rhenium','string!SHRED/osmium','string!SHRED/iridium','string!SHRED/platinum','string!SHRED/gold','string!SHRED/mercury','string!SHRED/thallium','string!SHRED/lead','string!SHRED/bismuth','string!SHRED/polonium','string!SHRED/astatine','string!SHRED/radon','string!SHRED/francium','string!SHRED/radium','string!SHRED/actinium','string!SHRED/thorium','string!SHRED/protactinium','string!SHRED/uranium','string!SHRED/neptunium','string!SHRED/plutonium','string!SHRED/americium','string!SHRED/curium','string!SHRED/berkelium','string!SHRED/californium','string!SHRED/einsteinium','string!SHRED/fermium','string!SHRED/mendelevium','string!SHRED/nobelium','string!SHRED/lawrencium','string!SHRED/rutherfordium','string!SHRED/dubnium','string!SHRED/seaborgium','string!SHRED/bohrium','string!SHRED/hassium','string!SHRED/meitnerium','string!SHRED/darmstadtium','string!SHRED/roentgenium','string!SHRED/ununbium','string!SHRED/ununtrium','string!SHRED/flerovium','string!SHRED/ununpentium','string!SHRED/livermorium','string!SHRED/ununseptium','string!SHRED/ununoctium'],function( require ) {
  'use strict';
  var shred = require( 'SHRED/shred' );
  var Util = require( 'DOT/Util' );
  var TRACE_ABUNDANCE = 0.000000000001;
  var nameTable = [
    '',
    require( 'string!SHRED/hydrogen' ),
    require( 'string!SHRED/helium' ),
    require( 'string!SHRED/lithium' ),
    require( 'string!SHRED/beryllium' ),
    require( 'string!SHRED/boron' ),
    require( 'string!SHRED/carbon' ),
    require( 'string!SHRED/nitrogen' ),
    require( 'string!SHRED/oxygen' ),
    require( 'string!SHRED/fluorine' ),
    require( 'string!SHRED/neon' ),
    require( 'string!SHRED/sodium' ),
    require( 'string!SHRED/magnesium' ),
    require( 'string!SHRED/aluminum' ),
    require( 'string!SHRED/silicon' ),
    require( 'string!SHRED/phosphorus' ),
    require( 'string!SHRED/sulfur' ),
    require( 'string!SHRED/chlorine' ),
    require( 'string!SHRED/argon' ),
    require( 'string!SHRED/potassium' ),
    require( 'string!SHRED/calcium' ),
    require( 'string!SHRED/scandium' ),
    require( 'string!SHRED/titanium' ),
    require( 'string!SHRED/vanadium' ),
    require( 'string!SHRED/chromium' ),
    require( 'string!SHRED/manganese' ),
    require( 'string!SHRED/iron' ),
    require( 'string!SHRED/cobalt' ),
    require( 'string!SHRED/nickel' ),
    require( 'string!SHRED/copper' ),
    require( 'string!SHRED/zinc' ),
    require( 'string!SHRED/gallium' ),
    require( 'string!SHRED/germanium' ),
    require( 'string!SHRED/arsenic' ),
    require( 'string!SHRED/selenium' ),
    require( 'string!SHRED/bromine' ),
    require( 'string!SHRED/krypton' ),
    require( 'string!SHRED/rubidium' ),
    require( 'string!SHRED/strontium' ),
    require( 'string!SHRED/yttrium' ),
    require( 'string!SHRED/zirconium' ),
    require( 'string!SHRED/niobium' ),
    require( 'string!SHRED/molybdenum' ),
    require( 'string!SHRED/technetium' ),
    require( 'string!SHRED/ruthenium' ),
    require( 'string!SHRED/rhodium' ),
    require( 'string!SHRED/palladium' ),
    require( 'string!SHRED/silver' ),
    require( 'string!SHRED/cadmium' ),
    require( 'string!SHRED/indium' ),
    require( 'string!SHRED/tin' ),
    require( 'string!SHRED/antimony' ),
    require( 'string!SHRED/tellurium' ),
    require( 'string!SHRED/iodine' ),
    require( 'string!SHRED/xenon' ),
    require( 'string!SHRED/cesium' ),
    require( 'string!SHRED/barium' ),
    require( 'string!SHRED/lanthanum' ),
    require( 'string!SHRED/cerium' ),
    require( 'string!SHRED/praseodymium' ),
    require( 'string!SHRED/neodymium' ),
    require( 'string!SHRED/promethium' ),
    require( 'string!SHRED/samarium' ),
    require( 'string!SHRED/europium' ),
    require( 'string!SHRED/gadolinium' ),
    require( 'string!SHRED/terbium' ),
    require( 'string!SHRED/dysprosium' ),
    require( 'string!SHRED/holmium' ),
    require( 'string!SHRED/erbium' ),
    require( 'string!SHRED/thulium' ),
    require( 'string!SHRED/ytterbium' ),
    require( 'string!SHRED/lutetium' ),
    require( 'string!SHRED/hafnium' ),
    require( 'string!SHRED/tantalum' ),
    require( 'string!SHRED/tungsten' ),
    require( 'string!SHRED/rhenium' ),
    require( 'string!SHRED/osmium' ),
    require( 'string!SHRED/iridium' ),
    require( 'string!SHRED/platinum' ),
    require( 'string!SHRED/gold' ),
    require( 'string!SHRED/mercury' ),
    require( 'string!SHRED/thallium' ),
    require( 'string!SHRED/lead' ),
    require( 'string!SHRED/bismuth' ),
    require( 'string!SHRED/polonium' ),
    require( 'string!SHRED/astatine' ),
    require( 'string!SHRED/radon' ),
    require( 'string!SHRED/francium' ),
    require( 'string!SHRED/radium' ),
    require( 'string!SHRED/actinium' ),
    require( 'string!SHRED/thorium' ),
    require( 'string!SHRED/protactinium' ),
    require( 'string!SHRED/uranium' ),
    require( 'string!SHRED/neptunium' ),
    require( 'string!SHRED/plutonium' ),
    require( 'string!SHRED/americium' ),
    require( 'string!SHRED/curium' ),
    require( 'string!SHRED/berkelium' ),
    require( 'string!SHRED/californium' ),
    require( 'string!SHRED/einsteinium' ),
    require( 'string!SHRED/fermium' ),
    require( 'string!SHRED/mendelevium' ),
    require( 'string!SHRED/nobelium' ),
    require( 'string!SHRED/lawrencium' ),
    require( 'string!SHRED/rutherfordium' ),
    require( 'string!SHRED/dubnium' ),
    require( 'string!SHRED/seaborgium' ),
    require( 'string!SHRED/bohrium' ),
    require( 'string!SHRED/hassium' ),
    require( 'string!SHRED/meitnerium' ),
    require( 'string!SHRED/darmstadtium' ),
    require( 'string!SHRED/roentgenium' ),
    require( 'string!SHRED/ununbium' ),
    require( 'string!SHRED/ununtrium' ),
    require( 'string!SHRED/flerovium' ),
    require( 'string!SHRED/ununpentium' ),
    require( 'string!SHRED/livermorium' ),
    require( 'string!SHRED/ununseptium' ),
    require( 'string!SHRED/ununoctium' )
  ];
  var symbolTable = [
    '-', // 0, NO ELEMENT
    'H', // 1, HYDROGEN
    'He', // 2, HELIUM
    'Li', // 3, LITHIUM
    'Be', // 4, BERYLLIUM
    'B', // 5, BORON
    'C', // 6, CARBON
    'N', // 7, NITROGEN
    'O', // 8, OXYGEN
    'F', // 9, FLUORINE
    'Ne', // 10, NEON
    'Na', // 11, SODIUM
    'Mg', // 12, MAGNESIUM
    'Al', // 13, ALUMINUM
    'Si', // 14, SILICON
    'P', // 15, PHOSPHORUS
    'S', // 16, SULFUR
    'Cl', // 17, CHLORINE
    'Ar', // 18, ARGON
    'K', // 19, POTASSIUM
    'Ca', // 20, CALCIUM
    'Sc', // 21, SCANDIUM
    'Ti', // 22, TITANIUM
    'V', // 23, VANADIUM
    'Cr', // 24, CHROMIUM
    'Mn', // 25, MANGANESE
    'Fe', // 26, IRON
    'Co', // 27, COBALT
    'Ni', // 28, NICKEL
    'Cu', // 29, COPPER
    'Zn', // 30, ZINC
    'Ga', // 31, GALLIUM
    'Ge', // 32, GERMANIUM
    'As', // 33, ARSENIC
    'Se', // 34, SELENIUM
    'Br', // 35, BROMINE
    'Kr', // 36, KRYPTON
    'Rb', // 37, RUBIDIUM
    'Sr', // 38, STRONTIUM
    'Y', // 39, YTTRIUM
    'Zr', // 40, ZIRCONIUM
    'Nb', // 41, NIOBIUM
    'Mo', // 42, MOLYBDENUM
    'Tc', // 43, TECHNETIUM
    'Ru', // 44, RUTHENIUM
    'Rh', // 45, RHODIUM
    'Pd', // 46, PALLADIUM
    'Ag', // 47, SILVER
    'Cd', // 48, CADMIUM
    'In', // 49, INDIUM
    'Sn', // 50, TIN
    'Sb', // 51, ANTIMONY
    'Te', // 52, TELLURIUM
    'I', // 53, IODINE
    'Xe', // 54, XENON
    'Cs', // 55, CAESIUM
    'Ba', // 56, BARIUM
    'La', // 57, LANTHANUM
    'Ce', // 58, CERIUM
    'Pr', // 59, PRASEODYMIUM
    'Nd', // 60, NEODYMIUM
    'Pm', // 61, PROMETHIUM
    'Sm', // 62, SAMARIUM
    'Eu', // 63, EUROPIUM
    'Gd', // 64, GADOLINIUM
    'Tb', // 65, TERBIUM
    'Dy', // 66, DYSPROSIUM
    'Ho', // 67, HOLMIUM
    'Er', // 68, ERBIUM
    'Tm', // 69, THULIUM
    'Yb', // 70, YTTERBIUM
    'Lu', // 71, LUTETIUM
    'Hf', // 72, HAFNIUM
    'Ta', // 73, TANTALUM
    'W', // 74, TUNGSTEN
    'Re', // 75, RHENIUM
    'Os', // 76, OSMIUM
    'Ir', // 77, IRIDIUM
    'Pt', // 78, PLATINUM
    'Au', // 79, GOLD
    'Hg', // 80, MERCURY
    'Tl', // 81, THALLIUM
    'Pb', // 82, LEAD
    'Bi', // 83, BISMUTH
    'Po', // 84, POLONIUM
    'At', // 85, ASTATINE
    'Rn', // 86, RADON
    'Fr', // 87, FRANCIUM
    'Ra', // 88, RADIUM
    'Ac', // 89, ACTINIUM
    'Th', // 90, THORIUM
    'Pa', // 91, PROTACTINIUM
    'U', // 92, URANIUM
    'Np', // 93, NEPTUNIUM
    'Pu', // 94, PLUTONIUM
    'Am', // 95, AMERICIUM
    'Cm', // 96, CURIUM
    'Bk', // 97, BERKELIUM
    'Cf', // 98, CALIFORNIUM
    'Es', // 99, EINSTEINIUM
    'Fm', // 100, FERMIUM
    'Md', // 101, MENDELEVIUM
    'No', // 102, NOBELIUM
    'Lr', // 103, LAWRENCIUM
    'Rf', // 104, RUTHERFORDIUM
    'Db', // 105, DUBNIUM
    'Sg', // 106, SEABORGIUM
    'Bh', // 107, BOHRIUM
    'Hs', // 108, HASSIUM
    'Mt', // 109, MEITNERIUM
    'Ds', // 110, DARMSTADTIUM
    'Rg', // 111, ROENTGENIUM
    'Cn', // 112, COPERNICIUM
    'Nh', // 113, NIHONIUM
    'Fl', // 114, FLEROVIUM
    'Mc', // 115, MOSCOVIUM
    'Lv', // 116, LIVERMORIUM
    'Ts', // 117, Tennessine
    'Og'  // 118, OGANESSON
  ];
  var stableElementTable = [
    [],
    [ 0, 1 ],
    [ 1, 2 ],
    [ 3, 4 ],
    [ 5 ],
    [ 5, 6 ],
    [ 6, 7 ],
    [ 7, 8 ],
    [ 8, 9, 10 ],
    [ 10 ],
    [ 10, 11, 12 ],
    [ 12 ],
    [ 12, 13, 14 ],
    [ 14 ],
    [ 14, 15, 16 ],
    [ 16 ],
    [ 16, 17, 18, 20 ],
    [ 18, 20 ],
    [ 18, 20, 22 ]
  ];
  var numNeutronsInMostStableIsotope = [
    0,
    0,
    2,
    4,
    5,
    6,
    6,
    7,
    8,
    10,
    10,
    12,
    12,
    14,
    14,
    16,
    16,
    18,
    22,
    20,
    20,
    24,
    26,
    28,
    28,
    30,
    30,
    32,
    31,
    35,
    35,
    39,
    41,
    42,
    45,
    45,
    48,
    48,
    50,
    50,
    51,
    52,
    54,
    55,
    57,
    58,
    60,
    61,
    64,
    66,
    69,
    71,
    76,
    74,
    77,
    78,
    81,
    82,
    82,
    82,
    84,
    84,
    88,
    89,
    93,
    94,
    97,
    98,
    99,
    100,
    103,
    104,
    106,
    108,
    110,
    111,
    114,
    115,
    117,
    118,
    121,
    123,
    125,
    126,
    125,
    125,
    136,
    136,
    138,
    138,
    142,
    140,
    146,
    144,
    150,
    148,
    151,
    150,
    153,
    153,
    157,
    157,
    157,
    159,
    157,
    157,
    160,
    157,
    161
  ];
  var ISOTOPE_INFO_TABLE = {
    1: { // atomic number
      1: { // massNumber
        atomicMass: 1.00782503207,
        abundance: 0.999885
      },
      2: {
        atomicMass: 2.0141017778,
        abundance: 0.000115
      },
      3: {
        atomicMass: 3.0160492777,
        abundance: TRACE_ABUNDANCE
      }
    },
    2: {
      3: {
        atomicMass: 3.0160293191,
        abundance: 0.00000134
      },
      4: {
        atomicMass: 4.00260325415,
        abundance: 0.99999866
      }
    },
    3: {
      6: {
        atomicMass: 6.015122795,
        abundance: 0.0759
      },
      7: {
        atomicMass: 7.01600455,
        abundance: 0.9241
      }
    },
    4: {
      9: {
        atomicMass: 9.0121822,
        abundance: 1.0000
      }
    },
    5: {
      10: {
        atomicMass: 10.0129370,
        abundance: 0.199
      },
      11: {
        atomicMass: 11.0093054,
        abundance: 0.801
      }
    },
    6: {
      12: {
        atomicMass: 12.0000000,
        abundance: 0.9893
      },
      13: {
        atomicMass: 13.0033548378,
        abundance: 0.0107
      },
      14: {
        atomicMass: 14.003241989,
        abundance: TRACE_ABUNDANCE
      }
    },
    7: {
      14: {
        atomicMass: 14.0030740048,
        abundance: 0.99636
      },
      15: {
        atomicMass: 15.0001088982,
        abundance: 0.00364
      }
    },
    8: {
      16: {
        atomicMass: 15.99491461956,
        abundance: 0.99757
      },
      17: {
        atomicMass: 16.99913170,
        abundance: 0.00038
      },
      18: {
        atomicMass: 17.9991610,
        abundance: 0.00205
      }
    },
    9: {
      19: {
        atomicMass: 18.99840322,
        abundance: 1.0000
      }
    },
    10: {
      20: {
        atomicMass: 19.9924401754,
        abundance: 0.9048
      },
      21: {
        atomicMass: 20.99384668,
        abundance: 0.0027
      },
      22: {
        atomicMass: 21.991385114,
        abundance: 0.0925
      }
    },
    11: {
      23: {
        atomicMass: 22.9897692809,
        abundance: 1.0000
      }
    },
    12: {
      24: {
        atomicMass: 23.985041700,
        abundance: 0.7899
      },
      25: {
        atomicMass: 24.98583692,
        abundance: 0.1000
      },
      26: {
        atomicMass: 25.982592929,
        abundance: 0.1101
      }
    },
    13: {
      27: {
        atomicMass: 26.98153863,
        abundance: 1.0000
      }
    },
    14: {
      28: {
        atomicMass: 27.9769265325,
        abundance: 0.92223
      },
      29: {
        atomicMass: 28.976494700,
        abundance: 0.04685
      },
      30: {
        atomicMass: 29.97377017,
        abundance: 0.03092
      }
    },
    15: {
      31: {
        atomicMass: 30.97376163,
        abundance: 1.0000
      }
    },
    16: {
      32: {
        atomicMass: 31.97207100,
        abundance: 0.9499
      },
      33: {
        atomicMass: 32.97145876,
        abundance: 0.0075
      },
      34: {
        atomicMass: 33.96786690,
        abundance: 0.0425
      },
      36: {
        atomicMass: 35.96708076,
        abundance: 0.0001
      }
    },
    17: {
      35: {
        atomicMass: 34.96885268,
        abundance: 0.7576
      },
      37: {
        atomicMass: 36.96590259,
        abundance: 0.2424
      }
    },
    18: {
      36: {
        atomicMass: 35.967545106,
        abundance: 0.003365
      },
      38: {
        atomicMass: 37.9627324,
        abundance: 0.000632
      },
      40: {
        atomicMass: 39.9623831225,
        abundance: 0.996003
      }
    }
  };
  var standardMassTable = [
    0, // 0, NO ELEMENT
    1.00794, // 1, HYDROGEN
    4.002602, // 2, HELIUM
    6.941, // 3, LITHIUM
    9.012182, // 4, BERYLLIUM
    10.811, // 5, BORON
    12.0107, // 6, CARBON
    14.0067, // 7, NITROGEN
    15.9994, // 8, OXYGEN
    18.9984032, // 9, FLUORINE
    20.1797, // 10, NEON
    22.98976928, // 11, SODIUM
    24.3050, // 12, MAGNESIUM
    26.9815386, // 13, ALUMINUM
    28.0855, // 14, SILICON
    30.973762, // 15, PHOSPHORUS
    32.065, // 16, SULFUR
    35.453, // 17, CHLORINE
    39.948, // 18, ARGON
    39.0983, // 19, POTASSIUM
    40.078, // 20, CALCIUM
    44.955912, // 21, SCANDIUM
    47.867, // 22, TITANIUM
    50.9415, // 23, VANADIUM
    51.9961, // 24, CHROMIUM
    54.938045, // 25, MANGANESE
    55.845, // 26, IRON
    58.933195, // 27, COBALT
    58.6934, // 28, NICKEL
    63.546, // 29, COPPER
    65.38, // 30, ZINC
    69.723, // 31, GALLIUM
    72.64, // 32, GERMANIUM
    74.9216, // 33, ARSENIC
    78.96, // 34, SELENIUM
    79.904, // 35, BROMINE
    83.798, // 36, KRYPTON
    85.4678, // 37, RUBIDIUM
    87.62, // 38, STRONTIUM
    88.90585, // 39, YTTRIUM
    91.224, // 40, ZIRCONIUM
    92.90638, // 41, NIOBIUM
    95.96, // 42, MOLYBDENUM
    98, // 43, TECHNETIUM
    101.07, // 44, RUTHENIUM
    102.9055, // 45, RHODIUM
    106.42, // 46, PALLADIUM
    107.8682, // 47, SILVER
    112.411, // 48, CADMIUM
    114.818, // 49, INDIUM
    118.71, // 50, TIN
    121.76, // 51, ANTIMONY
    127.6, // 52, TELLURIUM
    126.90447, // 53, IODINE
    131.293, // 54, XENON
    132.9054519, // 55, CAESIUM
    137.327, // 56, BARIUM
    138.90547, // 57, LANTHANUM
    140.116, // 58, CERIUM
    140.90765, // 59, PRASEODYMIUM
    144.242, // 60, NEODYMIUM
    145, // 61, PROMETHIUM
    150.36, // 62, SAMARIUM
    151.964, // 63, EUROPIUM
    157.25, // 64, GADOLINIUM
    158.92535, // 65, TERBIUM
    162.5, // 66, DYSPROSIUM
    164.93032, // 67, HOLMIUM
    167.259, // 68, ERBIUM
    168.93421, // 69, THULIUM
    173.054, // 70, YTTERBIUM
    174.9668, // 71, LUTETIUM
    178.49, // 72, HAFNIUM
    180.94788, // 73, TANTALUM
    183.84, // 74, TUNGSTEN
    186.207, // 75, RHENIUM
    190.23, // 76, OSMIUM
    192.217, // 77, IRIDIUM
    195.084, // 78, PLATINUM
    196.966569, // 79, GOLD
    200.59, // 80, MERCURY
    204.3833, // 81, THALLIUM
    207.2, // 82, LEAD
    208.9804 // 83, BISMUTH
  ];
  var AtomIdentifier = {
    getSymbol: function( numProtons ) {
      return symbolTable[ numProtons ];
    },
    getName: function( numProtons ) {
      return nameTable[ numProtons ];
    },
    isStable: function( numProtons, numNeutrons ) {
      var tableEntry = stableElementTable[ numProtons ];
      if ( typeof( tableEntry ) === 'undefined' ) {
        return false;
      }
      return $.inArray( numNeutrons, tableEntry ) > -1;
    },
    getNumNeutronsInMostCommonIsotope: function( atomicNumber ) {
      return numNeutronsInMostStableIsotope[ atomicNumber ];
    },
    getStandardAtomicMass: function( numProtons ) {
      return standardMassTable[ numProtons ];
    },
    getIsotopeAtomicMass: function( protons, neutrons ) {
      if ( protons !== 0 ) {
        var tableEntry = ISOTOPE_INFO_TABLE[ protons ][ protons + neutrons ];
        if ( typeof( tableEntry ) === 'undefined' ) {
          return -1;
        }
      }
      else {
        return -1;
      }
      return tableEntry.atomicMass;
    },
    getNaturalAbundance: function( atom ) {
      return this.getNaturalAbundancePreciseDecimal( atom );
    },
    getNaturalAbundancePreciseDecimal: function( atom ) {
      var defaultReturnValue = Util.toFixedNumber( 0, 10 );
      if ( atom.protonCountProperty.get() > 0 &&
           ISOTOPE_INFO_TABLE[ atom.protonCountProperty.get() ][ atom.massNumberProperty.get() ] !== undefined ) {
        return Util.toFixedNumber(
          ISOTOPE_INFO_TABLE[ atom.protonCountProperty.get() ][ atom.massNumberProperty.get() ].abundance, 10 );
      }
      return defaultReturnValue;
    },
    getAllIsotopesOfElement: function( atomicNumber ) {
      var isotopesList = [];
      for ( var massNumber in ISOTOPE_INFO_TABLE[ atomicNumber ] ) {
        var numNeutrons = massNumber - atomicNumber;
        var moleculeNumberList = [ atomicNumber, numNeutrons, atomicNumber ];
        isotopesList.push( moleculeNumberList );
      }
      return isotopesList;
    },
    getStableIsotopesOfElement: function( atomicNumber ) {
      var isotopesList = this.getAllIsotopesOfElement( atomicNumber );
      var stableIsotopesList = [];
      for ( var isotopeIndex in isotopesList ) {
        var numProtons = isotopesList[ isotopeIndex ][ 0 ];
        var numNeutrons = isotopesList[ isotopeIndex ][ 1 ];
        if ( this.isStable( numProtons, numNeutrons ) ) {
          stableIsotopesList.push( [ numProtons, numNeutrons, numProtons ] );
        }
      }
      return stableIsotopesList;
    }
  };
  shred.register( 'AtomIdentifier', AtomIdentifier );
  return AtomIdentifier;
} );
define( 'PHET_CORE/extend',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function extend( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );
        }
      }
    } );
    return obj;
  }
  phetCore.register( 'extend', extend );
  return extend;
} );
define( 'PHET_CORE/inherit',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );
  function inherit( supertype, subtype, prototypeProperties, staticProperties ) {
    assert && assert( typeof supertype === 'function' );
    function F() {}
    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype
    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy
      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely
      { constructor: subtype }, // overrides the constructor properly
      prototypeProperties       // [optional] additional properties for the prototype, as an object.
    );
    extend( subtype, staticProperties );
    return subtype; // pass back the subtype so it can be returned immediately as a module export
  }
  phetCore.register( 'inherit', inherit );
  return inherit;
} );
define( 'AXON/axon',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'axon' );
} );
define( 'AXON/Emitter',['require','PHET_CORE/inherit','AXON/axon'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var axon = require( 'AXON/axon' );
  function Emitter() {
    this.listeners = [];
    this.listenersToEmitTo = [];
  }
  axon.register( 'Emitter', Emitter );
  return inherit( Object, Emitter, {
    dispose: function() {
      assert && assert( !this.hasListeners(), 'Listeners should have been removed before disposal' );
    },
    addListener: function( listener ) {
      this.defendCallbacks();
      this.listeners.push( listener );
    },
    removeListener: function( listener ) {
      var index = this.listeners.indexOf( listener );
      assert && assert( index >= 0, 'tried to removeListener on something that wasnt a listener' );
      this.defendCallbacks();
      this.listeners.splice( index, 1 );
    },
    removeAllListeners: function() {
      while ( this.listeners.length > 0 ) {
        this.removeListener( this.listeners[ 0 ] );
      }
    },
    defendCallbacks: function() {
      for ( var i = this.listenersToEmitTo.length - 1; i >= 0; i-- ) {
        if ( this.listenersToEmitTo[ i ].defended ) {
          break;
        }
        else {
          var defendedListeners = this.listeners.slice();
          defendedListeners.defended = true;
          this.listenersToEmitTo[ i ] = defendedListeners;
        }
      }
    },
    emit: function() {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;
      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]();
      }
      this.listenersToEmitTo.pop();
    },
    emit1: function( arg1 ) {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;
      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1 );
      }
      this.listenersToEmitTo.pop();
    },
    emit2: function( arg1, arg2 ) {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;
      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1, arg2 );
      }
      this.listenersToEmitTo.pop();
    },
    emit3: function( arg1, arg2, arg3 ) {
      this.listenersToEmitTo.push( this.listeners );
      var lastEntry = this.listenersToEmitTo.length - 1;
      for ( var i = 0; i < this.listenersToEmitTo[ lastEntry ].length; i++ ) {
        this.listenersToEmitTo[ lastEntry ][ i ]( arg1, arg2, arg3 );
      }
      this.listenersToEmitTo.pop();
    },
    hasListener: function( listener ) {
      assert && assert( arguments.length === 1, 'Emitter.hasListener should be called with 1 argument' );
      return this.listeners.indexOf( listener ) >= 0;
    },
    hasListeners: function() {
      assert && assert( arguments.length === 0, 'Emitter.hasListeners should be called without arguments' );
      return this.listeners.length > 0;
    }
  } );
} );
define( 'SCENERY/scenery',['require','PHET_CORE/Namespace','PHET_CORE/extend','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  var extend = require( 'PHET_CORE/extend' );
  window.sceneryLog = null;
  window.sceneryAccessibilityLog = null;
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  var scratchCanvas = document.createElement( 'canvas' );
  var scratchContext = scratchCanvas.getContext( '2d' );
  var logPadding = '';
  var scenery = new Namespace( 'scenery' );
  scenery.register( 'scratchCanvas', scratchCanvas );
  scenery.register( 'scratchContext', scratchContext );
  scenery.register( 'svgns', 'http://www.w3.org/2000/svg' );
  scenery.register( 'xlinkns', 'http://www.w3.org/1999/xlink' );
  function stringLogFunction( message ) {
    scenery.logString += message.replace( /%c/g, '' ) + '\n';
  }
  function consoleLogFunction() {
    window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
  }
  var logProperties = {
    dirty: { name: 'dirty', style: 'color: #aaa;' },
    bounds: { name: 'bounds', style: 'color: #aaa;' },
    hitTest: { name: 'hitTest', style: 'color: #aaa;' },
    hitTestInternal: { name: 'hitTestInternal', style: 'color: #aaa;' },
    PerfCritical: { name: 'Perf', style: 'color: #f00;' },
    PerfMajor: { name: 'Perf', style: 'color: #aa0;' },
    PerfMinor: { name: 'Perf', style: 'color: #088;' },
    PerfVerbose: { name: 'Perf', style: 'color: #888;' },
    Cursor: { name: 'Cursor', style: 'color: #000;' },
    Stitch: { name: 'Stitch', style: 'color: #000;' },
    StitchDrawables: { name: 'Stitch', style: 'color: #000;' },
    GreedyStitcher: { name: 'Greedy', style: 'color: #088;' },
    GreedyVerbose: { name: 'Greedy', style: 'color: #888;' },
    RelativeTransform: { name: 'RelativeTransform', style: 'color: #606;' },
    BackboneDrawable: { name: 'Backbone', style: 'color: #a00;' },
    CanvasBlock: { name: 'Canvas', style: 'color: #000;' },
    WebGLBlock: { name: 'WebGL', style: 'color: #000;' },
    Display: { name: 'Display', style: 'color: #000;' },
    DOMBlock: { name: 'DOM', style: 'color: #000;' },
    Drawable: { name: '', style: 'color: #000;' },
    FittedBlock: { name: 'FittedBlock', style: 'color: #000;' },
    Input: { name: 'Input', style: 'color: #000;' },
    InputEvent: { name: 'InputEvent', style: 'color: #000;' },
    OnInput: { name: 'OnInput', style: 'color: #000;' },
    InputListener: { name: 'InputListener', style: 'color: #000;' },
    Instance: { name: 'Instance', style: 'color: #000;' },
    InstanceTree: { name: 'InstanceTree', style: 'color: #000;' },
    ChangeInterval: { name: 'ChangeInterval', style: 'color: #0a0;' },
    SVGBlock: { name: 'SVG', style: 'color: #000;' },
    SVGGroup: { name: 'SVGGroup', style: 'color: #000;' },
    ImageSVGDrawable: { name: 'ImageSVGDrawable', style: 'color: #000;' },
    Paints: { name: 'Paints', style: 'color: #000;' },
    Accessibility: { name: 'Accessibility', style: 'color: #000;' },
    AccessibleInstance: { name: 'AccessibleInstance', style: 'color: #000;' },
    AlignBox: { name: 'AlignBox', style: 'color: #000;' },
    AlignGroup: { name: 'AlignGroup', style: 'color: #000;' }
  };
  extend( scenery, {
    logString: '',
    logFunction: function() {
      window.console && window.console.log && window.console.log.apply( window.console, Array.prototype.slice.call( arguments, 0 ) );
    },
    switchLogToConsole: function() {
      scenery.logFunction = consoleLogFunction;
    },
    switchLogToString: function() {
      window.console && window.console.log( 'switching to string log' );
      scenery.logFunction = stringLogFunction;
    },
    enableIndividualLog: function( name ) {
      if ( name === 'stitch' ) {
        this.enableIndividualLog( 'Stitch' );
        this.enableIndividualLog( 'StitchDrawables' );
        this.enableIndividualLog( 'GreedyStitcher' );
        this.enableIndividualLog( 'GreedyVerbose' );
        return;
      }
      if ( name === 'perf' ) {
        this.enableIndividualLog( 'PerfCritical' );
        this.enableIndividualLog( 'PerfMajor' );
        this.enableIndividualLog( 'PerfMinor' );
        this.enableIndividualLog( 'PerfVerbose' );
        return;
      }
      if ( name ) {
        assert && assert( logProperties[ name ],
          'Unknown logger: ' + name + ', please use periods (.) to separate different log names' );
        window.sceneryLog[ name ] = window.sceneryLog[ name ] || function( ob, styleOverride ) {
            var data = logProperties[ name ];
            var prefix = data.name ? '[' + data.name + '] ' : '';
            var padStyle = 'color: #ddd;';
            scenery.logFunction( '%c' + logPadding + '%c' + prefix + ob, padStyle, styleOverride ? styleOverride : data.style );
          };
      }
    },
    disableIndividualLog: function( name ) {
      if ( name ) {
        delete window.sceneryLog[ name ];
      }
    },
    enableLogging: function( logNames ) {
      window.sceneryLog = function( ob ) { scenery.logFunction( ob ); };
      window.sceneryLog.push = function() {
        logPadding += '| ';
      };
      window.sceneryLog.pop = function() {
        logPadding = logPadding.slice( 0, -2 );
      };
      window.sceneryLog.getDepth = function() {
        return logPadding.length / 2;
      };
      for ( var i = 0; i < logNames.length; i++ ) {
        this.enableIndividualLog( logNames[ i ] );
      }
    },
    disableLogging: function() {
      window.sceneryLog = null;
    },
    isLoggingPerformance: function() {
      return window.sceneryLog.PerfCritical || window.sceneryLog.PerfMajor ||
             window.sceneryLog.PerfMinor || window.sceneryLog.PerfVerbose;
    }
  } );
  return scenery;
} );
define( 'PHET_CORE/Poolable',['require','PHET_CORE/phetCore','PHET_CORE/extend'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  var extend = require( 'PHET_CORE/extend' );
  var Poolable = {
    mixin: function( type, options ) {
      var proto = type.prototype;
      options = extend( {
        maxPoolSize: 50, // since we don't want to blow too much memory
        initialSize: 0
      }, options );
      var pool = type.pool = [];
      if ( options.defaultFactory ) {
        type.dirtyFromPool = function() {
          if ( pool.length ) {
            return pool.pop();
          }
          else {
            return options.defaultFactory();
          }
        };
        type.fillPool = function( n ) {
          while ( pool.length < n ) {
            pool.push( options.defaultFactory() );
          }
        };
        type.fillPool( options.initialSize );
      }
      if ( options.constructorDuplicateFactory ) {
        type.createFromPool = options.constructorDuplicateFactory( pool );
      }
      proto.freeToPool = function() {
        if ( pool.length < options.maxPoolSize ) {
          pool.push( this );
        }
      };
    }
  };
  phetCore.register( 'Poolable', Poolable );
  return Poolable;
} );
define( 'DOT/Vector2',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );
  function Vector2( x, y ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    phetAllocation && phetAllocation( 'Vector2' );
  }
  dot.register( 'Vector2', Vector2 );
  inherit( Object, Vector2, {
    isVector2: true,
    dimension: 2,
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },
    distanceXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return Math.sqrt( dx * dx + dy * dy );
    },
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      return dx * dx + dy * dy;
    },
    distanceSquaredXY: function( x, y ) {
      var dx = this.x - x;
      var dy = this.y - y;
      return dx * dx + dy * dy;
    },
    dot: function( v ) {
      return this.x * v.x + this.y * v.y;
    },
    dotXY: function( x, y ) {
      return this.x * x + this.y * y;
    },
    angle: function() {
      return Math.atan2( this.y, this.x );
    },
    angleBetween: function( v ) {
      var thisMagnitude = this.magnitude();
      var vMagnitude = v.magnitude();
      return Math.acos( dot.clamp( ( this.x * v.x + this.y * v.y ) / ( thisMagnitude * vMagnitude ), -1, 1 ) );
    },
    equals: function( other ) {
      return this.x === other.x && this.y === other.y;
    },
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;
    },
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y );
    },
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector2( this.x, this.y );
      }
    },
    crossScalar: function( v ) {
      return this.x * v.y - this.y * v.x;
    },
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector2( this.x / mag, this.y / mag );
      }
    },
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },
    timesScalar: function( scalar ) {
      return new Vector2( this.x * scalar, this.y * scalar );
    },
    times: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },
    componentTimes: function( v ) {
      return new Vector2( this.x * v.x, this.y * v.y );
    },
    plus: function( v ) {
      return new Vector2( this.x + v.x, this.y + v.y );
    },
    plusXY: function( x, y ) {
      return new Vector2( this.x + x, this.y + y );
    },
    plusScalar: function( scalar ) {
      return new Vector2( this.x + scalar, this.y + scalar );
    },
    minus: function( v ) {
      return new Vector2( this.x - v.x, this.y - v.y );
    },
    minusXY: function( x, y ) {
      return new Vector2( this.x - x, this.y - y );
    },
    minusScalar: function( scalar ) {
      return new Vector2( this.x - scalar, this.y - scalar );
    },
    dividedScalar: function( scalar ) {
      return new Vector2( this.x / scalar, this.y / scalar );
    },
    negated: function() {
      return new Vector2( -this.x, -this.y );
    },
    perpendicular: function() {
      return new Vector2( this.y, -this.x );
    },
    rotated: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return new Vector2( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },
    rotateAboutXY: function( x, y, angle ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var cos = Math.cos( angle );
      var sin = Math.sin( angle );
      this.x = x + dx * cos - dy * sin;
      this.y = y + dx * sin + dy * cos;
      return this; // for chaining
    },
    rotateAboutPoint: function( point, angle ) {
      return this.rotateAboutXY( point.x, point.y, angle );
    },
    rotatedAboutXY: function( x, y, angle ) {
      return new Vector2( this.x, this.y ).rotateAboutXY( x, y, angle );
    },
    rotatedAboutPoint: function( point, angle ) {
      return this.rotatedAboutXY( point.x, point.y, angle );
    },
    blend: function( vector, ratio ) {
      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );
    },
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },
    toString: function() {
      return 'Vector2(' + this.x + ', ' + this.y + ')';
    },
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, 0 );
    },
    setXY: function( x, y ) {
      this.x = x;
      this.y = y;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    set: function( v ) {
      return this.setXY( v.x, v.y );
    },
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },
    add: function( v ) {
      return this.setXY( this.x + v.x, this.y + v.y );
    },
    addXY: function( x, y ) {
      return this.setXY( this.x + x, this.y + y );
    },
    addScalar: function( scalar ) {
      return this.setXY( this.x + scalar, this.y + scalar );
    },
    subtract: function( v ) {
      return this.setXY( this.x - v.x, this.y - v.y );
    },
    subtractXY: function( x, y ) {
      return this.setXY( this.x - x, this.y - y );
    },
    subtractScalar: function( scalar ) {
      return this.setXY( this.x - scalar, this.y - scalar );
    },
    multiplyScalar: function( scalar ) {
      return this.setXY( this.x * scalar, this.y * scalar );
    },
    multiply: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },
    componentMultiply: function( v ) {
      return this.setXY( this.x * v.x, this.y * v.y );
    },
    divideScalar: function( scalar ) {
      return this.setXY( this.x / scalar, this.y / scalar );
    },
    negate: function() {
      return this.setXY( -this.x, -this.y );
    },
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    },
    roundSymmetric: function() {
      return this.setXY( dot.Util.roundSymmetric( this.x ),
        dot.Util.roundSymmetric( this.y ) );
    },
    rotate: function( angle ) {
      var newAngle = this.angle() + angle;
      var mag = this.magnitude();
      return this.setXY( mag * Math.cos( newAngle ), mag * Math.sin( newAngle ) );
    },
    setPolar: function( magnitude, angle ) {
      return this.setXY( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );
    },
    toStateObject: function() {
      return { x: this.x, y: this.y };
    }
  }, { // static functions on Vector2 itself
    createPolar: function( magnitude, angle ) {
      return new Vector2().setPolar( magnitude, angle );
    },
    fromStateObject: function( stateObject ) {
      return new Vector2( stateObject.x, stateObject.y );
    },
    getAngleBetweenVectors: function( startVector, endVector ) {
      var dx = endVector.x - startVector.x;
      var dy = endVector.y - startVector.y;
      return Math.atan2( dy, dx );
    },
    getDistanceBetweenVectors: function( startVector, endVector ) {
      var dx = endVector.x - startVector.x;
      var dy = endVector.y - startVector.y;
      return Math.sqrt( dx * dx + dy * dy );
    }
  } );
  Poolable.mixin( Vector2, {
    defaultFactory: function() { return new Vector2(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y );
        }
        else {
          return new Vector2( x, y );
        }
      };
    }
  } );
  Vector2.Immutable = function ImmutableVector2( x, y ) {
    Vector2.call( this, x, y );
  };
  var Immutable = Vector2.Immutable;
  inherit( Vector2, Immutable );
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector2' );
    };
  };
  Immutable.mutableOverrideHelper( 'setXY' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Vector2.ZERO = assert ? new Immutable( 0, 0 ) : new Vector2( 0, 0 );
  Vector2.X_UNIT = assert ? new Immutable( 1, 0 ) : new Vector2( 1, 0 );
  Vector2.Y_UNIT = assert ? new Immutable( 0, 1 ) : new Vector2( 0, 1 );
  return Vector2;
} );
define( 'DOT/Vector4',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );
  function Vector4( x, y, z, w ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
    this.w = w !== undefined ? w : 1;
    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );
    assert && assert( typeof this.w === 'number', 'w needs to be a number' );
    phetAllocation && phetAllocation( 'Vector4' );
  }
  dot.register( 'Vector4', Vector4 );
  inherit( Object, Vector4, {
    isVector4: true,
    dimension: 4,
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },
    magnitudeSquared: function() {
      this.dot( this );
    },
    distance: function( point ) {
      return this.minus( point ).magnitude();
    },
    distanceXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return Math.sqrt( dx * dx + dy * dy + dz * dz + dw * dw );
    },
    distanceSquared: function( point ) {
      return this.minus( point ).magnitudeSquared();
    },
    distanceSquaredXYZW: function( x, y, z, w ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      var dw = this.w - w;
      return dx * dx + dy * dy + dz * dz + dw * dw;
    },
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    dotXYZW: function( x, y, z, w ) {
      return this.x * x + this.y * y + this.z * z + this.w * w;
    },
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    },
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;
    },
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );
    },
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector4( this.x, this.y, this.z, this.w );
      }
    },
    normalized: function() {
      var magnitude = this.magnitude();
      assert && assert( magnitude !== 0, 'Cannot normalize a zero-magnitude vector' );
      return this.dividedScalar( magnitude );
    },
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },
    timesScalar: function( scalar ) {
      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },
    times: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },
    componentTimes: function( v ) {
      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },
    plus: function( v ) {
      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },
    plusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x + x, this.y + y, this.z + z, this.w + w );
    },
    plusScalar: function( scalar ) {
      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },
    minus: function( v ) {
      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },
    minusXYZW: function( x, y, z, w ) {
      return new Vector4( this.x - x, this.y - y, this.z - z, this.w - w );
    },
    minusScalar: function( scalar ) {
      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },
    dividedScalar: function( scalar ) {
      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },
    negated: function() {
      return new Vector4( -this.x, -this.y, -this.z, -this.w );
    },
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },
    toString: function() {
      return 'Vector4(' + this.x + ', ' + this.y + ', ' + this.z + ', ' + this.w + ')';
    },
    toVector3: function() {
      return new dot.Vector3( this.x, this.y, this.z );
    },
    setXYZW: function( x, y, z, w ) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    setZ: function( z ) {
      this.z = z;
      return this;
    },
    setW: function( w ) {
      this.w = w;
      return this;
    },
    set: function( v ) {
      return this.setXYZW( v.x, v.y, v.z, v.w );
    },
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },
    add: function( v ) {
      return this.setXYZW( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );
    },
    addXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x + x, this.y + y, this.z + z, this.w + w );
    },
    addScalar: function( scalar ) {
      return this.setXYZW( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );
    },
    subtract: function( v ) {
      return this.setXYZW( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );
    },
    subtractXYZW: function( x, y, z, w ) {
      return this.setXYZW( this.x - x, this.y - y, this.z - z, this.w - w );
    },
    subtractScalar: function( scalar ) {
      return this.setXYZW( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );
    },
    multiplyScalar: function( scalar ) {
      return this.setXYZW( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );
    },
    multiply: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },
    componentMultiply: function( v ) {
      return this.setXYZW( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );
    },
    divideScalar: function( scalar ) {
      return this.setXYZW( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );
    },
    negate: function() {
      return this.setXYZW( -this.x, -this.y, -this.z, -this.w );
    },
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      return this.divideScalar( mag );
    },
    roundSymmetric: function() {
      return this.setXYZW( dot.Util.roundSymmetric( this.x ),
                           dot.Util.roundSymmetric( this.y ),
                           dot.Util.roundSymmetric( this.z ),
                           dot.Util.roundSymmetric( this.w ) );
    }
  } );
  Poolable.mixin( Vector4, {
    defaultFactory: function() { return new Vector4(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z, w ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z, w );
        }
        else {
          return new Vector4( x, y, z, w );
        }
      };
    }
  } );
  Vector4.Immutable = function( x, y, z, w ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
    this.w = w !== undefined ? w : 1;
  };
  var Immutable = Vector4.Immutable;
  inherit( Vector4, Immutable );
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector4' );
    };
  };
  Immutable.mutableOverrideHelper( 'setXYZW' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );
  Immutable.mutableOverrideHelper( 'setW' );
  Vector4.ZERO = assert ? new Immutable( 0, 0, 0, 0 ) : new Vector4( 0, 0, 0, 0 );
  Vector4.X_UNIT = assert ? new Immutable( 1, 0, 0, 0 ) : new Vector4( 1, 0, 0, 0 );
  Vector4.Y_UNIT = assert ? new Immutable( 0, 1, 0, 0 ) : new Vector4( 0, 1, 0, 0 );
  Vector4.Z_UNIT = assert ? new Immutable( 0, 0, 1, 0 ) : new Vector4( 0, 0, 1, 0 );
  Vector4.W_UNIT = assert ? new Immutable( 0, 0, 0, 1 ) : new Vector4( 0, 0, 0, 1 );
  return Vector4;
} );
define( 'DOT/Vector3',['require','DOT/dot','PHET_CORE/inherit','PHET_CORE/Poolable','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  require( 'DOT/Util' );
  require( 'DOT/Vector2' );
  require( 'DOT/Vector4' );
  function Vector3( x, y, z ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
    assert && assert( typeof this.x === 'number', 'x needs to be a number' );
    assert && assert( typeof this.y === 'number', 'y needs to be a number' );
    assert && assert( typeof this.z === 'number', 'z needs to be a number' );
    phetAllocation && phetAllocation( 'Vector3' );
  }
  dot.register( 'Vector3', Vector3 );
  inherit( Object, Vector3, {
    isVector3: true,
    dimension: 3,
    magnitude: function() {
      return Math.sqrt( this.magnitudeSquared() );
    },
    magnitudeSquared: function() {
      return this.dot( this );
    },
    distance: function( point ) {
      return Math.sqrt( this.distanceSquared( point ) );
    },
    distanceXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return Math.sqrt( dx * dx + dy * dy + dz * dz );
    },
    distanceSquared: function( point ) {
      var dx = this.x - point.x;
      var dy = this.y - point.y;
      var dz = this.z - point.z;
      return dx * dx + dy * dy + dz * dz;
    },
    distanceSquaredXYZ: function( x, y, z ) {
      var dx = this.x - x;
      var dy = this.y - y;
      var dz = this.z - z;
      return dx * dx + dy * dy + dz * dz;
    },
    dot: function( v ) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    dotXYZ: function( x, y, z ) {
      return this.x * x + this.y * y + this.z * z;
    },
    angleBetween: function( v ) {
      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );
    },
    equals: function( other ) {
      return this.x === other.x && this.y === other.y && this.z === other.z;
    },
    equalsEpsilon: function( other, epsilon ) {
      if ( !epsilon ) {
        epsilon = 0;
      }
      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;
    },
    isFinite: function() {
      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );
    },
    copy: function( vector ) {
      if ( vector ) {
        return vector.set( this );
      }
      else {
        return new Vector3( this.x, this.y, this.z );
      }
    },
    cross: function( v ) {
      return new Vector3(
        this.y * v.z - this.z * v.y,
        this.z * v.x - this.x * v.z,
        this.x * v.y - this.y * v.x
      );
    },
    normalized: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return new Vector3( this.x / mag, this.y / mag, this.z / mag );
      }
    },
    roundedSymmetric: function() {
      return this.copy().roundSymmetric();
    },
    withMagnitude: function( magnitude ) {
      return this.copy().setMagnitude( magnitude );
    },
    timesScalar: function( scalar ) {
      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );
    },
    times: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.timesScalar( scalar );
    },
    componentTimes: function( v ) {
      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );
    },
    plus: function( v ) {
      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );
    },
    plusXYZ: function( x, y, z ) {
      return new Vector3( this.x + x, this.y + y, this.z + z );
    },
    plusScalar: function( scalar ) {
      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );
    },
    minus: function( v ) {
      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );
    },
    minusXYZ: function( x, y, z ) {
      return new Vector3( this.x - x, this.y - y, this.z - z );
    },
    minusScalar: function( scalar ) {
      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );
    },
    dividedScalar: function( scalar ) {
      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );
    },
    negated: function() {
      return new Vector3( -this.x, -this.y, -this.z );
    },
    blend: function( vector, ratio ) {
      return this.plus( vector.minus( this ).times( ratio ) );
    },
    average: function( vector ) {
      return this.blend( vector, 0.5 );
    },
    toString: function() {
      return 'Vector3(' + this.x + ', ' + this.y + ', ' + this.z + ')';
    },
    toVector2: function() {
      return new dot.Vector2( this.x, this.y );
    },
    toVector4: function() {
      return new dot.Vector4( this.x, this.y, this.z, 1 );
    },
    setXYZ: function( x, y, z ) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setX: function( x ) {
      this.x = x;
      return this;
    },
    setY: function( y ) {
      this.y = y;
      return this;
    },
    setZ: function( z ) {
      this.z = z;
      return this;
    },
    set: function( v ) {
      return this.setXYZ( v.x, v.y, v.z );
    },
    setMagnitude: function( magnitude ) {
      var scale = magnitude / this.magnitude();
      return this.multiplyScalar( scale );
    },
    add: function( v ) {
      return this.setXYZ( this.x + v.x, this.y + v.y, this.z + v.z );
    },
    addXYZ: function( x, y, z ) {
      return this.setXYZ( this.x + x, this.y + y, this.z + z );
    },
    addScalar: function( scalar ) {
      return this.setXYZ( this.x + scalar, this.y + scalar, this.z + scalar );
    },
    subtract: function( v ) {
      return this.setXYZ( this.x - v.x, this.y - v.y, this.z - v.z );
    },
    subtractXYZ: function( x, y, z ) {
      return this.setXYZ( this.x - x, this.y - y, this.z - z );
    },
    subtractScalar: function( scalar ) {
      return this.setXYZ( this.x - scalar, this.y - scalar, this.z - scalar );
    },
    multiplyScalar: function( scalar ) {
      return this.setXYZ( this.x * scalar, this.y * scalar, this.z * scalar );
    },
    multiply: function( scalar ) {
      assert && assert( scalar.dimension === undefined );
      return this.multiplyScalar( scalar );
    },
    componentMultiply: function( v ) {
      return this.setXYZ( this.x * v.x, this.y * v.y, this.z * v.z );
    },
    divideScalar: function( scalar ) {
      return this.setXYZ( this.x / scalar, this.y / scalar, this.z / scalar );
    },
    negate: function() {
      return this.setXYZ( -this.x, -this.y, -this.z );
    },
    normalize: function() {
      var mag = this.magnitude();
      if ( mag === 0 ) {
        throw new Error( 'Cannot normalize a zero-magnitude vector' );
      }
      else {
        return this.divideScalar( mag );
      }
    },
    roundSymmetric: function() {
      return this.setXYZ( dot.Util.roundSymmetric( this.x ),
                          dot.Util.roundSymmetric( this.y ),
                          dot.Util.roundSymmetric( this.z ) );
    }
  }, {
    slerp: function( start, end, ratio ) {
      return dot.Quaternion.slerp( new dot.Quaternion(), dot.Quaternion.getRotationQuaternion( start, end ), ratio ).timesVector3( start );
    }
  } );
  Poolable.mixin( Vector3, {
    defaultFactory: function() { return new Vector3(); },
    constructorDuplicateFactory: function( pool ) {
      return function( x, y, z ) {
        if ( pool.length ) {
          return pool.pop().setXY( x, y, z );
        }
        else {
          return new Vector3( x, y, z );
        }
      };
    }
  } );
  Vector3.Immutable = function( x, y, z ) {
    this.x = x !== undefined ? x : 0;
    this.y = y !== undefined ? y : 0;
    this.z = z !== undefined ? z : 0;
  };
  var Immutable = Vector3.Immutable;
  inherit( Vector3, Immutable );
  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {
    Immutable.prototype[ mutableFunctionName ] = function() {
      throw new Error( 'Cannot call mutable method \'' + mutableFunctionName + '\' on immutable Vector3' );
    };
  };
  Immutable.mutableOverrideHelper( 'setXYZ' );
  Immutable.mutableOverrideHelper( 'setX' );
  Immutable.mutableOverrideHelper( 'setY' );
  Immutable.mutableOverrideHelper( 'setZ' );
  Vector3.ZERO = assert ? new Immutable( 0, 0, 0 ) : new Vector3( 0, 0, 0 );
  Vector3.X_UNIT = assert ? new Immutable( 1, 0, 0 ) : new Vector3( 1, 0, 0 );
  Vector3.Y_UNIT = assert ? new Immutable( 0, 1, 0 ) : new Vector3( 0, 1, 0 );
  Vector3.Z_UNIT = assert ? new Immutable( 0, 0, 1 ) : new Vector3( 0, 0, 1 );
  return Vector3;
} );
define( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  require( 'DOT/Vector3' );
  require( 'DOT/Vector4' );
  var Float32Array = window.Float32Array || Array;
  function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
    this.entries = new Float32Array( 16 );
    this.rowMajor(
      v00 !== undefined ? v00 : 1, v01 !== undefined ? v01 : 0, v02 !== undefined ? v02 : 0, v03 !== undefined ? v03 : 0,
      v10 !== undefined ? v10 : 0, v11 !== undefined ? v11 : 1, v12 !== undefined ? v12 : 0, v13 !== undefined ? v13 : 0,
      v20 !== undefined ? v20 : 0, v21 !== undefined ? v21 : 0, v22 !== undefined ? v22 : 1, v23 !== undefined ? v23 : 0,
      v30 !== undefined ? v30 : 0, v31 !== undefined ? v31 : 0, v32 !== undefined ? v32 : 0, v33 !== undefined ? v33 : 1,
      type );
  }
  dot.register( 'Matrix4', Matrix4 );
  Matrix4.Types = {
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_3D: 2,
    SCALING: 3,
    AFFINE: 4
  };
  var Types = Matrix4.Types;
  Matrix4.identity = function() {
    return new Matrix4(
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.IDENTITY );
  };
  Matrix4.translation = function( x, y, z ) {
    return new Matrix4(
      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1,
      Types.TRANSLATION_3D );
  };
  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };
  Matrix4.scaling = function( x, y, z ) {
    y = y === undefined ? x : y;
    z = z === undefined ? x : z;
    return new Matrix4(
      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1,
      Types.SCALING );
  };
  Matrix4.rotationAxisAngle = function( axis, angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var C = 1 - c;
    return new Matrix4(
      axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,
      axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,
      axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };
  Matrix4.rotationX = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    return new Matrix4(
      1, 0, 0, 0,
      0, c, -s, 0,
      0, s, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };
  Matrix4.rotationY = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    return new Matrix4(
      c, 0, s, 0,
      0, 1, 0, 0,
      -s, 0, c, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };
  Matrix4.rotationZ = function( angle ) {
    var c = Math.cos( angle );
    var s = Math.sin( angle );
    return new Matrix4(
      c, -s, 0, 0,
      s, c, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1,
      Types.AFFINE );
  };
  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {
    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );
    return new Matrix4(
      cotangent / aspect, 0, 0, 0,
      0, cotangent, 0, 0,
      0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),
      0, 0, -1, 0 );
  };
  Matrix4.prototype = {
    constructor: Matrix4,
    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v30;
      this.entries[ 4 ] = v01;
      this.entries[ 5 ] = v11;
      this.entries[ 6 ] = v21;
      this.entries[ 7 ] = v31;
      this.entries[ 8 ] = v02;
      this.entries[ 9 ] = v12;
      this.entries[ 10 ] = v22;
      this.entries[ 11 ] = v32;
      this.entries[ 12 ] = v03;
      this.entries[ 13 ] = v13;
      this.entries[ 14 ] = v23;
      this.entries[ 15 ] = v33;
      this.type = type === undefined ? ( ( v30 === 0 && v31 === 0 && v32 === 0 && v33 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },
    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {
      return this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );
    },
    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(), matrix.m03(),
        matrix.m10(), matrix.m11(), matrix.m12(), matrix.m13(),
        matrix.m20(), matrix.m21(), matrix.m22(), matrix.m23(),
        matrix.m30(), matrix.m31(), matrix.m32(), matrix.m33(),
        matrix.type );
    },
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 4 ]; },
    m02: function() { return this.entries[ 8 ]; },
    m03: function() { return this.entries[ 12 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 5 ]; },
    m12: function() { return this.entries[ 9 ]; },
    m13: function() { return this.entries[ 13 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 6 ]; },
    m22: function() { return this.entries[ 10 ]; },
    m23: function() { return this.entries[ 14 ]; },
    m30: function() { return this.entries[ 3 ]; },
    m31: function() { return this.entries[ 7 ]; },
    m32: function() { return this.entries[ 11 ]; },
    m33: function() { return this.entries[ 15 ]; },
    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m03() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m13() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() ) &&
             isFinite( this.m23() ) &&
             isFinite( this.m30() ) &&
             isFinite( this.m31() ) &&
             isFinite( this.m32() ) &&
             isFinite( this.m33() );
    },
    getTranslation: function() {
      return new dot.Vector3( this.m03(), this.m13(), this.m23() );
    },
    get translation() { return this.getTranslation(); },
    getScaleVector: function() {
      var m0003 = this.m00() + this.m03();
      var m1013 = this.m10() + this.m13();
      var m2023 = this.m20() + this.m23();
      var m3033 = this.m30() + this.m33();
      var m0103 = this.m01() + this.m03();
      var m1113 = this.m11() + this.m13();
      var m2123 = this.m21() + this.m23();
      var m3133 = this.m31() + this.m33();
      var m0203 = this.m02() + this.m03();
      var m1213 = this.m12() + this.m13();
      var m2223 = this.m22() + this.m23();
      var m3233 = this.m32() + this.m33();
      return new dot.Vector3(
        Math.sqrt( m0003 * m0003 + m1013 * m1013 + m2023 * m2023 + m3033 * m3033 ),
        Math.sqrt( m0103 * m0103 + m1113 * m1113 + m2123 * m2123 + m3133 * m3133 ),
        Math.sqrt( m0203 * m0203 + m1213 * m1213 + m2223 * m2223 + m3233 * m3233 ) );
    },
    get scaleVector() { return this.getScaleVector(); },
    getCSSTransform: function() {
      return 'matrix3d(' +
             this.entries[ 0 ].toFixed( 20 ) + ',' +
             this.entries[ 1 ].toFixed( 20 ) + ',' +
             this.entries[ 2 ].toFixed( 20 ) + ',' +
             this.entries[ 3 ].toFixed( 20 ) + ',' +
             this.entries[ 4 ].toFixed( 20 ) + ',' +
             this.entries[ 5 ].toFixed( 20 ) + ',' +
             this.entries[ 6 ].toFixed( 20 ) + ',' +
             this.entries[ 7 ].toFixed( 20 ) + ',' +
             this.entries[ 8 ].toFixed( 20 ) + ',' +
             this.entries[ 9 ].toFixed( 20 ) + ',' +
             this.entries[ 10 ].toFixed( 20 ) + ',' +
             this.entries[ 11 ].toFixed( 20 ) + ',' +
             this.entries[ 12 ].toFixed( 20 ) + ',' +
             this.entries[ 13 ].toFixed( 20 ) + ',' +
             this.entries[ 14 ].toFixed( 20 ) + ',' +
             this.entries[ 15 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() && this.m03() === m.m03() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() && this.m13() === m.m13() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22() && this.m23() === m.m23() &&
             this.m30() === m.m30() && this.m31() === m.m31() && this.m32() === m.m32() && this.m33() === m.m33();
    },
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon &&
             Math.abs( this.m01() - m.m01() ) < epsilon &&
             Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m03() - m.m03() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon &&
             Math.abs( this.m11() - m.m11() ) < epsilon &&
             Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m13() - m.m13() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon &&
             Math.abs( this.m21() - m.m21() ) < epsilon &&
             Math.abs( this.m22() - m.m22() ) < epsilon &&
             Math.abs( this.m23() - m.m23() ) < epsilon &&
             Math.abs( this.m30() - m.m30() ) < epsilon &&
             Math.abs( this.m31() - m.m31() ) < epsilon &&
             Math.abs( this.m32() - m.m32() ) < epsilon &&
             Math.abs( this.m33() - m.m33() ) < epsilon;
    },
    copy: function() {
      return new Matrix4(
        this.m00(), this.m01(), this.m02(), this.m03(),
        this.m10(), this.m11(), this.m12(), this.m13(),
        this.m20(), this.m21(), this.m22(), this.m23(),
        this.m30(), this.m31(), this.m32(), this.m33(),
        this.type
      );
    },
    plus: function( m ) {
      return new Matrix4(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),
        this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()
      );
    },
    minus: function( m ) {
      return new Matrix4(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),
        this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()
      );
    },
    transposed: function() {
      return new Matrix4(
        this.m00(), this.m10(), this.m20(), this.m30(),
        this.m01(), this.m11(), this.m21(), this.m31(),
        this.m02(), this.m12(), this.m22(), this.m32(),
        this.m03(), this.m13(), this.m23(), this.m33() );
    },
    negated: function() {
      return new Matrix4(
        -this.m00(), -this.m01(), -this.m02(), -this.m03(),
        -this.m10(), -this.m11(), -this.m12(), -this.m13(),
        -this.m20(), -this.m21(), -this.m22(), -this.m23(),
        -this.m30(), -this.m31(), -this.m32(), -this.m33() );
    },
    inverted: function() {
      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_3D:
          return new Matrix4(
            1, 0, 0, -this.m03(),
            0, 1, 0, -this.m13(),
            0, 0, 1, -this.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        case Types.SCALING:
          return new Matrix4(
            1 / this.m00(), 0, 0, 0,
            0, 1 / this.m11(), 0, 0,
            0, 0, 1 / this.m22(), 0,
            0, 0, 0, 1 / this.m33(), Types.SCALING );
        case Types.AFFINE:
        case Types.OTHER:
          var det = this.getDeterminant();
          if ( det !== 0 ) {
            return new Matrix4(
              ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,
              ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,
              ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,
              ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,
              ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,
              ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,
              ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,
              ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,
              ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,
              ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,
              ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,
              ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,
              ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,
              ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,
              ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,
              ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },
    timesMatrix: function( m ) {
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }
      if ( this.type === m.type ) {
        if ( this.type === Types.TRANSLATION_3D ) {
          return new Matrix4(
            1, 0, 0, this.m03() + m.m02(),
            0, 1, 0, this.m13() + m.m12(),
            0, 0, 1, this.m23() + m.m23(),
            0, 0, 0, 1, Types.TRANSLATION_3D );
        }
        else if ( this.type === Types.SCALING ) {
          return new Matrix4(
            this.m00() * m.m00(), 0, 0, 0,
            0, this.m11() * m.m11(), 0, 0,
            0, 0, this.m22() * m.m22(), 0,
            0, 0, 0, 1, Types.SCALING );
        }
      }
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        return new Matrix4(
          this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
          this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03(),
          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
          this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13(),
          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22(),
          this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23(),
          0, 0, 0, 1, Types.AFFINE );
      }
      return new Matrix4(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),
        this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),
        this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),
        this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),
        this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),
        this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),
        this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),
        this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33() );
    },
    timesVector4: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;
      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },
    timesVector3: function( v ) {
      return this.timesVector4( v.toVector4() ).toVector3();
    },
    timesTransposeVector4: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;
      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;
      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;
      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;
      return new dot.Vector4( x, y, z, w );
    },
    timesTransposeVector3: function( v ) {
      return this.timesTransposeVector4( v.toVector4() ).toVector3();
    },
    timesRelativeVector3: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;
      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;
      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },
    getDeterminant: function() {
      return this.m03() * this.m12() * this.m21() * this.m30() -
             this.m02() * this.m13() * this.m21() * this.m30() -
             this.m03() * this.m11() * this.m22() * this.m30() +
             this.m01() * this.m13() * this.m22() * this.m30() +
             this.m02() * this.m11() * this.m23() * this.m30() -
             this.m01() * this.m12() * this.m23() * this.m30() -
             this.m03() * this.m12() * this.m20() * this.m31() +
             this.m02() * this.m13() * this.m20() * this.m31() +
             this.m03() * this.m10() * this.m22() * this.m31() -
             this.m00() * this.m13() * this.m22() * this.m31() -
             this.m02() * this.m10() * this.m23() * this.m31() +
             this.m00() * this.m12() * this.m23() * this.m31() +
             this.m03() * this.m11() * this.m20() * this.m32() -
             this.m01() * this.m13() * this.m20() * this.m32() -
             this.m03() * this.m10() * this.m21() * this.m32() +
             this.m00() * this.m13() * this.m21() * this.m32() +
             this.m01() * this.m10() * this.m23() * this.m32() -
             this.m00() * this.m11() * this.m23() * this.m32() -
             this.m02() * this.m11() * this.m20() * this.m33() +
             this.m01() * this.m12() * this.m20() * this.m33() +
             this.m02() * this.m10() * this.m21() * this.m33() -
             this.m00() * this.m12() * this.m21() * this.m33() -
             this.m01() * this.m10() * this.m22() * this.m33() +
             this.m00() * this.m11() * this.m22() * this.m33();
    },
    get determinant() { return this.getDeterminant(); },
    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + ' ' + this.m03() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + ' ' + this.m13() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22() + ' ' + this.m23() + '\n' +
             this.m30() + ' ' + this.m31() + ' ' + this.m32() + ' ' + this.m33();
    },
    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
    }
  };
  Matrix4.IDENTITY = new Matrix4();
  Matrix4.IDENTITY.makeImmutable();
  return Matrix4;
} );
define( 'DOT/Matrix3',['require','DOT/dot','PHET_CORE/Poolable','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var FastArray = dot.FastArray;
  require( 'DOT/Vector2' );
  require( 'DOT/Vector3' );
  require( 'DOT/Matrix4' );
  var identityFastArray = new FastArray( 9 );
  identityFastArray[ 0 ] = 1;
  identityFastArray[ 4 ] = 1;
  identityFastArray[ 8 ] = 1;
  var createIdentityArray = FastArray === Array ?
                            function() {
                              return [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
                            } :
                            function() {
                              return new FastArray( identityFastArray );
                            };
  function Matrix3( argumentsShouldNotExist ) {
    assert && assert( !argumentsShouldNotExist, 'Matrix3 constructor should not be called with any arguments.  Use Matrix3.createFromPool()/Matrix3.identity()/etc.' );
    this.entries = createIdentityArray();
    phetAllocation && phetAllocation( 'Matrix3' );
    this.type = Types.IDENTITY;
  }
  dot.register( 'Matrix3', Matrix3 );
  Matrix3.Types = {
    OTHER: 0, // default
    IDENTITY: 1,
    TRANSLATION_2D: 2,
    SCALING: 3,
    AFFINE: 4
  };
  var Types = Matrix3.Types;
  Matrix3.identity = function() { return Matrix3.dirtyFromPool().setToIdentity(); };
  Matrix3.translation = function( x, y ) { return Matrix3.dirtyFromPool().setToTranslation( x, y ); };
  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };
  Matrix3.scaling = function( x, y ) { return Matrix3.dirtyFromPool().setToScale( x, y ); };
  Matrix3.scale = Matrix3.scaling;
  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) { return Matrix3.dirtyFromPool().setToAffine( m00, m01, m02, m10, m11, m12 ); };
  Matrix3.rowMajor = function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) { return Matrix3.dirtyFromPool().rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ); };
  Matrix3.rotationAxisAngle = function( axis, angle ) { return Matrix3.dirtyFromPool().setToRotationAxisAngle( axis, angle ); };
  Matrix3.rotationX = function( angle ) { return Matrix3.dirtyFromPool().setToRotationX( angle ); };
  Matrix3.rotationY = function( angle ) { return Matrix3.dirtyFromPool().setToRotationY( angle ); };
  Matrix3.rotationZ = function( angle ) { return Matrix3.dirtyFromPool().setToRotationZ( angle ); };
  Matrix3.rotation2 = Matrix3.rotationZ;
  Matrix3.rotationAround = function( angle, x, y ) {
    return Matrix3.translation( x, y ).timesMatrix( Matrix3.rotation2( angle ) ).timesMatrix( Matrix3.translation( -x, -y ) );
  };
  Matrix3.rotationAroundPoint = function( angle, point ) {
    return Matrix3.rotationAround( angle, point.x, point.y );
  };
  Matrix3.fromSVGMatrix = function( svgMatrix ) { return Matrix3.dirtyFromPool().setToSVGMatrix( svgMatrix ); };
  Matrix3.rotateAToB = function( a, b ) { return Matrix3.dirtyFromPool().setRotationAToB( a, b ); };
  Matrix3.prototype = {
    constructor: Matrix3,
    m00: function() { return this.entries[ 0 ]; },
    m01: function() { return this.entries[ 3 ]; },
    m02: function() { return this.entries[ 6 ]; },
    m10: function() { return this.entries[ 1 ]; },
    m11: function() { return this.entries[ 4 ]; },
    m12: function() { return this.entries[ 7 ]; },
    m20: function() { return this.entries[ 2 ]; },
    m21: function() { return this.entries[ 5 ]; },
    m22: function() { return this.entries[ 8 ]; },
    isIdentity: function() {
      return this.type === Types.IDENTITY || this.equals( Matrix3.IDENTITY );
    },
    isFastIdentity: function() {
      return this.type === Types.IDENTITY;
    },
    isAffine: function() {
      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );
    },
    isAligned: function() {
      return this.isAffine() && this.m01() === 0 && this.m10() === 0;
    },
    isAxisAligned: function() {
      return this.isAffine() && ( ( this.m01() === 0 && this.m10() === 0 ) || ( this.m00() === 0 && this.m11() === 0 ) );
    },
    isFinite: function() {
      return isFinite( this.m00() ) &&
             isFinite( this.m01() ) &&
             isFinite( this.m02() ) &&
             isFinite( this.m10() ) &&
             isFinite( this.m11() ) &&
             isFinite( this.m12() ) &&
             isFinite( this.m20() ) &&
             isFinite( this.m21() ) &&
             isFinite( this.m22() );
    },
    getDeterminant: function() {
      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();
    },
    get determinant() { return this.getDeterminant(); },
    getTranslation: function() {
      return new dot.Vector2( this.m02(), this.m12() );
    },
    get translation() { return this.getTranslation(); },
    getScaleVector: function() {
      return new dot.Vector2(
        Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),
        Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );
    },
    get scaleVector() { return this.getScaleVector(); },
    getRotation: function() {
      return Math.atan2( this.m10(), this.m00() );
    },
    get rotation() { return this.getRotation(); },
    toMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), this.m02(), 0,
        this.m10(), this.m11(), this.m12(), 0,
        this.m20(), this.m21(), this.m22(), 0,
        0, 0, 0, 1 );
    },
    toAffineMatrix4: function() {
      return new dot.Matrix4(
        this.m00(), this.m01(), 0, this.m02(),
        this.m10(), this.m11(), 0, this.m12(),
        0, 0, 1, 0,
        0, 0, 0, 1 );
    },
    toString: function() {
      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\n' +
             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\n' +
             this.m20() + ' ' + this.m21() + ' ' + this.m22();
    },
    toSVGMatrix: function() {
      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();
      result.a = this.m00();
      result.b = this.m10();
      result.c = this.m01();
      result.d = this.m11();
      result.e = this.m02();
      result.f = this.m12();
      return result;
    },
    getCSSTransform: function() {
      return 'matrix(' + this.entries[ 0 ].toFixed( 20 ) + ',' + this.entries[ 1 ].toFixed( 20 ) + ',' + this.entries[ 3 ].toFixed( 20 ) + ',' + this.entries[ 4 ].toFixed( 20 ) + ',' + this.entries[ 6 ].toFixed( 20 ) + ',' + this.entries[ 7 ].toFixed( 20 ) + ')';
    },
    get cssTransform() { return this.getCSSTransform(); },
    getSVGTransform: function() {
      function svgNumber( number ) {
        return number.toFixed( 20 );
      }
      switch( this.type ) {
        case Types.IDENTITY:
          return '';
        case Types.TRANSLATION_2D:
          return 'translate(' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
        case Types.SCALING:
          return 'scale(' + svgNumber( this.entries[ 0 ] ) + ( this.entries[ 0 ] === this.entries[ 4 ] ? '' : ',' + svgNumber( this.entries[ 4 ] ) ) + ')';
        default:
          return 'matrix(' + svgNumber( this.entries[ 0 ] ) + ',' + svgNumber( this.entries[ 1 ] ) + ',' + svgNumber( this.entries[ 3 ] ) + ',' + svgNumber( this.entries[ 4 ] ) + ',' + svgNumber( this.entries[ 6 ] ) + ',' + svgNumber( this.entries[ 7 ] ) + ')';
      }
    },
    get svgTransform() { return this.getSVGTransform(); },
    getCSSTransformStyles: function() {
      var transformCSS = this.getCSSTransform();
      return {
        '-webkit-perspective': 1000,
        '-webkit-backface-visibility': 'hidden',
        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible
        '-ms-transform': transformCSS,
        '-o-transform': transformCSS,
        'transform': transformCSS,
        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin
        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?
      };
    },
    get cssTransformStyles() { return this.getCSSTransformStyles(); },
    equals: function( m ) {
      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&
             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&
             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();
    },
    equalsEpsilon: function( m, epsilon ) {
      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&
             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&
             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;
    },
    copy: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m01(), this.m02(),
        this.m10(), this.m11(), this.m12(),
        this.m20(), this.m21(), this.m22(),
        this.type
      );
    },
    plus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },
    minus: function( m ) {
      return Matrix3.createFromPool(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },
    transposed: function() {
      return Matrix3.createFromPool(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },
    negated: function() {
      return Matrix3.createFromPool(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },
    inverted: function() {
      var det;
      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return Matrix3.createFromPool(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return Matrix3.createFromPool(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return Matrix3.createFromPool(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },
    timesMatrix: function( m ) {
      if ( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {
        return this.type === Types.IDENTITY ? m : this;
      }
      if ( this.type === m.type ) {
        if ( this.type === Types.TRANSLATION_2D ) {
          return Matrix3.createFromPool(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          return Matrix3.createFromPool(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        return Matrix3.createFromPool(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }
      return Matrix3.createFromPool(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },
    timesVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02();
      var y = this.m10() * v.x + this.m11() * v.y + this.m12();
      return new dot.Vector2( x, y );
    },
    timesVector3: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;
      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;
      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;
      return new dot.Vector3( x, y, z );
    },
    timesTransposeVector2: function( v ) {
      var x = this.m00() * v.x + this.m10() * v.y;
      var y = this.m01() * v.x + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },
    timesRelativeVector2: function( v ) {
      var x = this.m00() * v.x + this.m01() * v.y;
      var y = this.m10() * v.y + this.m11() * v.y;
      return new dot.Vector2( x, y );
    },
    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
      this.entries[ 0 ] = v00;
      this.entries[ 1 ] = v10;
      this.entries[ 2 ] = v20;
      this.entries[ 3 ] = v01;
      this.entries[ 4 ] = v11;
      this.entries[ 5 ] = v21;
      this.entries[ 6 ] = v02;
      this.entries[ 7 ] = v12;
      this.entries[ 8 ] = v22;
      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;
      return this;
    },
    set: function( matrix ) {
      return this.rowMajor(
        matrix.m00(), matrix.m01(), matrix.m02(),
        matrix.m10(), matrix.m11(), matrix.m12(),
        matrix.m20(), matrix.m21(), matrix.m22(),
        matrix.type );
    },
    setArray: function( array ) {
      return this.rowMajor(
        array[ 0 ], array[ 3 ], array[ 6 ],
        array[ 1 ], array[ 4 ], array[ 7 ],
        array[ 2 ], array[ 5 ], array[ 8 ] );
    },
    set00: function( value ) {
      this.entries[ 0 ] = value;
      return this;
    },
    set01: function( value ) {
      this.entries[ 3 ] = value;
      return this;
    },
    set02: function( value ) {
      this.entries[ 6 ] = value;
      return this;
    },
    set10: function( value ) {
      this.entries[ 1 ] = value;
      return this;
    },
    set11: function( value ) {
      this.entries[ 4 ] = value;
      return this;
    },
    set12: function( value ) {
      this.entries[ 7 ] = value;
      return this;
    },
    set20: function( value ) {
      this.entries[ 2 ] = value;
      return this;
    },
    set21: function( value ) {
      this.entries[ 5 ] = value;
      return this;
    },
    set22: function( value ) {
      this.entries[ 8 ] = value;
      return this;
    },
    makeImmutable: function() {
      this.rowMajor = function() {
        throw new Error( 'Cannot modify immutable matrix' );
      };
      return this;
    },
    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {
      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
    },
    add: function( m ) {
      return this.rowMajor(
        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),
        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),
        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()
      );
    },
    subtract: function( m ) {
      return this.rowMajor(
        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),
        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),
        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()
      );
    },
    transpose: function() {
      return this.rowMajor(
        this.m00(), this.m10(), this.m20(),
        this.m01(), this.m11(), this.m21(),
        this.m02(), this.m12(), this.m22(),
        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined
      );
    },
    negate: function() {
      return this.rowMajor(
        -this.m00(), -this.m01(), -this.m02(),
        -this.m10(), -this.m11(), -this.m12(),
        -this.m20(), -this.m21(), -this.m22()
      );
    },
    invert: function() {
      var det;
      switch( this.type ) {
        case Types.IDENTITY:
          return this;
        case Types.TRANSLATION_2D:
          return this.rowMajor(
            1, 0, -this.m02(),
            0, 1, -this.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        case Types.SCALING:
          return this.rowMajor(
            1 / this.m00(), 0, 0,
            0, 1 / this.m11(), 0,
            0, 0, 1 / this.m22(), Types.SCALING );
        case Types.AFFINE:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              0, 0, 1, Types.AFFINE
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        case Types.OTHER:
          det = this.getDeterminant();
          if ( det !== 0 ) {
            return this.rowMajor(
              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,
              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,
              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,
              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,
              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,
              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,
              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,
              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,
              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,
              Types.OTHER
            );
          }
          else {
            throw new Error( 'Matrix could not be inverted, determinant === 0' );
          }
        default:
          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );
      }
    },
    multiplyMatrix: function( m ) {
      if ( m.type === Types.IDENTITY ) {
        return this;
      }
      if ( this.type === Types.IDENTITY ) {
        return this.set( m );
      }
      if ( this.type === m.type ) {
        if ( this.type === Types.TRANSLATION_2D ) {
          return this.rowMajor(
            1, 0, this.m02() + m.m02(),
            0, 1, this.m12() + m.m12(),
            0, 0, 1, Types.TRANSLATION_2D );
        }
        else if ( this.type === Types.SCALING ) {
          return this.rowMajor(
            this.m00() * m.m00(), 0, 0,
            0, this.m11() * m.m11(), 0,
            0, 0, 1, Types.SCALING );
        }
      }
      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {
        return this.rowMajor(
          this.m00() * m.m00() + this.m01() * m.m10(),
          this.m00() * m.m01() + this.m01() * m.m11(),
          this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),
          this.m10() * m.m00() + this.m11() * m.m10(),
          this.m10() * m.m01() + this.m11() * m.m11(),
          this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),
          0, 0, 1, Types.AFFINE );
      }
      return this.rowMajor(
        this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),
        this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),
        this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),
        this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),
        this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),
        this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),
        this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),
        this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),
        this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );
    },
    prependTranslation: function( x, y ) {
      this.set02( this.m02() + x );
      this.set12( this.m12() + y );
      if ( this.type === Types.IDENTITY || this.type === Types.TRANSLATION_2D ) {
        this.type = Types.TRANSLATION_2D;
      }
      else if ( this.type === Types.OTHER ) {
        this.type = Types.OTHER;
      }
      else {
        this.type = Types.AFFINE;
      }
      return this; // for chaining
    },
    setToIdentity: function() {
      return this.rowMajor(
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
        Types.IDENTITY );
    },
    setToTranslation: function( x, y ) {
      return this.rowMajor(
        1, 0, x,
        0, 1, y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    },
    setToScale: function( x, y ) {
      y = y === undefined ? x : y;
      return this.rowMajor(
        x, 0, 0,
        0, y, 0,
        0, 0, 1,
        Types.SCALING );
    },
    setToAffine: function( m00, m01, m02, m10, m11, m12 ) {
      return this.rowMajor( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );
    },
    setToRotationAxisAngle: function( axis, angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      var C = 1 - c;
      return this.rowMajor(
        axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,
        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,
        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,
        Types.OTHER );
    },
    setToRotationX: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      return this.rowMajor(
        1, 0, 0,
        0, c, -s,
        0, s, c,
        Types.OTHER );
    },
    setToRotationY: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      return this.rowMajor(
        c, 0, s,
        0, 1, 0,
        -s, 0, c,
        Types.OTHER );
    },
    setToRotationZ: function( angle ) {
      var c = Math.cos( angle );
      var s = Math.sin( angle );
      return this.rowMajor(
        c, -s, 0,
        s, c, 0,
        0, 0, 1,
        Types.AFFINE );
    },
    setToSVGMatrix: function( svgMatrix ) {
      return this.rowMajor(
        svgMatrix.a, svgMatrix.c, svgMatrix.e,
        svgMatrix.b, svgMatrix.d, svgMatrix.f,
        0, 0, 1,
        Types.AFFINE );
    },
    setRotationAToB: function( a, b ) {
      var start = a;
      var end = b;
      var epsilon = 0.0001;
      var e;
      var h;
      var f;
      var v = start.cross( end );
      e = start.dot( end );
      f = ( e < 0 ) ? -e : e;
      if ( f > 1.0 - epsilon ) {
        var c1;
        var c2;
        var c3;
        var x = new dot.Vector3(
          ( start.x > 0.0 ) ? start.x : -start.x,
          ( start.y > 0.0 ) ? start.y : -start.y,
          ( start.z > 0.0 ) ? start.z : -start.z
        );
        if ( x.x < x.y ) {
          if ( x.x < x.z ) {
            x = dot.Vector3.X_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }
        else {
          if ( x.y < x.z ) {
            x = dot.Vector3.Y_UNIT;
          }
          else {
            x = dot.Vector3.Z_UNIT;
          }
        }
        var u = x.minus( start );
        v = x.minus( end );
        c1 = 2.0 / u.dot( u );
        c2 = 2.0 / v.dot( v );
        c3 = c1 * c2 * u.dot( v );
        return this.rowMajor(
          -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x + 1,
          -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,
          -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,
          -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,
          -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y + 1,
          -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,
          -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,
          -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,
          -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z + 1
        );
      }
      else {
        var hvx;
        var hvz;
        var hvxy;
        var hvxz;
        var hvyz;
        h = 1.0 / ( 1.0 + e );
        hvx = h * v.x;
        hvz = h * v.z;
        hvxy = hvx * v.y;
        hvxz = hvx * v.z;
        hvyz = hvz * v.y;
        return this.rowMajor(
          e + hvx * v.x, hvxy - v.z, hvxz + v.y,
          hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,
          hvxz - v.y, hvyz + v.x, e + hvz * v.z
        );
      }
    },
    setTo32Bit: function() {
      if ( window.Float32Array ) {
        this.entries = new window.Float32Array( this.entries );
      }
      return this;
    },
    setTo64Bit: function() {
      if ( window.Float64Array ) {
        this.entries = new window.Float64Array( this.entries );
      }
      return this;
    },
    multiplyVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y + this.m02(),
        this.m10() * v.x + this.m11() * v.y + this.m12() );
    },
    multiplyVector3: function( v ) {
      return v.setXYZ(
        this.m00() * v.x + this.m01() * v.y + this.m02() * v.z,
        this.m10() * v.x + this.m11() * v.y + this.m12() * v.z,
        this.m20() * v.x + this.m21() * v.y + this.m22() * v.z );
    },
    multiplyTransposeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m10() * v.y,
        this.m01() * v.x + this.m11() * v.y );
    },
    multiplyRelativeVector2: function( v ) {
      return v.setXY(
        this.m00() * v.x + this.m01() * v.y,
        this.m10() * v.y + this.m11() * v.y );
    },
    canvasSetTransform: function( context ) {
      context.setTransform(
        this.entries[ 0 ],
        this.entries[ 1 ],
        this.entries[ 3 ],
        this.entries[ 4 ],
        this.entries[ 6 ],
        this.entries[ 7 ]
      );
    },
    canvasAppendTransform: function( context ) {
      if ( this.type !== Types.IDENTITY ) {
        context.transform(
          this.entries[ 0 ],
          this.entries[ 1 ],
          this.entries[ 3 ],
          this.entries[ 4 ],
          this.entries[ 6 ],
          this.entries[ 7 ]
        );
      }
    }
  };
  Poolable.mixin( Matrix3, {
    defaultFactory: function() { return new Matrix3(); },
    constructorDuplicateFactory: function( pool ) {
      return function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {
        var instance = pool.length ? pool.pop() : new Matrix3();
        return instance.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );
      };
    }
  } );
  Matrix3.IDENTITY = Matrix3.identity();
  Matrix3.IDENTITY.makeImmutable();
  Matrix3.X_REFLECTION = Matrix3.createFromPool(
    -1, 0, 0,
    0, 1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.X_REFLECTION.makeImmutable();
  Matrix3.Y_REFLECTION = Matrix3.createFromPool(
    1, 0, 0,
    0, -1, 0,
    0, 0, 1,
    Types.AFFINE );
  Matrix3.Y_REFLECTION.makeImmutable();
  Matrix3.translationTimesMatrix = function( x, y, m ) {
    var type;
    if ( m.type === Types.IDENTITY || m.type === Types.TRANSLATION_2D ) {
      return Matrix3.createFromPool(
        1, 0, m.m02() + x,
        0, 1, m.m12() + y,
        0, 0, 1,
        Types.TRANSLATION_2D );
    }
    else if ( m.type === Types.OTHER ) {
      type = Types.OTHER;
    }
    else {
      type = Types.AFFINE;
    }
    return Matrix3.createFromPool(
      m.m00(), m.m01(), m.m02() + x,
      m.m10(), m.m11(), m.m12() + y,
      m.m20(), m.m21(), m.m22(),
      type );
  };
  Matrix3.printer = {
    print: function( matrix ) {
      console.log( matrix.toString() );
    }
  };
  return Matrix3;
} );
define( 'PHET_CORE/cleanArray',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function cleanArray( arr ) {
    assert && assert( !arr || ( arr instanceof Array ), 'cleanArray either takes an Array' );
    if ( arr ) {
      while ( arr.length ) {
        arr.pop();
      }
      return arr;
    }
    else {
      return [];
    }
  }
  phetCore.register( 'cleanArray', cleanArray );
  return cleanArray;
} );
define( 'AXON/Events',['require','AXON/axon','PHET_CORE/cleanArray'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  function Events() {
    this._eventListeners = {}; // @private
    this._staticEventListeners = {}; // @private
  }
  axon.register( 'Events', Events );
  Events.prototype = {
    dispose: function() {
    },
    on: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      this._eventListeners[ eventName ] = this._eventListeners[ eventName ] || [];
      this._eventListeners[ eventName ].push( callback );
    },
    onStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      this._staticEventListeners[ eventName ] = this._staticEventListeners[ eventName ] || [];
      this._staticEventListeners[ eventName ].push( callback );
    },
    once: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      var self = this;
      var wrappedCallback = function() {
        self.off( eventName, wrappedCallback );
        if ( arguments.length === 0 ) {
          callback();
        }
        else {
          callback.apply( this, Array.prototype.slice.call( arguments, 0 ) );
        }
      };
      this.on( eventName, wrappedCallback );
      return wrappedCallback;
    },
    off: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      var index = -1;
      if ( this._eventListeners[ eventName ] ) {
        index = this._eventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._eventListeners[ eventName ].splice( index, 1 );
        }
      }
      return index; // so we can tell if we actually removed a listener
    },
    offStatic: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      var index = -1;
      if ( this._staticEventListeners[ eventName ] ) {
        index = this._staticEventListeners[ eventName ].indexOf( callback );
        if ( index !== -1 ) {
          this._staticEventListeners[ eventName ].splice( index, 1 );
        }
      }
      return index; // so we can tell if we actually removed a listener
    },
    hasListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      var array = this._eventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },
    hasStaticListener: function( eventName, callback ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      assert && assert( typeof callback === 'function', 'callback should be a function' );
      var array = this._staticEventListeners[ eventName ];
      return !!array && array.indexOf( callback ) >= 0;
    },
    removeAllEventListeners: function() {
      var eventName;
      for ( eventName in this._eventListeners ) {
        cleanArray( this._eventListeners[ eventName ] );
      }
      for ( eventName in this._staticEventListeners ) {
        cleanArray( this._staticEventListeners[ eventName ] );
      }
    },
    trigger: function( eventName ) {
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;
      var suffix;
      var hasNoArguments = arguments.length === 1;
      if ( !hasNoArguments && ( count > 0 || staticCount > 0 ) ) {
        phetAllocation && phetAllocation( 'Array' );
        suffix = Array.prototype.slice.call( arguments, 1 );
      }
      if ( count > 0 ) {
        listeners = listeners.slice();
      }
      var i;
      for ( i = 0; i < count; i++ ) {
        var listener = listeners[ i ];
        if ( hasNoArguments ) {
          listener();
        }
        else {
          listener.apply( this, suffix );
        }
        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }
      for ( i = 0; i < staticCount; i++ ) {
        var staticListener = staticListeners[ i ];
        if ( hasNoArguments ) {
          staticListener( arguments );
        }
        else {
          staticListener.apply( this, suffix );
        }
        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },
    trigger0: function( eventName ) {
      assert && assert( arguments.length === 1 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;
      if ( count > 0 ) {
        listeners = listeners.slice();
      }
      var i;
      for ( i = 0; i < count; i++ ) {
        listeners[ i ]();
        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }
      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]();
        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },
    trigger1: function( eventName, param1 ) {
      assert && assert( arguments.length === 2 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;
      if ( count > 0 ) {
        listeners = listeners.slice();
      }
      var i;
      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1 );
        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }
      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1 );
        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    },
    trigger2: function( eventName, param1, param2 ) {
      assert && assert( arguments.length === 3 );
      assert && assert( typeof eventName === 'string', 'eventName should be a string' );
      var listeners = this._eventListeners[ eventName ];
      var staticListeners = this._staticEventListeners[ eventName ];
      var count = listeners ? listeners.length : 0;
      var staticCount = staticListeners ? staticListeners.length : 0;
      if ( count > 0 ) {
        listeners = listeners.slice();
      }
      var i;
      for ( i = 0; i < count; i++ ) {
        listeners[ i ]( param1, param2 );
        assert && assert( !staticListeners || staticListeners.length === staticCount, 'Concurrent modifications of static listeners from within non-static listeners are forbidden' );
      }
      for ( i = 0; i < staticCount; i++ ) {
        staticListeners[ i ]( param1, param2 );
        assert && assert( staticListeners.length === staticCount, 'Concurrent modifications from static listeners are forbidden' );
      }
    }
  };
  return Events;
} );
define( 'DOT/Ray2',['require','DOT/dot'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  function Ray2( position, direction ) {
    this.position = position; // @public (read-only)
    this.direction = direction; // @public (read-only)
    assert && assert( Math.abs( direction.magnitude() - 1 ) < 0.01 , 'the direction must be a unit vector');
    phetAllocation && phetAllocation( 'Ray2' );
  }
  dot.register( 'Ray2', Ray2 );
  Ray2.prototype = {
    constructor: Ray2,
    shifted: function( distance ) {
      return new Ray2( this.pointAtDistance( distance ), this.direction );
    },
    pointAtDistance: function( distance ) {
      return this.position.plus( this.direction.timesScalar( distance ) );
    },
    toString: function() {
      return this.position.toString() + ' => ' + this.direction.toString();
    }
  };
  return Ray2;
} );
define( 'DOT/Transform3',['require','PHET_CORE/inherit','AXON/Events','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var dot = require( 'DOT/dot' );
  require( 'DOT/Matrix3' );
  require( 'DOT/Vector2' );
  require( 'DOT/Ray2' );
  var scratchMatrix = new dot.Matrix3();
  function checkMatrix( matrix ) {
    return ( matrix instanceof dot.Matrix3 ) && matrix.isFinite();
  }
  function Transform3( matrix ) {
    Events.call( this );
    this.matrix = dot.Matrix3.IDENTITY.copy();
    this.inverse = dot.Matrix3.IDENTITY.copy();
    this.matrixTransposed = dot.Matrix3.IDENTITY.copy();
    this.inverseTransposed = dot.Matrix3.IDENTITY.copy();
    this.inverseValid = true;
    this.transposeValid = true;
    this.inverseTransposeValid = true;
    if ( matrix ) {
      this.setMatrix( matrix );
    }
    phetAllocation && phetAllocation( 'Transform3' );
  }
  dot.register( 'Transform3', Transform3 );
  inherit( Events, Transform3, {
    setMatrix: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );
      this.matrix.set( matrix );
      this.invalidate();
    },
    invalidate: function() {
      assert && assert( this.matrix.isFinite() );
      this.inverseValid = false;
      this.transposeValid = false;
      this.inverseTransposeValid = false;
      this.trigger0( 'change' );
    },
    prepend: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );
      scratchMatrix.set( this.matrix );
      this.matrix.set( matrix );
      this.matrix.multiplyMatrix( scratchMatrix );
      this.invalidate();
    },
    prependTranslation: function( x, y ) {
      assert && assert( typeof x === 'number' && typeof y === 'number' && isFinite( x ) && isFinite( y ),
        'Attempted to prepend non-finite or non-number (x,y) to the transform' );
      this.matrix.prependTranslation( x, y );
      this.invalidate();
    },
    append: function( matrix ) {
      assert && assert( checkMatrix( matrix ), 'Matrix has NaNs, non-finite values, or isn\'t a matrix!' );
      this.matrix.multiplyMatrix( matrix );
      this.invalidate();
    },
    prependTransform: function( transform ) {
      this.prepend( transform.matrix );
    },
    appendTransform: function( transform ) {
      this.append( transform.matrix );
    },
    applyToCanvasContext: function( context ) {
      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );
    },
    copy: function() {
      var transform = new Transform3( this.matrix );
      transform.inverse = this.inverse;
      transform.matrixTransposed = this.matrixTransposed;
      transform.inverseTransposed = this.inverseTransposed;
      transform.inverseValid = this.inverseValid;
      transform.transposeValid = this.transposeValid;
      transform.inverseTransposeValid = this.inverseTransposeValid;
    },
    getMatrix: function() {
      return this.matrix;
    },
    getInverse: function() {
      if ( !this.inverseValid ) {
        this.inverseValid = true;
        this.inverse.set( this.matrix );
        this.inverse.invert();
      }
      return this.inverse;
    },
    getMatrixTransposed: function() {
      if ( !this.transposeValid ) {
        this.transposeValid = true;
        this.matrixTransposed.set( this.matrix );
        this.matrixTransposed.transpose();
      }
      return this.matrixTransposed;
    },
    getInverseTransposed: function() {
      if ( !this.inverseTransposeValid ) {
        this.inverseTransposeValid = true;
        this.inverseTransposed.set( this.getInverse() ); // triggers inverse to be valid
        this.inverseTransposed.transpose();
      }
      return this.inverseTransposed;
    },
    isIdentity: function() {
      return this.matrix.type === dot.Matrix3.Types.IDENTITY;
    },
    isFinite: function() {
      return this.matrix.isFinite();
    },
    transformPosition2: function( v ) {
      return this.matrix.timesVector2( v );
    },
    transformDelta2: function( v ) {
      var m = this.getMatrix();
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },
    transformNormal2: function( v ) {
      return this.getInverse().timesTransposeVector2( v ).normalize();
    },
    transformX: function( x ) {
      var m = this.getMatrix();
      assert && assert( !m.m01(), 'Transforming an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },
    transformY: function( y ) {
      var m = this.getMatrix();
      assert && assert( !m.m10(), 'Transforming a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },
    transformDeltaX: function( x ) {
      var m = this.getMatrix();
      return m.m00() * x;
    },
    transformDeltaY: function( y ) {
      var m = this.getMatrix();
      return m.m11() * y;
    },
    transformBounds2: function( bounds ) {
      return bounds.transformed( this.matrix );
    },
    transformShape: function( shape ) {
      return shape.transformed( this.matrix );
    },
    transformRay2: function( ray ) {
      return new dot.Ray2( this.transformPosition2( ray.position ), this.transformDelta2( ray.direction ).normalized() );
    },
    inversePosition2: function( v ) {
      return this.getInverse().timesVector2( v );
    },
    inverseDelta2: function( v ) {
      var m = this.getInverse();
      return new dot.Vector2( m.m00() * v.x + m.m01() * v.y, m.m10() * v.x + m.m11() * v.y );
    },
    inverseNormal2: function( v ) {
      return this.matrix.timesTransposeVector2( v ).normalize();
    },
    inverseX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      return m.m00() * x + m.m02();
    },
    inverseY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y + m.m12();
    },
    inverseDeltaX: function( x ) {
      var m = this.getInverse();
      assert && assert( !m.m01(), 'Inverting an X value with a rotation/shear is ill-defined' );
      return m.m00() * x;
    },
    inverseDeltaY: function( y ) {
      var m = this.getInverse();
      assert && assert( !m.m10(), 'Inverting a Y value with a rotation/shear is ill-defined' );
      return m.m11() * y;
    },
    inverseBounds2: function( bounds ) {
      return bounds.transformed( this.getInverse() );
    },
    inverseShape: function( shape ) {
      return shape.transformed( this.getInverse() );
    },
    inverseRay2: function( ray ) {
      return new dot.Ray2( this.inversePosition2( ray.position ), this.inverseDelta2( ray.direction ).normalized() );
    }
  } );
  return Transform3;
} );
define( 'SCENERY/util/TrailPointer',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  function TrailPointer( trail, isBefore ) {
    assert && assert( trail instanceof scenery.Trail, 'trail is not a trail' );
    this.trail = trail;
    this.setBefore( isBefore );
    phetAllocation && phetAllocation( 'TrailPointer' );
  }
  scenery.register( 'TrailPointer', TrailPointer );
  inherit( Object, TrailPointer, {
    copy: function() {
      return new TrailPointer( this.trail.copy(), this.isBefore );
    },
    setBefore: function( isBefore ) {
      this.isBefore = isBefore;
      this.isAfter = !isBefore;
    },
    getRenderSwappedPointer: function() {
      var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();
      if ( newTrail === null ) {
        return null;
      }
      else {
        return new TrailPointer( newTrail, !this.isBefore );
      }
    },
    getRenderBeforePointer: function() {
      return this.isBefore ? this : this.getRenderSwappedPointer();
    },
    getRenderAfterPointer: function() {
      return this.isAfter ? this : this.getRenderSwappedPointer();
    },
    compareRender: function( other ) {
      assert && assert( other !== null );
      var a = this.getRenderBeforePointer();
      var b = other.getRenderBeforePointer();
      if ( a !== null && b !== null ) {
        return a.trail.compare( b.trail );
      }
      else {
        if ( a === b ) {
          return 0; // uniqueness guarantees they were the same
        }
        else {
          return a === null ? 1 : -1;
        }
      }
    },
    compareNested: function( other ) {
      assert && assert( other );
      var comparison = this.trail.compare( other.trail );
      if ( comparison === 0 ) {
        if ( this.isBefore === other.isBefore ) {
          return 0;
        }
        else {
          return this.isBefore ? -1 : 1;
        }
      }
      else {
        if ( this.trail.isExtensionOf( other.trail ) ) {
          return other.isBefore ? 1 : -1;
        }
        else if ( other.trail.isExtensionOf( this.trail ) ) {
          return this.isBefore ? -1 : 1;
        }
        else {
          return comparison;
        }
      }
    },
    equalsRender: function( other ) {
      return this.compareRender( other ) === 0;
    },
    equalsNested: function( other ) {
      return this.compareNested( other ) === 0;
    },
    hasTrail: function() {
      return !!this.trail;
    },
    nestedForwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.lastNode()._children.length > 0 ) {
          this.trail.addDescendant( this.trail.lastNode()._children[ 0 ], 0 );
        }
        else {
          this.setBefore( false );
        }
      }
      else {
        if ( this.trail.indices.length === 0 ) {
          this.trail = null;
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();
          if ( this.trail.lastNode()._children.length > index + 1 ) {
            this.trail.addDescendant( this.trail.lastNode()._children[ index + 1 ], index + 1 );
            this.setBefore( true );
          }
          else {
          }
        }
      }
      return this;
    },
    nestedBackwards: function() {
      if ( this.isBefore ) {
        if ( this.trail.indices.length === 0 ) {
          this.trail = null;
          return null;
        }
        else {
          var index = this.trail.indices[ this.trail.indices.length - 1 ];
          this.trail.removeDescendant();
          if ( index - 1 >= 0 ) {
            this.trail.addDescendant( this.trail.lastNode()._children[ index - 1 ], index - 1 );
            this.setBefore( false );
          }
          else {
          }
        }
      }
      else {
        if ( this.trail.lastNode()._children.length > 0 ) {
          var children = this.trail.lastNode()._children;
          this.trail.addDescendant( children[ children.length - 1 ], children.length - 1 );
        }
        else {
          this.setBefore( true );
        }
      }
      return this;
    },
    eachNodeBetween: function( other, callback ) {
      this.eachTrailBetween( other, function( trail ) {
        return callback( trail.lastNode() );
      } );
    },
    eachTrailBetween: function( other, callback ) {
      if ( this.isBefore ) {
        callback( this.trail );
      }
      this.depthFirstUntil( other, function( pointer ) {
        if ( pointer.isBefore ) {
          return callback( pointer.trail );
        }
      }, true ); // exclude the endpoints so we can ignore the ending 'before' case
    },
    depthFirstUntil: function( other, callback, excludeEndpoints ) {
      assert && assert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );
      assert && assert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );
      this.trail.reindex();
      other.trail.reindex();
      var pointer = this.copy();
      pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified
      var first = true;
      while ( !pointer.equalsNested( other ) ) {
        assert && assert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );
        var skipSubtree = false;
        if ( first ) {
          if ( !excludeEndpoints ) {
            skipSubtree = callback( pointer );
          }
          first = false;
        }
        else {
          skipSubtree = callback( pointer );
        }
        if ( skipSubtree && pointer.isBefore ) {
          pointer.setBefore( false );
          if ( pointer.compareNested( other ) === 1 ) {
            break;
          }
        }
        else {
          pointer.nestedForwards();
        }
      }
      if ( !excludeEndpoints ) {
        callback( pointer );
      }
    },
    toString: function() {
      return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );
    }
  } );
  TrailPointer.compareNested = function( trailA, isBeforeA, trailB, isBeforeB ) {
    var comparison = trailA.compare( trailB );
    if ( comparison === 0 ) {
      if ( isBeforeA === isBeforeB ) {
        return 0;
      }
      else {
        return isBeforeA ? -1 : 1;
      }
    }
    else {
      if ( trailA.isExtensionOf( trailB ) ) {
        return isBeforeB ? 1 : -1;
      }
      else if ( trailB.isExtensionOf( trailA ) ) {
        return isBeforeA ? -1 : 1;
      }
      else {
        return comparison;
      }
    }
  };
  return TrailPointer;
} );
define( 'DOT/Bounds2',['require','DOT/dot','DOT/Vector2','PHET_CORE/inherit','PHET_CORE/Poolable'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var Vector2 = require( 'DOT/Vector2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scratchVector2 = new dot.Vector2();
  function Bounds2( minX, minY, maxX, maxY ) {
    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
    phetAllocation && phetAllocation( 'Bounds2' );
  }
  dot.register( 'Bounds2', Bounds2 );
  inherit( Object, Bounds2, {
    isBounds: true,
    dimension: 2,
    getWidth: function() { return this.maxX - this.minX; },
    get width() { return this.getWidth(); },
    getHeight: function() { return this.maxY - this.minY; },
    get height() { return this.getHeight(); },
    getX: function() { return this.minX; },
    get x() { return this.getX(); },
    getY: function() { return this.minY; },
    get y() { return this.getY(); },
    getMinX: function() { return this.minX; },
    getMinY: function() { return this.minY; },
    getMaxX: function() { return this.maxX; },
    getMaxY: function() { return this.maxY; },
    getLeft: function() { return this.minX; },
    get left() { return this.minX; },
    getTop: function() { return this.minY; },
    get top() { return this.minY; },
    getRight: function() { return this.maxX; },
    get right() { return this.maxX; },
    getBottom: function() { return this.maxY; },
    get bottom() { return this.maxY; },
    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },
    get centerX() { return this.getCenterX(); },
    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },
    get centerY() { return this.getCenterY(); },
    getLeftTop: function() { return new dot.Vector2( this.minX, this.minY ); },
    get leftTop() { return this.getLeftTop(); },
    getCenterTop: function() { return new dot.Vector2( this.getCenterX(), this.minY ); },
    get centerTop() { return this.getCenterTop(); },
    getRightTop: function() { return new dot.Vector2( this.maxX, this.minY ); },
    get rightTop() { return this.getRightTop(); },
    getLeftCenter: function() { return new dot.Vector2( this.minX, this.getCenterY() ); },
    get leftCenter() { return this.getLeftCenter(); },
    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },
    get center() { return this.getCenter(); },
    getRightCenter: function() { return new dot.Vector2( this.maxX, this.getCenterY() ); },
    get rightCenter() { return this.getRightCenter(); },
    getLeftBottom: function() { return new dot.Vector2( this.minX, this.maxY ); },
    get leftBottom() { return this.getLeftBottom(); },
    getCenterBottom: function() { return new dot.Vector2( this.getCenterX(), this.maxY ); },
    get centerBottom() { return this.getCenterBottom(); },
    getRightBottom: function() { return new dot.Vector2( this.maxX, this.maxY ); },
    get rightBottom() { return this.getRightBottom(); },
    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },
    isFinite: function() {
      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );
    },
    hasNonzeroArea: function() {
      return this.getWidth() > 0 && this.getHeight() > 0;
    },
    isValid: function() {
      return !this.isEmpty() && this.isFinite();
    },
    closestPointTo: function( location ) {
      if ( this.containsCoordinates( location.x, location.y ) ) {
        return location;
      }
      else {
        var xConstrained = Math.max( Math.min( location.x, this.maxX ), this.x );
        var yConstrained = Math.max( Math.min( location.y, this.maxY ), this.y );
        return new Vector2( xConstrained, yConstrained );
      }
    },
    containsCoordinates: function( x, y ) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    },
    containsPoint: function( point ) {
      return this.containsCoordinates( point.x, point.y );
    },
    containsBounds: function( bounds ) {
      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;
    },
    intersectsBounds: function( bounds ) {
      var minX = Math.max( this.minX, bounds.minX );
      var minY = Math.max( this.minY, bounds.minY );
      var maxX = Math.min( this.maxX, bounds.maxX );
      var maxY = Math.min( this.maxY, bounds.maxY );
      return ( maxX - minX ) >= 0 && ( maxY - minY >= 0 );
    },
    minimumDistanceToPointSquared: function( point ) {
      var closeX = point.x < this.minX ? this.minX : ( point.x > this.maxX ? this.maxX : null );
      var closeY = point.y < this.minY ? this.minY : ( point.y > this.maxY ? this.maxY : null );
      var d;
      if ( closeX === null && closeY === null ) {
        return 0;
      }
      else if ( closeX === null ) {
        d = closeY - point.y;
        return d * d;
      }
      else if ( closeY === null ) {
        d = closeX - point.x;
        return d * d;
      }
      else {
        var dx = closeX - point.x;
        var dy = closeY - point.y;
        return dx * dx + dy * dy;
      }
    },
    maximumDistanceToPointSquared: function( point ) {
      var x = point.x > this.getCenterX() ? this.minX : this.maxX;
      var y = point.y > this.getCenterY() ? this.minY : this.maxY;
      x -= point.x;
      y -= point.y;
      return x * x + y * y;
    },
    toString: function() {
      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';
    },
    equals: function( other ) {
      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;
    },
    equalsEpsilon: function( other, epsilon ) {
      epsilon = epsilon !== undefined ? epsilon : 0;
      var thisFinite = this.isFinite();
      var otherFinite = other.isFinite();
      if ( thisFinite && otherFinite ) {
        return Math.abs( this.minX - other.minX ) < epsilon &&
               Math.abs( this.minY - other.minY ) < epsilon &&
               Math.abs( this.maxX - other.maxX ) < epsilon &&
               Math.abs( this.maxY - other.maxY ) < epsilon;
      }
      else if ( thisFinite !== otherFinite ) {
        return false; // one is finite, the other is not. definitely not equal
      }
      else if ( this === other ) {
        return true; // exact same instance, must be equal
      }
      else {
        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&
               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&
               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&
               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );
      }
    },
    copy: function( bounds ) {
      if ( bounds ) {
        return bounds.set( this );
      }
      else {
        return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );
      }
    },
    union: function( bounds ) {
      return new Bounds2(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },
    intersection: function( bounds ) {
      return new Bounds2(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    withCoordinates: function( x, y ) {
      return new Bounds2(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },
    withPoint: function( point ) {
      return this.withCoordinates( point.x, point.y );
    },
    withMinX: function( minX ) {
      return new Bounds2( minX, this.minY, this.maxX, this.maxY );
    },
    withMinY: function( minY ) {
      return new Bounds2( this.minX, minY, this.maxX, this.maxY );
    },
    withMaxX: function( maxX ) {
      return new Bounds2( this.minX, this.minY, maxX, this.maxY );
    },
    withMaxY: function( maxY ) {
      return new Bounds2( this.minX, this.minY, this.maxX, maxY );
    },
    roundedOut: function() {
      return new Bounds2(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },
    roundedIn: function() {
      return new Bounds2(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },
    transformed: function( matrix ) {
      return this.copy().transform( matrix );
    },
    dilated: function( d ) {
      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },
    dilatedX: function( x ) {
      return new Bounds2( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },
    dilatedY: function( y ) {
      return new Bounds2( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },
    dilatedXY: function( x, y ) {
      return new Bounds2( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },
    eroded: function( amount ) { return this.dilated( -amount ); },
    erodedX: function( x ) { return this.dilatedX( -x ); },
    erodedY: function( y ) { return this.dilatedY( -y ); },
    erodedXY: function( x, y ) { return this.dilatedXY( -x, -y ); },
    withOffsets: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },
    shiftedX: function( x ) {
      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },
    shiftedY: function( y ) {
      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },
    shifted: function( x, y ) {
      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },
    setMinMax: function( minX, minY, maxX, maxY ) {
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
      return this;
    },
    setMinX: function( minX ) {
      this.minX = minX;
      return this;
    },
    setMinY: function( minY ) {
      this.minY = minY;
      return this;
    },
    setMaxX: function( maxX ) {
      this.maxX = maxX;
      return this;
    },
    setMaxY: function( maxY ) {
      this.maxY = maxY;
      return this;
    },
    set: function( bounds ) {
      return this.setMinMax( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );
    },
    includeBounds: function( bounds ) {
      return this.setMinMax(
        Math.min( this.minX, bounds.minX ),
        Math.min( this.minY, bounds.minY ),
        Math.max( this.maxX, bounds.maxX ),
        Math.max( this.maxY, bounds.maxY )
      );
    },
    constrainBounds: function( bounds ) {
      return this.setMinMax(
        Math.max( this.minX, bounds.minX ),
        Math.max( this.minY, bounds.minY ),
        Math.min( this.maxX, bounds.maxX ),
        Math.min( this.maxY, bounds.maxY )
      );
    },
    addCoordinates: function( x, y ) {
      return this.setMinMax(
        Math.min( this.minX, x ),
        Math.min( this.minY, y ),
        Math.max( this.maxX, x ),
        Math.max( this.maxY, y )
      );
    },
    addPoint: function( point ) {
      return this.addCoordinates( point.x, point.y );
    },
    roundOut: function() {
      return this.setMinMax(
        Math.floor( this.minX ),
        Math.floor( this.minY ),
        Math.ceil( this.maxX ),
        Math.ceil( this.maxY )
      );
    },
    roundIn: function() {
      return this.setMinMax(
        Math.ceil( this.minX ),
        Math.ceil( this.minY ),
        Math.floor( this.maxX ),
        Math.floor( this.maxY )
      );
    },
    transform: function( matrix ) {
      if ( this.isEmpty() ) {
        return this;
      }
      if ( matrix.isIdentity() ) {
        return this;
      }
      var minX = this.minX;
      var minY = this.minY;
      var maxX = this.maxX;
      var maxY = this.maxY;
      this.set( dot.Bounds2.NOTHING );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( minX, maxY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, minY ) ) );
      this.addPoint( matrix.multiplyVector2( scratchVector2.setXY( maxX, maxY ) ) );
      return this;
    },
    dilate: function( d ) {
      return this.setMinMax( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );
    },
    dilateX: function( x ) {
      return this.setMinMax( this.minX - x, this.minY, this.maxX + x, this.maxY );
    },
    dilateY: function( y ) {
      return this.setMinMax( this.minX, this.minY - y, this.maxX, this.maxY + y );
    },
    dilateXY: function( x, y ) {
      return this.setMinMax( this.minX - x, this.minY - y, this.maxX + x, this.maxY + y );
    },
    erode: function( d ) { return this.dilate( -d ); },
    erodeX: function( x ) { return this.dilateX( -x ); },
    erodeY: function( y ) { return this.dilateY( -y ); },
    erodeXY: function( x, y ) { return this.dilateXY( -x, -y ); },
    offset: function( left, top, right, bottom ) {
      return new Bounds2( this.minX - left, this.minY - top, this.maxX + right, this.maxY + bottom );
    },
    shiftX: function( x ) {
      return this.setMinMax( this.minX + x, this.minY, this.maxX + x, this.maxY );
    },
    shiftY: function( y ) {
      return this.setMinMax( this.minX, this.minY + y, this.maxX, this.maxY + y );
    },
    shift: function( x, y ) {
      return this.setMinMax( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );
    },
    getClosestPoint: function( x, y, result ) {
      if ( result ) {
        result.setXY( x, y );
      }
      else {
        result = new dot.Vector2( x, y );
      }
      if ( result.x < this.minX ) { result.x = this.minX; }
      if ( result.x > this.maxX ) { result.x = this.maxX; }
      if ( result.y < this.minY ) { result.y = this.minY; }
      if ( result.y > this.maxY ) { result.y = this.maxY; }
      return result;
    }
  }, {
    rect: function( x, y, width, height ) {
      return new Bounds2( x, y, x + width, y + height );
    },
    point: function( x, y ) {
      if ( x instanceof dot.Vector2 ) {
        var p = x;
        return new Bounds2( p.x, p.y, p.x, p.y );
      }
      else {
        return new Bounds2( x, y, x, y );
      }
    }
  } );
  Poolable.mixin( Bounds2, {
    defaultFactory: function() { return Bounds2.NOTHING.copy(); },
    constructorDuplicateFactory: function( pool ) {
      return function( minX, minY, maxX, maxY ) {
        if ( pool.length ) {
          return pool.pop().setMinMax( minX, minY, maxX, maxY );
        }
        else {
          return new Bounds2( minX, minY, maxX, maxY );
        }
      };
    }
  } );
  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );
  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
  function catchImmutableSetterLowHangingFruit( bounds ) {
    bounds.setMinMax = function() { throw new Error( 'Attempt to set \"setMinMax\" of an immutable Bounds2 object' ); };
    bounds.set = function() { throw new Error( 'Attempt to set \"set\" of an immutable Bounds2 object' ); };
    bounds.includeBounds = function() { throw new Error( 'Attempt to set \"includeBounds\" of an immutable Bounds2 object' ); };
    bounds.constrainBounds = function() { throw new Error( 'Attempt to set \"constrainBounds\" of an immutable Bounds2 object' ); };
    bounds.addCoordinates = function() { throw new Error( 'Attempt to set \"addCoordinates\" of an immutable Bounds2 object' ); };
    bounds.transform = function() { throw new Error( 'Attempt to set \"transform\" of an immutable Bounds2 object' ); };
  }
  if ( assert ) {
    catchImmutableSetterLowHangingFruit( Bounds2.EVERYTHING );
    catchImmutableSetterLowHangingFruit( Bounds2.NOTHING );
  }
  return Bounds2;
} );
define( 'KITE/kite',['require','PHET_CORE/Namespace','PHET_CORE/phetAllocation'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  window.phetAllocation = require( 'PHET_CORE/phetAllocation' );
  var kite = new Namespace( 'kite' );
  kite.register( 'svgNumber', function( n ) {
    return n.toFixed( 20 );
  } );
  return kite;
} );
define( 'KITE/segments/Segment',['require','KITE/kite','PHET_CORE/inherit','AXON/Events','DOT/Util','DOT/Bounds2'],function( require ) {
  'use strict';
  var kite = require( 'KITE/kite' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match
  var Bounds2 = require( 'DOT/Bounds2' );
  function Segment() {
    Events.call( this );
  }
  kite.register( 'Segment', Segment );
  var identityFunction = function identityFunction( x ) { return x; };
  inherit( Events, Segment, {
    areStrokedBoundsDilated: function() {
      var epsilon = 0.0000001;
      return Math.abs( this.startTangent.x * this.startTangent.y ) < epsilon && Math.abs( this.endTangent.x * this.endTangent.y ) < epsilon;
    },
    getBoundsWithTransform: function( matrix ) {
      var transformedSegment = this.transformed( matrix );
      return transformedSegment.getBounds();
    },
    subdivisions: function( tList ) {
      var right = this; // eslint-disable-line consistent-this
      var result = [];
      for ( var i = 0; i < tList.length; i++ ) {
        var t = tList[ i ];
        var arr = right.subdivided( t );
        assert && assert( arr.length === 2 );
        result.push( arr[ 0 ] );
        right = arr[ 1 ];
        for ( var j = i + 1; j < tList.length; j++ ) {
          tList[ j ] = DotUtil.linear( t, 1, 0, 1, tList[ j ] );
        }
      }
      result.push( right );
      return result;
    },
    subdividedIntoMonotone: function() {
      return this.subdivisions( this.getInteriorExtremaTs() );
    },
    toPiecewiseLinearSegments: function( options, minLevels, maxLevels, segments, start, end ) {
      minLevels = minLevels === undefined ? options.minLevels : minLevels;
      maxLevels = maxLevels === undefined ? options.maxLevels : maxLevels;
      segments = segments || [];
      var pointMap = options.pointMap || identityFunction;
      start = start || pointMap( this.start );
      end = end || pointMap( this.end );
      var middle = pointMap( this.positionAt( 0.5 ) );
      assert && assert( minLevels <= maxLevels );
      assert && assert( options.distanceEpsilon === null || typeof options.distanceEpsilon === 'number' );
      assert && assert( options.curveEpsilon === null || typeof options.curveEpsilon === 'number' );
      assert && assert( !pointMap || typeof pointMap === 'function' );
      var finished = maxLevels === 0; // bail out once we reach our maximum number of subdivision levels
      if ( !finished && minLevels <= 0 ) { // force subdivision if minLevels hasn't been reached
        finished = ( options.curveEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) / start.distanceSquared( end ) < options.curveEpsilon ) ) &&
                   ( options.distanceEpsilon === null || ( DotUtil.distToSegmentSquared( middle, start, end ) < options.distanceEpsilon ) );
      }
      if ( finished ) {
        segments.push( new kite.Line( start, end ) );
      }
      else {
        var subdividedSegments = this.subdivided( 0.5 );
        subdividedSegments[ 0 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, start, middle );
        subdividedSegments[ 1 ].toPiecewiseLinearSegments( options, minLevels - 1, maxLevels - 1, segments, middle, end );
      }
      return segments;
    }
  } );
  Segment.addInvalidatingGetterSetter = function( type, name ) {
    var internalName = '_' + name;
    var capitalizedName = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
    var getterName = 'get' + capitalizedName;
    var setterName = 'set' + capitalizedName;
    type.prototype[ getterName ] = function() {
      return this[ internalName ];
    };
    type.prototype[ setterName ] = function( value ) {
      if ( this[ internalName ] !== value ) {
        this[ internalName ] = value;
        this.invalidate();
      }
      return this; // allow chaining
    };
    Object.defineProperty( type.prototype, name, {
      set: type.prototype[ setterName ],
      get: type.prototype[ getterName ]
    } );
  };
  Segment.closestToPoint = function( segments, point, threshold ) {
    var thresholdSquared = threshold * threshold;
    var items = [];
    var bestList = [];
    var bestDistanceSquared = Number.POSITIVE_INFINITY;
    var thresholdOk = false;
    _.each( segments, function( segment ) {
      if ( segment.explicitClosestToPoint ) {
        var infos = segment.explicitClosestToPoint( point );
        _.each( infos, function( info ) {
          if ( info.distanceSquared < bestDistanceSquared ) {
            bestList = [ info ];
            bestDistanceSquared = info.distanceSquared;
          }
          else if ( info.distanceSquared === bestDistanceSquared ) {
            bestList.push( info );
          }
        } );
      }
      else {
        var ts = [ 0 ].concat( segment.getInteriorExtremaTs() ).concat( [ 1 ] );
        for ( var i = 0; i < ts.length - 1; i++ ) {
          var ta = ts[ i ];
          var tb = ts[ i + 1 ];
          var pa = segment.positionAt( ta );
          var pb = segment.positionAt( tb );
          var bounds = Bounds2.point( pa ).addPoint( pb );
          var minDistanceSquared = bounds.minimumDistanceToPointSquared( point );
          if ( minDistanceSquared <= bestDistanceSquared ) {
            var maxDistanceSquared = bounds.maximumDistanceToPointSquared( point );
            if ( maxDistanceSquared < bestDistanceSquared ) {
              bestDistanceSquared = maxDistanceSquared;
              bestList = []; // clear it
            }
            items.push( {
              ta: ta,
              tb: tb,
              pa: pa,
              pb: pb,
              segment: segment,
              bounds: bounds,
              min: minDistanceSquared,
              max: maxDistanceSquared
            } );
          }
        }
      }
    } );
    while ( items.length && !thresholdOk ) {
      var curItems = items;
      items = [];
      thresholdOk = true;
      _.each( curItems, function( item ) {
        if ( item.minDistanceSquared > bestDistanceSquared ) {
          return; // drop this item
        }
        if ( thresholdOk && item.pa.distanceSquared( item.pb ) > thresholdSquared ) {
          thresholdOk = false;
        }
        var tmid = ( item.ta + item.tb ) / 2;
        var pmid = item.segment.positionAt( tmid );
        var boundsA = Bounds2.point( item.pa ).addPoint( pmid );
        var boundsB = Bounds2.point( item.pb ).addPoint( pmid );
        var minA = boundsA.minimumDistanceToPointSquared( point );
        var minB = boundsB.minimumDistanceToPointSquared( point );
        if ( minA <= bestDistanceSquared ) {
          var maxA = boundsA.maximumDistanceToPointSquared( point );
          if ( maxA < bestDistanceSquared ) {
            bestDistanceSquared = maxA;
            bestList = []; // clear it
          }
          items.push( {
            ta: item.ta,
            tb: tmid,
            pa: item.pa,
            pb: pmid,
            segment: item.segment,
            bounds: boundsA,
            min: minA,
            max: maxA
          } );
        }
        if ( minB <= bestDistanceSquared ) {
          var maxB = boundsB.maximumDistanceToPointSquared( point );
          if ( maxB < bestDistanceSquared ) {
            bestDistanceSquared = maxB;
            bestList = []; // clear it
          }
          items.push( {
            ta: tmid,
            tb: item.tb,
            pa: pmid,
            pb: item.pb,
            segment: item.segment,
            bounds: boundsB,
            min: minB,
            max: maxB
          } );
        }
      } );
    }
    _.each( items, function( item ) {
      var t = ( item.ta + item.tb ) / 2;
      var closestPoint = item.segment.positionAt( t );
      bestList.push( {
        segment: item.segment,
        t: t,
        closestPoint: closestPoint,
        distanceSquared: point.distanceSquared( closestPoint )
      } );
    } );
    return bestList;
  };
  Segment.polynomialGetOverlapCubic = function( p0s, p1s, p2s, p3s, q0s, q1s, q2s, q3s ) {
    if ( q3s === 0 ) {
      return Segment.polynomialGetOverlapQuadratic( p0s, p1s, p2s, q0s, q1s, q2s );
    }
    var a = Math.pow( p3s / q3s, 1 / 3 );
    if ( a === 0 ) {
      return null; // If there would be solutions, then q3s would have been non-zero
    }
    var b = ( p2s - a * a * q2s ) / ( 3 * a * a * q3s );
    return {
      a: a,
      b: b
    };
  };
  Segment.polynomialGetOverlapQuadratic = function( p0s, p1s, p2s, q0s, q1s, q2s ) {
    if ( q2s === 0 ) {
      return Segment.polynomialGetOverlapLinear( p0s, p1s, q0s, q1s );
    }
    var discr = p2s / q2s;
    if ( discr < 0 ) {
      return null; // not possible to have a solution with an imaginary a
    }
    var a = Math.sqrt( p2s / q2s );
    if ( a === 0 ) {
      return null; // If there would be solutions, then q2s would have been non-zero
    }
    var b = ( p1s - a * q1s ) / ( 2 * a * q2s );
    return {
      a: a,
      b: b
    };
  };
  Segment.polynomialGetOverlapLinear = function( p0s, p1s, q0s, q1s ) {
    if ( q1s === 0 ) {
      if ( p0s === q0s ) {
        return true;
      }
      else {
        return null;
      }
    }
    var a = p1s / q1s;
    if ( a === 0 ) {
      return null;
    }
    var b = ( p0s - q0s ) / q1s;
    return {
      a: a,
      b: b
    };
  };
  Segment.clipOverlap = function( overlap ) {
  };
  return Segment;
} );
define( 'KITE/segments/Arc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var DotUtil = require( 'DOT/Util' ); // eslint-disable-line require-statement-match
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  function Arc( center, radius, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );
    this._center = center; // @private {Vector2}
    this._radius = radius; // @private {number}
    this._startAngle = startAngle; // @private {number}
    this._endAngle = endAngle; // @private {number}
    this._anticlockwise = anticlockwise; // @private {boolean}
    this.invalidate();
  }
  kite.register( 'Arc', Arc );
  inherit( Segment, Arc, {
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );
      return this.positionAtAngle( this.angleAt( t ) );
    },
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );
      return this.tangentAtAngle( this.angleAt( t ) );
    },
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );
      return ( this._anticlockwise ? -1 : 1 ) / this._radius;
    },
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.Arc( this._center, this._radius, angle0, angleT, this._anticlockwise ),
        new kite.Arc( this._center, this._radius, angleT, angle1, this._anticlockwise )
      ];
    },
    invalidate: function() {
      this._start = null; // {Vector2|null}
      this._end = null; // {Vector2|null}
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._actualEndAngle = null; // {number|null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean|null} - Whether it's a full circle (and not just an arc)
      this._angleDifference = null; // {number|null}
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}
      if ( this._radius < 0 ) {
        this._radius = -this._radius;
        this._startAngle += Math.PI;
        this._endAngle += Math.PI;
      }
      assert && assert( !( ( !this.anticlockwise && this._endAngle - this._startAngle <= -Math.PI * 2 ) ||
                           ( this.anticlockwise && this._startAngle - this._endAngle <= -Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this.anticlockwise && this._endAngle - this._startAngle > Math.PI * 2 ) ||
                           ( this.anticlockwise && this._startAngle - this._endAngle > Math.PI * 2 ) ),
        'Not handling arcs with start/end angles that show differences in-between browser handling' );
      this.trigger0( 'invalidated' );
    },
    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },
    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        if ( this._anticlockwise ) {
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },
    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.copy().withPoint( this.getStart() )
          .withPoint( this.getEnd() );
        if ( this._startAngle !== this._endAngle ) {
          this.includeBoundsAtAngle( 0 );
          this.includeBoundsAtAngle( Math.PI / 2 );
          this.includeBoundsAtAngle( Math.PI );
          this.includeBoundsAtAngle( 3 * Math.PI / 2 );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    getNondegenerateSegments: function() {
      if ( this._radius <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else {
        return [ this ]; // basically, Arcs aren't really degenerate that easily
      }
    },
    includeBoundsAtAngle: function( angle ) {
      if ( this.containsAngle( angle ) ) {
        this._bounds = this._bounds.withPoint( this._center.plus( Vector2.createPolar( this._radius, angle ) ) );
      }
    },
    mapAngle: function( angle ) {
      return ( this._startAngle > this.getActualEndAngle() ) ?
             DotUtil.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             DotUtil.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },
    positionAtAngle: function( angle ) {
      return this._center.plus( Vector2.createPolar( this._radius, angle ) );
    },
    tangentAtAngle: function( angle ) {
      var normal = Vector2.createPolar( 1, angle );
      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },
    containsAngle: function( angle ) {
      var normalizedAngle = this._anticlockwise ? angle - this._endAngle : angle - this._startAngle;
      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );
      return positiveMinAngle <= this.angleDifference;
    },
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
        var sweepFlag = this._anticlockwise ? '0' : '1';
        var largeArcFlag;
        if ( this.angleDifference < Math.PI * 2 - epsilon ) {
          largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';
          this._svgPathFragment = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' + largeArcFlag +
                                  ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );
        }
        else {
          var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
          var splitPoint = this._center.plus( Vector2.createPolar( this._radius, splitOppositeAngle ) );
          largeArcFlag = '0'; // since we split it in 2, it's always the small arc
          var firstArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                         largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
          var secondArc = 'A ' + kite.svgNumber( this._radius ) + ' ' + kite.svgNumber( this._radius ) + ' 0 ' +
                          largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.end.x ) + ' ' + kite.svgNumber( this.end.y );
          this._svgPathFragment = firstArc + ' ' + secondArc;
        }
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    strokeLeft: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? 1 : -1 ) * lineWidth / 2, this._startAngle, this._endAngle, this._anticlockwise ) ];
    },
    strokeRight: function( lineWidth ) {
      return [ new kite.Arc( this._center, this._radius + ( this._anticlockwise ? -1 : 1 ) * lineWidth / 2, this._endAngle, this._startAngle, !this._anticlockwise ) ];
    },
    getInteriorExtremaTs: function() {
      var self = this;
      var result = [];
      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {
        if ( self.containsAngle( angle ) ) {
          var t = self.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },
    intersection: function( ray ) {
      var result = []; // hits in order
      var epsilon = 0;
      var centerToRay = ray.position.minus( this._center );
      var tmp = ray.direction.dot( centerToRay );
      var centerToRayDistSq = centerToRay.magnitudeSquared();
      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this._radius * this._radius );
      if ( discriminant < epsilon ) {
        return result;
      }
      var base = ray.direction.dot( this._center ) - ray.direction.dot( ray.position );
      var sqt = Math.sqrt( discriminant ) / 2;
      var ta = base - sqt;
      var tb = base + sqt;
      if ( tb < epsilon ) {
        return result;
      }
      var pointB = ray.pointAtDistance( tb );
      var normalB = pointB.minus( this._center ).normalized();
      if ( ta < epsilon ) {
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(), // normal is towards the ray
            wind: this._anticlockwise ? -1 : 1 // since we are inside, wind this way
          } );
        }
      }
      else {
        var pointA = ray.pointAtDistance( ta );
        var normalA = pointA.minus( this._center ).normalized();
        if ( this.containsAngle( normalA.angle() ) ) {
          result.push( {
            distance: ta,
            point: pointA,
            normal: normalA,
            wind: this._anticlockwise ? 1 : -1 // hit from outside
          } );
        }
        if ( this.containsAngle( normalB.angle() ) ) {
          result.push( {
            distance: tb,
            point: pointB,
            normal: normalB.negated(),
            wind: this._anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way
          } );
        }
      }
      return result;
    },
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    writeToContext: function( context ) {
      context.arc( this._center.x, this._center.y, this._radius, this._startAngle, this._endAngle, this._anticlockwise );
    },
    transformed: function( matrix ) {
      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this._startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this._endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();
      var anticlockwise = matrix.getDeterminant() >= 0 ? this._anticlockwise : !this._anticlockwise;
      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }
      var scaleVector = matrix.getScaleVector();
      if ( scaleVector.x !== scaleVector.y ) {
        var radiusX = scaleVector.x * this._radius;
        var radiusY = scaleVector.y * this._radius;
        return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );
      }
      else {
        var radius = scaleVector.x * this._radius;
        return new kite.Arc( matrix.timesVector2( this._center ), radius, startAngle, endAngle, anticlockwise );
      }
    }
  } );
  Segment.addInvalidatingGetterSetter( Arc, 'center' );
  Segment.addInvalidatingGetterSetter( Arc, 'radius' );
  Segment.addInvalidatingGetterSetter( Arc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( Arc, 'anticlockwise' );
  return Arc;
} );
define( 'KITE/util/Overlap',['require','PHET_CORE/inherit','KITE/kite'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var kite = require( 'KITE/kite' );
  function Overlap( a, b ) {
    assert && assert( typeof a === 'number' && isFinite( a ) && a !== 0,
      'a should be a finite non-zero number' );
    assert && assert( typeof b === 'number' && isFinite( b ),
      'b should be a finite number' );
    this.a = a;
    this.b = b;
    var t0 = 0;
    var t1 = 1;
    var qt0 = this.apply( t0 );
    var qt1 = this.apply( t1 );
    if ( qt0 > 1 ) {
      qt0 = 1;
      t0 = this.applyInverse( qt0 );
    }
    if ( qt0 < 0 ) {
      qt0 = 0;
      t0 = this.applyInverse( qt0 );
    }
    if ( qt1 > 1 ) {
      qt1 = 1;
      t1 = this.applyInverse( qt1 );
    }
    if ( qt1 < 0 ) {
      qt1 = 0;
      t1 = this.applyInverse( qt1 );
    }
    this.t0 = t0;
    this.t1 = t1;
    if ( a > 0 ) {
      this.qt0 = qt0;
      this.qt1 = qt1;
    }
    else {
      this.qt0 = qt1;
      this.qt1 = qt0;
    }
    assert && assert( this.t0 >= 0 && this.t0 <= 1, 't0 out of range: ' + this.t0 );
    assert && assert( this.t1 >= 0 && this.t1 <= 1, 't1 out of range: ' + this.t1 );
    assert && assert( this.qt0 >= 0 && this.qt0 <= 1, 'qt0 out of range: ' + this.qt0 );
    assert && assert( this.qt1 >= 0 && this.qt1 <= 1, 'qt1 out of range: ' + this.qt1 );
  }
  kite.register( 'Overlap', Overlap );
  inherit( Object, Overlap, {
    apply: function( t ) {
      return this.a * t + this.b;
    },
    applyInverse: function( t ) {
      return ( t - this.b ) / this.a;
    }
  } );
  return kite.Overlap;
} );
define( 'KITE/segments/Quadratic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );
  var solveQuadraticRootsReal = Util.solveQuadraticRootsReal;
  var arePointsCollinear = Util.arePointsCollinear;
  function Quadratic( start, control, end ) {
    Segment.call( this );
    this._start = start;
    this._control = control;
    this._end = end;
    this.invalidate();
  }
  kite.register( 'Quadratic', Quadratic );
  inherit( Segment, Quadratic, {
    degree: 2, // degree of the polynomial (quadratic)
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );
      var mt = 1 - t;
      return this._start.times( mt * mt ).plus( this._control.times( 2 * mt * t ) ).plus( this._end.times( t * t ) );
    },
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );
      return this._control.minus( this._start ).times( 2 * ( 1 - t ) ).plus( this._end.minus( this._control ).times( 2 * t ) );
    },
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = this._control;
        var p2 = isZero ? this._end : this._start;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t, true )[ 0 ].curvatureAt( 1 );
      }
    },
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }
      var leftMid = this._start.blend( this._control, t );
      var rightMid = this._control.blend( this._end, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Quadratic( this._start, leftMid, mid ),
        new kite.Quadratic( mid, rightMid, this._end )
      ];
    },
    invalidate: function() {
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._tCriticalX = null; // {number|null} T where x-derivative is 0 (replaced with NaN if not in range)
      this._tCriticalY = null; // {number|null} T where y-derivative is 0 (replaced with NaN if not in range)
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}
      this.trigger0( 'invalidated' );
    },
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        var controlIsStart = this._start.equals( this._control );
        this._startTangent = controlIsStart ?
                             this._end.minus( this._start ).normalized() :
                             this._control.minus( this._start ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        var controlIsEnd = this._end.equals( this._control );
        this._endTangent = controlIsEnd ?
                           this._end.minus( this._start ).normalized() :
                           this._end.minus( this._control ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    getTCriticalX: function() {
      if ( this._tCriticalX === null ) {
        this._tCriticalX = Quadratic.extremaT( this._start.x, this._control.x, this._end.x );
      }
      return this._tCriticalX;
    },
    get tCriticalX() { return this.getTCriticalX(); },
    getTCriticalY: function() {
      if ( this._tCriticalY === null ) {
        this._tCriticalY = Quadratic.extremaT( this._start.y, this._control.y, this._end.y );
      }
      return this._tCriticalY;
    },
    get tCriticalY() { return this.getTCriticalY(); },
    getNondegenerateSegments: function() {
      var start = this._start;
      var control = this._control;
      var end = this._end;
      var startIsEnd = start.equals( end );
      var startIsControl = start.equals( control );
      var endIsControl = start.equals( control );
      if ( startIsEnd && startIsControl ) {
        return [];
      }
      else if ( startIsEnd ) {
        var halfPoint = this.positionAt( 0.5 );
        return [
          new kite.Line( start, halfPoint ),
          new kite.Line( halfPoint, end )
        ];
      }
      else if ( arePointsCollinear( start, control, end ) ) {
        if ( startIsControl || endIsControl ) {
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
        var delta = end.minus( start );
        var p1d = control.minus( start ).dot( delta.normalized ) / delta.magnitude();
        var t = Quadratic.extremaT( 0, p1d, 1 );
        if ( !isNaN( t ) && t > 0 && t < 1 ) {
          var pt = this.positionAt( t );
          return _.flatten( [
            new kite.Line( start, pt ).getNondegenerateSegments(),
            new kite.Line( pt, end ).getNondegenerateSegments()
          ] );
        }
        else {
          return [ new kite.Line( start, end ) ]; // no extra nondegenerate check since start !== end
        }
      }
      else {
        return [ this ];
      }
    },
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = new Bounds2( Math.min( this._start.x, this._end.x ), Math.min( this._start.y, this._end.y ), Math.max( this._start.x, this._end.x ), Math.max( this._start.y, this._end.y ) );
        var tCriticalX = this.getTCriticalX();
        var tCriticalY = this.getTCriticalY();
        if ( !isNaN( tCriticalX ) && tCriticalX > 0 && tCriticalX < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalX ) );
        }
        if ( !isNaN( tCriticalY ) && tCriticalY > 0 && tCriticalY < 1 ) {
          this._bounds = this._bounds.withPoint( this.positionAt( tCriticalY ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    offsetTo: function( r, reverse ) {
      var curves = [ this ];
      var depth = 5; // generates 2^depth curves
      for ( var i = 0; i < depth; i++ ) {
        curves = _.flatten( _.map( curves, function( curve ) {
          return curve.subdivided( 0.5, true );
        } ) );
      }
      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );
      if ( reverse ) {
        offsetCurves.reverse();
        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );
      }
      return offsetCurves;
    },
    degreeElevated: function() {
      return new kite.Cubic(
        this._start,
        this._start.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end.plus( this._control.timesScalar( 2 ) ).dividedScalar( 3 ),
        this._end
      );
    },
    reversed: function() {
      return new kite.Quadratic( this._end, this._control, this._start );
    },
    approximateOffset: function( r ) {
      return new kite.Quadratic(
        this._start.plus( ( this._start.equals( this._control ) ? this._end.minus( this._start ) : this._control.minus( this._start ) ).perpendicular().normalized().times( r ) ),
        this._control.plus( this._end.minus( this._start ).perpendicular().normalized().times( r ) ),
        this._end.plus( ( this._end.equals( this._control ) ? this._end.minus( this._start ) : this._end.minus( this._control ) ).perpendicular().normalized().times( r ) )
      );
    },
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'Q ' + kite.svgNumber( this._control.x ) + ' ' + kite.svgNumber( this._control.y ) + ' ' +
                                kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    getInteriorExtremaTs: function() {
      var result = [];
      var epsilon = 0.0000000001; // TODO: general kite epsilon?
      var criticalX = this.getTCriticalX();
      var criticalY = this.getTCriticalY();
      if ( !isNaN( criticalX ) && criticalX > epsilon && criticalX < 1 - epsilon ) {
        result.push( this.tCriticalX );
      }
      if ( !isNaN( criticalY ) && criticalY > epsilon && criticalY < 1 - epsilon ) {
        result.push( this.tCriticalY );
      }
      return result.sort();
    },
    intersection: function( ray ) {
      var self = this;
      var result = [];
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );
      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control );
      var p2 = inverseMatrix.timesVector2( this._end );
      var a = p0.y - 2 * p1.y + p2.y;
      var b = -2 * p0.y + 2 * p1.y;
      var c = p0.y;
      var ts = solveQuadraticRootsReal( a, b, c );
      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    writeToContext: function( context ) {
      context.quadraticCurveTo( this._control.x, this._control.y, this._end.x, this._end.y );
    },
    transformed: function( matrix ) {
      return new kite.Quadratic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control ), matrix.timesVector2( this._end ) );
    },
    reparameterized: function( a, b ) {
      var p = this._start.plus( this._end.plus( this._control.timesScalar( -2 ) ) );
      var q = this._control.minus( this._start ).timesScalar( 2 );
      var r = this._start;
      var alpha = p.timesScalar( a * a );
      var beta = p.timesScalar( a * b ).timesScalar( 2 ).plus( q.timesScalar( a ) );
      var gamma = p.timesScalar( b * b ).plus( q.timesScalar( b ) ).plus( r );
      return new kite.Quadratic( gamma, beta.timesScalar( 0.5 ).plus( gamma ), alpha.plus( beta ).plus( gamma ) );
    }
  } );
  Segment.addInvalidatingGetterSetter( Quadratic, 'start' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'control' );
  Segment.addInvalidatingGetterSetter( Quadratic, 'end' );
  Quadratic.extremaT = function( start, control, end ) {
    var divisorX = 2 * ( end - 2 * control + start );
    if ( divisorX !== 0 ) {
      return -2 * ( control - start ) / divisorX;
    }
    else {
      return NaN;
    }
  };
  Quadratic.getOverlaps = function( quadratic1, quadratic2 ) {
    assert && assert( quadratic1 instanceof Quadratic, 'first Quadratic is not an instance of Quadratic' );
    assert && assert( quadratic2 instanceof Quadratic, 'second Quadratic is not an instance of Quadratic' );
    var noOverlap = [];
    var p0x = quadratic1._start.x;
    var p1x = -2 * quadratic1._start.x + 2 * quadratic1._control.x;
    var p2x = quadratic1._start.x - 2 * quadratic1._control.x + quadratic1._end.x;
    var p0y = quadratic1._start.y;
    var p1y = -2 * quadratic1._start.y + 2 * quadratic1._control.y;
    var p2y = quadratic1._start.y - 2 * quadratic1._control.y + quadratic1._end.y;
    var q0x = quadratic2._start.x;
    var q1x = -2 * quadratic2._start.x + 2 * quadratic2._control.x;
    var q2x = quadratic2._start.x - 2 * quadratic2._control.x + quadratic2._end.x;
    var q0y = quadratic2._start.y;
    var q1y = -2 * quadratic2._start.y + 2 * quadratic2._control.y;
    var q2y = quadratic2._start.y - 2 * quadratic2._control.y + quadratic2._end.y;
    var xOverlap = Segment.polynomialGetOverlapQuadratic( p0x, p1x, p2x, q0x, q1x, q2x );
    var yOverlap = Segment.polynomialGetOverlapQuadratic( p0y, p1y, p2y, q0y, q1y, q2y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) + Math.abs( p2x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) + Math.abs( p2y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) + Math.abs( q2x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) + Math.abs( q2y ) ) * 1e-6;
    var a = overlap.a;
    var b = overlap.b;
    var aa = a * a;
    var bb = b * b;
    var ab2 = 2 * a * b;
    if ( Math.abs( q0x + b * q1x + bb * q2x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x + ab2 * q2x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2x - p2x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y + bb * q2y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y + ab2 * q2y - p1y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2y - p2y ) > approxEpsilon ) { return noOverlap; }
    var qt0 = b;
    var qt1 = a + b;
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }
    return [ new Overlap( a, b ) ];
  };
  return Quadratic;
} );
define( 'KITE/segments/Cubic',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap','KITE/segments/Quadratic'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );
  require( 'KITE/segments/Quadratic' );
  var solveQuadraticRootsReal = Util.solveQuadraticRootsReal; // function that returns an array of number
  var solveCubicRootsReal = Util.solveCubicRootsReal; // function that returns an array of number
  var arePointsCollinear = Util.arePointsCollinear; // function that returns a boolean
  var scratchVector1 = new Vector2();
  var scratchVector2 = new Vector2();
  var scratchVector3 = new Vector2();
  function isBetween0And1( t ) {
    return t >= 0 && t <= 1;
  }
  function Cubic( start, control1, control2, end ) {
    Segment.call( this );
    this._start = start; //  @private {Vector2}
    this._control1 = control1; // @private {Vector2}
    this._control2 = control2; // @private {Vector2}
    this._end = end; // @private {Vector2}
    this.invalidate();
  }
  kite.register( 'Cubic', Cubic );
  inherit( Segment, Cubic, {
    degree: 3, // degree of this polynomial (cubic)
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );
      var mt = 1 - t;
      return this._start.times( mt * mt * mt ).plus( this._control1.times( 3 * mt * mt * t ) ).plus( this._control2.times( 3 * mt * t * t ) ).plus( this._end.times( t * t * t ) );
    },
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );
      var mt = 1 - t;
      var result = new Vector2();
      return result.set( this._start ).multiplyScalar( -3 * mt * mt )
        .add( scratchVector1.set( this._control1 ).multiplyScalar( 3 * mt * mt - 6 * mt * t ) )
        .add( scratchVector1.set( this._control2 ).multiplyScalar( 6 * mt * t - 3 * t * t ) )
        .add( scratchVector1.set( this._end ).multiplyScalar( 3 * t * t ) );
    },
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );
      var epsilon = 0.0000001;
      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {
        var isZero = t < 0.5;
        var p0 = isZero ? this._start : this._end;
        var p1 = isZero ? this._control1 : this._control2;
        var p2 = isZero ? this._control2 : this._control1;
        var d10 = p1.minus( p0 );
        var a = d10.magnitude();
        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );
        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );
      }
      else {
        return this.subdivided( t )[ 0 ].curvatureAt( 1 );
      }
    },
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }
      var left = this._start.blend( this._control1, t );
      var right = this._control2.blend( this._end, t );
      var middle = this._control1.blend( this._control2, t );
      var leftMid = left.blend( middle, t );
      var rightMid = middle.blend( right, t );
      var mid = leftMid.blend( rightMid, t );
      return [
        new kite.Cubic( this._start, left, leftMid, mid ),
        new kite.Cubic( mid, rightMid, right, this._end )
      ];
    },
    invalidate: function() {
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._r = null; // {number|null}
      this._s = null; // {number|null}
      this._tCusp = null; // {number|null} - T value for a potential cusp
      this._tDeterminant = null; // {number|null}
      this._tInflection1 = null; // {number|null} - NaN if not applicable
      this._tInflection2 = null; // {number|null} - NaN if not applicable
      this._quadratics = null; // {Array.<Quadratic>|null}
      this._xExtremaT = null; // {Array.<number>|null}
      this._yExtremaT = null; // {Array.<number>|null}
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}
      this.trigger0( 'invalidated' );
    },
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAt( 0 ).normalized();
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAt( 1 ).normalized();
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    getR: function() {
      if ( this._r === null ) {
        this._r = this._control1.minus( this._start ).normalized();
      }
      return this._r;
    },
    get r() { return this.getR(); },
    getS: function() {
      if ( this._s === null ) {
        this._s = this.getR().perpendicular();
      }
      return this._s;
    },
    get s() { return this.getS(); },
    getTCusp: function() {
      if ( this._tCusp === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tCusp !== null );
      return this._tCusp;
    },
    get tCusp() { return this.getTCusp(); },
    getTDeterminant: function() {
      if ( this._tDeterminant === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tDeterminant !== null );
      return this._tDeterminant;
    },
    get tDeterminant() { return this.getTDeterminant(); },
    getTInflection1: function() {
      if ( this._tInflection1 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection1 !== null );
      return this._tInflection1;
    },
    get tInflection1() { return this.getTInflection1(); },
    getTInflection2: function() {
      if ( this._tInflection2 === null ) {
        this.computeCuspInfo();
      }
      assert && assert( this._tInflection2 !== null );
      return this._tInflection2;
    },
    get tInflection2() { return this.getTInflection2(); },
    getQuadratics: function() {
      if ( this._quadratics === null ) {
        this.computeCuspSegments();
      }
      assert && assert( this._quadratics !== null );
      return this._quadratics;
    },
    getXExtremaT: function() {
      if ( this._xExtremaT === null ) {
        this._xExtremaT = Cubic.extremaT( this._start.x, this._control1.x, this._control2.x, this._end.x );
      }
      return this._xExtremaT;
    },
    get xExtremaT() { return this.getXExtremaT(); },
    getYExtremaT: function() {
      if ( this._yExtremaT === null ) {
        this._yExtremaT = Cubic.extremaT( this._start.y, this._control1.y, this._control2.y, this._end.y );
      }
      return this._yExtremaT;
    },
    get yExtremaT() { return this.getYExtremaT(); },
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING;
        this._bounds = this._bounds.withPoint( this._start );
        this._bounds = this._bounds.withPoint( this._end );
        var self = this;
        _.each( this.getXExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            self._bounds = self._bounds.withPoint( self.positionAt( t ) );
          }
        } );
        _.each( this.getYExtremaT(), function( t ) {
          if ( t >= 0 && t <= 1 ) {
            self._bounds = self._bounds.withPoint( self.positionAt( t ) );
          }
        } );
        if ( this.hasCusp() ) {
          this._bounds = this._bounds.withPoint( this.positionAt( this.getTCusp() ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    computeCuspInfo: function() {
      var a = this._start.times( -1 ).plus( this._control1.times( 3 ) ).plus( this._control2.times( -3 ) ).plus( this._end );
      var b = this._start.times( 3 ).plus( this._control1.times( -6 ) ).plus( this._control2.times( 3 ) );
      var c = this._start.times( -3 ).plus( this._control1.times( 3 ) );
      var aPerp = a.perpendicular(); // {Vector2}
      var bPerp = b.perpendicular(); // {Vector2}
      var aPerpDotB = aPerp.dot( b ); // {number}
      this._tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB ); // {number}
      this._tDeterminant = this._tCusp * this._tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB ); // {number}
      if ( this._tDeterminant >= 0 ) {
        var sqrtDet = Math.sqrt( this._tDeterminant );
        this._tInflection1 = this._tCusp - sqrtDet;
        this._tInflection2 = this._tCusp + sqrtDet;
      }
      else {
        this._tInflection1 = NaN;
        this._tInflection2 = NaN;
      }
    },
    computeCuspSegments: function() {
      if ( this.hasCusp() ) {
        this._quadratics = [];
        var tCusp = this.getTCusp();
        if ( tCusp === 0 ) {
          this._quadratics.push( new kite.Quadratic( this.start, this.control2, this.end, false ) );
        }
        else if ( tCusp === 1 ) {
          this._quadratics.push( new kite.Quadratic( this.start, this.control1, this.end, false ) );
        }
        else {
          var subdividedAtCusp = this.subdivided( tCusp );
          this._quadratics.push( new kite.Quadratic( subdividedAtCusp[ 0 ].start, subdividedAtCusp[ 0 ].control1, subdividedAtCusp[ 0 ].end, false ) );
          this._quadratics.push( new kite.Quadratic( subdividedAtCusp[ 1 ].start, subdividedAtCusp[ 1 ].control2, subdividedAtCusp[ 1 ].end, false ) );
        }
      }
      else {
        this._quadratics = null;
      }
    },
    getNondegenerateSegments: function() {
      var self = this;
      var start = this._start;
      var control1 = this._control1;
      var control2 = this._control2;
      var end = this._end;
      var reduced = this.degreeReduced( 1e-9 );
      if ( start.equals( end ) && start.equals( control1 ) && start.equals( control2 ) ) {
        return [];
      }
      else if ( this.hasCusp() ) {
        return _.flatten( this.getQuadratics().map( function( quadratic ) {
          return quadratic.getNondegenerateSegments();
        } ) );
      }
      else if ( reduced ) {
        return reduced.getNondegenerateSegments();
      }
      else if ( arePointsCollinear( start, control1, end ) && arePointsCollinear( start, control2, end ) ) {
        var extremaPoints = this.getXExtremaT().concat( this.getYExtremaT() ).sort().map( function( t ) {
          return self.positionAt( t );
        } );
        var segments = [];
        var lastPoint = start;
        if ( extremaPoints.length ) {
          segments.push( new kite.Line( start, extremaPoints[ 0 ] ) );
          lastPoint = extremaPoints[ 0 ];
        }
        for ( var i = 1; i < extremaPoints.length; i++ ) {
          segments.push( new kite.Line( extremaPoints[ i - 1 ], extremaPoints[ i ] ) );
          lastPoint = extremaPoints[ i ];
        }
        segments.push( new kite.Line( lastPoint, end ) );
        return _.flatten( segments.map( function( segment ) { return segment.getNondegenerateSegments(); } ), true );
      }
      else {
        return [ this ];
      }
    },
    hasCusp: function() {
      var tCusp = this.getTCusp();
      var epsilon = 1e-7; // TODO: make this available to change?
      return tCusp >= 0 && tCusp <= 1 && this.tangentAt( tCusp ).magnitude() < epsilon;
    },
    toRS: function( point ) {
      var firstVector = point.minus( this._start );
      return new Vector2( firstVector.dot( this.getR() ), firstVector.dot( this.getS() ) );
    },
    offsetTo: function( r, reverse ) {
      var quantity = 32;
      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var t = i / ( quantity - 1 );
        if ( reverse ) {
          t = 1 - t;
        }
        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }
      return result;
    },
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'C ' + kite.svgNumber( this._control1.x ) + ' ' + kite.svgNumber( this._control1.y ) + ' ' +
                                kite.svgNumber( this._control2.x ) + ' ' + kite.svgNumber( this._control2.y ) + ' ' +
                                kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    getInteriorExtremaTs: function() {
      var ts = this.getXExtremaT().concat( this.getYExtremaT() );
      var result = [];
      _.each( ts, function( t ) {
        var epsilon = 0.0000000001; // TODO: general kite epsilon?
        if ( t > epsilon && t < 1 - epsilon ) {
          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {
            result.push( t );
          }
        }
      } );
      return result.sort();
    },
    intersection: function( ray ) {
      var self = this;
      var result = [];
      var inverseMatrix = Matrix3.rotation2( -ray.direction.angle() ).timesMatrix( Matrix3.translation( -ray.position.x, -ray.position.y ) );
      var p0 = inverseMatrix.timesVector2( this._start );
      var p1 = inverseMatrix.timesVector2( this._control1 );
      var p2 = inverseMatrix.timesVector2( this._control2 );
      var p3 = inverseMatrix.timesVector2( this._end );
      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;
      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;
      var c = -3 * p0.y + 3 * p1.y;
      var d = p0.y;
      var ts = solveCubicRootsReal( a, b, c, d );
      _.each( ts, function( t ) {
        if ( t >= 0 && t <= 1 ) {
          var hitPoint = self.positionAt( t );
          var unitTangent = self.tangentAt( t ).normalized();
          var perp = unitTangent.perpendicular();
          var toHit = hitPoint.minus( ray.position );
          if ( toHit.dot( ray.direction ) > 0 ) {
            result.push( {
              distance: toHit.magnitude(),
              point: hitPoint,
              normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
              wind: ray.direction.perpendicular().dot( unitTangent ) < 0 ? 1 : -1
            } );
          }
        }
      } );
      return result;
    },
    windingIntersection: function( ray ) {
      var wind = 0;
      var hits = this.intersection( ray );
      _.each( hits, function( hit ) {
        wind += hit.wind;
      } );
      return wind;
    },
    writeToContext: function( context ) {
      context.bezierCurveTo( this._control1.x, this._control1.y, this._control2.x, this._control2.y, this._end.x, this._end.y );
    },
    transformed: function( matrix ) {
      return new kite.Cubic( matrix.timesVector2( this._start ), matrix.timesVector2( this._control1 ), matrix.timesVector2( this._control2 ), matrix.timesVector2( this._end ) );
    },
    degreeReduced: function( epsilon ) {
      epsilon = epsilon || 0; // if not provided, use an exact version
      var controlA = scratchVector1.set( this._control1 ).multiplyScalar( 3 ).subtract( this._start ).divideScalar( 2 );
      var controlB = scratchVector2.set( this._control2 ).multiplyScalar( 3 ).subtract( this._end ).divideScalar( 2 );
      var difference = scratchVector3.set( controlA ).subtract( controlB );
      if ( difference.magnitude() <= epsilon ) {
        return new kite.Quadratic(
          this._start,
          controlA.average( controlB ), // average the control points for stability. they should be almost identical
          this._end
        );
      }
      else {
        return null;
      }
    }
  } );
  Segment.addInvalidatingGetterSetter( Cubic, 'start' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control1' );
  Segment.addInvalidatingGetterSetter( Cubic, 'control2' );
  Segment.addInvalidatingGetterSetter( Cubic, 'end' );
  Cubic.extremaT = function( v0, v1, v2, v3 ) {
    if ( v0 === v1 && v0 === v2 && v0 === v3 ) {
      return [];
    }
    var a = -3 * v0 + 9 * v1 - 9 * v2 + 3 * v3;
    var b = 6 * v0 - 12 * v1 + 6 * v2;
    var c = -3 * v0 + 3 * v1;
    return _.filter( solveQuadraticRootsReal( a, b, c ), isBetween0And1 );
  };
  Cubic.getOverlaps = function( cubic1, cubic2 ) {
    assert && assert( cubic1 instanceof Cubic, 'first Cubic is not an instance of Cubic' );
    assert && assert( cubic2 instanceof Cubic, 'second Cubic is not an instance of Cubic' );
    var noOverlap = [];
    var p0x = cubic1._start.x;
    var p1x = -3 * cubic1._start.x + 3 * cubic1._control1.x;
    var p2x = 3 * cubic1._start.x - 6 * cubic1._control1.x + 3 * cubic1._control2.x;
    var p3x = -1 * cubic1._start.x + 3 * cubic1._control1.x - 3 * cubic1._control2.x + cubic1._end.x;
    var p0y = cubic1._start.y;
    var p1y = -3 * cubic1._start.y + 3 * cubic1._control1.y;
    var p2y = 3 * cubic1._start.y - 6 * cubic1._control1.y + 3 * cubic1._control2.y;
    var p3y = -1 * cubic1._start.y + 3 * cubic1._control1.y - 3 * cubic1._control2.y + cubic1._end.y;
    var q0x = cubic2._start.x;
    var q1x = -3 * cubic2._start.x + 3 * cubic2._control1.x;
    var q2x = 3 * cubic2._start.x - 6 * cubic2._control1.x + 3 * cubic2._control2.x;
    var q3x = -1 * cubic2._start.x + 3 * cubic2._control1.x - 3 * cubic2._control2.x + cubic2._end.x;
    var q0y = cubic2._start.y;
    var q1y = -3 * cubic2._start.y + 3 * cubic2._control1.y;
    var q2y = 3 * cubic2._start.y - 6 * cubic2._control1.y + 3 * cubic2._control2.y;
    var q3y = -1 * cubic2._start.y + 3 * cubic2._control1.y - 3 * cubic2._control2.y + cubic2._end.y;
    var xOverlap = Segment.polynomialGetOverlapCubic( p0x, p1x, p2x, p3x, q0x, q1x, q2x, q3x );
    var yOverlap = Segment.polynomialGetOverlapCubic( p0y, p1y, p2y, p3y, q0y, q1y, q2y, q3y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) + Math.abs( p2x ) + Math.abs( p3x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) + Math.abs( p2y ) + Math.abs( p3y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) + Math.abs( q2x ) + Math.abs( q3x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) + Math.abs( q2y ) + Math.abs( q3y ) ) * 1e-6;
    var a = overlap.a;
    var b = overlap.b;
    var aa = a * a;
    var aaa = a * a * a;
    var bb = b * b;
    var bbb = b * b * b;
    var ab2 = 2 * a * b;
    var abb3 = 3 * a * bb;
    var aab3 = 3 * aa * b;
    if ( Math.abs( q0x + b * q1x + bb * q2x + bbb * q3x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x + ab2 * q2x + abb3 * q3x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2x + aab3 * q3x - p2x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aaa * q3x - p3x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y + bb * q2y + bbb * q3y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y + ab2 * q2y + abb3 * q3y - p1y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aa * q2y + aab3 * q3y - p2y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( aaa * q3y - p3y ) > approxEpsilon ) { return noOverlap; }
    var qt0 = b;
    var qt1 = a + b;
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }
    return [ new Overlap( a, b ) ];
  };
  return Cubic;
} );
define( 'KITE/segments/EllipticalArc',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','KITE/kite','KITE/segments/Segment'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var toDegrees = Util.toDegrees;
  function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
    Segment.call( this );
    this._center = center;
    this._radiusX = radiusX;
    this._radiusY = radiusY;
    this._rotation = rotation;
    this._startAngle = startAngle;
    this._endAngle = endAngle;
    this._anticlockwise = anticlockwise;
    this.invalidate();
  }
  kite.register( 'EllipticalArc', EllipticalArc );
  inherit( Segment, EllipticalArc, {
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );
      return this.positionAtAngle( this.angleAt( t ) );
    },
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );
      return this.tangentAtAngle( this.angleAt( t ) );
    },
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );
      var angle = this.angleAt( t );
      var aq = this._radiusX * Math.sin( angle );
      var bq = this._radiusY * Math.cos( angle );
      var denominator = Math.pow( bq * bq + aq * aq, 3 / 2 );
      return ( this._anticlockwise ? -1 : 1 ) * this._radiusX * this._radiusY / denominator;
    },
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }
      var angle0 = this.angleAt( 0 );
      var angleT = this.angleAt( t );
      var angle1 = this.angleAt( 1 );
      return [
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angle0, angleT, this._anticlockwise ),
        new kite.EllipticalArc( this._center, this._radiusX, this._radiusY, this._rotation, angleT, angle1, this._anticlockwise )
      ];
    },
    invalidate: function() {
      this._unitTransform = null; // {Transform3|null} - Mapping between our ellipse and a unit circle
      this._start = null; // {Vector2|null}
      this._end = null; // {Vector2|null}
      this._startTangent = null; // {Vector2|null}
      this._endTangent = null; // {Vector2|null}
      this._actualEndAngle = null; // {number|null} - End angle in relation to our start angle (can get remapped)
      this._isFullPerimeter = null; // {boolean|null} - Whether it's a full ellipse (and not just an arc)
      this._angleDifference = null; // {number|null}
      this._unitArcSegment = null; // {Arc|null} - Corresponding circular arc for our unit transform.
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}
      if ( this._radiusX < 0 ) {
        this._radiusX = -this._radiusX;
        this._startAngle = Math.PI - this._startAngle;
        this._endAngle = Math.PI - this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusY < 0 ) {
        this._radiusY = -this._radiusY;
        this._startAngle = -this._startAngle;
        this._endAngle = -this._endAngle;
        this._anticlockwise = !this._anticlockwise;
      }
      if ( this._radiusX < this._radiusY ) {
        this._rotation += Math.PI / 2;
        this._startAngle -= Math.PI / 2;
        this._endAngle -= Math.PI / 2;
        var tmpR = this._radiusX;
        this._radiusX = this._radiusY;
        this._radiusY = tmpR;
      }
      if ( this._radiusX < this._radiusY ) {
        throw new Error( 'Not verified to work if radiusX < radiusY' );
      }
      assert && assert( !( ( !this._anticlockwise && this._endAngle - this._startAngle <= -Math.PI * 2 ) ||
                           ( this._anticlockwise && this._startAngle - this._endAngle <= -Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
      assert && assert( !( ( !this._anticlockwise && this._endAngle - this._startAngle > Math.PI * 2 ) ||
                           ( this._anticlockwise && this._startAngle - this._endAngle > Math.PI * 2 ) ),
        'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );
      this.trigger0( 'invalidated' );
    },
    getUnitTransform: function() {
      if ( this._unitTransform === null ) {
        this._unitTransform = EllipticalArc.computeUnitTransform( this._center, this._radiusX, this._radiusY, this._rotation );
      }
      return this._unitTransform;
    },
    get unitTransform() { return this.getUnitTransform(); },
    getStart: function() {
      if ( this._start === null ) {
        this._start = this.positionAtAngle( this._startAngle );
      }
      return this._start;
    },
    get start() { return this.getStart(); },
    getEnd: function() {
      if ( this._end === null ) {
        this._end = this.positionAtAngle( this._endAngle );
      }
      return this._end;
    },
    get end() { return this.getEnd(); },
    getStartTangent: function() {
      if ( this._startTangent === null ) {
        this._startTangent = this.tangentAtAngle( this._startAngle );
      }
      return this._startTangent;
    },
    get startTangent() { return this.getStartTangent(); },
    getEndTangent: function() {
      if ( this._endTangent === null ) {
        this._endTangent = this.tangentAtAngle( this._endAngle );
      }
      return this._endTangent;
    },
    get endTangent() { return this.getEndTangent(); },
    getActualEndAngle: function() {
      if ( this._actualEndAngle === null ) {
        if ( this._anticlockwise ) {
          if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle - 2 * Math.PI;
          }
          else {
            this._actualEndAngle = this._startAngle;
          }
        }
        else {
          if ( this._startAngle < this._endAngle ) {
            this._actualEndAngle = this._endAngle;
          }
          else if ( this._startAngle > this._endAngle ) {
            this._actualEndAngle = this._endAngle + Math.PI * 2;
          }
          else {
            this._actualEndAngle = this._startAngle;
          }
        }
      }
      return this._actualEndAngle;
    },
    get actualEndAngle() { return this.getActualEndAngle(); },
    getIsFullPerimeter: function() {
      if ( this._isFullPerimeter === null ) {
        this._isFullPerimeter = ( !this._anticlockwise && this._endAngle - this._startAngle >= Math.PI * 2 ) || ( this._anticlockwise && this._startAngle - this._endAngle >= Math.PI * 2 );
      }
      return this._isFullPerimeter;
    },
    get isFullPerimeter() { return this.getIsFullPerimeter(); },
    getAngleDifference: function() {
      if ( this._angleDifference === null ) {
        this._angleDifference = this._anticlockwise ? this._startAngle - this._endAngle : this._endAngle - this._startAngle;
        if ( this._angleDifference < 0 ) {
          this._angleDifference += Math.PI * 2;
        }
        assert && assert( this._angleDifference >= 0 ); // now it should always be zero or positive
      }
      return this._angleDifference;
    },
    get angleDifference() { return this.getAngleDifference(); },
    getUnitArcSegment: function() {
      if ( this._unitArcSegment === null ) {
        this._unitArcSegment = new kite.Arc( Vector2.ZERO, 1, this._startAngle, this._endAngle, this._anticlockwise );
      }
      return this._unitArcSegment;
    },
    get unitArcSegment() { return this.getUnitArcSegment(); },
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.withPoint( this.getStart() )
          .withPoint( this.getEnd() );
        if ( this._startAngle !== this._endAngle ) {
          var xAngle = Math.atan( -( this._radiusY / this._radiusX ) * Math.tan( this._rotation ) );
          var yAngle = Math.atan( ( this._radiusY / this._radiusX ) / Math.tan( this._rotation ) );
          this.possibleExtremaAngles = [
            xAngle,
            xAngle + Math.PI,
            yAngle,
            yAngle + Math.PI
          ];
          _.each( this.possibleExtremaAngles, this.includeBoundsAtAngle.bind( this ) );
        }
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    getNondegenerateSegments: function() {
      if ( this._radiusX <= 0 || this._radiusY <= 0 || this._startAngle === this._endAngle ) {
        return [];
      }
      else if ( this._radiusX === this._radiusY ) {
        var startAngle = this._startAngle - this._rotation;
        var endAngle = this._endAngle - this._rotation;
        if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
          endAngle = this._anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
        }
        return [ new kite.Arc( this._center, this._radiusX, startAngle, endAngle, this._anticlockwise ) ];
      }
      else {
        return [ this ];
      }
    },
    includeBoundsAtAngle: function( angle ) {
      if ( this.unitArcSegment.containsAngle( angle ) ) {
        this._bounds = this._bounds.withPoint( this.positionAtAngle( angle ) );
      }
    },
    mapAngle: function( angle ) {
      return ( this._startAngle > this.getActualEndAngle() ) ?
             Util.moduloBetweenUp( angle, this._startAngle - 2 * Math.PI, this._startAngle ) :
             Util.moduloBetweenDown( angle, this._startAngle, this._startAngle + 2 * Math.PI );
    },
    tAtAngle: function( angle ) {
      return ( this.mapAngle( angle ) - this._startAngle ) / ( this.getActualEndAngle() - this._startAngle );
    },
    angleAt: function( t ) {
      return this._startAngle + ( this.getActualEndAngle() - this._startAngle ) * t;
    },
    positionAtAngle: function( angle ) {
      return this.getUnitTransform().transformPosition2( Vector2.createPolar( 1, angle ) );
    },
    tangentAtAngle: function( angle ) {
      var normal = this.getUnitTransform().transformNormal2( Vector2.createPolar( 1, angle ) );
      return this._anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();
    },
    offsetTo: function( r, reverse ) {
      var quantity = 32;
      var points = [];
      var result = [];
      for ( var i = 0; i < quantity; i++ ) {
        var ratio = i / ( quantity - 1 );
        if ( reverse ) {
          ratio = 1 - ratio;
        }
        var angle = this.angleAt( ratio );
        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );
        if ( i > 0 ) {
          result.push( new kite.Line( points[ i - 1 ], points[ i ] ) );
        }
      }
      return result;
    },
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        var epsilon = 0.01; // allow some leeway to render things as 'almost circles'
        var sweepFlag = this._anticlockwise ? '0' : '1';
        var largeArcFlag;
        var degreesRotation = toDegrees( this._rotation ); // bleh, degrees?
        if ( this.getAngleDifference() < Math.PI * 2 - epsilon ) {
          largeArcFlag = this.getAngleDifference() < Math.PI ? '0' : '1';
          this._svgPathFragment = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' + degreesRotation +
                                  ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );
        }
        else {
          var splitOppositeAngle = ( this._startAngle + this._endAngle ) / 2; // this _should_ work for the modular case?
          var splitPoint = this.positionAtAngle( splitOppositeAngle );
          largeArcFlag = '0'; // since we split it in 2, it's always the small arc
          var firstArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                         degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                         kite.svgNumber( splitPoint.x ) + ' ' + kite.svgNumber( splitPoint.y );
          var secondArc = 'A ' + kite.svgNumber( this._radiusX ) + ' ' + kite.svgNumber( this._radiusY ) + ' ' +
                          degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' +
                          kite.svgNumber( this.getEnd().x ) + ' ' + kite.svgNumber( this.getEnd().y );
          this._svgPathFragment = firstArc + ' ' + secondArc;
        }
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    strokeLeft: function( lineWidth ) {
      return this.offsetTo( -lineWidth / 2, false );
    },
    strokeRight: function( lineWidth ) {
      return this.offsetTo( lineWidth / 2, true );
    },
    getInteriorExtremaTs: function() {
      var self = this;
      var result = [];
      _.each( this.possibleExtremaAngles, function( angle ) {
        if ( self.unitArcSegment.containsAngle( angle ) ) {
          var t = self.tAtAngle( angle );
          var epsilon = 0.0000000001; // TODO: general kite epsilon?
          if ( t > epsilon && t < 1 - epsilon ) {
            result.push( t );
          }
        }
      } );
      return result.sort(); // modifies original, which is OK
    },
    intersection: function( ray ) {
      var unitTransform = this.getUnitTransform();
      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );
      var hits = this.getUnitArcSegment().intersection( rayInUnitCircleSpace );
      return _.map( hits, function( hit ) {
        var transformedPoint = unitTransform.transformPosition2( hit.point );
        return {
          distance: ray.position.distance( transformedPoint ),
          point: transformedPoint,
          normal: unitTransform.inverseNormal2( hit.normal ),
          wind: hit.wind
        };
      } );
    },
    windingIntersection: function( ray ) {
      var rayInUnitCircleSpace = this.getUnitTransform().inverseRay2( ray );
      return this.getUnitArcSegment().windingIntersection( rayInUnitCircleSpace );
    },
    writeToContext: function( context ) {
      if ( context.ellipse ) {
        context.ellipse( this._center.x, this._center.y, this._radiusX, this._radiusY, this._rotation, this._startAngle, this._endAngle, this._anticlockwise );
      }
      else {
        this.getUnitTransform().getMatrix().canvasAppendTransform( context );
        context.arc( 0, 0, 1, this._startAngle, this._endAngle, this._anticlockwise );
        this.getUnitTransform().getInverse().canvasAppendTransform( context );
      }
    },
    transformed: function( matrix ) {
      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusX, this._rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this._radiusY, this._rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );
      var rotation = transformedSemiMajorAxis.angle();
      var radiusX = transformedSemiMajorAxis.magnitude();
      var radiusY = transformedSemiMinorAxis.magnitude();
      var reflected = matrix.getDeterminant() < 0;
      var anticlockwise = reflected ? !this._anticlockwise : this._anticlockwise;
      var startAngle = reflected ? -this._startAngle : this._startAngle;
      var endAngle = reflected ? -this._endAngle : this._endAngle;
      if ( Math.abs( this._endAngle - this._startAngle ) === Math.PI * 2 ) {
        endAngle = anticlockwise ? startAngle - Math.PI * 2 : startAngle + Math.PI * 2;
      }
      return new kite.EllipticalArc( matrix.timesVector2( this._center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    }
  } );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'center' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusX' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'radiusY' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'rotation' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'startAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'endAngle' );
  Segment.addInvalidatingGetterSetter( EllipticalArc, 'anticlockwise' );
  EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {
    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this._center) when available
      .timesMatrix( Matrix3.rotation2( rotation ) )
      .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );
  };
  return EllipticalArc;
} );
define( 'KITE/segments/Line',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Util','KITE/kite','KITE/segments/Segment','KITE/util/Overlap'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  var kite = require( 'KITE/kite' );
  var Segment = require( 'KITE/segments/Segment' );
  var Overlap = require( 'KITE/util/Overlap' );
  var scratchVector2 = new Vector2();
  function Line( start, end ) {
    Segment.call( this );
    this._start = start; // @private {Vector2}
    this._end = end; // @private  {Vector2}
    this.invalidate();
  }
  kite.register( 'Line', Line );
  inherit( Segment, Line, {
    positionAt: function( t ) {
      assert && assert( t >= 0, 'positionAt t should be non-negative' );
      assert && assert( t <= 1, 'positionAt t should be no greater than 1' );
      return this._start.plus( this._end.minus( this._start ).times( t ) );
    },
    tangentAt: function( t ) {
      assert && assert( t >= 0, 'tangentAt t should be non-negative' );
      assert && assert( t <= 1, 'tangentAt t should be no greater than 1' );
      return this.getStartTangent();
    },
    curvatureAt: function( t ) {
      assert && assert( t >= 0, 'curvatureAt t should be non-negative' );
      assert && assert( t <= 1, 'curvatureAt t should be no greater than 1' );
      return 0; // no curvature on a straight line segment
    },
    subdivided: function( t ) {
      assert && assert( t >= 0, 'subdivided t should be non-negative' );
      assert && assert( t <= 1, 'subdivided t should be no greater than 1' );
      if ( t === 0 || t === 1 ) {
        return [ this ];
      }
      var pt = this.positionAt( t );
      return [
        new kite.Line( this._start, pt ),
        new kite.Line( pt, this._end )
      ];
    },
    invalidate: function() {
      this._tangent = null; // {Vector2|null}
      this._bounds = null; // {Bounds2|null}
      this._svgPathFragment = null; // {string|null}
      this.trigger0( 'invalidated' );
    },
    getStartTangent: function() {
      if ( this._tangent === null ) {
        this._tangent = this._end.minus( this._start ).normalized();
      }
      return this._tangent;
    },
    get startTangent() { return this.getStartTangent(); },
    getEndTangent: function() {
      return this.getStartTangent();
    },
    get endTangent() { return this.getEndTangent(); },
    getBounds: function() {
      if ( this._bounds === null ) {
        this._bounds = Bounds2.NOTHING.copy().addPoint( this._start ).addPoint( this._end );
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    getBoundsWithTransform: function( matrix ) {
      var bounds = Bounds2.NOTHING.copy();
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._start ) ) );
      bounds.addPoint( matrix.multiplyVector2( scratchVector2.set( this._end ) ) );
      return bounds;
    },
    getNondegenerateSegments: function() {
      if ( this._start.equals( this._end ) ) {
        return [];
      }
      else {
        return [ this ];
      }
    },
    getSVGPathFragment: function() {
      if ( assert ) {
        var oldPathFragment = this._svgPathFragment;
        this._svgPathFragment = null;
      }
      if ( !this._svgPathFragment ) {
        this._svgPathFragment = 'L ' + kite.svgNumber( this._end.x ) + ' ' + kite.svgNumber( this._end.y );
      }
      if ( assert ) {
        if ( oldPathFragment ) {
          assert( oldPathFragment === this._svgPathFragment, 'Quadratic line segment changed without invalidate()' );
        }
      }
      return this._svgPathFragment;
    },
    strokeLeft: function( lineWidth ) {
      var offset = this.getEndTangent().perpendicular().negated().times( lineWidth / 2 );
      return [ new kite.Line( this._start.plus( offset ), this._end.plus( offset ) ) ];
    },
    strokeRight: function( lineWidth ) {
      var offset = this.getStartTangent().perpendicular().times( lineWidth / 2 );
      return [ new kite.Line( this._end.plus( offset ), this._start.plus( offset ) ) ];
    },
    getInteriorExtremaTs: function() { return []; },
    intersection: function( ray ) {
      var result = [];
      var start = this._start;
      var end = this._end;
      var diff = end.minus( start );
      if ( diff.magnitudeSquared() === 0 ) {
        return result;
      }
      var denom = ray.direction.y * diff.x - ray.direction.x * diff.y;
      if ( denom === 0 ) {
        return result;
      }
      var t = ( ray.direction.x * ( start.y - ray.position.y ) - ray.direction.y * ( start.x - ray.position.x ) ) / denom;
      if ( t < 0 || t >= 1 ) {
        return result;
      }
      var s = ( diff.x * ( start.y - ray.position.y ) - diff.y * ( start.x - ray.position.x ) ) / denom;
      if ( s < 0.00000001 ) {
        return result;
      }
      var perp = diff.perpendicular();
      result.push( {
        distance: s,
        point: start.plus( diff.times( t ) ),
        normal: perp.dot( ray.direction ) > 0 ? perp.negated() : perp,
        wind: ray.direction.perpendicular().dot( diff ) < 0 ? 1 : -1,
        segment: this
      } );
      return result;
    },
    windingIntersection: function( ray ) {
      var hits = this.intersection( ray );
      if ( hits.length ) {
        return hits[ 0 ].wind;
      }
      else {
        return 0;
      }
    },
    writeToContext: function( context ) {
      context.lineTo( this._end.x, this._end.y );
    },
    transformed: function( matrix ) {
      return new kite.Line( matrix.timesVector2( this._start ), matrix.timesVector2( this._end ) );
    },
    explicitClosestToPoint: function( point ) {
      var diff = this._end.minus( this._start );
      var t = point.minus( this._start ).dot( diff ) / diff.magnitudeSquared();
      t = Util.clamp( t, 0, 1 );
      var closestPoint = this.positionAt( t );
      return [
        {
          segment: this,
          t: t,
          closestPoint: closestPoint,
          distanceSquared: point.distanceSquared( closestPoint )
        }
      ];
    },
    reparameterized: function( a, b ) {
      return new kite.Line( this.positionAt( b ), this.positionAt( a + b ) );
    },
    polarToCartesian: function( options ) {
      if ( this._start.x === this._end.x ) {
        return [ new kite.Line( Vector2.createPolar( this._start.y, this._start.x ), Vector2.createPolar( this._end.y, this._end.x ) ) ];
      }
      else if ( this._start.y === this._end.y ) {
        return [ new kite.Arc( Vector2.ZERO, this._start.y, this._start.x, this._end.x, this._start.x > this._end.x ) ];
      }
      else {
        return this.toPiecewiseLinearSegments( options );
      }
    }
  } );
  Segment.addInvalidatingGetterSetter( Line, 'start' );
  Segment.addInvalidatingGetterSetter( Line, 'end' );
  Line.getOverlaps = function( line1, line2 ) {
    assert && assert( line1 instanceof Line, 'first Line is not an instance of Line' );
    assert && assert( line2 instanceof Line, 'second Line is not an instance of Line' );
    var noOverlap = [];
    var p0x = line1._start.x;
    var p1x = -1 * line1._start.x + line1._end.x;
    var p0y = line1._start.y;
    var p1y = -1 * line1._start.y + line1._end.y;
    var q0x = line2._start.x;
    var q1x = -1 * line2._start.x + line2._end.x;
    var q0y = line2._start.y;
    var q1y = -1 * line2._start.y + line2._end.y;
    var xOverlap = Segment.polynomialGetOverlapLinear( p0x, p1x, q0x, q1x );
    var yOverlap = Segment.polynomialGetOverlapLinear( p0y, p1y, q0y, q1y );
    var overlap = ( xOverlap === null || xOverlap === true ) ? yOverlap : xOverlap;
    if ( overlap === null || overlap === true ) {
      return noOverlap; // No way to pin down an overlap
    }
    var approxEpsilon = ( Math.abs( p0x ) + Math.abs( p1x ) +
                          Math.abs( p0y ) + Math.abs( p1y ) +
                          Math.abs( q0x ) + Math.abs( q1x ) +
                          Math.abs( q0y ) + Math.abs( q1y ) ) * 1e-6;
    var a = overlap.a;
    var b = overlap.b;
    if ( Math.abs( q0x + b * q1x - p0x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1x - p1x ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( q0y + b * q1y - p0y ) > approxEpsilon ) { return noOverlap; }
    if ( Math.abs( a * q1y - p1y ) > approxEpsilon ) { return noOverlap; }
    var qt0 = b;
    var qt1 = a + b;
    if ( ( qt0 > 1 && qt1 > 1 ) || ( qt0 < 0 && qt1 < 0 ) ) {
      return noOverlap;
    }
    return [ new Overlap( a, b ) ];
  };
  return Line;
} );
define( 'KITE/util/LineStyles',['require','KITE/kite','DOT/Util','PHET_CORE/inherit','KITE/segments/Arc','KITE/segments/Line'],function( require ) {
  'use strict';
  var kite = require( 'KITE/kite' );
  var Util = require( 'DOT/Util' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Arc = require( 'KITE/segments/Arc' );
  var Line = require( 'KITE/segments/Line' );
  var lineLineIntersection = Util.lineLineIntersection;
  function LineStyles( args ) {
    if ( args === undefined ) {
      args = {};
    }
    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;
    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square
    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel
    this.lineDash = args.lineDash ? args.lineDash : []; // [] is default, otherwise an array of numbers
    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number
    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations
    assert && assert( Array.isArray( this.lineDash ) );
  }
  kite.register( 'LineStyles', LineStyles );
  inherit( Object, LineStyles, {
    equals: function( other ) {
      var typical = this.lineWidth === other.lineWidth &&
                    this.lineCap === other.lineCap &&
                    this.lineJoin === other.lineJoin &&
                    this.miterLimit === other.miterLimit &&
                    this.lineDashOffset === other.lineDashOffset;
      if ( !typical ) {
        return false;
      }
      if ( this.lineDash.length === other.lineDash.length ) {
        for ( var i = 0; i < this.lineDash.length; i++ ) {
          if ( this.lineDash[ i ] !== other.lineDash[ i ] ) {
            return false;
          }
        }
      }
      else {
        return false;
      }
      return true;
    },
    leftJoin: function( center, fromTangent, toTangent ) {
      fromTangent = fromTangent.normalized();
      toTangent = toTangent.normalized();
      var fromPoint = center.plus( fromTangent.perpendicular().negated().times( this.lineWidth / 2 ) );
      var toPoint = center.plus( toTangent.perpendicular().negated().times( this.lineWidth / 2 ) );
      var bevel = ( fromPoint.equals( toPoint ) ? [] : [ new Line( fromPoint, toPoint ) ] );
      if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {
        switch( this.lineJoin ) {
          case 'round':
            var fromAngle = fromTangent.angle() + Math.PI / 2;
            var toAngle = toTangent.angle() + Math.PI / 2;
            return [ new Arc( center, this.lineWidth / 2, fromAngle, toAngle, true ) ];
          case 'miter':
            var theta = fromTangent.angleBetween( toTangent.negated() );
            if ( 1 / Math.sin( theta / 2 ) <= this.miterLimit && theta < Math.PI - 0.00001 ) {
              var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );
              return [
                new Line( fromPoint, miterPoint ),
                new Line( miterPoint, toPoint )
              ];
            }
            else {
              return bevel;
            }
          case 'bevel':
            return bevel;
          default:
            throw new Error( 'invalid lineJoin: ' + this.lineJoin );
        }
      }
      else {
        return bevel;
      }
    },
    rightJoin: function( center, fromTangent, toTangent ) {
      return this.leftJoin( center, toTangent.negated(), fromTangent.negated() );
    },
    cap: function( center, tangent ) {
      tangent = tangent.normalized();
      var fromPoint = center.plus( tangent.perpendicular().times( -this.lineWidth / 2 ) );
      var toPoint = center.plus( tangent.perpendicular().times( this.lineWidth / 2 ) );
      switch( this.lineCap ) {
        case 'butt':
          return [ new Line( fromPoint, toPoint ) ];
        case 'round':
          var tangentAngle = tangent.angle();
          return [ new Arc( center, this.lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true ) ];
        case 'square':
          var toLeft = tangent.perpendicular().negated().times( this.lineWidth / 2 );
          var toRight = tangent.perpendicular().times( this.lineWidth / 2 );
          var toFront = tangent.times( this.lineWidth / 2 );
          var left = center.plus( toLeft ).plus( toFront );
          var right = center.plus( toRight ).plus( toFront );
          return [
            new Line( fromPoint, left ),
            new Line( left, right ),
            new Line( right, toPoint )
          ];
        default:
          throw new Error( 'invalid lineCap: ' + this.lineCap );
      }
    }
  } );
  return kite.LineStyles;
} );
define( 'KITE/util/Subpath',['require','DOT/Bounds2','PHET_CORE/inherit','AXON/Events','KITE/kite','KITE/segments/Line','KITE/segments/Arc','KITE/util/LineStyles'],function( require ) {
  'use strict';
  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var kite = require( 'KITE/kite' );
  var Line = require( 'KITE/segments/Line' );
  var Arc = require( 'KITE/segments/Arc' );
  var LineStyles = require( 'KITE/util/LineStyles' );
  function Subpath( segments, points, closed ) {
    Events.call( this );
    var self = this;
    this.segments = [];
    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[ segments.length - 1 ].end ) : [] );
    this.closed = !!closed;
    this._strokedSubpaths = null;
    this._strokedSubpathsComputed = false;
    this._strokedStyles = null;
    this._bounds = null; // {Bounds2 | null} - If non-null, the bounds of the subpath
    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times
    if ( segments ) {
      for ( var i = 0; i < segments.length; i++ ) {
        _.each( segments[ i ].getNondegenerateSegments(), function( segment ) {
          self.addSegmentDirectly( segment );
        } );
      }
    }
  }
  kite.register( 'Subpath', Subpath );
  inherit( Events, Subpath, {
    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.segments, function( segment ) {
          bounds.includeBounds( segment.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    copy: function() {
      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );
    },
    invalidatePoints: function() {
      this._invalidatingPoints = true;
      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        this.segments[ i ].invalidate();
      }
      this._invalidatingPoints = false;
      this.invalidate();
    },
    invalidate: function() {
      if ( !this._invalidatingPoints ) {
        this._bounds = null;
        this._strokedSubpathsComputed = false;
        this.trigger0( 'invalidated' );
      }
    },
    addPoint: function( point ) {
      this.points.push( point );
      return this; // allow chaining
    },
    addSegmentDirectly: function( segment ) {
      assert && assert( segment.start.isFinite(), 'Segment start is infinite' );
      assert && assert( segment.end.isFinite(), 'Segment end is infinite' );
      assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );
      assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );
      assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );
      this.segments.push( segment );
      segment.onStatic( 'invalidated', this._invalidateListener );
      return this; // allow chaining
    },
    addSegment: function( segment ) {
      var nondegenerateSegments = segment.getNondegenerateSegments();
      var numNondegenerateSegments = nondegenerateSegments.length;
      for ( var i = 0; i < numNondegenerateSegments; i++ ) {
        this.addSegmentDirectly( segment );
      }
      this.invalidate(); // need to invalidate after addSegmentDirectly
      return this; // allow chaining
    },
    addClosingSegment: function() {
      if ( this.hasClosingSegment() ) {
        var closingSegment = this.getClosingSegment();
        this.addSegmentDirectly( closingSegment );
        this.invalidate(); // need to invalidate after addSegmentDirectly
        this.addPoint( this.getFirstPoint() );
        this.closed = true;
      }
    },
    close: function() {
      this.closed = true;
    },
    getLength: function() {
      return this.points.length;
    },
    getFirstPoint: function() {
      return _.first( this.points );
    },
    getLastPoint: function() {
      return _.last( this.points );
    },
    getFirstSegment: function() {
      return _.first( this.segments );
    },
    getLastSegment: function() {
      return _.last( this.segments );
    },
    isDrawable: function() {
      return this.segments.length > 0;
    },
    isClosed: function() {
      return this.closed;
    },
    hasClosingSegment: function() {
      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );
    },
    getClosingSegment: function() {
      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );
      return new Line( this.getLastPoint(), this.getFirstPoint() );
    },
    writeToContext: function( context ) {
      if ( this.isDrawable() ) {
        var startPoint = this.getFirstSegment().start;
        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start
        var len = this.segments.length;
        for ( var i = 0; i < len; i++ ) {
          this.segments[ i ].writeToContext( context );
        }
        if ( this.closed ) {
          context.closePath();
        }
      }
    },
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'For use with pointMap, please use nonlinearTransformed' );
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        return segment.toPiecewiseLinearSegments( options );
      } ) ), null, this.closed );
    },
    transformed: function( matrix ) {
      return new Subpath(
        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),
        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),
        this.closed
      );
    },
    nonlinearTransformed: function( options ) {
      if ( this.closed && this.hasClosingSegment() ) {
        this.addClosingSegment();
      }
      return new Subpath( _.flatten( _.map( this.segments, function( segment ) {
        if ( options.methodName && segment[ options.methodName ] ) {
          return segment[ options.methodName ]( options );
        }
        else {
          return segment.toPiecewiseLinearSegments( options );
        }
      } ) ), null, this.closed );
    },
    getBoundsWithTransform: function( matrix ) {
      var bounds = Bounds2.NOTHING.copy();
      var numSegments = this.segments.length;
      for ( var i = 0; i < numSegments; i++ ) {
        bounds.includeBounds( this.segments[ i ].getBoundsWithTransform( matrix ) );
      }
      return bounds;
    },
    offset: function( distance ) {
      if ( !this.isDrawable() ) {
        return new Subpath( [], null, this.closed );
      }
      if ( distance === 0 ) {
        return new Subpath( this.segments.slice(), null, this.closed );
      }
      var i;
      var regularSegments = this.segments.slice();
      if ( this.closed && this.hasClosingSegment() ) {
        regularSegments.push( this.getClosingSegment() );
      }
      var offsets = [];
      for ( i = 0; i < regularSegments.length; i++ ) {
        offsets.push( regularSegments[ i ].strokeLeft( 2 * distance ) );
      }
      var segments = [];
      for ( i = 0; i < regularSegments.length; i++ ) {
        if ( this.closed || i > 0 ) {
          var previousI = ( i > 0 ? i : regularSegments.length ) - 1;
          var center = regularSegments[ i ].start;
          var fromTangent = regularSegments[ previousI ].endTangent;
          var toTangent = regularSegments[ i ].startTangent;
          var startAngle = fromTangent.perpendicular().negated().times( distance ).angle();
          var endAngle = toTangent.perpendicular().negated().times( distance ).angle();
          var anticlockwise = fromTangent.perpendicular().dot( toTangent ) > 0;
          segments.push( new Arc( center, Math.abs( distance ), startAngle, endAngle, anticlockwise ) );
        }
        segments = segments.concat( offsets[ i ] );
      }
      return new Subpath( segments, null, this.closed );
    },
    stroked: function( lineStyles ) {
      if ( !this.isDrawable() ) {
        return [];
      }
      if ( lineStyles === undefined ) {
        lineStyles = new LineStyles();
      }
      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {
        return this._strokedSubpaths;
      }
      var lineWidth = lineStyles.lineWidth;
      var i;
      var leftSegments = [];
      var rightSegments = [];
      var firstSegment = this.getFirstSegment();
      var lastSegment = this.getLastSegment();
      function appendLeftSegments( segments ) {
        leftSegments = leftSegments.concat( segments );
      }
      function appendRightSegments( segments ) {
        rightSegments = rightSegments.concat( segments );
      }
      var alreadyClosed = lastSegment.end.equals( firstSegment.start );
      var closingSegment = alreadyClosed ? null : new Line( this.segments[ this.segments.length - 1 ].end, this.segments[ 0 ].start );
      for ( i = 0; i < this.segments.length; i++ ) {
        if ( i > 0 ) {
          appendLeftSegments( lineStyles.leftJoin( this.segments[ i ].start, this.segments[ i - 1 ].endTangent, this.segments[ i ].startTangent ) );
        }
        appendLeftSegments( this.segments[ i ].strokeLeft( lineWidth ) );
      }
      for ( i = this.segments.length - 1; i >= 0; i-- ) {
        if ( i < this.segments.length - 1 ) {
          appendRightSegments( lineStyles.rightJoin( this.segments[ i ].end, this.segments[ i ].endTangent, this.segments[ i + 1 ].startTangent ) );
        }
        appendRightSegments( this.segments[ i ].strokeRight( lineWidth ) );
      }
      var subpaths;
      if ( this.closed ) {
        if ( alreadyClosed ) {
          appendLeftSegments( lineStyles.leftJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( lineStyles.rightJoin( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );
        }
        else {
          appendLeftSegments( lineStyles.leftJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
          appendLeftSegments( closingSegment.strokeLeft( lineWidth ) );
          appendLeftSegments( lineStyles.leftJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( lineStyles.rightJoin( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );
          appendRightSegments( closingSegment.strokeRight( lineWidth ) );
          appendRightSegments( lineStyles.rightJoin( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );
        }
        subpaths = [
          new Subpath( leftSegments, null, true ),
          new Subpath( rightSegments, null, true )
        ];
      }
      else {
        subpaths = [
          new Subpath( leftSegments.concat( lineStyles.cap( lastSegment.end, lastSegment.endTangent ) )
            .concat( rightSegments )
            .concat( lineStyles.cap( firstSegment.start, firstSegment.startTangent.negated() ) ),
            null, true )
        ];
      }
      this._strokedSubpaths = subpaths;
      this._strokedSubpathsComputed = true;
      this._strokedStyles = new LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable
      return subpaths;
    }
  } );
  return kite.Subpath;
} );
define( 'KITE/parser/svgPath',['require','KITE/kite'],function( require ) {
  var kite = require( 'KITE/kite' );
  function quote( s ) {
    return '"' + s
        .replace( /\\/g, '\\\\' )  // backslash
        .replace( /"/g, '\\"' )    // closing quote character
        .replace( /\x08/g, '\\b' ) // backspace
        .replace( /\t/g, '\\t' )   // horizontal tab
        .replace( /\n/g, '\\n' )   // line feed
        .replace( /\f/g, '\\f' )   // form feed
        .replace( /\r/g, '\\r' )   // carriage return
        .replace( /[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape )
           + '"';
  }
  var result = {
    parse: function( input, startRule ) {
      var parseFunctions = {
        "svgPath": parse_svgPath,
        "movetoDrawtoCommandGroups": parse_movetoDrawtoCommandGroups,
        "movetoDrawtoCommandGroup": parse_movetoDrawtoCommandGroup,
        "drawtoCommands": parse_drawtoCommands,
        "drawtoCommand": parse_drawtoCommand,
        "moveto": parse_moveto,
        "movetoArgumentSequence": parse_movetoArgumentSequence,
        "closepath": parse_closepath,
        "lineto": parse_lineto,
        "linetoArgumentSequence": parse_linetoArgumentSequence,
        "horizontalLineto": parse_horizontalLineto,
        "horizontalLinetoArgumentSequence": parse_horizontalLinetoArgumentSequence,
        "verticalLineto": parse_verticalLineto,
        "verticalLinetoArgumentSequence": parse_verticalLinetoArgumentSequence,
        "curveto": parse_curveto,
        "curvetoArgumentSequence": parse_curvetoArgumentSequence,
        "curvetoArgument": parse_curvetoArgument,
        "smoothCurveto": parse_smoothCurveto,
        "smoothCurvetoArgumentSequence": parse_smoothCurvetoArgumentSequence,
        "smoothCurvetoArgument": parse_smoothCurvetoArgument,
        "quadraticBezierCurveto": parse_quadraticBezierCurveto,
        "quadraticBezierCurvetoArgumentSequence": parse_quadraticBezierCurvetoArgumentSequence,
        "quadraticBezierCurvetoArgument": parse_quadraticBezierCurvetoArgument,
        "smoothQuadraticBezierCurveto": parse_smoothQuadraticBezierCurveto,
        "smoothQuadraticBezierCurvetoArgumentSequence": parse_smoothQuadraticBezierCurvetoArgumentSequence,
        "ellipticalArc": parse_ellipticalArc,
        "ellipticalArcArgumentSequence": parse_ellipticalArcArgumentSequence,
        "ellipticalArcArgument": parse_ellipticalArcArgument,
        "coordinatePair": parse_coordinatePair,
        "nonnegativeNumber": parse_nonnegativeNumber,
        "number": parse_number,
        "flag": parse_flag,
        "commaWsp": parse_commaWsp,
        "comma": parse_comma,
        "floatingPointConstant": parse_floatingPointConstant,
        "fractionalConstant": parse_fractionalConstant,
        "exponent": parse_exponent,
        "sign": parse_sign,
        "digitSequence": parse_digitSequence,
        "digit": parse_digit,
        "wsp": parse_wsp
      };
      if ( startRule !== undefined ) {
        if ( parseFunctions[ startRule ] === undefined ) {
          throw new Error( "Invalid rule name: " + quote( startRule ) + "." );
        }
      }
      else {
        startRule = "svgPath";
      }
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      function padLeft( input, padding, length ) {
        var result = input;
        var padLength = length - input.length;
        for ( var i = 0; i < padLength; i++ ) {
          result = padding + result;
        }
        return result;
      }
      function escape( ch ) {
        var charCode = ch.charCodeAt( 0 );
        var escapeChar;
        var length;
        if ( charCode <= 0xFF ) {
          escapeChar = 'x';
          length = 2;
        }
        else {
          escapeChar = 'u';
          length = 4;
        }
        return '\\' + escapeChar + padLeft( charCode.toString( 16 ).toUpperCase(), '0', length );
      }
      function matchFailed( failure ) {
        if ( pos < rightmostFailuresPos ) {
          return;
        }
        if ( pos > rightmostFailuresPos ) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        rightmostFailuresExpected.push( failure );
      }
      function parse_svgPath() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_wsp();
        while ( result1 !== null ) {
          result0.push( result1 );
          result1 = parse_wsp();
        }
        if ( result0 !== null ) {
          result1 = parse_movetoDrawtoCommandGroups();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, path ) { return path ? path : []; })( pos0, result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_movetoDrawtoCommandGroups() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_movetoDrawtoCommandGroup();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoDrawtoCommandGroups();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a.concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_movetoDrawtoCommandGroup();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_movetoDrawtoCommandGroup() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_moveto();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            result2 = result2 !== null ? result2 : "";
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, m, c ) { return c.length ? m.concat( c ) : m; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_drawtoCommands() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_drawtoCommand();
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_drawtoCommands();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, cmd, cmds ) { return cmd.concat( cmds ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_drawtoCommand();
          if ( result0 !== null ) {
            result0 = (function( offset, cmd ) { return cmd; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_drawtoCommand() {
        var result0;
        result0 = parse_closepath();
        if ( result0 === null ) {
          result0 = parse_lineto();
          if ( result0 === null ) {
            result0 = parse_horizontalLineto();
            if ( result0 === null ) {
              result0 = parse_verticalLineto();
              if ( result0 === null ) {
                result0 = parse_curveto();
                if ( result0 === null ) {
                  result0 = parse_smoothCurveto();
                  if ( result0 === null ) {
                    result0 = parse_quadraticBezierCurveto();
                    if ( result0 === null ) {
                      result0 = parse_smoothQuadraticBezierCurveto();
                      if ( result0 === null ) {
                        result0 = parse_ellipticalArc();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      function parse_moveto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 77 ) {
          result0 = "M";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"M\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_movetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) { return createMoveTo( args, false ); })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 109 ) {
            result0 = "m";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"m\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_movetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) { return createMoveTo( args, true ); })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_movetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, pair, list ) { return [ pair ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, pair ) { return [ pair ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_closepath() {
        var result0;
        var pos0;
        pos0 = pos;
        if ( input.charCodeAt( pos ) === 90 ) {
          result0 = "Z";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Z\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 122 ) {
            result0 = "z";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"z\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset, command ) { return { cmd: 'close' }; })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_lineto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 76 ) {
          result0 = "L";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"L\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'lineTo',
                args: [ arg.x, arg.y ]
              };
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 108 ) {
            result0 = "l";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"l\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_linetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'lineToRelative',
                  args: [ arg.x, arg.y ]
                };
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_linetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_linetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_horizontalLineto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 72 ) {
          result0 = "H";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"H\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'horizontalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 104 ) {
            result0 = "h";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"h\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_horizontalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'horizontalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_horizontalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_horizontalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_verticalLineto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 86 ) {
          result0 = "V";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"V\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'verticalLineTo',
                args: [ arg ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 118 ) {
            result0 = "v";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"v\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_verticalLinetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'verticalLineToRelative',
                  args: [ arg ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_verticalLinetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_verticalLinetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a ].concat( b ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_number();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_curveto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 67 ) {
          result0 = "C";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"C\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'cubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 99 ) {
            result0 = "c";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"c\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_curvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'cubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_curvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_curvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_curvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_curvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_curvetoArgument() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_coordinatePair();
                if ( result4 !== null ) {
                  result0 = [ result0, result1, result2, result3, result4 ];
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_smoothCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 83 ) {
          result0 = "S";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"S\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothCubicCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 115 ) {
            result0 = "s";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"s\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothCubicCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_smoothCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_smoothCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_smoothCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_smoothCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_quadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 81 ) {
          result0 = "Q";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"Q\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'quadraticCurveTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 113 ) {
            result0 = "q";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"q\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_quadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'quadraticCurveToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_quadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_quadraticBezierCurvetoArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_quadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_quadraticBezierCurvetoArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_quadraticBezierCurvetoArgument() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_coordinatePair();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return [ a.x, a.y, b.x, b.y ]; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_smoothQuadraticBezierCurveto() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 84 ) {
          result0 = "T";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"T\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'smoothQuadraticCurveTo',
                args: [ arg.x, arg.y ]
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 116 ) {
            result0 = "t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"t\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'smoothQuadraticCurveToRelative',
                  args: [ arg.x, arg.y ]
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_coordinatePair();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_coordinatePair();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_ellipticalArc() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 65 ) {
          result0 = "A";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"A\"" );
          }
        }
        if ( result0 !== null ) {
          result1 = [];
          result2 = parse_wsp();
          while ( result2 !== null ) {
            result1.push( result2 );
            result2 = parse_wsp();
          }
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, args ) {
            return args.map( function( arg ) {
              return {
                cmd: 'ellipticalArcTo',
                args: arg
              }
            } );
          })( pos0, result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          if ( input.charCodeAt( pos ) === 97 ) {
            result0 = "a";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"a\"" );
            }
          }
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result2 = parse_ellipticalArcArgumentSequence();
              if ( result2 !== null ) {
                result0 = [ result0, result1, result2 ];
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, args ) {
              return args.map( function( arg ) {
                return {
                  cmd: 'ellipticalArcToRelative',
                  args: arg
                }
              } );
            })( pos0, result0[ 2 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_ellipticalArcArgumentSequence() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ellipticalArcArgument();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_ellipticalArcArgumentSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, list ) { return [ a ].concat( list ); })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_ellipticalArcArgument();
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return [ a ]; })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_ellipticalArcArgument() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_nonnegativeNumber();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_nonnegativeNumber();
            if ( result2 !== null ) {
              result3 = parse_commaWsp();
              result3 = result3 !== null ? result3 : "";
              if ( result3 !== null ) {
                result4 = parse_number();
                if ( result4 !== null ) {
                  result5 = parse_commaWsp();
                  if ( result5 !== null ) {
                    result6 = parse_flag();
                    if ( result6 !== null ) {
                      result7 = parse_commaWsp();
                      result7 = result7 !== null ? result7 : "";
                      if ( result7 !== null ) {
                        result8 = parse_flag();
                        if ( result8 !== null ) {
                          result9 = parse_commaWsp();
                          result9 = result9 !== null ? result9 : "";
                          if ( result9 !== null ) {
                            result10 = parse_coordinatePair();
                            if ( result10 !== null ) {
                              result0 = [ result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10 ];
                            }
                            else {
                              result0 = null;
                              pos = pos1;
                            }
                          }
                          else {
                            result0 = null;
                            pos = pos1;
                          }
                        }
                        else {
                          result0 = null;
                          pos = pos1;
                        }
                      }
                      else {
                        result0 = null;
                        pos = pos1;
                      }
                    }
                    else {
                      result0 = null;
                      pos = pos1;
                    }
                  }
                  else {
                    result0 = null;
                    pos = pos1;
                  }
                }
                else {
                  result0 = null;
                  pos = pos1;
                }
              }
              else {
                result0 = null;
                pos = pos1;
              }
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, rx, ry, rot, largeArc, sweep, to ) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })( pos0, result0[ 0 ], result0[ 2 ], result0[ 4 ], result0[ 6 ], result0[ 8 ], result0[ 10 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_coordinatePair() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_number();
        if ( result0 !== null ) {
          result1 = parse_commaWsp();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_number();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return { x: a, y: b }; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_nonnegativeNumber() {
        var result0;
        var pos0;
        pos0 = pos;
        result0 = parse_floatingPointConstant();
        if ( result0 !== null ) {
          result0 = (function( offset, number ) { return parseFloat( number ); })( pos0, result0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result0 = (function( offset, number ) { return parseInt( number, 10 ); })( pos0, result0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_number() {
        var result0, result1;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_sign();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          result1 = parse_floatingPointConstant();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, sign, number ) { return parseFloat( sign + number ); })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_sign();
          result0 = result0 !== null ? result0 : "";
          if ( result0 !== null ) {
            result1 = parse_digitSequence();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, sign, number ) { return parseInt( sign + number, 10 ); })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_flag() {
        var result0;
        var pos0;
        pos0 = pos;
        if ( input.charCodeAt( pos ) === 48 ) {
          result0 = "0";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"0\"" );
          }
        }
        if ( result0 !== null ) {
          result0 = (function( offset ) { return false; })( pos0 );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          if ( input.charCodeAt( pos ) === 49 ) {
            result0 = "1";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"1\"" );
            }
          }
          if ( result0 !== null ) {
            result0 = (function( offset ) { return true; })( pos0 );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_commaWsp() {
        var result0, result1, result2, result3;
        var pos0;
        pos0 = pos;
        result1 = parse_wsp();
        if ( result1 !== null ) {
          result0 = [];
          while ( result1 !== null ) {
            result0.push( result1 );
            result1 = parse_wsp();
          }
        }
        else {
          result0 = null;
        }
        if ( result0 !== null ) {
          result1 = parse_comma();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = [];
            result3 = parse_wsp();
            while ( result3 !== null ) {
              result2.push( result3 );
              result3 = parse_wsp();
            }
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        else {
          result0 = null;
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          result0 = parse_comma();
          if ( result0 !== null ) {
            result1 = [];
            result2 = parse_wsp();
            while ( result2 !== null ) {
              result1.push( result2 );
              result2 = parse_wsp();
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos0;
            }
          }
          else {
            result0 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_comma() {
        var result0;
        if ( input.charCodeAt( pos ) === 44 ) {
          result0 = ",";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\",\"" );
          }
        }
        return result0;
      }
      function parse_floatingPointConstant() {
        var result0, result1;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_fractionalConstant();
        if ( result0 !== null ) {
          result1 = parse_exponent();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            result1 = parse_exponent();
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_fractionalConstant() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_digitSequence();
        result0 = result0 !== null ? result0 : "";
        if ( result0 !== null ) {
          if ( input.charCodeAt( pos ) === 46 ) {
            result1 = ".";
            pos++;
          }
          else {
            result1 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\".\"" );
            }
          }
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + '.' + b; })( pos0, result0[ 0 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_digitSequence();
          if ( result0 !== null ) {
            if ( input.charCodeAt( pos ) === 46 ) {
              result1 = ".";
              pos++;
            }
            else {
              result1 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\".\"" );
              }
            }
            if ( result1 !== null ) {
              result0 = [ result0, result1 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
          if ( result0 !== null ) {
            result0 = (function( offset, a ) { return a })( pos0, result0[ 0 ] );
          }
          if ( result0 === null ) {
            pos = pos0;
          }
        }
        return result0;
      }
      function parse_exponent() {
        var result0, result1, result2;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        if ( input.charCodeAt( pos ) === 101 ) {
          result0 = "e";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"e\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 69 ) {
            result0 = "E";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"E\"" );
            }
          }
        }
        if ( result0 !== null ) {
          result1 = parse_sign();
          result1 = result1 !== null ? result1 : "";
          if ( result1 !== null ) {
            result2 = parse_digitSequence();
            if ( result2 !== null ) {
              result0 = [ result0, result1, result2 ];
            }
            else {
              result0 = null;
              pos = pos1;
            }
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b, c ) { return a + b + c; })( pos0, result0[ 0 ], result0[ 1 ], result0[ 2 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        return result0;
      }
      function parse_sign() {
        var result0;
        if ( input.charCodeAt( pos ) === 43 ) {
          result0 = "+";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\"+\"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 45 ) {
            result0 = "-";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"-\"" );
            }
          }
        }
        return result0;
      }
      function parse_digitSequence() {
        var result0, result1;
        var pos0, pos1;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_digit();
        if ( result0 !== null ) {
          result1 = parse_digitSequence();
          if ( result1 !== null ) {
            result0 = [ result0, result1 ];
          }
          else {
            result0 = null;
            pos = pos1;
          }
        }
        else {
          result0 = null;
          pos = pos1;
        }
        if ( result0 !== null ) {
          result0 = (function( offset, a, b ) { return a + b; })( pos0, result0[ 0 ], result0[ 1 ] );
        }
        if ( result0 === null ) {
          pos = pos0;
        }
        if ( result0 === null ) {
          result0 = parse_digit();
        }
        return result0;
      }
      function parse_digit() {
        var result0;
        if ( /^[0-9]/.test( input.charAt( pos ) ) ) {
          result0 = input.charAt( pos );
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "[0-9]" );
          }
        }
        return result0;
      }
      function parse_wsp() {
        var result0;
        if ( input.charCodeAt( pos ) === 32 ) {
          result0 = " ";
          pos++;
        }
        else {
          result0 = null;
          if ( reportFailures === 0 ) {
            matchFailed( "\" \"" );
          }
        }
        if ( result0 === null ) {
          if ( input.charCodeAt( pos ) === 9 ) {
            result0 = "\t";
            pos++;
          }
          else {
            result0 = null;
            if ( reportFailures === 0 ) {
              matchFailed( "\"\\t\"" );
            }
          }
          if ( result0 === null ) {
            if ( input.charCodeAt( pos ) === 13 ) {
              result0 = "\r";
              pos++;
            }
            else {
              result0 = null;
              if ( reportFailures === 0 ) {
                matchFailed( "\"\\r\"" );
              }
            }
            if ( result0 === null ) {
              if ( input.charCodeAt( pos ) === 10 ) {
                result0 = "\n";
                pos++;
              }
              else {
                result0 = null;
                if ( reportFailures === 0 ) {
                  matchFailed( "\"\\n\"" );
                }
              }
            }
          }
        }
        return result0;
      }
      function cleanupExpected( expected ) {
        expected.sort();
        var lastExpected = null;
        var cleanExpected = [];
        for ( var i = 0; i < expected.length; i++ ) {
          if ( expected[ i ] !== lastExpected ) {
            cleanExpected.push( expected[ i ] );
            lastExpected = expected[ i ];
          }
        }
        return cleanExpected;
      }
      function computeErrorPosition() {
        var line = 1;
        var column = 1;
        var seenCR = false;
        for ( var i = 0; i < Math.max( pos, rightmostFailuresPos ); i++ ) {
          var ch = input.charAt( i );
          if ( ch === "\n" ) {
            if ( !seenCR ) { line++; }
            column = 1;
            seenCR = false;
          }
          else if ( ch === "\r" || ch === "\u2028" || ch === "\u2029" ) {
            line++;
            column = 1;
            seenCR = true;
          }
          else {
            column++;
            seenCR = false;
          }
        }
        return { line: line, column: column };
      }
      function createMoveTo( args, isRelative ) {
        var result = [ {
          cmd: isRelative ? 'moveToRelative' : 'moveTo',
          args: [ args[ 0 ].x, args[ 0 ].y ]
        } ];
        if ( args.length > 1 ) {
          for ( var i = 1; i < args.length; i++ ) {
            result.push( {
              cmd: isRelative ? 'lineToRelative' : 'lineTo',
              args: [ args[ i ].x, args[ i ].y ]
            } );
          }
        }
        return result;
      }
      var result = parseFunctions[ startRule ]();
      if ( result === null || pos !== input.length ) {
        var offset = Math.max( pos, rightmostFailuresPos );
        var found = offset < input.length ? input.charAt( offset ) : null;
        var errorPosition = computeErrorPosition();
        throw new this.SyntaxError(
          cleanupExpected( rightmostFailuresExpected ),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      return result;
    },
    toSource: function() { return this._source; }
  };
  result.SyntaxError = function( expected, found, offset, line, column ) {
    function buildMessage( expected, found ) {
      var expectedHumanized, foundHumanized;
      switch( expected.length ) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[ 0 ];
          break;
        default:
          expectedHumanized = expected.slice( 0, expected.length - 1 ).join( ", " )
                              + " or "
                              + expected[ expected.length - 1 ];
      }
      foundHumanized = found ? quote( found ) : "end of input";
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage( expected, found );
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  result.SyntaxError.prototype = Error.prototype;
  kite.register( 'svgPath', result );
  return kite.svgPath;
} );
define( 'KITE/Shape',['require','KITE/segments/Arc','DOT/Bounds2','KITE/segments/Cubic','AXON/Events','KITE/segments/EllipticalArc','KITE/kite','PHET_CORE/inherit','KITE/segments/Line','KITE/segments/Quadratic','DOT/Ray2','KITE/util/Subpath','KITE/parser/svgPath','DOT/Vector2'],function( require ) {
  'use strict';
  var Arc = require( 'KITE/segments/Arc' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Cubic = require( 'KITE/segments/Cubic' );
  var Events = require( 'AXON/Events' );
  var EllipticalArc = require( 'KITE/segments/EllipticalArc' );
  var kite = require( 'KITE/kite' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'KITE/segments/Line' );
  var Quadratic = require( 'KITE/segments/Quadratic' );
  var Ray2 = require( 'DOT/Ray2' );
  var Subpath = require( 'KITE/util/Subpath' );
  var svgPath = require( 'KITE/parser/svgPath' );
  var Vector2 = require( 'DOT/Vector2' );
  function v( x, y ) { return new Vector2( x, y ); }
  function weightedSplineVector( beforeVector, currentVector, afterVector, tension ) {
    return afterVector.copy()
      .subtract( beforeVector )
      .multiplyScalar( ( 1 - tension ) / 6 )
      .add( currentVector );
  }
  function Shape( subpaths, bounds ) {
    var self = this;
    Events.call( this );
    this.subpaths = [];
    this._bounds = bounds ? bounds.copy() : null; // {Bounds2 | null}
    this.resetControlPoints();
    this._invalidateListener = this.invalidate.bind( this );
    this._invalidatingPoints = false; // So we can invalidate all of the points without firing invalidation tons of times
    this._immutable = false;
    if ( typeof subpaths === 'object' ) {
      for ( var i = 0; i < subpaths.length; i++ ) {
        this.addSubpath( subpaths[ i ] );
      }
    }
    if ( subpaths && typeof subpaths !== 'object' ) {
      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' );
      _.each( svgPath.parse( subpaths ), function( item ) {
        assert && assert( Shape.prototype[ item.cmd ] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );
        self[ item.cmd ].apply( self, item.args );
      } );
    }
    this.invalidate();
    phetAllocation && phetAllocation( 'Shape' );
  }
  kite.register( 'Shape', Shape );
  inherit( Events, Shape, {
    resetControlPoints: function() {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = null;
    },
    setQuadraticControlPoint: function( point ) {
      this.lastQuadraticControlPoint = point;
      this.lastCubicControlPoint = null;
    },
    setCubicControlPoint: function( point ) {
      this.lastQuadraticControlPoint = null;
      this.lastCubicControlPoint = point;
    },
    subpath: function() {
      if ( this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }
      return this; // for chaining
    },
    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },
    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },
    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },
    moveToPoint: function( point ) {
      this.addSubpath( new Subpath().addPoint( point ) );
      this.resetControlPoints();
     return this;  // for chaining
    },
    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },
    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },
    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },
    lineToPoint: function( point ) {
      if ( this.hasSubpaths() ) {
        var start = this.getLastSubpath().getLastPoint();
        var end = point;
        var line = new Line( start, end );
        this.getLastSubpath().addPoint( end );
        this.addSegmentAndBounds( line );
      }
      else {
        this.ensure( point );
      }
      this.resetControlPoints();
     return this;  // for chaining
    },
    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },
    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },
    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },
    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },
    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },
    quadraticCurveToPointRelative: function( controlPoint, point ) {
      var relativePoint = this.getRelativePoint();
      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );
    },
    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },
    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },
    quadraticCurveToPoint: function( controlPoint, point ) {
      var self = this;
      this.ensure( controlPoint );
      var start = this.getLastSubpath().getLastPoint();
      var quadratic = new Quadratic( start, controlPoint, point );
      this.getLastSubpath().addPoint( point );
      var nondegenerateSegments = quadratic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        self.addSegmentAndBounds( segment );
      } );
      this.setQuadraticControlPoint( controlPoint );
     return this;  // for chaining
    },
    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },
    cubicCurveToPointRelative: function( control1, control2, point ) {
      var relativePoint = this.getRelativePoint();
      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );
    },
    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },
    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },
    cubicCurveToPoint: function( control1, control2, point ) {
      var self = this;
      this.ensure( control1 );
      var start = this.getLastSubpath().getLastPoint();
      var cubic = new Cubic( start, control1, control2, point );
      var nondegenerateSegments = cubic.getNondegenerateSegments();
      _.each( nondegenerateSegments, function( segment ) {
        self.addSegmentAndBounds( segment );
      } );
      this.getLastSubpath().addPoint( point );
      this.setCubicControlPoint( control2 );
     return this;  // for chaining
    },
    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },
    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {
      var arc = new Arc( center, radius, startAngle, endAngle, anticlockwise );
      var startPoint = arc.getStart();
      var endPoint = arc.getEnd();
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );
      this.addSegmentAndBounds( arc );
      this.resetControlPoints();
     return this;  // for chaining
    },
    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
    },
    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {
      var ellipticalArc = new EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );
      var startPoint = ellipticalArc.start;
      var endPoint = ellipticalArc.end;
      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {
        this.addSegmentAndBounds( new Line( this.getLastSubpath().getLastPoint(), startPoint ) );
      }
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
      }
      this.getLastSubpath().addPoint( startPoint );
      this.getLastSubpath().addPoint( endPoint );
      this.addSegmentAndBounds( ellipticalArc );
      this.resetControlPoints();
     return this;  // for chaining
    },
    close: function() {
      if ( this.hasSubpaths() ) {
        var previousPath = this.getLastSubpath();
        var nextPath = new Subpath();
        previousPath.close();
        this.addSubpath( nextPath );
        nextPath.addPoint( previousPath.getFirstPoint() );
      }
      this.resetControlPoints();
     return this;  // for chaining
    },
    makeImmutable: function() {
      this._immutable = true;
      this.notifyInvalidationListeners();
      return this; // for chaining
    },
    isImmutable: function() {
      return this._immutable;
    },
    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      var relativePoint = this.getRelativePoint();
      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );
    },
    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {
      throw new Error( 'ellipticalArcTo unimplemented' );
    },
    circle: function( centerX, centerY, radius ) {
      if ( typeof centerX === 'object' ) {
        var center = centerX;
        radius = centerY;
        return this.arcPoint( center, radius, 0, Math.PI * 2, false ).close();
      }
      else {
        return this.arcPoint( v( centerX, centerY ), radius, 0, Math.PI * 2, false ).close();
      }
    },
    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {
      if ( typeof centerX === 'object' ) {
        var center = centerX;
        rotation = radiusY;
        radiusY = radiusX;
        radiusX = centerY;
        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false ).close();
      }
      else {
        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false ).close();
      }
    },
    rect: function( x, y, width, height ) {
      var subpath = new Subpath();
      this.addSubpath( subpath );
      subpath.addPoint( v( x, y ) );
      subpath.addPoint( v( x + width, y ) );
      subpath.addPoint( v( x + width, y + height ) );
      subpath.addPoint( v( x, y + height ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 0 ], subpath.points[ 1 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 1 ], subpath.points[ 2 ] ) );
      this.addSegmentAndBounds( new Line( subpath.points[ 2 ], subpath.points[ 3 ] ) );
      subpath.close();
      this.addSubpath( new Subpath() );
      this.getLastSubpath().addPoint( v( x, y ) );
      assert && assert( !isNaN( this.bounds.getX() ) );
      this.resetControlPoints();
      return this;
    },
    roundRect: function( x, y, width, height, arcw, arch ) {
      var lowX = x + arcw;
      var highX = x + width - arcw;
      var lowY = y + arch;
      var highY = y + height - arch;
      if ( arcw === arch ) {
        this
          .arc( highX, lowY, arcw, -Math.PI / 2, 0, false )
          .arc( highX, highY, arcw, 0, Math.PI / 2, false )
          .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )
          .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      else {
        this
          .ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )
          .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )
          .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )
          .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )
          .close();
      }
      return this;
    },
    polygon: function( vertices ) {
      var length = vertices.length;
      if ( length > 0 ) {
        this.moveToPoint( vertices[ 0 ] );
        for ( var i = 1; i < length; i++ ) {
          this.lineToPoint( vertices[ i ] );
        }
      }
      return this.close();
    },
    cardinalSpline: function( positions, options ) {
      options = _.extend( {
        tension: 0,
        isClosedLineSegments: false
      }, options );
      assert && assert( options.tension < 1 && options.tension > -1, ' the tension goes from -1 to 1 ' );
      var pointNumber = positions.length; // number of points in the array
      var segmentNumber = ( options.isClosedLineSegments ) ? pointNumber : pointNumber - 1;
      for ( var i = 0; i < segmentNumber; i++ ) {
        var cardinalPoints; // {Array.<Vector2>} cardinal points Array
        if ( i === 0 && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ 0 ],
            positions[ 0 ],
            positions[ 1 ],
            positions[ 2 ] ];
        }
        else if ( (i === segmentNumber - 1) && !options.isClosedLineSegments ) {
          cardinalPoints = [
            positions[ i - 1 ],
            positions[ i ],
            positions[ i + 1 ],
            positions[ i + 1 ] ];
        }
        else {
          cardinalPoints = [
            positions[ ( i - 1 + pointNumber ) % pointNumber ],
            positions[ i % pointNumber ],
            positions[ ( i + 1 ) % pointNumber ],
            positions[ ( i + 2 ) % pointNumber ] ];
        }
        var bezierPoints = [
          cardinalPoints[ 1 ],
          weightedSplineVector( cardinalPoints[ 0 ], cardinalPoints[ 1 ], cardinalPoints[ 2 ], options.tension ),
          weightedSplineVector( cardinalPoints[ 3 ], cardinalPoints[ 2 ], cardinalPoints[ 1 ], options.tension ),
          cardinalPoints[ 2 ]
        ];
        if ( i === 0 ) {
          this.ensure( bezierPoints[ 0 ] );
          this.getLastSubpath().addPoint( bezierPoints[ 0 ] );
        }
        this.cubicCurveToPoint( bezierPoints[ 1 ], bezierPoints[ 2 ], bezierPoints[ 3 ] );
      }
      return this;
    },
    copy: function() {
      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );
    },
    writeToContext: function( context ) {
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        this.subpaths[ i ].writeToContext( context );
      }
    },
    getSVGPath: function() {
      var string = '';
      var len = this.subpaths.length;
      for ( var i = 0; i < len; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() ) {
          var startPoint = subpath.segments[ 0 ].start;
          string += 'M ' + kite.svgNumber( startPoint.x ) + ' ' + kite.svgNumber( startPoint.y ) + ' ';
          for ( var k = 0; k < subpath.segments.length; k++ ) {
            string += subpath.segments[ k ].getSVGPathFragment() + ' ';
          }
          if ( subpath.isClosed() ) {
            string += 'Z ';
          }
        }
      }
      return string;
    },
    transformed: function( matrix ) {
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },
    nonlinearTransformed: function( options ) {
      options = _.extend( {
        minLevels: 0,
        maxLevels: 7,
        distanceEpsilon: 0.16, // NOTE: this will change when the Shape is scaled, since this is a threshold for the square of a distance value
        curveEpsilon: ( options && options.includeCurvature ) ? 0.002 : null
      }, options );
      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.nonlinearTransformed( options ); } );
      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.bounds ); }, Bounds2.NOTHING );
      return new Shape( subpaths, bounds );
    },
    polarToCartesian: function( options ) {
      return this.nonlinearTransformed( _.extend( {
        pointMap: function( p ) {
          return Vector2.createPolar( p.y, p.x );
        },
        methodName: 'polarToCartesian' // this will be called on Segments if it exists to do more optimized conversion (see Line)
      }, options ) );
    },
    toPiecewiseLinear: function( options ) {
      assert && assert( !options.pointMap, 'No pointMap for toPiecewiseLinear allowed, since it could create non-linear segments' );
      assert && assert( !options.methodName, 'No methodName for toPiecewiseLinear allowed, since it could create non-linear segments' );
      return this.nonlinearTransformed( options );
    },
    containsPoint: function( point ) {
      var ray = new Ray2( point, Vector2.X_UNIT );
      return this.windingIntersection( ray ) !== 0;
    },
    intersection: function( ray ) {
      var hits = [];
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            var segment = subpath.segments[ k ];
            hits = hits.concat( segment.intersection( ray ) );
          }
          if ( subpath.hasClosingSegment() ) {
            hits = hits.concat( subpath.getClosingSegment().intersection( ray ) );
          }
        }
      }
      return _.sortBy( hits, function( hit ) { return hit.distance; } );
    },
    interiorIntersectsLineSegment: function( startPoint, endPoint ) {
      var midpoint = startPoint.blend( endPoint, 0.5 );
      if ( this.containsPoint( midpoint ) ) {
        return true;
      }
      var delta = endPoint.minus( startPoint );
      var length = delta.magnitude();
      if ( length === 0 ) {
        return false;
      }
      delta.normalize(); // so we can use it as a unit vector, expected by the Ray
      var hits = this.intersection( new Ray2( startPoint, delta ) );
      for ( var i = 0; i < hits.length; i++ ) {
        if ( hits[ i ].distance <= length ) {
          return true;
        }
      }
      return false;
    },
    windingIntersection: function( ray ) {
      var wind = 0;
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() ) {
          var numSegments = subpath.segments.length;
          for ( var k = 0; k < numSegments; k++ ) {
            wind += subpath.segments[ k ].windingIntersection( ray );
          }
          if ( subpath.hasClosingSegment() ) {
            wind += subpath.getClosingSegment().windingIntersection( ray );
          }
        }
      }
      return wind;
    },
    intersectsBounds: function( bounds ) {
      if ( this.bounds.intersection( bounds ).equals( this.bounds ) ) {
        return true;
      }
      var minHorizontalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 1, 0 ) );
      var minVerticalRay = new Ray2( new Vector2( bounds.minX, bounds.minY ), new Vector2( 0, 1 ) );
      var maxHorizontalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( -1, 0 ) );
      var maxVerticalRay = new Ray2( new Vector2( bounds.maxX, bounds.maxY ), new Vector2( 0, -1 ) );
      var hitPoint;
      var i;
      var horizontalRayIntersections = this.intersection( minHorizontalRay ).concat( this.intersection( maxHorizontalRay ) );
      for ( i = 0; i < horizontalRayIntersections.length; i++ ) {
        hitPoint = horizontalRayIntersections[ i ].point;
        if ( hitPoint.x >= bounds.minX && hitPoint.x <= bounds.maxX ) {
          return true;
        }
      }
      var verticalRayIntersections = this.intersection( minVerticalRay ).concat( this.intersection( maxVerticalRay ) );
      for ( i = 0; i < verticalRayIntersections.length; i++ ) {
        hitPoint = verticalRayIntersections[ i ].point;
        if ( hitPoint.y >= bounds.minY && hitPoint.y <= bounds.maxY ) {
          return true;
        }
      }
      return false;
    },
    getStrokedShape: function( lineStyles ) {
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        var subpath = this.subpaths[ i ];
        var strokedSubpath = subpath.stroked( lineStyles );
        subpaths = subpaths.concat( strokedSubpath );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },
    getOffsetShape: function( distance ) {
      var subpaths = [];
      var bounds = Bounds2.NOTHING.copy();
      var subLen = this.subpaths.length;
      for ( var i = 0; i < subLen; i++ ) {
        subpaths.push( this.subpaths[ i ].offset( distance ) );
      }
      subLen = subpaths.length;
      for ( i = 0; i < subLen; i++ ) {
        bounds.includeBounds( subpaths[ i ].bounds );
      }
      return new Shape( subpaths, bounds );
    },
    getBounds: function() {
      if ( this._bounds === null ) {
        var bounds = Bounds2.NOTHING.copy();
        _.each( this.subpaths, function( subpath ) {
          bounds.includeBounds( subpath.getBounds() );
        } );
        this._bounds = bounds;
      }
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    getStrokedBounds: function( lineStyles ) {
      var areStrokedBoundsDilated = true;
      for ( var i = 0; i < this.subpaths.length; i++ ) {
        var subpath = this.subpaths[ i ];
        if ( subpath.isDrawable() && !subpath.isClosed() ) {
          areStrokedBoundsDilated = false;
          break;
        }
        for ( var j = 0; j < subpath.segments.length; j++ ) {
          var segment = subpath.segments[ j ];
          if ( !segment.areStrokedBoundsDilated() ) {
            areStrokedBoundsDilated = false;
            break;
          }
        }
      }
      if ( areStrokedBoundsDilated ) {
        return this.bounds.dilated( lineStyles.lineWidth / 2 );
      }
      else {
        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );
      }
    },
    getBoundsWithTransform: function( matrix, lineStyles ) {
      if ( matrix.isAxisAligned() ) {
        return this.getStrokedBounds( lineStyles );
      }
      var bounds = Bounds2.NOTHING.copy();
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        var subpath = this.subpaths[ i ];
        bounds.includeBounds( subpath.getBoundsWithTransform( matrix ) );
      }
      if ( lineStyles ) {
        bounds.includeBounds( this.getStrokedShape( lineStyles ).getBoundsWithTransform( matrix ) );
      }
      return bounds;
    },
    getApproximateArea: function( numSamples ) {
      var x = this.bounds.minX;
      var y = this.bounds.minY;
      var width = this.bounds.width;
      var height = this.bounds.height;
      var rectangleArea = width * height;
      var count = 0;
      var point = new Vector2();
      for ( var i = 0; i < numSamples; i++ ) {
        point.x = x + Math.random() * width;
        point.y = y + Math.random() * height;
        if ( this.containsPoint( point ) ) {
          count++;
        }
      }
      return rectangleArea * count / numSamples;
    },
    getApproximateCentroid: function( numSamples ) {
      var x = this.bounds.minX;
      var y = this.bounds.minY;
      var width = this.bounds.width;
      var height = this.bounds.height;
      var count = 0;
      var sum = new Vector2();
      var point = new Vector2();
      for ( var i = 0; i < numSamples; i++ ) {
        point.x = x + Math.random() * width;
        point.y = y + Math.random() * height;
        if ( this.containsPoint( point ) ) {
          sum.add( point );
          count++;
        }
      }
      return sum.dividedScalar( count );
    },
    invalidatePoints: function() {
      this._invalidatingPoints = true;
      var numSubpaths = this.subpaths.length;
      for ( var i = 0; i < numSubpaths; i++ ) {
        this.subpaths[ i ].invalidatePoints();
      }
      this._invalidatingPoints = false;
      this.invalidate();
    },
    toString: function() {
      return 'new kite.Shape( \'' + this.getSVGPath() + '\' )';
    },
    invalidate: function() {
      assert && assert( !this._immutable, 'Attempt to modify an immutable Shape' );
      if ( !this._invalidatingPoints ) {
        this._bounds = null;
        this.notifyInvalidationListeners();
      }
    },
    notifyInvalidationListeners: function() {
      this.trigger0( 'invalidated' );
    },
    addSegmentAndBounds: function( segment ) {
      this.getLastSubpath().addSegment( segment );
      this.invalidate();
    },
    ensure: function( point ) {
      if ( !this.hasSubpaths() ) {
        this.addSubpath( new Subpath() );
        this.getLastSubpath().addPoint( point );
      }
    },
    addSubpath: function( subpath ) {
      this.subpaths.push( subpath );
      subpath.onStatic( 'invalidated', this._invalidateListener );
      this.invalidate();
      return this; // allow chaining
    },
    hasSubpaths: function() {
      return this.subpaths.length > 0;
    },
    getLastSubpath: function() {
      return _.last( this.subpaths );
    },
    getLastPoint: function() {
      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;
    },
    getLastSegment: function() {
      if ( !this.hasSubpaths() ) { return null; }
      var subpath = this.getLastSubpath();
      if ( !subpath.isDrawable() ) { return null; }
      return subpath.getLastSegment();
    },
    getSmoothQuadraticControlPoint: function() {
      var lastPoint = this.getLastPoint();
      if ( this.lastQuadraticControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastQuadraticControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },
    getSmoothCubicControlPoint: function() {
      var lastPoint = this.getLastPoint();
      if ( this.lastCubicControlPoint ) {
        return lastPoint.plus( lastPoint.minus( this.lastCubicControlPoint ) );
      }
      else {
        return lastPoint;
      }
    },
    getRelativePoint: function() {
      var lastPoint = this.getLastPoint();
      return lastPoint ? lastPoint : Vector2.ZERO;
    }
  } );
  Shape.rectangle = function( x, y, width, height ) {
    return new Shape().rect( x, y, width, height );
  };
  Shape.rect = Shape.rectangle;
  Shape.roundRect = function( x, y, width, height, arcw, arch ) {
    return new Shape().roundRect( x, y, width, height, arcw, arch );
  };
  Shape.roundRectangle = Shape.roundRect;
  Shape.roundedRectangleWithRadii = function( x, y, width, height, cornerRadii ) {
    var topLeftRadius = cornerRadii && cornerRadii.topLeft || 0;
    var topRightRadius = cornerRadii && cornerRadii.topRight || 0;
    var bottomLeftRadius = cornerRadii && cornerRadii.bottomLeft || 0;
    var bottomRightRadius = cornerRadii && cornerRadii.bottomRight || 0;
    assert && assert( typeof x === 'number' && isFinite( x ), 'Non-finite x' );
    assert && assert( typeof y === 'number' && isFinite( y ), 'Non-finite y' );
    assert && assert( typeof width === 'number' && width >= 0 && isFinite( width ), 'Negative or non-finite width' );
    assert && assert( typeof height === 'number' && height >= 0 && isFinite( height ), 'Negative or non-finite height' );
    assert && assert( typeof topLeftRadius === 'number' && topLeftRadius >= 0 && isFinite( topLeftRadius ),
      'Invalid topLeft' );
    assert && assert( typeof topRightRadius === 'number' && topRightRadius >= 0 && isFinite( topRightRadius ),
      'Invalid topRight' );
    assert && assert( typeof bottomLeftRadius === 'number' && bottomLeftRadius >= 0 && isFinite( bottomLeftRadius ),
      'Invalid bottomLeft' );
    assert && assert( typeof bottomRightRadius === 'number' && bottomRightRadius >= 0 && isFinite( bottomRightRadius ),
      'Invalid bottomRight' );
    assert && assert( topLeftRadius + topRightRadius <= width, 'Corner overlap on top edge' );
    assert && assert( bottomLeftRadius + bottomRightRadius <= width, 'Corner overlap on bottom edge' );
    assert && assert( topLeftRadius + bottomLeftRadius <= height, 'Corner overlap on left edge' );
    assert && assert( topRightRadius + bottomRightRadius <= height, 'Corner overlap on right edge' );
    var shape = new kite.Shape();
    var right = x + width;
    var bottom = y + height;
    if ( bottomRightRadius > 0 ) {
      shape.arc( right - bottomRightRadius, bottom - bottomRightRadius, bottomRightRadius, 0, Math.PI / 2, false );
    }
    else {
      shape.moveTo( right, bottom );
    }
    if ( bottomLeftRadius > 0 ) {
      shape.arc( x + bottomLeftRadius, bottom - bottomLeftRadius, bottomLeftRadius, Math.PI / 2, Math.PI, false );
    }
    else {
      shape.lineTo( x, bottom );
    }
    if ( topLeftRadius > 0 ) {
      shape.arc( x + topLeftRadius, y + topLeftRadius, topLeftRadius, Math.PI, 3 * Math.PI / 2, false );
    }
    else {
      shape.lineTo( x, y );
    }
    if ( topRightRadius > 0 ) {
      shape.arc( right - topRightRadius, y + topRightRadius, topRightRadius, 3 * Math.PI / 2, 2 * Math.PI, false );
    }
    else {
      shape.lineTo( right, y );
    }
    shape.close();
    return shape;
  };
  Shape.polygon = function( vertices ) {
    return new Shape().polygon( vertices );
  };
  Shape.bounds = function( bounds ) {
    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );
  };
  Shape.lineSegment = function( a, b, c, d ) {
    if ( typeof a === 'number' ) {
      return new Shape().moveTo( a, b ).lineTo( c, d );
    }
    else {
      return new Shape().moveToPoint( a ).lineToPoint( b );
    }
  };
  Shape.regularPolygon = function( sides, radius ) {
    var shape = new Shape();
    _.each( _.range( sides ), function( k ) {
      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );
      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );
    } );
    return shape.close();
  };
  Shape.circle = function( centerX, centerY, radius ) {
    if ( centerY === undefined ) {
      return new Shape().circle( 0, 0, centerX );
    }
    return new Shape().circle( centerX, centerY, radius );
  };
  Shape.ellipse = function( centerX, centerY, radiusX, radiusY, rotation ) {
    if ( radiusY === undefined ) {
      return new Shape().ellipse( 0, 0, centerX, centerY, radiusX );
    }
    return new Shape().ellipse( centerX, centerY, radiusX, radiusY, rotation );
  };
  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {
    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );
  };
  return Shape;
} );
define( 'SCENERY/display/Renderer',['require','SCENERY/scenery'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = {};
  scenery.register( 'Renderer', Renderer );
  Renderer.numActiveRenderers = 4;
  Renderer.bitsPerRenderer = 5;
  Renderer.bitmaskRendererArea = 0x00000FF;
  Renderer.bitmaskCurrentRendererArea = 0x000000F;
  Renderer.bitmaskLacksOffset = 0x10000;
  Renderer.bitmaskLacksShift = 16; // number of bits between the main renderer bitmask and the "lacks" variety
  Renderer.bitmaskNodeDefault = Renderer.bitmaskRendererArea;
  Renderer.bitmaskCanvas = 0x0000001;
  Renderer.bitmaskSVG = 0x0000002;
  Renderer.bitmaskDOM = 0x0000004;
  Renderer.bitmaskWebGL = 0x0000008;
  Renderer.bitmaskSingleCanvas = 0x100;
  Renderer.bitmaskSingleSVG = 0x200;
  Renderer.bitmaskNotPainted = 0x1000;
  Renderer.bitmaskBoundsValid = 0x2000;
  Renderer.bitmaskNotAccessible = 0x4000;
  Renderer.bitmaskLacksCanvas = Renderer.bitmaskCanvas << Renderer.bitmaskLacksShift; // 0x10000
  Renderer.bitmaskLacksSVG = Renderer.bitmaskSVG << Renderer.bitmaskLacksShift; // 0x20000
  Renderer.bitmaskLacksDOM = Renderer.bitmaskDOM << Renderer.bitmaskLacksShift; // 0x40000
  Renderer.bitmaskLacksWebGL = Renderer.bitmaskWebGL << Renderer.bitmaskLacksShift; // 0x80000
  Renderer.isCanvas = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskCanvas ) !== 0;
  };
  Renderer.isSVG = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskSVG ) !== 0;
  };
  Renderer.isDOM = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskDOM ) !== 0;
  };
  Renderer.isWebGL = function( bitmask ) {
    return ( bitmask & Renderer.bitmaskWebGL ) !== 0;
  };
  var rendererMap = {
    canvas: Renderer.bitmaskCanvas,
    svg: Renderer.bitmaskSVG,
    dom: Renderer.bitmaskDOM,
    webgl: Renderer.bitmaskWebGL
  };
  Renderer.fromName = function( name ) {
    return rendererMap[ name ];
  };
  Renderer.stripBitmask = function( bitmask ) {
    return bitmask & Renderer.bitmaskRendererArea;
  };
  Renderer.createOrderBitmask = function( firstRenderer, secondRenderer, thirdRenderer, fourthRenderer ) {
    firstRenderer = firstRenderer || 0;
    secondRenderer = secondRenderer || 0;
    thirdRenderer = thirdRenderer || 0;
    fourthRenderer = fourthRenderer || 0;
    return firstRenderer |
           ( secondRenderer << 5 ) |
           ( thirdRenderer << 10 ) |
           ( fourthRenderer << 15 );
  };
  Renderer.bitmaskOrder = function( bitmask, n ) {
    if ( n > 0 ) {
      bitmask = bitmask >> ( 5 * n );
    }
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFirst = function( bitmask ) {
    return bitmask & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderSecond = function( bitmask ) {
    return ( bitmask >> 5 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderThird = function( bitmask ) {
    return ( bitmask >> 10 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.bitmaskOrderFourth = function( bitmask ) {
    return ( bitmask >> 15 ) & Renderer.bitmaskCurrentRendererArea;
  };
  Renderer.pushOrderBitmask = function( bitmask, renderer ) {
    assert && assert( typeof bitmask === 'number' );
    assert && assert( typeof renderer === 'number' );
    var rendererToInsert = renderer;
    var totalBits = Renderer.bitsPerRenderer * Renderer.numActiveRenderers;
    for ( var i = 0; i <= totalBits; i += Renderer.bitsPerRenderer ) {
      var currentRenderer = ( bitmask >> i ) & Renderer.bitmaskCurrentRendererArea;
      if ( currentRenderer === rendererToInsert ) {
        return bitmask;
      }
      else if ( currentRenderer === 0 ) {
        bitmask = bitmask | ( rendererToInsert << i );
        return bitmask;
      }
      else {
        bitmask = ( bitmask & ~( Renderer.bitmaskCurrentRendererArea << i ) );
        bitmask = bitmask | ( rendererToInsert << i );
        rendererToInsert = currentRenderer;
      }
      if ( rendererToInsert === renderer ) {
        return bitmask;
      }
    }
    throw new Error( 'pushOrderBitmask overflow' );
  };
  Renderer.createSelfDrawable = function( instance, node, selfRenderer, fittable ) {
    var drawable;
    if ( Renderer.isCanvas( selfRenderer ) ) {
      drawable = node.createCanvasDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isSVG( selfRenderer ) ) {
      drawable = node.createSVGDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isDOM( selfRenderer ) ) {
      drawable = node.createDOMDrawable( selfRenderer, instance );
    }
    else if ( Renderer.isWebGL( selfRenderer ) ) {
      drawable = node.createWebGLDrawable( selfRenderer, instance );
    }
    else {
      throw new Error( 'Unrecognized renderer: ' + selfRenderer );
    }
    if ( assert ) {
      _.each( node.drawableMarkFlags, function( flag ) {
        var methodName = 'markDirty' + flag[ 0 ].toUpperCase() + flag.slice( 1 );
        assert( typeof drawable[ methodName ] === 'function', 'Did not find ' + methodName );
      } );
    }
    drawable.setFittable( fittable );
    return drawable;
  };
  Renderer.webglCustom = 0x1;
  Renderer.webglTexturedTriangles = 0x2;
  Renderer.webglVertexColorPolygons = 0x3;
  return Renderer;
} );
define( 'SCENERY/util/RendererSummary',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var summaryBits = [
    Renderer.bitmaskCanvas,
    Renderer.bitmaskSVG,
    Renderer.bitmaskDOM,
    Renderer.bitmaskWebGL,
    Renderer.bitmaskSingleCanvas,
    Renderer.bitmaskSingleSVG,
    Renderer.bitmaskNotPainted,
    Renderer.bitmaskBoundsValid,
    Renderer.bitmaskNotAccessible,
    Renderer.bitmaskLacksCanvas,
    Renderer.bitmaskLacksSVG,
    Renderer.bitmaskLacksDOM,
    Renderer.bitmaskLacksWebGL
  ];
  var numSummaryBits = summaryBits.length;
  var bitmaskAll = 0;
  for ( var l = 0; l < numSummaryBits; l++ ) {
    bitmaskAll |= summaryBits[ l ];
  }
  function RendererSummary( node ) {
    assert && assert( node._rendererBitmask === Renderer.bitmaskNodeDefault, 'Node must have a default bitmask when creating a RendererSummary' );
    assert && assert( node._children.length === 0, 'Node cannot have children when creating a RendererSummary' );
    this.node = node;
    this._counts = {};
    for ( var i = 0; i < numSummaryBits; i++ ) {
      this._counts[ summaryBits[ i ] ] = 0; // set everything to 0 at first
    }
    this.bitmask = bitmaskAll;
    this.selfBitmask = RendererSummary.summaryBitmaskForNodeSelf( node );
    this.summaryChange( this.bitmask, this.selfBitmask );
    var listener = this.selfChange.bind( this );
    this.node.onStatic( 'opacity', listener );
    this.node.onStatic( 'hint', listener ); // should fire on things like node.renderer being changed
    this.node.onStatic( 'clip', listener );
    this.node.onStatic( 'selfBoundsValid', listener ); // e.g. Text, may change based on boundsMethod
    this.node.onStatic( 'accessibleContent', listener );
  }
  scenery.register( 'RendererSummary', RendererSummary );
  inherit( Object, RendererSummary, {
    summaryChange: function( oldBitmask, newBitmask ) {
      assert && this.audit();
      var changeBitmask = oldBitmask ^ newBitmask; // bit set only if it changed
      var ancestorOldMask = 0;
      var ancestorNewMask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        if ( bit & changeBitmask ) {
          if ( bit & newBitmask ) {
            this._counts[ bit ]--; // reduce count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 0 ) {
              ancestorNewMask |= bit; // add our bit to the "new" mask we will send to ancestors
            }
          }
          else {
            this._counts[ bit ]++; // increment the count, since we count the number of 0s (unsupported)
            if ( this._counts[ bit ] === 1 ) {
              ancestorOldMask |= bit; // add our bit to the "old" mask we will send to ancestors
            }
          }
        }
      }
      if ( ancestorOldMask || ancestorNewMask ) {
        for ( var j = 0; j < numSummaryBits; j++ ) {
          var ancestorBit = summaryBits[ j ];
          if ( ancestorNewMask & ancestorBit ) {
            this.bitmask |= ancestorBit;
          }
          if ( ancestorOldMask & ancestorBit ) {
            this.bitmask ^= ancestorBit;
            assert && assert( !( this.bitmask & ancestorBit ),
              'Should be cleared, doing cheaper XOR assuming it already was set' );
          }
        }
        this.node.trigger0( 'rendererSummary' ); // please don't change children when listening to this!
        var len = this.node._parents.length;
        for ( var k = 0; k < len; k++ ) {
          this.node._parents[ k ]._rendererSummary.summaryChange( ancestorOldMask, ancestorNewMask );
        }
        assert && assert( this.bitmask === this.computeBitmask(), 'Sanity check' );
      }
      assert && this.audit();
    },
    selfChange: function() {
      var oldBitmask = this.selfBitmask;
      var newBitmask = RendererSummary.summaryBitmaskForNodeSelf( this.node );
      if ( oldBitmask !== newBitmask ) {
        this.summaryChange( oldBitmask, newBitmask );
        this.selfBitmask = newBitmask;
      }
    },
    computeBitmask: function() {
      var bitmask = 0;
      for ( var i = 0; i < numSummaryBits; i++ ) {
        if ( this._counts[ summaryBits[ i ] ] === 0 ) {
          bitmask |= summaryBits[ i ];
        }
      }
      return bitmask;
    },
    isSubtreeFullyCompatible: function( renderer ) {
      return !!( renderer & this.bitmask );
    },
    isSubtreeContainingCompatible: function( renderer ) {
      return !( ( renderer << Renderer.bitmaskLacksShift ) & this.bitmask );
    },
    isSingleCanvasSupported: function() {
      return !!( Renderer.bitmaskSingleCanvas & this.bitmask );
    },
    isSingleSVGSupported: function() {
      return !!( Renderer.bitmaskSingleSVG & this.bitmask );
    },
    isNotPainted: function() {
      return !!( Renderer.bitmaskNotPainted & this.bitmask );
    },
    isNotAccessible: function() {
      return !!( Renderer.bitmaskNotAccessible & this.bitmask );
    },
    areBoundsValid: function() {
      return !!( Renderer.bitmaskBoundsValid & this.bitmask );
    },
    isSubtreeRenderedExclusivelySVG: function( preferredRenderers ) {
      if ( !this.isSingleSVGSupported() ) {
        return false;
      }
      for ( var i = 0; i < Renderer.numActiveRenderers; i++ ) {
        var renderer = Renderer.bitmaskOrder( preferredRenderers, i );
        if ( Renderer.bitmaskSVG & renderer ) {
          return true;
        }
        if ( this.isSubtreeContainingCompatible( renderer ) ) {
          return false;
        }
      }
      return false; // sanity check
    },
    isSubtreeRenderedExclusivelyCanvas: function( preferredRenderers ) {
      if ( !this.isSingleCanvasSupported() ) {
        return false;
      }
      for ( var i = 0; i < Renderer.numActiveRenderers; i++ ) {
        var renderer = Renderer.bitmaskOrder( preferredRenderers, i );
        if ( Renderer.bitmaskCanvas & renderer ) {
          return true;
        }
        if ( this.isSubtreeContainingCompatible( renderer ) ) {
          return false;
        }
      }
      return false; // sanity check
    },
    audit: function() {
      if ( assert ) {
        for ( var i = 0; i < numSummaryBits; i++ ) {
          var bit = summaryBits[ i ];
          var countIsZero = this._counts[ bit ] === 0;
          var bitmaskContainsBit = !!( this.bitmask & bit );
          assert( countIsZero === bitmaskContainsBit, 'Bits should be set if count is zero' );
        }
      }
    },
    toString: function() {
      var result = RendererSummary.bitmaskToString( this.bitmask );
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        var countForBit = this._counts[ bit ];
        if ( countForBit !== 0 ) {
          result += ' ' + RendererSummary.bitToString( bit ) + ':' + countForBit;
        }
      }
      return result;
    }
  }, {
    bitmaskAll: bitmaskAll,
    summaryBitmaskForNodeSelf: function( node ) {
      var bitmask = node._rendererBitmask;
      if ( node.isPainted() ) {
        bitmask |= ( ( node._rendererBitmask & Renderer.bitmaskCurrentRendererArea ) ^ Renderer.bitmaskCurrentRendererArea ) << Renderer.bitmaskLacksShift;
      }
      else {
        bitmask |= Renderer.bitmaskCurrentRendererArea << Renderer.bitmaskLacksShift;
      }
      var requiresSplit = node._hints.requireElement || node._hints.cssTransform || node._hints.layerSplit;
      var rendererHint = node._hints.renderer;
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           Renderer.isSVG( node._rendererBitmask ) && // If our node doesn't support SVG, can't do it
           ( !rendererHint || Renderer.isSVG( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleSVG;
      }
      if ( !requiresSplit && // Can't have a single SVG element if we are split
           Renderer.isCanvas( node._rendererBitmask ) && // If our node doesn't support Canvas, can't do it
           ( !rendererHint || Renderer.isCanvas( rendererHint ) ) ) { // Can't if a renderer hint is set to something else
        bitmask |= Renderer.bitmaskSingleCanvas;
      }
      if ( !node.isPainted() ) {
        bitmask |= Renderer.bitmaskNotPainted;
      }
      if ( node.areSelfBoundsValid() ) {
        bitmask |= Renderer.bitmaskBoundsValid;
      }
      if ( !node.accessibleContent ) {
        bitmask |= Renderer.bitmaskNotAccessible;
      }
      return bitmask;
    },
    bitToString: function( bit ) {
      if ( bit === Renderer.bitmaskCanvas ) { return 'Canvas'; }
      if ( bit === Renderer.bitmaskSVG ) { return 'SVG'; }
      if ( bit === Renderer.bitmaskDOM ) { return 'DOM'; }
      if ( bit === Renderer.bitmaskWebGL ) { return 'WebGL'; }
      if ( bit === Renderer.bitmaskLacksCanvas ) { return '(-Canvas)'; }
      if ( bit === Renderer.bitmaskLacksSVG ) { return '(-SVG)'; }
      if ( bit === Renderer.bitmaskLacksDOM ) { return '(-DOM)'; }
      if ( bit === Renderer.bitmaskLacksWebGL ) { return '(-WebGL)'; }
      if ( bit === Renderer.bitmaskSingleCanvas ) { return 'SingleCanvas'; }
      if ( bit === Renderer.bitmaskSingleSVG ) { return 'SingleSVG'; }
      if ( bit === Renderer.bitmaskNotPainted ) { return 'NotPainted'; }
      if ( bit === Renderer.bitmaskBoundsValid ) { return 'BoundsValid'; }
      if ( bit === Renderer.bitmaskNotAccessible ) { return 'NotAccessible'; }
      return '?';
    },
    bitmaskToString: function( bitmask ) {
      var result = '';
      for ( var i = 0; i < numSummaryBits; i++ ) {
        var bit = summaryBits[ i ];
        if ( bitmask & bit ) {
          result += RendererSummary.bitToString( bit ) + ' ';
        }
      }
      return result;
    }
  } );
  return RendererSummary;
} );
define( 'SCENERY/util/Picker',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','DOT/Vector2'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  function Picker( node ) {
    this.node = node;
    this.selfPruned = false;
    this.selfInclusive = false;
    this.subtreePrunable = true;
    this.subtreePickableCount = 0;
    this.mouseInclusiveBounds = Bounds2.NOTHING.copy();
    this.mouseExclusiveBounds = Bounds2.NOTHING.copy();
    this.touchInclusiveBounds = Bounds2.NOTHING.copy();
    this.touchExclusiveBounds = Bounds2.NOTHING.copy();
    this.mouseInclusiveDirty = true;
    this.mouseExclusiveDirty = true;
    this.touchInclusiveDirty = true;
    this.touchExclusiveDirty = true;
    this.scratchVector = new Vector2();
  }
  scenery.register( 'Picker', Picker );
  inherit( Object, Picker, {
    hitTest: function( point, useMouse, useTouch ) {
      assert && assert( point, 'trailUnderPointer requires a point' );
      sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( '-------------- ' + this.node.constructor.name + '#' + this.node.id );
      var isBaseInclusive = this.selfInclusive;
      if ( useMouse ) {
        if ( isBaseInclusive ) {
          this.validateMouseInclusive();
        }
        else {
          this.validateMouseExclusive();
        }
      }
      else if ( useTouch ) {
        if ( isBaseInclusive ) {
          this.validateTouchInclusive();
        }
        else {
          this.validateTouchExclusive();
        }
      }
      else {
        this.node.validateBounds();
      }
      return this.recursiveHitTest( point, useMouse, useTouch, false );
    },
    recursiveHitTest: function( point, useMouse, useTouch, isInclusive ) {
      isInclusive = isInclusive || this.selfInclusive;
      if ( this.selfPruned || ( !isInclusive && this.subtreePrunable ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id +
          ' pruned ' + ( this.selfPruned ? '(self)' : '(subtree)' ) );
        return null;
      }
      var pruningBounds;
      if ( useMouse ) {
        pruningBounds = isInclusive ? this.mouseInclusiveBounds : this.mouseExclusiveBounds;
        assert && assert( isInclusive ? !this.mouseInclusiveDirty : !this.mouseExclusiveDirty );
      }
      else if ( useTouch ) {
        pruningBounds = isInclusive ? this.touchInclusiveBounds : this.touchExclusiveBounds;
        assert && assert( isInclusive ? !this.touchInclusiveDirty : !this.touchExclusiveDirty );
      }
      else {
        pruningBounds = this.node._bounds;
        assert && assert( !this.node._boundsDirty );
      }
      if ( !pruningBounds.containsPoint( point ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' pruned: ' + ( useMouse ? 'mouse' : ( useTouch ? 'touch' : 'regular' ) ) );
        return null; // not in our bounds, so this point can't possibly be contained
      }
      var localPoint = this.node._transform.getInverse().multiplyVector2( this.scratchVector.set( point ) );
      if ( this.node.hasClipArea() && !this.node._clipArea.containsPoint( localPoint ) ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' out of clip area' );
        return null;
      }
      sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id );
      for ( var i = this.node._children.length - 1; i >= 0; i-- ) {
        var child = this.node._children[ i ];
        sceneryLog && sceneryLog.hitTest && sceneryLog.push();
        var childHit = child._picker.recursiveHitTest( localPoint, useMouse, useTouch, isInclusive );
        sceneryLog && sceneryLog.hitTest && sceneryLog.pop();
        if ( childHit ) {
          return childHit.addAncestor( this.node, i );
        }
      }
      if ( useMouse && this.node._mouseArea ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' mouse area hit' );
        return this.node._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this.node ) : null;
      }
      if ( useTouch && this.node._touchArea ) {
        sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' touch area hit' );
        return this.node._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this.node ) : null;
      }
      if ( this.node.selfBounds.containsPoint( localPoint ) ) {
        if ( this.node.containsPointSelf( localPoint ) ) {
          sceneryLog && sceneryLog.hitTest && sceneryLog.hitTest( this.node.constructor.name + '#' + this.node.id + ' self hit' );
          return new scenery.Trail( this.node );
        }
      }
      return null;
    },
    invalidate: function( andExclusive, ignoreSelfDirty ) {
      assert && assert( typeof andExclusive === 'boolean' );
      var wasNotDirty = !!ignoreSelfDirty || !this.mouseInclusiveDirty || !this.touchInclusiveDirty;
      this.mouseInclusiveDirty = true;
      this.touchInclusiveDirty = true;
      if ( andExclusive ) {
        wasNotDirty = wasNotDirty || !this.mouseExclusiveDirty || !this.touchExclusiveDirty;
        this.mouseExclusiveDirty = true;
        this.touchExclusiveDirty = true;
      }
      if ( !this.selfPruned && wasNotDirty ) {
        var parents = this.node._parents;
        for ( var i = 0; i < parents.length; i++ ) {
          parents[ i ]._picker.invalidate( andExclusive || this.selfInclusive, false );
        }
      }
    },
    validateMouseInclusive: function() {
      if ( !this.mouseInclusiveDirty ) {
        return;
      }
      this.mouseInclusiveBounds.set( this.node.selfBounds );
      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;
        if ( !childPicker.selfPruned ) {
          childPicker.validateMouseInclusive();
          this.mouseInclusiveBounds.includeBounds( childPicker.mouseInclusiveBounds );
        }
      }
      this.applyAreasAndTransform( this.mouseInclusiveBounds, this.node._mouseArea );
      this.mouseInclusiveDirty = false;
    },
    validateMouseExclusive: function() {
      if ( !this.mouseExclusiveDirty ) {
        return;
      }
      this.mouseExclusiveBounds.set( this.node.selfBounds );
      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;
        if ( !childPicker.subtreePrunable ) {
          if ( childPicker.selfInclusive ) {
            childPicker.validateMouseInclusive();
            this.mouseExclusiveBounds.includeBounds( childPicker.mouseInclusiveBounds );
          }
          else {
            childPicker.validateMouseExclusive();
            this.mouseExclusiveBounds.includeBounds( childPicker.mouseExclusiveBounds );
          }
        }
      }
      this.applyAreasAndTransform( this.mouseExclusiveBounds, this.node._mouseArea );
      this.mouseExclusiveDirty = false;
    },
    validateTouchInclusive: function() {
      if ( !this.touchInclusiveDirty ) {
        return;
      }
      this.touchInclusiveBounds.set( this.node.selfBounds );
      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;
        if ( !childPicker.selfPruned ) {
          childPicker.validateTouchInclusive();
          this.touchInclusiveBounds.includeBounds( childPicker.touchInclusiveBounds );
        }
      }
      this.applyAreasAndTransform( this.touchInclusiveBounds, this.node._touchArea );
      this.touchInclusiveDirty = false;
    },
    validateTouchExclusive: function() {
      if ( !this.touchExclusiveDirty ) {
        return;
      }
      this.touchExclusiveBounds.set( this.node.selfBounds );
      var children = this.node._children;
      for ( var i = 0; i < children.length; i++ ) {
        var childPicker = children[ i ]._picker;
        if ( !childPicker.subtreePrunable ) {
          if ( childPicker.selfInclusive ) {
            childPicker.validateTouchInclusive();
            this.touchExclusiveBounds.includeBounds( childPicker.touchInclusiveBounds );
          }
          else {
            childPicker.validateTouchExclusive();
            this.touchExclusiveBounds.includeBounds( childPicker.touchExclusiveBounds );
          }
        }
      }
      this.applyAreasAndTransform( this.touchExclusiveBounds, this.node._touchArea );
      this.touchExclusiveDirty = false;
    },
    applyAreasAndTransform: function( mutableBounds, pointerArea ) {
      if ( pointerArea ) {
        mutableBounds.includeBounds( pointerArea.isBounds ? pointerArea : pointerArea.bounds );
      }
      if ( this.node.hasClipArea() ) {
        mutableBounds.constrainBounds( this.node._clipArea.bounds );
      }
      this.node.transformBoundsFromLocalToParent( mutableBounds );
    },
    onInsertChild: function( childNode ) {
      if ( !childNode._picker.selfPruned ) {
        var hasPickable = childNode._picker.subtreePickableCount > 0;
        if ( hasPickable ) {
          this.changePickableCount( 1 );
        }
        this.invalidate( hasPickable, true );
      }
    },
    onRemoveChild: function( childNode ) {
      if ( !childNode._picker.selfPruned ) {
        var hasPickable = childNode._picker.subtreePickableCount > 0;
        if ( hasPickable ) {
          this.changePickableCount( -1 );
        }
        this.invalidate( hasPickable, true );
      }
    },
    onAddInputListener: function() {
      this.checkSelfInclusive();
      this.checkSubtreePrunable();
      this.changePickableCount( 1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds
      if ( assertSlow ) { this.audit(); }
    },
    onRemoveInputListener: function() {
      this.checkSelfInclusive();
      this.checkSubtreePrunable();
      this.changePickableCount( -1 ); // NOTE: this should also trigger invalidation of mouse/touch bounds
      if ( assertSlow ) { this.audit(); }
    },
    onPickableChange: function( oldPickable, pickable ) {
      this.checkSelfPruned();
      this.checkSelfInclusive();
      this.checkSubtreePrunable();
      var change = ( oldPickable === true ? -1 : 0 ) + ( pickable === true ? 1 : 0 );
      if ( change ) {
        this.changePickableCount( change );
      }
      if ( assertSlow ) { this.audit(); }
    },
    onVisibilityChange: function() {
      this.checkSelfPruned();
      this.checkSubtreePrunable();
    },
    onMouseAreaChange: function() {
      this.invalidate( true );
    },
    onTouchAreaChange: function() {
      this.invalidate( true );
    },
    onTransformChange: function() {
      this.invalidate( true );
    },
    onSelfBoundsDirty: function() {
      this.invalidate( true );
    },
    onClipAreaChange: function() {
      this.invalidate( true );
    },
    checkSelfPruned: function() {
      var selfPruned = this.node._pickable === false || !this.node.isVisible();
      if ( this.selfPruned !== selfPruned ) {
        this.selfPruned = selfPruned;
        var parents = this.node._parents;
        for ( var i = 0; i < parents.length; i++ ) {
          var picker = parents[ i ]._picker;
          if ( this.subtreePickableCount > 0 ) {
            picker.invalidate( true, true );
            picker.changePickableCount( this.selfPruned ? -1 : 1 );
          }
          else {
            picker.invalidate( false, true );
          }
        }
      }
    },
    checkSelfInclusive: function() {
      var selfInclusive = this.node._pickable === true || this.node._inputListeners.length > 0;
      if ( this.selfInclusive !== selfInclusive ) {
        this.selfInclusive = selfInclusive;
        this.invalidate( true, true );
      }
    },
    checkSubtreePrunable: function() {
      var subtreePrunable = this.node._pickable === false ||
                            !this.node.isVisible() ||
                            ( this.node._pickable !== true && this.subtreePickableCount === 0 );
      if ( this.subtreePrunable !== subtreePrunable ) {
        this.subtreePrunable = subtreePrunable;
        this.invalidate( true, true );
      }
    },
    changePickableCount: function( n ) {
      if ( n === 0 ) {
        return;
      }
      var wasZero = this.subtreePickableCount === 0;
      this.subtreePickableCount += n;
      var isZero = this.subtreePickableCount === 0;
      this.checkSubtreePrunable();
      assert && assert( this.subtreePickableCount >= 0, 'subtree pickable count should be guaranteed to be >= 0' );
      if ( !this.selfPruned && wasZero !== isZero ) {
        var len = this.node._parents.length;
        for ( var i = 0; i < len; i++ ) {
          this.node._parents[ i ]._picker.changePickableCount( wasZero ? 1 : -1 );
        }
      }
    },
    audit: function() {
      if ( assertSlow ) {
        var self = this;
        _.each( this.node._children, function( node ) {
          node._picker.audit();
        } );
        var expectedSelfPruned = this.node.pickable === false || !this.node.isVisible();
        var expectedSelfInclusive = this.node.pickable === true || this.node._inputListeners.length > 0;
        var expectedSubtreePrunable = this.node.pickable === false ||
                                      !this.node.isVisible() ||
                                      ( this.node.pickable !== true && this.subtreePickableCount === 0 );
        var expectedSubtreePickableCount = this.node._inputListeners.length +
                                           ( this.node._pickable === true ? 1 : 0 ) +
                                           _.filter( this.node._children, function( child ) {
                                             return !child._picker.selfPruned && child._picker.subtreePickableCount > 0;
                                           } ).length;
        assertSlow( this.selfPruned === expectedSelfPruned, 'selfPruned mismatch' );
        assertSlow( this.selfInclusive === expectedSelfInclusive, 'selfInclusive mismatch' );
        assertSlow( this.subtreePrunable === expectedSubtreePrunable, 'subtreePrunable mismatch' );
        assertSlow( this.subtreePickableCount === expectedSubtreePickableCount, 'subtreePickableCount mismatch' );
        _.each( this.node._parents, function( parent ) {
          var parentPicker = parent._picker;
          var childPicker = self;
          if ( !parentPicker.mouseInclusiveDirty ) {
            assertSlow( childPicker.selfPruned || !childPicker.mouseInclusiveDirty );
          }
          if ( !parentPicker.mouseExclusiveDirty ) {
            if ( childPicker.selfInclusive ) {
              assertSlow( childPicker.selfPruned || !childPicker.mouseInclusiveDirty );
            }
            else {
              assertSlow( childPicker.selfPruned || childPicker.subtreePrunable || !childPicker.mouseExclusiveDirty );
            }
          }
          if ( !parentPicker.touchInclusiveDirty ) {
            assertSlow( childPicker.selfPruned || !childPicker.touchInclusiveDirty );
          }
          if ( !parentPicker.touchExclusiveDirty ) {
            if ( childPicker.selfInclusive ) {
              assertSlow( childPicker.selfPruned || !childPicker.touchInclusiveDirty );
            }
            else {
              assertSlow( childPicker.selfPruned || childPicker.subtreePrunable || !childPicker.touchExclusiveDirty );
            }
          }
        } );
      }
    }
  } );
  return Picker;
} );
define( 'SCENERY/accessibility/AccessibilityUtil',['require','SCENERY/scenery'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var NEXT = 'NEXT';
  var PREVIOUS = 'PREVIOUS';
  var BOLD_TAG = 'B';
  var STRONG_TAG = 'STRONG';
  var I_TAG = 'I';
  var EM_TAG = 'EM';
  var MARK_TAG = 'MARK';
  var SMALL_TAG = 'SMALL';
  var DEL_TAG = 'DEL';
  var INS_TAG = 'INS';
  var SUB_TAG = 'SUB';
  var SUP_TAG = 'SUP';
  var FORMATTING_TAGS = [ BOLD_TAG, STRONG_TAG, I_TAG, EM_TAG, MARK_TAG, SMALL_TAG, DEL_TAG, INS_TAG, SUB_TAG, SUP_TAG ];
  function getLinearDOMElements( domElement ) {
    var children = domElement.getElementsByTagName( '*' );
    var linearDOM = [];
    for ( var i = 0; i < children.length; i++ ) {
      if ( children[ i ].nodeType === Node.ELEMENT_NODE ) {
        linearDOM[ i ] = ( children[ i ] );
      }
    }
    return linearDOM;
  }
  function isElementHidden( domElement ) {
    if ( domElement.hidden ) {
      return true;
    }
    else if ( domElement === document.body ) {
      return false;
    }
    else {
      return isElementHidden( domElement.parentElement );
    }
  }
  function getNextPreviousFocusable( direction, parentElement ) {
    var parent = parentElement || document.body;
    var linearDOM = getLinearDOMElements( parent );
    var activeElement = document.activeElement;
    var activeIndex = linearDOM.indexOf( activeElement );
    var delta = direction === NEXT ? +1 : -1;
    var nextIndex = activeIndex + delta;
    var nextFocusable;
    while ( !nextFocusable && nextIndex < linearDOM.length && nextIndex >= 0 ) {
      var nextElement = linearDOM[ nextIndex ];
      nextIndex += delta;
      if ( isElementHidden( nextElement ) ) {
        continue;
      }
      if ( _.includes( FORMATTING_TAGS, nextElement.tagName ) ) {
        continue;
      }
      if ( nextElement.tabIndex > -1 ) {
        nextFocusable = nextElement;
        break;
      }
    }
    return nextFocusable || activeElement;
  }
  var AccessibilityUtil = {
    getNextFocusable: function( parentElement ) {
      return getNextPreviousFocusable( NEXT, parentElement );
    },
    getPreviousFocusable: function( parentElement ) {
      return getNextPreviousFocusable( PREVIOUS, parentElement );
    },
    usesFormattingTagsExclusive: function( textContent ) {
      if ( textContent.indexOf( '<' ) < 0 ) {
        return false;
      }
      var i = 0;
      var openIndices = [];
      var closeIndices = [];
      while ( i < textContent.length ) {
        var openIndex = textContent.indexOf( '<', i );
        var closeIndex = textContent.indexOf( '>', i );
        if ( openIndex > -1 ) {
          openIndices.push( openIndex );
          i = openIndex + 1;
        }
        if ( closeIndex > -1 ) {
          closeIndices.push( closeIndex );
          i = closeIndex + 1;
        }
        else {
          i++;
        }
      }
      if ( openIndices.length !== closeIndices.length ) {
        return false;
      }
      var onlyFormatting = true;
      var upperCaseContent = textContent.toUpperCase();
      for ( var j = 0; j < openIndices.length; j++ ) {
        var subString = upperCaseContent.substring( openIndices[ j ] + 1, closeIndices[ j ] );
        subString = subString.replace( '/', '' );
        if ( !_.includes( FORMATTING_TAGS, subString ) ) {
          onlyFormatting = false;
        }
      }
      return onlyFormatting;
    }
  };
  scenery.register( 'AccessibilityUtil', AccessibilityUtil );
  return AccessibilityUtil;
} );
define( 'SCENERY/accessibility/AccessiblePeer',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var globalId = 1;
  function AccessiblePeer( accessibleInstance, domElement, options ) {
    this.initializeAccessiblePeer( accessibleInstance, domElement, options );
  }
  scenery.register( 'AccessiblePeer', AccessiblePeer );
  inherit( Events, AccessiblePeer, {
    initializeAccessiblePeer: function( accessibleInstance, domElement, options ) {
      var self = this;
      options = _.extend( {
        parentContainerElement: null, // a parent container for this peer and potential siblings
        childContainerElement: null, // an child container element where nested elements can be placed
        labelElement: null, // the element containing this node's label content 
        descriptionElement: null // the element that will contain this node's description content
      }, options );
      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?
      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );
      this.id = this.id || globalId++;
      this.accessibleInstance = accessibleInstance;
      this.display = accessibleInstance.display;
      this.trail = accessibleInstance.trail;
      this.domElement = domElement;
      this.labelElement = options.labelElement;
      this.descriptionElement = options.descriptionElement;
      this.childContainerElement = options.childContainerElement ? options.childContainerElement : ( this.childContainerElement || null );
      this.parentContainerElement = options.parentContainerElement ? options.parentContainerElement : ( this.parentContainerElement || null );
      if ( this.parentContainerElement ) {
        var peerDOMElement = this.domElement;
        var firstChild = this.parentContainerElement.children[ 0 ];
        this.parentContainerElement.insertBefore( peerDOMElement, firstChild );
      }
      this.disposed = false;
      var focusEventListener = function( event ) {
        if ( event.target === self.domElement ) {
          scenery.Display.focus = {
            display: accessibleInstance.display,
            trail: accessibleInstance.trail
          };
        }
      };
      this.domElement.addEventListener( 'focus', focusEventListener );
      var blurEventListener = function( event ) {
        if ( event.target === self.domElement ) {
          scenery.Display.focus = null;
        }
      };
      this.domElement.addEventListener( 'blur', blurEventListener );
      this.disposeAccessiblePeer = function() {
        if ( scenery.Display.focus &&
            scenery.Display.focus.trail &&
              scenery.Display.focus.trail.equals( self.trail ) ) {
            scenery.Display.focus = null;
        }
        self.domElement.removeEventListener( 'blur', blurEventListener );
        self.domElement.removeEventListener( 'focus', focusEventListener );
      };
      return this;
    },
    hasParentContainer: function() {
      return !!this.parentContainerElement;
    },
    getParentContainerElement: function() {
      return this.parentContainerElement || this.domElement;
    },
    getChildContainerElement: function() {
      return this.childContainerElement || this.domElement;
    },
    getElementByAssociation: function( association ) {
      var htmlElement = null;
      if ( association === AccessiblePeer.NODE ) {
        return this.domElement;
      }
      else if ( association === AccessiblePeer.LABEL ) {
        return this.labelElement;
      }
      else if ( association === AccessiblePeer.DESCRIPTION ) {
        return this.descriptionElement;
      }
      else if ( association === AccessiblePeer.LABEL ) {
        return this.parentContainerElement;
      }
      assert && assert( htmlElement, 'no HTMLELement found by association ' + association );
      return htmlElement;
    },
    dispose: function() {
      this.disposed = true;
      this.disposeAccessiblePeer();
      this.freeToPool && this.freeToPool();
    }
  }, {
    NODE: 'NODE', // associate with all accessible content related to this peer
    LABEL: 'LABEL', // associate with just the label content of this peer
    DESCRIPTION: 'DESCRIPTION', // associate with just the description content of this peer
    PARENT_CONTAINER: 'PARENT_CONTAINER' // associate with everything under the parent container element of this peer
  } );
  AccessiblePeer.Poolable = {
    mixin: function( selfDrawableType ) {
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( accessibleInstance ) {
            if ( pool.length ) {
              return pool.pop().initialize( accessibleInstance );
            }
            else {
              return new selfDrawableType( accessibleInstance );
            }
          };
        }
      } );
    }
  };
  return AccessiblePeer;
} );
define( 'SCENERY/accessibility/Accessibility',['require','SCENERY/scenery','PHET_CORE/extend','SCENERY/accessibility/AccessibilityUtil','SCENERY/accessibility/AccessiblePeer'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var extend = require( 'PHET_CORE/extend' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var AccessiblePeer = require( 'SCENERY/accessibility/AccessiblePeer' );
  var INPUT_TAG = 'INPUT';
  var LABEL_TAG = 'LABEL';
  var BUTTON_TAG = 'BUTTON';
  var TEXTAREA_TAG = 'TEXTAREA';
  var SELECT_TAG = 'SELECT';
  var OPTGROUP_TAG = 'OPTGROUP';
  var DATALIST_TAG = 'DATALIST';
  var OUTPUT_TAG = 'OUTPUT';
  var A_TAG = 'A';
  var FORM_ELEMENTS = [ INPUT_TAG, BUTTON_TAG, TEXTAREA_TAG, SELECT_TAG, OPTGROUP_TAG, DATALIST_TAG, OUTPUT_TAG, A_TAG ];
  var ELEMENTS_WITHOUT_CLOSING_TAG = [ INPUT_TAG ];
  var ELEMENTS_REQUIRE_WIDTH = [ INPUT_TAG, A_TAG ];
  var INPUT_CHANGE_EVENTS = [ 'input', 'change' ];
  var DOM_EVENTS = [ 'input', 'change', 'click', 'keydown', 'keyup', 'focus', 'blur' ];
  var ACCESSIBILITY_OPTION_KEYS = [
    'tagName', // Sets the tag name for the DOM element representing this node in the parallel DOM
    'inputType', // Sets the input type for the representative DOM element, only relevant if tagname is 'input'
    'inputValue', // Sets the input value for the representative DOM element, only relevant if tagname is 'input'
    'accessibleChecked', // Sets the 'checked' state for inputs of type radio and checkbox, see setAccessibleChecked()
    'parentContainerTagName', // Sets the tag name for an element that contains this node's DOM element and its peers
    'labelTagName', // Sets the tag name for the DOM element labelling this node, usually a paragraph
    'descriptionTagName', // Sets the tag name for the DOM element describing this node, usually a paragraph
    'focusHighlight', // Sets the focus highlight for the node, see setFocusHighlight()
    'focusHighlightLayerable', // Flag to determine if the focus highlight node can be layered in the scene graph, see setFocusHighlightLayerable()
    'accessibleLabel', // Set the label content for the node, see setAccessibleLabel()
    'accessibleDescription', // Set the description content for the node, see setAccessibleDescription()
    'accessibleHidden', // Sets wheter or not the node's DOM element is hidden in the parallel DOM
    'accessibleContentDisplayed', // sets whether or not the accessible content of the node (and its subtree) is displayed, see setAccessibleContentDisplayed()
    'focusable', // Sets whether or not the node can receive keyboard focus
    'useAriaLabel', // Sets whether or not the label will use the 'aria-label' attribute, see setUseAriaLabel()
    'ariaRole', // Sets the ARIA role for the DOM element, see setAriaRole() for documentation
    'parentContainerAriaRole', // Sets the ARIA role for the parent container DOM element, see setParentContainerAriaRole()
    'ariaDescribedByElement', // Sets a description relationship for this node's DOM element by id, see setAriaDescribedByElement()
    'ariaLabelledByElement', // Sets a label relationship with another element in the DOM by id, see setAriaLabelledByElement()
    'prependLabels'// Sets whether we want to prepend labels above the node's HTML element, see setPrependLabels()
  ];
  var Accessibility = {
    mixin: function( type ) {
      var proto = type.prototype;
      extend( proto, {
        _mutatorKeys: ACCESSIBILITY_OPTION_KEYS.concat( proto._mutatorKeys ),
        initializeAccessibility: function() {
          this._tagName = null;
          this._parentContainerTagName = null;
          this._labelTagName = null;
          this._descriptionTagName = null;
          this._inputType = null;
          this._inputValue = null;
          this._accessibleChecked = false;
          this._prependLabels = null;
          this._accessibleAttributes = [];
          this._accessibleLabel = null;
          this._accessibleDescription = null;
          this._useAriaLabel = null;
          this._ariaRole = null;
          this._parentContainerAriaRole = null;
          this._ariaDescribesNode = null;
          this._ariaDescribesAssociation = AccessiblePeer.NODE;
          this._ariaLabelsNode = null;
          this._ariaLabelsAssociation = AccessiblePeer.NODE;
          this._focusable = null;
          this._focusHighlight = null;
          this._focusHighlightLayerable = false;
          this._accessibleHidden = null;
          this._accessibleContentDisplayed = true;
          this._accessibleInputListeners = [];
        },
        addAccessibleInputListener: function( accessibleInput ) {
          var self = this;
          var addedAccessibleInput = accessibleInput;
          for ( var ev in accessibleInput ) {
            if ( accessibleInput.hasOwnProperty( ev ) ) {
              addedAccessibleInput[ ev ] = accessibleInput[ ev ];
              if ( _.includes( INPUT_CHANGE_EVENTS, ev ) ) {
                var listenerFunction = accessibleInput[ ev ];
                addedAccessibleInput[ ev ] = function( event ) {
                    self._inputValue = event.target.value;
                    listenerFunction( event );
                };
              }
            }
          }
          var listenerAlreadyAdded = ( _.indexOf( this._accessibleInputListeners, addedAccessibleInput ) > 0 );
          assert && assert( !listenerAlreadyAdded, 'accessibleInput listener already added' );
          this._accessibleInputListeners.push( addedAccessibleInput );
          this.updateAccessiblePeers( function( accessiblePeer ) {
            self.addDOMEventListeners( addedAccessibleInput, accessiblePeer.domElement );
          } );
          return addedAccessibleInput;
        },
        removeAccessibleInputListener: function( accessibleInput ) {
          var addedIndex = _.indexOf( this._accessibleInputListeners, accessibleInput );
          assert && assert( addedIndex > -1, 'accessibleInput listener was not added' );
          this._accessibleInputListeners.splice( addedIndex, 1 );
          var self = this;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            self.removeDOMEventListeners( accessibleInput, accessiblePeer.domElement );
          } );
          return this;
        },
        getAccessibleInputListeners: function() {
          return this._accessibleInputListeners.slice( 0 ); // defensive copy
        },
        get accessibleInputListeners() { return this.getAccessibleInputListeners(); },
        setTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );
          this._tagName = tagName;
          this.invalidateAccessibleContent();
        },
        set tagName( tagName ) { this.setTagName( tagName ); },
        getTagName: function() {
          return this._tagName;
        },
        get tagName() { return this.getTagName(); },
        setLabelTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );
          this._labelTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set labelTagName( tagName ) { this.setLabelTagName( tagName ); },
        getLabelTagName: function() {
          return this._labelTagName;
        },
        get labelTagName() { return this.getLabelTagName(); },
        setDescriptionTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );
          this._descriptionTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set descriptionTagName( tagName ) { this.setDescriptionTagName( tagName ); },
        getDescriptionTagName: function() {
          return this._descriptionTagName;
        },
        get descriptionTagName() { return this.getDescriptionTagName(); },
        setInputType: function( inputType ) {
          assert && assert( this._tagName.toUpperCase() === INPUT_TAG, 'tag name must be INPUT to support inputType' );
          this._inputType = inputType;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.type = inputType;
          } );
        },
        set inputType( inputType ) { this.setInputType( inputType ); },
        getInputType: function() {
          return this._inputType;
        },
        get inputType() { return this.getInputType(); },
        setPrependLabels: function( prependLabels ) {
          this._prependLabels = prependLabels;
          if ( !this._parentContainerTagName ) {
            this.setParentContainerTagName( 'div' );
          }
          this.invalidateAccessibleContent();
        },
        set prependLabels( prependLabels ) { this.setPrependLabels( prependLabels ); },
        getPrependLabels: function() {
          return this._prependLabels;
        },
        get prependLabels() { return this.getPrependLabels(); },
        setParentContainerTagName: function( tagName ) {
          assert && assert( tagName === null || typeof tagName === 'string' );
          this._parentContainerTagName = tagName;
          this.invalidateAccessibleContent();
        },
        set parentContainerTagName( tagName ) { this.setParentContainerTagName( tagName ); },
        getParentContainerTagName: function() {
          return this._parentContainerTagName;
        },
        get parentContainerTagName() { return this.getParentContainerTagName(); },
        setAccessibleLabel: function( label ) {
          this._accessibleLabel = label;
          if ( this._useAriaLabel ) {
            this.setAccessibleAttribute( 'aria-label', this._accessibleLabel );
          }
          else if ( this._labelTagName ) {
            var self = this;
            this.updateAccessiblePeers( function( accessiblePeer ) {
              if ( accessiblePeer.labelElement ) {
                setTextContent( accessiblePeer.labelElement, self._accessibleLabel );
                if ( self._labelTagName.toUpperCase() === LABEL_TAG ) {
                  accessiblePeer.labelElement.setAttribute( 'for', accessiblePeer.domElement.id );
                }
              }
            } );
          }
          else {
            this.updateAccessiblePeers( function( accessiblePeer ) {
              if ( elementSupportsInnerHTML( accessiblePeer.domElement ) ) {
                setTextContent( accessiblePeer.domElement, label );
              }
            } );
          }
        },
        set accessibleLabel( label ) { this.setAccessibleLabel( label ); },
        getAccessibleLabel: function() {
          return this._accessibleLabel;
        },
        get accessibleLabel() { return this.getAccessibleLabel(); },
        setAccessibleDescription: function( textContent ) {
          this._accessibleDescription = textContent;
          if ( !this._descriptionTagName ) {
            this.setDescriptionTagName( 'p' );
          }
          this.updateAccessiblePeers( function( accessiblePeer ) {
            setTextContent( accessiblePeer.descriptionElement, textContent );
          } );
        },
        set accessibleDescription( textContent ) { this.setAccessibleDescription( textContent ); },
        getAccessibleDescription: function() {
          return this._accessibleDescription;
        },
        get accessibleDescription() { return this.getAccessibleDescription(); },
        setAriaRole: function( ariaRole ) {
          this._ariaRole = ariaRole;
          this.setAccessibleAttribute( 'role', ariaRole );
          this.invalidateAccessibleContent();
        },
        set ariaRole( ariaRole ) { this.setAriaRole( ariaRole ); },
        getAriaRole: function() {
          return this._ariaRole;
        },
        get ariaRole() { return this.getAriaRole(); },
        setParentContainerAriaRole: function( ariaRole ) {
          this._parentContainerAriaRole = ariaRole;
          this.invalidateAccessibleContent();
        },
        set parentContainerAriaRole( ariaRole ) { this.setParentContainerAriaRole( ariaRole ); },
        getParentContainerAriaRole: function() {
          return this._parentContainerAriaRole;
        },
        get parentcontainerAriaRole() { return this.getParentContainerAriaRole(); },
        setUseAriaLabel: function( useAriaLabel ) {
          this._useAriaLabel = useAriaLabel;
          var self = this;
          if ( useAriaLabel && this._labelTagName ) {
            self.setLabelTagName( null );
          }
          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.labelElement ) {
              self.setLabelTagName( null );
              accessiblePeer.labelElement.parentNode && accessiblePeer.labelElement.parentNode.removeChild( accessiblePeer.labelElement );
            }
          } );
          if ( this._accessibleLabel ) {
            this.setAccessibleLabel( this._accessibleLabel );
          }
        },
        set useAriaLabel( useAriaLabel ) { this.setUseAriaLabel( useAriaLabel ); },
        getUseAriaLabel: function() {
          return this._useAriaLabel;
        },
        get useAriaLabel() { return this.getUseAriaLabel(); },
        setFocusHighlight: function( focusHighlight ) {
          this._focusHighlight = focusHighlight;
          var isFocussed = false;
          if ( this.isFocussed() ) {
            isFocussed = true;
          }
          this.invalidateAccessibleContent();
          isFocussed && this.focus();
        },
        set focusHighlight( focusHighlight ) { this.setFocusHighlight( focusHighlight ); },
        getFocusHighlight: function() {
          return this._focusHighlight;
        },
        get focusHighlight() { return this.getFocusHighlight(); },
        setFocusHighlightLayerable: function( focusHighlightLayerable ) {
          this._focusHighlightLayerable = focusHighlightLayerable;
          this.invalidateAccessibleContent();
        },
        set focusHighlightLayerable( focusHighlightLayerable ) { this.setFocusHighlightLayerable( focusHighlightLayerable ); },
        getFocusHighlightLayerable: function() {
          return this._focusHighlightLayerable;
        },
        get focusHighlightLayerable() { return this.getFocusHighlightLayerable(); },
        setAriaDescribesNode: function( node, association ) {
          assert && assert( this.accessibleInstances.length < 2, 'Cannot describe another node if using DAG' );
          this._ariaDescribesNode = node;
          this._ariaDescribesAssociation = association || AccessiblePeer.NODE;
          if ( this.accessibleInstances.length > 0 ) {
            var peer = this.accessibleInstances[ 0 ].peer;
            var associatedElement = peer.getElementByAssociation( this._ariaDescribesAssociation );
            node.setAccessibleAttribute( 'aria-describedby', associatedElement.id );
          }
        },
        setAriaLabelsNode: function( node, association ) {
          assert && assert( this.accessibleInstances.length < 2, 'Cannot describe another node if using DAG' );
          this._ariaLabelsNode = node;
          this._ariaLabelsAssociation = association || AccessiblePeer.NODE;
          if ( this.accessibleInstances.length > 0 ) {
            var peer = this.accessibleInstances[ 0 ].peer;
            var associatedElement = peer.getElementByAssociation( this._ariaLabelsAssociation );
            node.setAccessibleAttribute( 'aria-labelledby', associatedElement.id );
          }
        },
        setAccessibleHidden: function( hidden ) {
          this._accessibleHidden = hidden;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.parentContainerElement ) {
              accessiblePeer.parentContainerElement.hidden = hidden;
            }
            else if ( accessiblePeer.domElement ) {
              accessiblePeer.domElement.hidden = hidden;
            }
          } );
        },
        set accessibleHidden( hidden ) { this.setAccessibleHidden( hidden ); },
        getAccessibleHidden: function() {
          return this._accessibleHidden;
        },
        get accessibleHidden() { return this.getAccessibleHidden(); },
        setAccessibleContentDisplayed: function( contentDisplayed ) {
          this._accessibleContentDisplayed = contentDisplayed;
          for ( var j = 0; j < this._children.length; j++ ) {
            var child = this._children[ j ];
            child.setAccessibleContentDisplayed( contentDisplayed );
          }
          this.invalidateAccessibleContent();
        },
        set accessibleContentDisplayed( contentDisplayed ) { this.setAccessibleContentDisplayed( contentDisplayed ); },
        getAccessibleContentDisplayed: function() {
          return this._accessibleContentDisplayed;
        },
        get accessibleContentDisplayed() { return this.getAccessibleContentDisplayed(); },
        setInputValue: function( value ) {
          assert && assert( _.includes( FORM_ELEMENTS, this._tagName.toUpperCase() ), 'dom element must be a form element to support value' );
          value = value.toString();
          this._inputValue = value;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.value = value;
          } );
        },
        set inputValue( value ) { this.setInputValue( value ); },
        getInputValue: function() {
          return this._inputValue;
        },
        get inputValue() { return this.getInputValue(); },
        setAccessibleChecked: function( checked ) {
          this._accessibleChecked = checked;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.checked = checked;
          } );
        },
        set accessibleChecked( checked ) { this.setAccessibleChecked( checked ); },
        getAccessibleChecked: function() {
          return this._accessibleChecked;
        },
        get accessibleChecked() { return this.getAccessibleChecked(); },
        getAccessibleAttributes: function() {
          return this._accessibleAttributes.slice( 0 ); // defensive copy
        },
        get accessibleAttributes() { return this.getAccessibleAttributes(); },
        setAccessibleAttribute: function( attribute, value ) {
          for ( var i = 0; i < this._accessibleAttributes.length; i++ ) {
            if ( this._accessibleAttributes[ i ].attribute === attribute ) {
              this._accessibleAttributes.splice( i, 1 );
            }
          }
          this._accessibleAttributes.push( { attribute: attribute, value: value } );
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.setAttribute( attribute, value );
          } );
        },
        removeAccessibleAttribute: function( attribute ) {
          var attributeRemoved = false;
          for ( var i = 0; i < this._accessibleAttributes.length; i++ ) {
            if ( this._accessibleAttributes[ i ].attribute === attribute ) {
              this._accessibleAttributes.splice( i, 1 );
              attributeRemoved = true;
            }
          }
          assert && assert( attributeRemoved, 'Node does not have accessible attribute ' + attribute );
          this.updateAccessiblePeers( function( accessiblePeer ) {
            accessiblePeer.domElement.removeAttribute( attribute );
          } );
        },
        removeAccessibleAttributes: function() {
          var attributes = this.getAccessibleAttributes();
          for ( var i = 0; i < attributes.length; i++ ) {
            var attribute = attributes[ i ].attribute;
            this.removeAccessibleAttribute( attribute );
          }
        },
        setFocusable: function( isFocusable ) {
          this._focusable = isFocusable;
          this.updateAccessiblePeers( function( accessiblePeer ) {
            if ( accessiblePeer.domElement ) {
              accessiblePeer.domElement.tabIndex = isFocusable ? 0 : -1;
            }
          } );
        },
        set focusable( isFocusable ) { this.setFocusable( isFocusable ); },
        getFocusable: function() {
          return this._focusable;
        },
        get focusable() { return this.getFocusable(); },
        isFocussed: function() {
          var isFocused = false;
          if ( this.accessibleInstances.length > 0 ) {
            isFocused = document.activeElement === this.accessibleInstances[ 0 ].peer.domElement;
          }
          return isFocused;
        },
        get focussed() { return this.isFocussed(); },
        focus: function() {
          if ( this.accessibleInstances.length > 0 ) {
            assert && assert( this._focusable, 'trying to set focus on a node that is not focusable' );
            assert && assert( !this._accessibleHidden, 'trying to set focus on a node with hidden accessible content' );
            assert && assert( this.accessibleInstances.length === 1, 'focus() unsuported for Nodes using DAG, accessible conotent is not unique' );
            this.accessibleInstances[ 0 ].peer.domElement.focus();
          }
        },
        blur: function() {
          if ( this.accessibleInstances.length > 0 ) {
            this.accessibleInstances[ 0 ].peer.domElement.blur();
          }
        },
        addDOMEventListeners: function( accessibleInput, domElement ) {
          for ( var event in accessibleInput ) {
            if ( accessibleInput.hasOwnProperty( event ) && _.includes( DOM_EVENTS, event ) ) {
              domElement.addEventListener( event, accessibleInput[ event ] );
            }
          }
        },
        removeDOMEventListeners: function( accessibleInput, domElement ) {
          for ( var event in accessibleInput ) {
            if ( accessibleInput.hasOwnProperty( event ) && _.includes( DOM_EVENTS, event ) ) {
              domElement.removeEventListener( event, accessibleInput[ event ] );
            }
          }
        },
        updateAccessiblePeers: function( callback ) {
          for ( var i = 0; i < this.accessibleInstances.length; i++ ) {
            this.accessibleInstances[ i ].peer && callback( this.accessibleInstances[ i ].peer );
          }
        }
      } );
      function setTextContent( domElement, textContent ) {
        if ( textContent && AccessibilityUtil.usesFormattingTagsExclusive( textContent ) ) {
          domElement.innerHTML = textContent;
        }
        else {
          domElement.textContent = textContent;
        }
      }
      function elementSupportsInnerHTML( domElement ) {
        return !_.includes( ELEMENTS_WITHOUT_CLOSING_TAG, domElement.tagName );
      }
      function createElement( tagName, focusable ) {
        var domElement = document.createElement( tagName );
        var upperCaseTagName = tagName.toUpperCase();
        if ( !_.includes( FORM_ELEMENTS, upperCaseTagName ) && !focusable ) {
          domElement.tabIndex = -1;
        }
        if ( _.includes( ELEMENTS_REQUIRE_WIDTH, upperCaseTagName ) ) {
          domElement.style.width = '1px';
        }
        return domElement;
      }
      function insertContentElement( accessiblePeer, contentElement, prependLabels ) {
        if ( accessiblePeer.parentContainerElement ) {
          if ( prependLabels && accessiblePeer.parentContainerElement === accessiblePeer.domElement.parentNode ) {
            accessiblePeer.parentContainerElement.insertBefore( contentElement, accessiblePeer.domElement );
          }
          else {
            accessiblePeer.parentContainerElement.appendChild( contentElement );
          }
        }
        else if ( accessiblePeer.domElement ) {
          accessiblePeer.domElement.appendChild( contentElement );
        }
      }
      function invalidateAccessibleContent() {
        var self = this;
        var i = 0;
        this.updateAccessiblePeers( function( accessiblePeer ) {
          var parentContainerElement = accessiblePeer.parentContainerElement;
          while ( parentContainerElement && parentContainerElement.hasChildNodes() ) {
            parentContainerElement.removeChild( parentContainerElement.lastChild );
          }
        } );
        var contentDisplayed = this._accessibleContentDisplayed;
        for ( i = 0; i < this._parents.length; i++ ) {
          if ( !this._parents[ i ].accessibleContentDisplayed ) {
            contentDisplayed = false;
          }
        }
        var accessibleContent = null;
        if ( contentDisplayed && this._tagName ) {
          accessibleContent = {
            focusHighlight: this._focusHighlight,
            focusHighlightLayerable: this._focusHighlightLayerable,
            createPeer: function( accessibleInstance ) {
              var uniqueId = accessibleInstance.trail.getUniqueId();
              var domElement = createElement( self._tagName, self._focusable );
              domElement.id = uniqueId;
              var parentContainerElement = null;
              if ( self._parentContainerTagName ) {
                parentContainerElement = createElement( self._parentContainerTagName, false );
                parentContainerElement.id = 'container-' + uniqueId;
                if ( self._parentContainerAriaRole ) {
                  parentContainerElement.setAttribute( 'role', self._parentContainerAriaRole );
                }
              }
              var labelElement = null;
              if ( self._labelTagName ) {
                labelElement = createElement( self._labelTagName, false );
                labelElement.id = 'label-' + uniqueId;
                if ( self._labelTagName.toUpperCase() === LABEL_TAG ) {
                  labelElement.setAttribute( 'for', uniqueId );
                }
              }
              var descriptionElement = null;
              if ( self._descriptionTagName ) {
                descriptionElement = createElement( self._descriptionTagName, false );
                descriptionElement.id = 'description-' + uniqueId;
              }
              var accessiblePeer = new AccessiblePeer( accessibleInstance, domElement, {
                parentContainerElement: parentContainerElement,
                labelElement: labelElement,
                descriptionElement: descriptionElement
              } );
              accessibleInstance.peer = accessiblePeer;
              if ( self._focusable === null ) {
                self._focusable = _.includes( FORM_ELEMENTS, self._tagName.toUpperCase() );
              }
              self.setFocusable( self._focusable );
              self._accessibleLabel && self.setAccessibleLabel( self._accessibleLabel );
              if ( self._useAriaLabel ) {
                self.setUseAriaLabel( self._useAriaLabel );
              }
              self.setAccessibleHidden( self._accessibleHidden );
              self.setAccessibleChecked( self._accessibleChecked );
              self._inputValue && self.setInputValue( self._inputValue );
              var defensiveAttributes = self.accessibleAttributes;
              for ( i = 0; i < defensiveAttributes.length; i++ ) {
                var attribute = defensiveAttributes[ i ].attribute;
                var value = defensiveAttributes[ i ].value;
                self.setAccessibleAttribute( attribute, value );
              }
              self._accessibleDescription && self.setAccessibleDescription( self._accessibleDescription );
              if ( self._tagName.toUpperCase() === INPUT_TAG && self._inputType ) {
                self.setInputType( self._inputType );
              }
              self._ariaLabelsNode && self.setAriaLabelsNode( self._ariaLabelsNode, self._ariaLabelsAssociation );
              self._ariaDescribesNode && self.setAriaDescribesNode( self._ariaDescribesNode, self._ariaDescribesAssociation );
              for ( i = 0; i < self._accessibleInputListeners.length; i++ ) {
                self.addDOMEventListeners( self._accessibleInputListeners[ i ], domElement );
              }
              labelElement && insertContentElement( accessiblePeer, labelElement, self._prependLabels );
              descriptionElement && insertContentElement( accessiblePeer, descriptionElement, self._prependLabels );
              if ( self._focusHighlightLayerable ) {
                self._focusHighlight.visible = false;
              }
              return accessiblePeer;
            }
          };
        }
        this.accessibleContent = accessibleContent;
      }
      if ( proto.invalidateAccessibleContent ) {
        var subtypeInvalidateAccesssibleContent = proto.invalidateAccessibleContent;
        proto.invalidateAccessibleContent = function() {
          subtypeInvalidateAccesssibleContent.call( this );
          invalidateAccessibleContent.call( this );
        };
      }
      else {
        proto.invalidateAccessibleContent = invalidateAccessibleContent;
      }
    }
  };
  scenery.register( 'Accessibility', Accessibility );
  return Accessibility;
} );
define( 'AXON/Multilink',['require','AXON/axon','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  function Multilink( dependencies, callback, lazy ) {
    this.dependencies = dependencies; // @private
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );
    var self = this;
    this.dependencyListeners = [];
    dependencies.forEach( function( dependency, i ) {
      var listener = function( value ) {
        self.dependencyValues[ i ] = value;
        callback.apply( null, self.dependencyValues );
      };
      self.dependencyListeners.push( listener );
      dependency.lazyLink( listener );
    } );
    if ( !lazy ) {
      callback.apply( null, this.dependencyValues );
    }
  }
  axon.register( 'Multilink', Multilink );
  return inherit( Object, Multilink, {
    dispose: function() {
      assert && assert( this.dependencies, 'A Multilink cannot be disposed twice.' );
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        this.dependencies[ i ].unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    }
  } );
} );
define( 'TANDEM/tandemNamespace',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'tandem' );
} );
define( 'PHET_CORE/toCamelCase',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function toCamelCase( str ) {
    return str.toLowerCase().replace( /-(.)/g, function( match, group1 ) {
      return group1.toUpperCase();
    } );
  }
  phetCore.register( 'toCamelCase', toCamelCase );
  return toCamelCase;
} );
define('text!REPOSITORY/package.json',[],function () { return '{\n  "name": "build-an-atom",\n  "version": "1.6.34",\n  "license": "GPL-3.0",\n  "repository": {\n    "type": "git",\n    "url": "https://github.com/phetsims/build-an-atom.git"\n  },\n  "devDependencies": {\n    "grunt": "~1.0.0"\n  },\n  "phet": {\n    "requirejsNamespace": "BUILD_AN_ATOM",\n    "phetLibs": [\n      "shred",\n      "vegas",\n      "vibe"\n    ],\n    "screenNameKeys": [\n      "BUILD_AN_ATOM/atom",\n      "BUILD_AN_ATOM/symbol",\n      "BUILD_AN_ATOM/game"\n    ]\n  }\n}';});
define( 'TANDEM/Tandem',['require','PHET_CORE/inherit','TANDEM/tandemNamespace','PHET_CORE/toCamelCase','text!REPOSITORY/package.json'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var toCamelCase = require( 'PHET_CORE/toCamelCase' );
  var packageString = require( 'text!REPOSITORY/package.json' );
  var packageJSON = JSON.parse( packageString );
  var launched = false;
  var requiredTandemIndex = 0;
  var optionalTandemIndex = 0;
  var uninstrumentedCodeIndex = 0;
  function Tandem( id, options ) {
    this.options = _.extend( {
      static: false,
      enabled: true,
      supplied: true, // if the tandem is not supplied and required, an error will be thrown.
      required: true // require === false means it is an optional tandem
    }, options );
    this.id = ( id !== undefined ) ? id : '';
    this.required = this.options.required;
    this.supplied = this.options.supplied;
    this.static = this.options.static;
    this.enabled = this.options.enabled;
  }
  var staticInstances = [];
  tandemNamespace.register( 'Tandem', Tandem );
  var instanceListeners = [];
  inherit( Object, Tandem, {
    isTandem: true,
    addInstance: function( instance, type ) {
      if ( window.phet && phet.phetio && this.enabled ) {
        if ( phet.phetio.queryParameters.phetioValidateTandems ) {
          assert && assert( !(this.required && !this.supplied), 'Tandem was required but not supplied' );
        }
        if ( phet.phetio.queryParameters.printMissingTandems && (this.required && !this.supplied) ) {
          var stackTrace = new Error().stack;
          console.log( 'Required Tandem not supplied.\n' +
                       'this.id = ' + this.id + '\n' +
                       'Stack trace: ' + stackTrace );
        }
        assert && assert( type && type.typeName, 'type must be specified and have a typeName for ' + this.id );
        if ( !this.required && !this.supplied ) {
          if ( phet.phetio.queryParameters.printMissingTandems ) {
            var stackTrace2 = new Error().stack;
            if ( stackTrace2.indexOf( 'PhetFont' ) === -1 ) {
              console.log( 'Optional Tandem not supplied.\n' +
                           'this.id = ' + this.id + '\n' +
                           'Stack trace: ' + stackTrace2 );
            }
          }
          return;
        }
        if ( this.static && !launched ) {
          staticInstances.push( { tandem: this, instance: instance, type: type } );
        }
        else {
          for ( var i = 0; i < instanceListeners.length; i++ ) {
            instanceListeners[ i ].addInstance( this.id, instance, type );
          }
        }
      }
    },
    removeInstance: function( instance ) {
      if ( window.phet && phet.phetio && this.enabled ) {
        for ( var i = 0; i < instanceListeners.length; i++ ) {
          instanceListeners[ i ].removeInstance( this.id, instance );
        }
      }
    },
    createTandem: function( id, options ) {
      assert && assert( typeof id === 'string' && id.length > 0, 'id must be defined' );
      var string = ( this.id.length > 0 ) ? ( this.id + '.' + id ) : id;
      options = _.extend( { static: this.static, enabled: this.enabled }, options );
      return new Tandem( string, options );
    },
    createGroupTandem: function( id ) {
      return new GroupTandem( this.id + '.' + id );
    },
    get tail() {
      assert && assert( this.id.indexOf( '.' ) >= 0, 'tandem ID does not have a tail' );
      var lastIndexOfDot = this.id.lastIndexOf( '.' );
      var tail = this.id.substring( lastIndexOfDot + 1 );
      assert && assert( tail.length > 0, 'tandem ID did not have a tail' );
      return tail;
    },
    get parentTandem() {
      assert && assert( this.id.indexOf( '.' ) >= 0, 'tandem ID does not have a tail' );
      var lastIndexOfDot = this.id.lastIndexOf( '.' );
      var headID = this.id.substring( 0, lastIndexOfDot );
      return new Tandem( headID, {
        static: this.static,
        required: this.required,
        supplied: this.supplied,
        enabled: this.enabled
      } );
    },
    createSupertypeTandem: function() {
      return new SupertypeTandem( this.id, this.options );
    },
    isLegalAndUsable: function() {
      return this.supplied || (this.optional && !this.supplied);
    }
  }, {
    tandemRequired: function() {
      return rootTandem.createTandem( 'requiredTandem' + (requiredTandemIndex++), {
        required: true,
        supplied: false
      } );
    },
    tandemOptional: function() {
      return rootTandem.createTandem( 'optionalTandem' + (optionalTandemIndex++), {
        required: false,
        supplied: false
      } );
    },
    addInstanceListener: function( instanceListener ) {
      instanceListeners.push( instanceListener );
    },
    createRootTandem: function() {
      return new Tandem( toCamelCase( packageJSON.name ) );
    },
    createStaticTandem: function( name ) {
      return Tandem.createRootTandem().createTandem( name, { static: true } );
    },
    launch: function() {
      assert && assert( !launched, 'Tandem was launched twice' );
      launched = true;
      while ( staticInstances.length > 0 ) {
        var staticInstance = staticInstances.shift();
        staticInstance.tandem.addInstance( staticInstance.instance, staticInstance.type );
      }
    },
    disallowTandem: function( options ) {
      if ( Tandem.validationEnabled() ) {
        assert && assert( !options.tandem, 'tandem is not allowed' );
      }
    },
    indicateUninstrumentedCode: function() {
      if ( window.phet && phet.phetio ) {
        if ( phet.phetio.queryParameters.phetioValidateTandems ) {
          assert && assert( false, 'Uninstrumented code detected' );
        }
        if ( phet.phetio.queryParameters.printMissingTandems ) {
          var stackTrace = new Error().stack;
          console.log( 'Uninstrumented Code! Tandem not supplied: ' + (uninstrumentedCodeIndex++) + '.\n' +
                       'Stack trace: ' + stackTrace );
        }
      }
    },
    validationEnabled: function() {
      return window.phet && phet.phetio && phet.phetio.queryParameters.phetioValidateTandems;
    }
  } );
  var rootTandem = Tandem.createRootTandem();
  if ( window.tandemPreloadInstanceListeners ) {
    for ( var i = 0; i < window.tandemPreloadInstanceListeners.length; i++ ) {
      Tandem.addInstanceListener( window.tandemPreloadInstanceListeners[ i ] );
    }
  }
  function GroupTandem( id ) {
    Tandem.call( this, id );
    this.groupElementIndex = 0;
  }
  tandemNamespace.register( 'Tandem.GroupTandem', GroupTandem );
  inherit( Tandem, GroupTandem, {
    createNextTandem: function() {
      return new Tandem( this.id + '_' + ( this.groupElementIndex++ ) );
    }
  } );
  function SupertypeTandem( id, options ) {
    Tandem.call( this, id, options );
  }
  tandemNamespace.register( 'Tandem.SupertypeTandem', SupertypeTandem );
  inherit( Tandem, SupertypeTandem, {
    addInstance: function( instance, type ) {},
    removeInstance: function( instance ) {}
  } );
  return Tandem;
} );
define( 'ifphetio',['require'],function( module ) {
  'use strict';
  var buildMap = {};
  return {
    load: function( id, require, load, config ) {
      if ( config.isBuild ) {
        var url = require.toUrl( id );
        if ( /\.js$/.test( url ) === false ) {
          url += '.js';
        }
        if ( global.phet && global.phet.chipper && global.phet.chipper.brand === 'phet-io' ) {
          buildMap[ id ] = {
            content: global.phet.chipper.grunt.file.read( url ),
            attach: module.attach
          };
          require( [ id ], load );
        }
        else {
          load();
        }
      }
      else {
        var brand = window.phet && window.phet.chipper && window.phet.chipper.brand;
        if ( brand === 'phet-io' ) {
          require( [ id ], load );
        }
        else {
          load( function() { return function() {};} );
        }
      }
    },
    write: function( pluginName, moduleName, write ) {
      var text = null;
      if ( global.phet && global.phet.chipper && global.phet.chipper.brand === 'phet-io' ) {
        text = 'define("' + moduleName + '", function(){' + buildMap[ moduleName ].content + '});';
        write.asModule( moduleName, text, buildMap[ moduleName ].content );
      }
      else {
        text = 'define("' + moduleName + '", function(){return function(){ return function(){}; };});';
        write( text );
      }
    }
  };
} );
define("PHET_IO/assertions/assertInstanceOf", function(){return function(){ return function(){}; };});
define("PHET_IO/phetioInherit", function(){return function(){ return function(){}; };});
define("PHET_IO/types/TFunctionWrapper", function(){return function(){ return function(){}; };});
define("PHET_IO/types/TObject", function(){return function(){ return function(){}; };});
define("PHET_IO/events/toEventOnEmit", function(){return function(){ return function(){}; };});
define("PHET_IO/types/TVoid", function(){return function(){ return function(){}; };});
define("PHET_IO/phetio", function(){return function(){ return function(){}; };});
define( 'AXON/TProperty',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/phetio'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  function TProperty( phetioValueType, options ) {
    options = _.extend( {
      phetioStateElement: true
    }, options );
    var TPropertyImpl = function TPropertyImpl( property, phetioID ) {
      assert && assert( !!phetioValueType, 'TProperty needs phetioValueType' );
      assert && assert( property, 'Property should exist' );
      assert && assert( _.endsWith( phetioID, 'Property' ), 'TProperty instances should end with the "Property" suffix, for ' + phetioID );
      assertInstanceOf( property, phet.axon.Property );
      TObject.call( this, property, phetioID );
      this.phetioStateElement = options.phetioStateElement;
      toEventOnEmit(
        property.startedCallbacksForChangedEmitter,
        property.endedCallbacksForChangedEmitter,
        'model',
        phetioID,
        this.constructor,
        'changed',
        function( newValue, oldValue ) {
          return {
            oldValue: phetioValueType.toStateObject( oldValue ),
            newValue: phetioValueType.toStateObject( newValue ),
            units: phetioValueType.units
          };
        } );
    };
    return phetioInherit( TObject, 'TProperty', TPropertyImpl, {
      getValue: {
        returnType: phetioValueType,
        parameterTypes: [],
        implementation: function() {
          return this.instance.get();
        },
        documentation: 'Gets the current value.'
      },
      setValue: {
        returnType: TVoid,
        parameterTypes: [ phetioValueType ],
        implementation: function( value ) {
          this.instance.set( value );
        },
        documentation: 'Sets the value of the property, and triggers notifications if the value is different'
      },
      link: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.link( listener );
        },
        documentation: 'Add a listener which will be called when the value changes.  The listener also gets an ' +
                       'immediate callback with the current value.'
      },
      lazyLink: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.lazyLink( listener );
        },
        documentation: 'Add a listener which will be called when the value changes, but not for the initial value.'
      },
      unlink: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, [ phetioValueType ] ) ],
        implementation: function( listener ) {
          this.instance.unlink( listener );
        },
        documentation: 'Removes a listener'
      }
    }, {
      phetioStateElement: options.phetioStateElement,
      documentation: 'Model values that can send out notifications when the value changes. This is different from the ' +
                     'traditional observer pattern in that listeners also receive a callback with the current value ' +
                     'when the listeners are registered.',
      valueType: phetioValueType,
      events: [ 'changed' ],
      getAPI: function() {
        return {
          valueType: phetio.getAPIForType( phetioValueType )
        };
      },
      fromStateObject: function( stateObject ) {
        return phetioValueType.fromStateObject( stateObject );
      },
      toStateObject: function( instance ) {
        assert && assert( instance, 'instance should be defined' );
        assert && assert( phetioValueType.toStateObject, 'toStateObject doesnt exist for ' + phetioValueType.typeName );
        return phetioValueType.toStateObject( instance.value );
      },
      setValue: function( instance, value ) {
        instance.set( value );
      },
      options: options
    } );
  }
  axon.register( 'TProperty', TProperty );
  return TProperty;
} );
define( 'AXON/Property',['require','AXON/axon','PHET_CORE/inherit','AXON/Emitter','AXON/Multilink','TANDEM/Tandem','AXON/TProperty','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var Multilink = require( 'AXON/Multilink' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TProperty = require( 'AXON/TProperty' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  function Property( value, options ) {
    var self = this;
    if ( options && options.isTandem ) {
      assert && assert( false, 'Options should be an Object, not a Tandem' );
    }
    options = _.extend( {
      tandem: Tandem.tandemOptional(),
      phetioValueType: null, // {function | null} phet-io type wrapper like TString, TNumber, etc.
      validValues: null,
      isValidValue: null,
      phetioInstanceDocumentation: '',
      phetioStateElement: true,
      useDeepEquality: false
    }, options );
    assert && assert( !( options.validValues && options.isValidValue ), 'validValues and isValidValue are mutually exclusive' );
    this.useDeepEquality = options.useDeepEquality;
    this.isValidValue = options.isValidValue; // @private
    if ( !this.isValidValue && options.validValues ) {
      this.isValidValue = function( value ) {
        return options.validValues.indexOf( value ) !== -1;
      };
    }
    assert && this.isValidValue && assert( this.isValidValue( value ), 'invalid initial value: ' + value );
    this.phetioValueType = options.phetioValueType;
    Tandem.validationEnabled() && options.tandem.isLegalAndUsable() && assert && assert( !!options.phetioValueType,
      'Type passed to Property must be specified. Tandem.id: ' + options.tandem.id );
    this.startedCallbacksForChangedEmitter = new Emitter();
    this.endedCallbacksForChangedEmitter = new Emitter();
    this._value = value;
    this._initialValue = value;
    this.changedEmitter = new Emitter();
    options.tandem.addInstance( this, TProperty( options.phetioValueType || TVoid, {
      phetioInstanceDocumentation: options.phetioInstanceDocumentation,
      phetioStateElement: options.phetioStateElement
    } ) );
    this.disposeProperty = function() {
      self.changedEmitter.listeners.length = 0;
      options.tandem.removeInstance( self );
    };
  }
  axon.register( 'Property', Property );
  return inherit( Object, Property, {
      get: function() {
        return this._value;
      },
      set: function( value ) {
        assert && this.isValidValue && assert( this.isValidValue( value ), 'invalid value: ' + value );
        if ( !this.equalsValue( value ) ) {
          this._setAndNotifyObservers( value );
        }
        return this;
      },
      equalsValue: function( value ) {
        return this.areValuesEqual( value, this._value );
      },
      areValuesEqual: function( a, b ) {
        if ( this.useDeepEquality ) {
          if ( a && b ) {
            assert && assert( !!a.equals, 'no equals function for 1st arg' );
            assert && assert( !!b.equals, 'no equals function for 2nd arg' );
            assert && assert( a.equals( b ) === b.equals( a ), 'incompatible equality checks' );
            return a.equals( b );
          }
          else {
            return a === b;
          }
        }
        else {
          return a === b;
        }
      },
      get initialValue() {
        return this._initialValue;
      },
      _setAndNotifyObservers: function( value ) {
        var oldValue = this.get();
        this._value = value;
        this._notifyObservers( oldValue );
      },
      _notifyObservers: function( oldValue ) {
        var value = this.get();
        this.startedCallbacksForChangedEmitter.emit2( value, oldValue );
        this.changedEmitter.emit2( value, oldValue );
        this.endedCallbacksForChangedEmitter.emit();
      },
      notifyObserversStatic: function() {
        this.changedEmitter.emit1( this.get() );
      },
      reset: function() {
        this.set( this._initialValue );
      },
      get value() { return this.get(); },
      set value( newValue ) { this.set( newValue ); },
      link: function( observer ) {
        if ( !this.changedEmitter.hasListener( observer ) ) {
          this.changedEmitter.addListener( observer );
          observer( this.get(), null ); // null should be used when an object is expected but unavailable
        }
      },
      linkWithDisposal: function( disposeEmitter, observer ) {
        var self = this;
        this.link( observer );
        disposeEmitter.addListener( function() {
          self.unlink( observer );
          disposeEmitter.removeListener( this );
        } );
      },
      lazyLink: function( observer ) {
        this.changedEmitter.addListener( observer );
      },
      unlink: function( observer ) {
        if ( this.changedEmitter.hasListener( observer ) ) {
          this.changedEmitter.removeListener( observer );
        }
      },
      unlinkAll: function() {
        this.changedEmitter.removeAllListeners();
      },
      linkAttribute: function( object, attributeName ) {
        var handle = function( value ) {object[ attributeName ] = value;};
        this.link( handle );
        return handle;
      },
      unlinkAttribute: function( observer ) {
        this.unlink( observer );
      },
      toString: function() {return 'Property{' + this.get() + '}'; },
      valueOf: function() {return this.toString();},
      once: function( observer ) {
        var self = this;
        var wrapper = function( newValue, oldValue ) {
          self.unlink( wrapper );
          observer( newValue, oldValue );
        };
        this.lazyLink( wrapper );
        return wrapper;
      },
      debug: function( name ) {
        var observer = function( value ) { console.log( name, value ); };
        this.link( observer );
        return observer;
      },
      get toggleFunction() {
        return this.toggle.bind( this );
      },
      toggle: function() {
        this.value = !this.value;
      },
      onValue: function( value, observer ) {
        assert && this.isValidValue && assert( this.isValidValue( value ), 'attempt to observe invalid value: ' + value );
        var self = this;
        var onValueObserver = function( v ) {
          if ( self.areValuesEqual( v, value ) ) {
            observer();
          }
        };
        this.link( onValueObserver );
        return onValueObserver;
      },
      dispose: function() {
        this.disposeProperty();
      },
      hasListener: function( listener ) {
        return this.changedEmitter.hasListener( listener );
      },
      hasListeners: function() {
        assert && assert( arguments.length === 0, 'Property.hasListeners should be called without arguments' );
        return this.changedEmitter.hasListeners();
      },
      getDeclarator: function( options ) {
        var self = this;
        return {
          get: function() {
            return self.get();
          },
          set: function( value ) { self.set( value ); },
          configurable: true,
          enumerable: true
        };
      }
    },
    {
      multilink: function( properties, observer ) {
        return new Multilink( properties, observer, false );
      },
      lazyMultilink: function( properties, observer ) {
        return new Multilink( properties, observer, true );
      },
      unmultilink: function( multilink ) {
        multilink.dispose();
      },
      preventGetSet: function( object, prop ) {
        Object.defineProperty( object, prop, {
          get: function() {
            assert && assert( false, 'getter prevented for prop: ' + prop );
          },
          set: function( value ) {
            assert && assert( false, 'setter prevented for prop: ' + prop );
          },
          configurable: true,
          enumerable: true
        } );
      }
    } );
} );
define( 'SCENERY/util/CanvasContextWrapper',['require','PHET_CORE/inherit','SCENERY/scenery','AXON/Property'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Property = require( 'AXON/Property' );
  function CanvasContextWrapper( canvas, context ) {
    this.canvas = canvas;
    this.context = context;
    this.resetStyles();
    phetAllocation && phetAllocation( 'CanvasContextWrapper' );
  }
  scenery.register( 'CanvasContextWrapper', CanvasContextWrapper );
  inherit( Object, CanvasContextWrapper, {
    resetStyles: function() {
      this.fillStyle = undefined; // null
      this.strokeStyle = undefined; // null
      this.lineWidth = undefined; // 1
      this.lineCap = undefined; // 'butt'
      this.lineJoin = undefined; // 'miter'
      this.lineDash = undefined; // []
      this.lineDashOffset = undefined; // 0
      this.miterLimit = undefined; // 10
      this.font = undefined; // '10px sans-serif'
      this.direction = undefined; // 'inherit'
    },
    setDimensions: function( width, height ) {
      this.canvas.width = width;
      this.canvas.height = height;
      this.resetStyles();
    },
    setFillStyle: function( style ) {
      if ( style && style instanceof Property ) {
        style = style.value;
      }
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }
      if ( this.fillStyle !== style ) {
        this.fillStyle = style;
        this.context.fillStyle = style;
      }
    },
    setStrokeStyle: function( style ) {
      if ( style && style instanceof Property ) {
        style = style.value;
      }
      if ( style && style.getCanvasStyle ) {
        style = style.getCanvasStyle();
      }
      if ( this.strokeStyle !== style ) {
        this.strokeStyle = style;
        this.context.strokeStyle = style;
      }
    },
    setLineWidth: function( width ) {
      if ( this.lineWidth !== width ) {
        this.lineWidth = width;
        this.context.lineWidth = width;
      }
    },
    setLineCap: function( cap ) {
      if ( this.lineCap !== cap ) {
        this.lineCap = cap;
        this.context.lineCap = cap;
      }
    },
    setLineJoin: function( join ) {
      if ( this.lineJoin !== join ) {
        this.lineJoin = join;
        this.context.lineJoin = join;
      }
    },
    setMiterLimit: function( miterLimit ) {
      assert && assert( typeof miterLimit === 'number' );
      if ( this.miterLimit !== miterLimit ) {
        this.miterLimit = miterLimit;
        this.context.miterLimit = miterLimit;
      }
    },
    setLineDash: function( dash ) {
      assert && assert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );
      if ( this.lineDash !== dash ) {
        this.lineDash = dash;
        if ( this.context.setLineDash ) {
          this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround
        }
        else if ( this.context.mozDash !== undefined ) {
          this.context.mozDash = dash;
        }
        else if ( this.context.webkitLineDash !== undefined ) {
          this.context.webkitLineDash = dash ? dash : [];
        }
        else {
        }
      }
    },
    setLineDashOffset: function( lineDashOffset ) {
      if ( this.lineDashOffset !== lineDashOffset ) {
        this.lineDashOffset = lineDashOffset;
        if ( this.context.lineDashOffset !== undefined ) {
          this.context.lineDashOffset = lineDashOffset;
        }
        else if ( this.context.webkitLineDashOffset !== undefined ) {
          this.context.webkitLineDashOffset = lineDashOffset;
        }
        else {
        }
      }
    },
    setFont: function( font ) {
      if ( this.font !== font ) {
        this.font = font;
        this.context.font = font;
      }
    },
    setDirection: function( direction ) {
      if ( this.direction !== direction ) {
        this.direction = direction;
        this.context.direction = direction;
      }
    }
  } );
  return CanvasContextWrapper;
} );
define("PHET_IO/types/TBoolean", function(){return function(){ return function(){}; };});
define("PHET_IO/types/TNumber", function(){return function(){ return function(){}; };});
define( 'SCENERY/nodes/TNode',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  function TNode( node, phetioID ) {
    TObject.call( this, node, phetioID );
    assertInstanceOf( node, phet.scenery.Node );
  }
  phetioInherit( TObject, 'TNode', TNode, {
    isVisible: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.visible;
      },
      documentation: 'Gets a Boolean value indicating whether the node can be seen and interacted with'
    },
    setVisible: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( visible ) {
        this.instance.visible = visible;
      },
      documentation: 'Set whether the node will be visible (and interactive)'
    },
    setPickable: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( pickable ) {
        this.instance.pickable = pickable;
      },
      documentation: 'Set whether the node will be pickable (and hence interactive)'
    },
    isPickable: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.pickable;
      },
      documentation: 'Gets whether the node is pickable (and hence interactive)'
    },
    addPickableListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( callback ) {
        var inst = this.instance;
        this.instance.on( 'pickability', function() {
          callback( inst.isPickable() );
        } );
      },
      documentation: 'Adds a listener for when pickability of the node changes'
    },
    addVisibleListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( callback ) {
        var inst = this.instance;
        this.instance.on( 'visibility', function() {
          callback( inst.isVisible() );
        } );
      },
      documentation: 'Adds a listener for when visibility of the node changes'
    },
    setOpacity: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( opacity ) {
        this.instance.opacity = opacity;
      },
      documentation: 'Set opacity between 0-1 (inclusive)'
    },
    setRotation: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( rotation ) {
        this.instance.rotation = rotation;
      },
      documentation: 'Set the rotation of the node, in radians'
    }
  }, {
    documentation: 'The base type for graphical and potentially interactive objects'
  } );
  scenery.register( 'TNode', TNode );
  return TNode;
} );
define( 'SCENERY/nodes/Node',['require','PHET_CORE/inherit','PHET_CORE/extend','AXON/Events','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/util/RendererSummary','SCENERY/util/Picker','SCENERY/accessibility/Accessibility','SCENERY/util/CanvasContextWrapper','SCENERY/nodes/TNode','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Transform3 = require( 'DOT/Transform3' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  var Shape = require( 'KITE/Shape' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RendererSummary = require( 'SCENERY/util/RendererSummary' );
  var Picker = require( 'SCENERY/util/Picker' );
  var Accessibility = require( 'SCENERY/accessibility/Accessibility' );
  require( 'SCENERY/util/CanvasContextWrapper' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var Tandem = require( 'TANDEM/Tandem' );
  var clamp = Util.clamp;
  var globalIdCounter = 1;
  var eventsRequiringBoundsValidation = {
    'childBounds': true,
    'localBounds': true,
    'bounds': true
  };
  function defaultTrailPredicate( node ) {
    return node._parents.length === 0;
  }
  function defaultLeafTrailPredicate( node ) {
    return node._children.length === 0;
  }
  function hasRootedDisplayPredicate( node ) {
    return node._rootedDisplays.length > 0;
  }
  var scratchBounds2 = Bounds2.NOTHING.copy(); // mutable {Bounds2} used temporarily in methods
  var scratchMatrix3 = new Matrix3();
  var NODE_OPTION_KEYS = [
    'children', // List of children to add (in order), see setChildren for more documentation
    'cursor', // CSS cursor to display when over this node, see setCursor() for more documentation
    'visible', // Whether the node is visible, see setVisible() for more documentation
    'pickable', // Whether the node is pickable, see setPickable() for more documentation
    'inputEnabled', // Whether input events can reach into this subtree, see setInputEnabled() for more documentation
    'inputListeners', // The input listeners attached to the Node, see setInputListeners() for more documentation
    'opacity', // Opacity of this node's subtree, see setOpacity() for more documentation
    'matrix', // Transformation matrix of the node, see setMatrix() for more documentation
    'translation', // x/y translation of the node, see setTranslation() for more documentation
    'x', // x translation of the node, see setX() for more documentation
    'y', // y translation of the node, see setY() for more documentation
    'rotation', // rotation (in radians) of the node, see setRotation() for more documentation
    'scale', // scale of the node, see scale() for more documentation
    'localBounds', // bounds of subtree in local coordinate frame, see setLocalBounds() for more documentation
    'maxWidth', // Constrains width of this node, see setMaxWidth() for more documentation
    'maxHeight', // Constrains height of this node, see setMaxHeight() for more documentation
    'leftTop', // The upper-left corner of this node's bounds, see setLeftTop() for more documentation
    'centerTop', // The top-center of this node's bounds, see setCenterTop() for more documentation
    'rightTop', // The upper-right corner of this node's bounds, see setRightTop() for more documentation
    'leftCenter', // The left-center of this node's bounds, see setLeftCenter() for more documentation
    'center', // The center of this node's bounds, see setCenter() for more documentation
    'rightCenter', // The center-right of this node's bounds, see setRightCenter() for more documentation
    'leftBottom', // The bottom-left of this node's bounds, see setLeftBottom() for more documentation
    'centerBottom', // The middle center of this node's bounds, see setCenterBottom() for more documentation
    'rightBottom', // The bottom right of this node's bounds, see setRightBottom() for more documentation
    'left', // The left side of this node's bounds, see setLeft() for more documentation
    'right', // The right side of this node's bounds, see setRight() for more documentation
    'top', // The top side of this node's bounds, see setTop() for more documentation
    'bottom', // The bottom side of this node's bounds, see setBottom() for more documentation
    'centerX', // The x-center of this node's bounds, see setCenterX() for more documentation
    'centerY', // The y-center of this node's bounds, see setCenterY() for more documentation
    'renderer', // The preferred renderer for this subtree, see setRenderer() for more documentation
    'layerSplit', // Forces this subtree into a layer of its own, see setLayerSplit() for more documentation
    'usesOpacity', // Hint that opacity will be changed, see setUsesOpacity() for more documentation
    'cssTransform', // Hint that can trigger using CSS transforms, see setCssTransform() for more documentation
    'excludeInvisible', // If this is invisible, exclude from DOM, see setExcludeInvisible() for more documentation
    'webglScale', // Hint to adjust WebGL scaling quality for this subtree, see setWebglScale() for more documentation
    'preventFit', // Prevents layers from fitting this subtree, see setPreventFit() for more documentation
    'mouseArea', // Changes the area the mouse can interact with, see setMouseArea() for more documentation
    'touchArea', // Changes the area touches can interact with, see setTouchArea() for more documentation
    'clipArea', // Makes things outside of a shape invisible, see setClipArea() for more documentation
    'transformBounds', // Flag that makes bounds tighter, see setTransformBounds() for more documentation
    'accessibleContent', // Sets up accessibility handling, see setAccessibleContent() for more documentation
    'accessibleOrder', // Modifies the keyboard accessibility order, see setAccessibleOrder() for more documentation
    'phetioType', // The corresponding phet-io wrapper type
    'tandem' // For instrumenting Scenery nodes, see setTandem().  This must be last so that (a) the phetioType
  ];
  function Node( options ) {
    Events.call( this );
    this._id = globalIdCounter++;
    this._tandem = null;
    this._phetioType = TNode;
    this._instances = [];
    this._accessibleInstances = [];
    this._rootedDisplays = [];
    this._drawables = [];
    this._visible = true;
    this._opacity = 1;
    this._pickable = null;
    this._inputEnabled = true;
    this._clipArea = null;
    this._mouseArea = null; // {Shape|Bounds2} for mouse position in the local coordinate frame
    this._touchArea = null; // {Shape|Bounds2} for touch and pen position in the local coordinate frame
    this._cursor = null;
    this._accessibleContent = null;
    this._accessibleOrder = null;
    this._children = []; // {Array.<Node>} - Ordered array of child nodes.
    this._parents = []; // {Array.<Node>} - Unordered array of parent nodes.
    this._transformBounds = false;
    this._transform = new Transform3(); // @private {Transform3}
    this._transformListener = this.onTransformChange.bind( this ); // @private {Function}
    this._transform.onStatic( 'change', this._transformListener ); // NOTE: Listener/transform bound to this node.
    this._maxWidth = null; // @private {number|null}
    this._maxHeight = null; // @private {number|null}
    this._appliedScaleFactor = 1; // @private {number} - Scale applied due to the maximum dimension constraints.
    this._inputListeners = [];
    this._bounds = Bounds2.NOTHING.copy();
    this._localBounds = Bounds2.NOTHING.copy();
    this._selfBounds = Bounds2.NOTHING.copy();
    this._childBounds = Bounds2.NOTHING.copy();
    this._localBoundsOverridden = false;
    this._boundsDirty = true; // @private {boolean} - Whether bounds needs to be recomputed to be valid.
    this._localBoundsDirty = true; // @private {boolean} - Whether localBounds needs to be recomputed to be valid.
    this._selfBoundsDirty = true; // @private {boolean} - Whether selfBounds needs to be recomputed to be valid.
    this._childBoundsDirty = true; // @private {boolean} - Whether childBounds needs to be recomputed to be valid.
    if ( assert ) {
      this._originalBounds = this._bounds;
      this._originalLocalBounds = this._localBounds;
      this._originalSelfBounds = this._selfBounds;
      this._originalChildBounds = this._childBounds;
    }
    this._hints = {
      renderer: 0,
      usesOpacity: false,
      layerSplit: false,
      cssTransform: false,
      fullResolution: false,
      excludeInvisible: false,
      webglScale: null,
      preventFit: false
    };
    this._rendererBitmask = Renderer.bitmaskNodeDefault;
    this._rendererSummary = new RendererSummary( this );
    this._boundsEventCount = 0; // @private {number}
    this._boundsEventSelfCount = 0;
    this._picker = new Picker( this );
    this.initializeAccessibility();
    this._isDisposed = false;
    if ( assert ) {
      var protoDispose = this.dispose;
      this.dispose = function() {
        assert && assert( !this._isDisposed, 'This Node has already been disposed, and cannot be disposed again' );
        protoDispose.call( this );
        assert && assert( this._isDisposed, 'Node.dispose() call is missing from an overridden dispose method' );
      };
    }
    if ( options ) {
      this.mutate( options );
    }
    phetAllocation && phetAllocation( 'Node' );
  }
  scenery.register( 'Node', Node );
  inherit( Object, Node, extend( {
    _mutatorKeys: NODE_OPTION_KEYS,
    drawableMarkFlags: [],
    insertChild: function( index, node ) {
      assert && assert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );
      assert && assert( node instanceof Node,
        'addChild/insertChild requires the child to be a Node. Constructor: ' +
        ( node.constructor ? node.constructor.name : 'none' ) );
      assert && assert( !_.includes( this._children, node ), 'Parent already contains child' );
      assert && assert( node !== this, 'Cannot add self as a child' );
      assert && assert( node._parents !== null, 'Tried to insert a disposed child node?' );
      this._picker.onInsertChild( node );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? 1 : 0 );
      this._rendererSummary.summaryChange( RendererSummary.bitmaskAll, node._rendererSummary.bitmask );
      node._parents.push( this );
      this._children.splice( index, 0, node );
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleAddChild( node );
      }
      node.invalidateBounds();
      this._boundsDirty = true;
      this.trigger2( 'childInserted', node, index );
      if ( assertSlow ) { this._picker.audit(); }
      return this; // allow chaining
    },
    addChild: function( node ) {
      this.insertChild( this._children.length, node );
      return this; // allow chaining
    },
    removeChild: function( node ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChild() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );
      var indexOfChild = _.indexOf( this._children, node );
      this.removeChildWithIndex( node, indexOfChild );
      return this; // allow chaining
    },
    removeChildAt: function( index ) {
      assert && assert( index >= 0 );
      assert && assert( index < this._children.length );
      var node = this._children[ index ];
      this.removeChildWithIndex( node, index );
      return this; // allow chaining
    },
    removeChildWithIndex: function( node, indexOfChild ) {
      assert && assert( node && node instanceof Node, 'Need to call node.removeChildWithIndex() with a Node.' );
      assert && assert( this.hasChild( node ), 'Attempted to removeChild with a node that was not a child.' );
      assert && assert( this._children[ indexOfChild ] === node, 'Incorrect index for removeChildWithIndex' );
      assert && assert( node._parents !== null, 'Tried to remove a disposed child node?' );
      var indexOfParent = _.indexOf( node._parents, this );
      if ( !node._rendererSummary.isNotAccessible() ) {
        this.onAccessibleRemoveChild( node );
      }
      this._picker.onRemoveChild( node );
      this.changeBoundsEventCount( node._boundsEventCount > 0 ? -1 : 0 );
      this._rendererSummary.summaryChange( node._rendererSummary.bitmask, RendererSummary.bitmaskAll );
      node._parents.splice( indexOfParent, 1 );
      this._children.splice( indexOfChild, 1 );
      this.invalidateBounds();
      this._childBoundsDirty = true; // force recomputation of child bounds after removing a child
      this.trigger2( 'childRemoved', node, indexOfChild );
      if ( assertSlow ) { this._picker.audit(); }
    },
    removeAllChildren: function() {
      this.setChildren( [] );
      return this; // allow chaining
    },
    setChildren: function( children ) {
      if ( this._children !== children ) {
        while ( this._children.length ) {
          this.removeChild( this._children[ this._children.length - 1 ] );
        }
        var len = children.length;
        for ( var i = 0; i < len; i++ ) {
          this.addChild( children[ i ] );
        }
      }
      return this; // allow chaining
    },
    set children( value ) { this.setChildren( value ); },
    getChildren: function() {
      return this._children.slice( 0 ); // create a defensive copy
    },
    get children() { return this.getChildren(); },
    getChildrenCount: function() {
      return this._children.length;
    },
    getParents: function() {
      return this._parents.slice( 0 ); // create a defensive copy
    },
    get parents() { return this.getParents(); },
    getParent: function() {
      assert && assert( this._parents.length <= 1, 'Cannot call getParent on a node with multiple parents' );
      return this._parents.length ? this._parents[ 0 ] : null;
    },
    getChildAt: function( index ) {
      return this._children[ index ];
    },
    indexOfParent: function( parent ) {
      return _.indexOf( this._parents, parent );
    },
    indexOfChild: function( child ) {
      return _.indexOf( this._children, child );
    },
    moveToFront: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToFront( self );
      } );
      return this; // allow chaining
    },
    moveChildToFront: function( child ) {
      if ( this.indexOfChild( child ) !== this._children.length - 1 ) {
        this.removeChild( child );
        this.addChild( child );
      }
      return this; // allow chaining
    },
    moveToBack: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.moveChildToBack( self );
      } );
      return this; // allow chaining
    },
    moveChildToBack: function( child ) {
      if ( this.indexOfChild( child ) !== 0 ) {
        this.removeChild( child );
        this.insertChild( 0, child );
      }
      return this; // allow chaining
    },
    detach: function() {
      var self = this;
      _.each( this._parents.slice( 0 ), function( parent ) {
        parent.removeChild( self );
      } );
      return this; // allow chaining
    },
    changeBoundsEventCount: function( n ) {
      if ( n !== 0 ) {
        var zeroBefore = this._boundsEventCount === 0;
        this._boundsEventCount += n;
        assert && assert( this._boundsEventCount >= 0, 'subtree bounds event count should be guaranteed to be >= 0' );
        var zeroAfter = this._boundsEventCount === 0;
        if ( zeroBefore !== zeroAfter ) {
          var parentDelta = zeroBefore ? 1 : -1;
          var len = this._parents.length;
          for ( var i = 0; i < len; i++ ) {
            this._parents[ i ].changeBoundsEventCount( parentDelta );
          }
        }
      }
    },
    validateSelfBounds: function() {
      if ( this._selfBoundsDirty ) {
        var didSelfBoundsChange = this.updateSelfBounds();
        this._selfBoundsDirty = false;
        if ( didSelfBoundsChange ) {
          this.trigger0( 'selfBounds' );
        }
        return true;
      }
      return false;
    },
    validateBounds: function() {
      var self = this;
      var i;
      var wasDirtyBefore = this.validateSelfBounds();
      if ( this._childBoundsDirty ) {
        wasDirtyBefore = true;
        i = this._children.length;
        while ( i-- ) {
          this._children[ i ].validateBounds();
        }
        var oldChildBounds = scratchBounds2.set( this._childBounds ); // store old value in a temporary Bounds2
        this._childBounds.set( Bounds2.NOTHING ); // initialize to a value that can be unioned with includeBounds()
        i = this._children.length;
        while ( i-- ) {
          this._childBounds.includeBounds( this._children[ i ]._bounds );
        }
        this._childBoundsDirty = false;
        if ( !this._childBounds.equals( oldChildBounds ) ) {
          this.trigger0( 'childBounds' );
        }
      }
      if ( this._localBoundsDirty && !this._localBoundsOverridden ) {
        wasDirtyBefore = true;
        this._localBoundsDirty = false; // we only need this to set local bounds as dirty
        var oldLocalBounds = scratchBounds2.set( this._localBounds ); // store old value in a temporary Bounds2
        this._localBounds.set( this._selfBounds ).includeBounds( this._childBounds );
        if ( this.hasClipArea() ) {
          this._localBounds.constrainBounds( this._clipArea.bounds );
        }
        if ( !this._localBounds.equals( oldLocalBounds ) ) {
          this.trigger0( 'localBounds' );
          this._boundsDirty = true;
        }
        if ( this._maxWidth !== null || this._maxHeight !== null ) {
          this.updateMaxDimension( this._localBounds );
        }
      }
      if ( this._boundsDirty ) {
        wasDirtyBefore = true;
        this._boundsDirty = false;
        var oldBounds = scratchBounds2.set( this._bounds ); // store old value in a temporary Bounds2
        if ( this._transformBounds && !this._transform.getMatrix().isAxisAligned() ) {
          var matrix = scratchMatrix3.set( this.getMatrix() ); // calls below mutate this matrix
          this._bounds.set( Bounds2.NOTHING );
          this._includeTransformedSubtreeBounds( matrix, this._bounds ); // self and children
          if ( this.hasClipArea() ) {
            this._bounds.constrainBounds( this._clipArea.getBoundsWithTransform( matrix ) );
          }
        }
        else {
          this._bounds.set( this._localBounds );
          this.transformBoundsFromLocalToParent( this._bounds );
        }
        if ( !this._bounds.equals( oldBounds ) ) {
          i = this._parents.length;
          while ( i-- ) {
            this._parents[ i ].invalidateBounds();
          }
          this.trigger0( 'bounds' );
        }
      }
      if ( this._childBoundsDirty || this._boundsDirty ) {
        this.validateBounds();
      }
      if ( assert ) {
        assert( this._originalBounds === this._bounds, 'Reference for _bounds changed!' );
        assert( this._originalLocalBounds === this._localBounds, 'Reference for _localBounds changed!' );
        assert( this._originalSelfBounds === this._selfBounds, 'Reference for _selfBounds changed!' );
        assert( this._originalChildBounds === this._childBounds, 'Reference for _childBounds changed!' );
      }
      if ( assertSlow ) {
        (function() {
          var epsilon = 0.000001;
          var childBounds = Bounds2.NOTHING.copy();
          _.each( self._children, function( child ) { childBounds.includeBounds( child._bounds ); } );
          var localBounds = self._selfBounds.union( childBounds );
          if ( self.hasClipArea() ) {
            localBounds = localBounds.intersection( self._clipArea.bounds );
          }
          var fullBounds = self.localToParentBounds( localBounds );
          assertSlow && assertSlow( self._childBounds.equalsEpsilon( childBounds, epsilon ),
            'Child bounds mismatch after validateBounds: ' +
            self._childBounds.toString() + ', expected: ' + childBounds.toString() );
          assertSlow && assertSlow( self._localBoundsOverridden ||
                                    self._transformBounds ||
                                    self._bounds.equalsEpsilon( fullBounds, epsilon ) ||
                                    self._bounds.equalsEpsilon( fullBounds, epsilon ),
            'Bounds mismatch after validateBounds: ' + self._bounds.toString() +
            ', expected: ' + fullBounds.toString() );
        })();
      }
      return wasDirtyBefore; // whether any dirty flags were set
    },
    _includeTransformedSubtreeBounds: function( matrix, bounds ) {
      if ( !this.selfBounds.isEmpty() ) {
        bounds.includeBounds( this.getTransformedSelfBounds( matrix ) );
      }
      var numChildren = this._children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        var child = this._children[ i ];
        matrix.multiplyMatrix( child._transform.getMatrix() );
        child._includeTransformedSubtreeBounds( matrix, bounds );
        matrix.multiplyMatrix( child._transform.getInverse() );
      }
      return bounds;
    },
    validateWatchedBounds: function() {
      while ( this.watchedBoundsScan() ) {
      }
    },
    watchedBoundsScan: function() {
      if ( this._boundsEventSelfCount !== 0 ) {
        return this.validateBounds();
      }
      else if ( this._boundsEventCount > 0 && this._childBoundsDirty ) {
        var changed = false;
        var numChildren = this._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          changed = this._children[ i ].watchedBoundsScan() || changed;
        }
        return changed;
      }
      else {
        return false;
      }
    },
    invalidateBounds: function() {
      this._boundsDirty = true;
      this._localBoundsDirty = true;
      var i = this._parents.length;
      while ( i-- ) {
        this._parents[ i ].invalidateChildBounds();
      }
    },
    invalidateChildBounds: function() {
      if ( !this._childBoundsDirty ) {
        this._childBoundsDirty = true;
        this._localBoundsDirty = true;
        var i = this._parents.length;
        while ( i-- ) {
          this._parents[ i ].invalidateChildBounds();
        }
      }
    },
    invalidateSelf: function( newSelfBounds ) {
      assert && assert( newSelfBounds === undefined || newSelfBounds instanceof Bounds2,
        'invalidateSelf\'s newSelfBounds, if proided, needs to be Bounds2' );
      if ( !newSelfBounds ) {
        this._selfBoundsDirty = true;
        this.invalidateBounds();
        this._picker.onSelfBoundsDirty();
      }
      else {
        assert && assert( newSelfBounds.isEmpty() || newSelfBounds.isFinite(), 'Bounds must be empty or finite in invalidateSelf' );
        this._selfBoundsDirty = false;
        if ( !this._selfBounds.equals( newSelfBounds ) ) {
          this.invalidateBounds();
          this._picker.onSelfBoundsDirty();
          this._selfBounds.set( newSelfBounds );
          this.trigger0( 'selfBounds' );
        }
      }
      if ( assertSlow ) { this._picker.audit(); }
    },
    updateSelfBounds: function() {
      assert && assert( this._selfBounds.equals( Bounds2.NOTHING ) );
      return false;
    },
    hasChild: function( potentialChild ) {
      assert && assert( potentialChild && ( potentialChild instanceof Node ), 'hasChild needs to be called with a Node' );
      var isOurChild = _.includes( this._children, potentialChild );
      assert && assert( isOurChild === _.includes( potentialChild._parents, this ), 'child-parent reference should match parent-child reference' );
      return isOurChild;
    },
    getSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },
    get selfBounds() { return this.getSelfBounds(); },
    getSafeSelfBounds: function() {
      this.validateSelfBounds();
      return this._selfBounds;
    },
    getChildBounds: function() {
      this.validateBounds();
      return this._childBounds;
    },
    get childBounds() { return this.getChildBounds(); },
    getLocalBounds: function() {
      this.validateBounds();
      return this._localBounds;
    },
    get localBounds() { return this.getLocalBounds(); },
    setLocalBounds: function( localBounds ) {
      assert && assert( localBounds === null || localBounds instanceof Bounds2, 'localBounds override should be set to either null or a Bounds2' );
      if ( localBounds === null ) {
        if ( this._localBoundsOverridden ) {
          this._localBoundsOverridden = false;
          this.trigger1( 'localBoundsOverride', false );
          this.invalidateBounds();
        }
      }
      else {
        var changed = !localBounds.equals( this._localBounds ) || !this._localBoundsOverridden;
        if ( changed ) {
          this._localBounds.set( localBounds );
        }
        if ( !this._localBoundsOverridden ) {
          this._localBoundsOverridden = true; // NOTE: has to be done before invalidating bounds, since this disables localBounds computation
          this.trigger1( 'localBoundsOverride', true );
        }
        if ( changed ) {
          this.invalidateBounds();
        }
      }
      return this; // allow chaining
    },
    set localBounds( value ) { return this.setLocalBounds( value ); },
    getTransformedSelfBounds: function( matrix ) {
      this.validateBounds(); // TODO: consider more fine-grained validation?
      return this._selfBounds.transformed( matrix );
    },
    setTransformBounds: function( transformBounds ) {
      assert && assert( typeof transformBounds === 'boolean', 'transformBounds should be boolean' );
      if ( this._transformBounds !== transformBounds ) {
        this._transformBounds = transformBounds;
        this.invalidateBounds();
      }
      return this; // allow chaining
    },
    set transformBounds( value ) { return this.setTransformBounds( value ); },
    getTransformBounds: function() {
      return this._transformBounds;
    },
    get transformBounds() { return this.getTransformBounds(); },
    getBounds: function() {
      this.validateBounds();
      return this._bounds;
    },
    get bounds() { return this.getBounds(); },
    getVisibleLocalBounds: function() {
      var bounds = this.selfBounds.copy();
      var i = this._children.length;
      while ( i-- ) {
        var child = this._children[ i ];
        if ( child.isVisible() ) {
          bounds.includeBounds( child.getVisibleBounds() );
        }
      }
      assert && assert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );
      return bounds;
    },
    get visibleLocalBounds() { return this.getVisibleLocalBounds(); },
    getVisibleBounds: function() {
      return this.getVisibleLocalBounds().transform( this.getMatrix() );
    },
    get visibleBounds() { return this.getVisibleBounds(); },
    trailUnderPointer: function( pointer ) {
      return this._picker.hitTest( pointer.point, pointer.isMouse, pointer.isTouch || pointer.isPen );
    },
    hitTest: function( point, isMouse, isTouch ) {
      return this._picker.hitTest( point, isMouse, isTouch );
    },
    trailUnderPoint: function( point ) {
      assert && assert( point, 'trailUnderPointer requires a point' );
      return this._picker.hitTest( point, false, false );
    },
    containsPoint: function( point ) {
      return this.trailUnderPoint( point ) !== null;
    },
    containsPointSelf: function( point ) {
      return this.selfBounds.containsPoint( point );
    },
    intersectsBoundsSelf: function( bounds ) {
      return this.selfBounds.intersectsBounds( bounds );
    },
    isPainted: function() {
      return false;
    },
    areSelfBoundsValid: function() {
      return true;
    },
    hasParent: function() {
      return this._parents.length !== 0;
    },
    hasChildren: function() {
      return this._children.length > 0;
    },
    walkDepthFirst: function( callback ) {
      callback( this );
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        this._children[ i ].walkDepthFirst( callback );
      }
    },
    getChildrenWithinBounds: function( bounds ) {
      var result = [];
      var length = this._children.length;
      for ( var i = 0; i < length; i++ ) {
        var child = this._children[ i ];
        if ( !child._bounds.intersection( bounds ).isEmpty() ) {
          result.push( child );
        }
      }
      return result;
    },
    addInputListener: function( listener ) {
      if ( _.indexOf( this._inputListeners, listener ) === -1 ) {
        this._inputListeners.push( listener );
        this._picker.onAddInputListener();
        if ( assertSlow ) { this._picker.audit(); }
      }
      return this;
    },
    removeInputListener: function( listener ) {
      assert && assert( _.indexOf( this._inputListeners, listener ) !== -1 );
      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );
      this._picker.onRemoveInputListener();
      if ( assertSlow ) { this._picker.audit(); }
      return this;
    },
    interruptInput: function() {
      var listenersCopy = this.inputListeners;
      for ( var i = 0; i < listenersCopy.length; i++ ) {
        var listener = listenersCopy[ i ];
        listener.interrupt && listener.interrupt(); // TODO: get rid of the event?
      }
      return this;
    },
    interruptSubtreeInput: function() {
      this.interruptInput();
      var children = this._children.slice();
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].interruptSubtreeInput();
      }
      return this;
    },
    onAccessibleAddChild: function( node ) {
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].addAccessibleTrail( trail );
        }
      }
    },
    onAccessibleRemoveChild: function( node ) {
      var trails = node.getTrails( hasRootedDisplayPredicate );
      for ( var i = 0; i < trails.length; i++ ) {
        var trail = trails[ i ];
        if ( trail.nodeFromTop( 1 ) !== this ) {
          continue;
        }
        var rootedDisplays = trail.rootNode()._rootedDisplays;
        for ( var j = 0; j < rootedDisplays.length; j++ ) {
          rootedDisplays[ j ].removeAccessibleTrail( trail );
        }
      }
    },
    translate: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );
        assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );
        assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean', 'If provided, prependInstead should be boolean' );
        if ( !x && !y ) { return; } // bail out if both are zero
        if ( prependInstead ) {
          this.prependTranslation( x, y );
        }
        else {
          this.appendMatrix( scratchMatrix3.setToTranslation( x, y ) );
        }
      }
      else {
        var vector = x;
        assert && assert( vector instanceof Vector2 && vector.isFinite(), 'translation should be a finite Vector2 if not finite numbers' );
        if ( !vector.x && !vector.y ) { return; } // bail out if both are zero
        this.translate( vector.x, vector.y, y ); // forward to full version
      }
    },
    scale: function( x, y, prependInstead ) {
      if ( typeof x === 'number' ) {
        assert && assert( isFinite( x ), 'scales should be finite' );
        if ( y === undefined || typeof y === 'boolean' ) {
          this.scale( x, x, y );
        }
        else {
          assert && assert( typeof y === 'number' && isFinite( y ), 'scales should be finite numbers' );
          assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean', 'If provided, prependInstead should be boolean' );
          if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)
          if ( prependInstead ) {
            this.prependMatrix( Matrix3.scaling( x, y ) );
          }
          else {
            this.appendMatrix( Matrix3.scaling( x, y ) );
          }
        }
      }
      else {
        var vector = x;
        assert && assert( vector instanceof Vector2 && vector.isFinite(), 'scale should be a finite Vector2 if not a finite number' );
        this.scale( vector.x, vector.y, y ); // forward to full version
      }
    },
    rotate: function( angle, prependInstead ) {
      assert && assert( typeof angle === 'number' && isFinite( angle ), 'angle should be a finite number' );
      assert && assert( prependInstead === undefined || typeof prependInstead === 'boolean' );
      if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0
      if ( prependInstead ) {
        this.prependMatrix( Matrix3.rotation2( angle ) );
      }
      else {
        this.appendMatrix( Matrix3.rotation2( angle ) );
      }
    },
    rotateAround: function( point, angle ) {
      assert && assert( point instanceof Vector2 && point.isFinite(), 'point should be a finite Vector2' );
      assert && assert( typeof angle === 'number' && isFinite( angle ), 'angle should be a finite number' );
      var matrix = Matrix3.translation( -point.x, -point.y );
      matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );
      matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );
      this.prependMatrix( matrix );
      return this;
    },
    setX: function( x ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );
      this.translate( x - this.getX(), 0, true );
      return this;
    },
    set x( value ) { this.setX( value ); },
    getX: function() {
      return this._transform.getMatrix().m02();
    },
    get x() { return this.getX(); },
    setY: function( y ) {
      assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );
      this.translate( 0, y - this.getY(), true );
      return this;
    },
    set y( value ) { this.setY( value ); },
    getY: function() {
      return this._transform.getMatrix().m12();
    },
    get y() { return this.getY(); },
    setScaleMagnitude: function( a, b ) {
      var currentScale = this.getScaleVector();
      if ( typeof a === 'number' ) {
        if ( b === undefined ) {
          b = a;
        }
        assert && assert( typeof a === 'number' && isFinite( a ), 'setScaleMagnitude parameters should be finite numbers' );
        assert && assert( typeof b === 'number' && isFinite( b ), 'setScaleMagnitude parameters should be finite numbers' );
        this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );
      }
      else {
        assert && assert( a instanceof Vector2 && a.isFinite(), 'first parameter should be a finite Vector2' );
        this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );
      }
      return this;
    },
    getScaleVector: function() {
      return this._transform.getMatrix().getScaleVector();
    },
    setRotation: function( rotation ) {
      assert && assert( typeof rotation === 'number' && isFinite( rotation ),
        'rotation should be a finite number' );
      this.appendMatrix( scratchMatrix3.setToRotationZ( rotation - this.getRotation() ) );
      return this;
    },
    set rotation( value ) { this.setRotation( value ); },
    getRotation: function() {
      return this._transform.getMatrix().getRotation();
    },
    get rotation() { return this.getRotation(); },
    setTranslation: function( a, b ) {
      var m = this._transform.getMatrix();
      var tx = m.m02();
      var ty = m.m12();
      var dx;
      var dy;
      if ( typeof a === 'number' ) {
        assert && assert( typeof a === 'number' && isFinite( a ), 'Parameters to setTranslation should be finite numbers' );
        assert && assert( typeof b === 'number' && isFinite( b ), 'Parameters to setTranslation should be finite numbers' );
        dx = a - tx;
        dy = b - ty;
      }
      else {
        assert && assert( a instanceof Vector2 && a.isFinite(), 'Should be a finite Vector2' );
        dx = a.x - tx;
        dy = a.y - ty;
      }
      this.translate( dx, dy, true );
      return this;
    },
    set translation( value ) { this.setTranslation( value ); },
    getTranslation: function() {
      var matrix = this._transform.getMatrix();
      return new Vector2( matrix.m02(), matrix.m12() );
    },
    get translation() { return this.getTranslation(); },
    appendMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );
      this._transform.append( matrix );
    },
    prependMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );
      this._transform.prepend( matrix );
    },
    prependTranslation: function( x, y ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'x should be a finite number' );
      assert && assert( typeof y === 'number' && isFinite( y ), 'y should be a finite number' );
      if ( !x && !y ) { return; } // bail out if both are zero
      this._transform.prependTranslation( x, y );
    },
    setMatrix: function( matrix ) {
      assert && assert( matrix instanceof Matrix3 && matrix.isFinite(), 'matrix should be a finite Matrix3' );
      assert && assert( matrix.getDeterminant() !== 0, 'matrix should not map plane to a line or point' );
      this._transform.setMatrix( matrix );
    },
    set matrix( value ) { this.setMatrix( value ); },
    getMatrix: function() {
      return this._transform.getMatrix();
    },
    get matrix() { return this.getMatrix(); },
    getTransform: function() {
      return this._transform;
    },
    get transform() { return this.getTransform(); },
    resetTransform: function() {
      this.setMatrix( Matrix3.IDENTITY );
    },
    onTransformChange: function() {
      this.invalidateBounds();
      this._picker.onTransformChange();
      if ( assertSlow ) { this._picker.audit(); }
      this.trigger0( 'transform' );
    },
    updateMaxDimension: function( localBounds ) {
      var currentScale = this._appliedScaleFactor;
      var idealScale = 1;
      if ( this._maxWidth !== null ) {
        var width = localBounds.width;
        if ( width > this._maxWidth ) {
          idealScale = Math.min( idealScale, this._maxWidth / width );
        }
      }
      if ( this._maxHeight !== null ) {
        var height = localBounds.height;
        if ( height > this._maxHeight ) {
          idealScale = Math.min( idealScale, this._maxHeight / height );
        }
      }
      var scaleAdjustment = idealScale / currentScale;
      if ( scaleAdjustment !== 1 ) {
        this.scale( scaleAdjustment );
        this._appliedScaleFactor = idealScale;
      }
    },
    onMaxDimensionChange: function( beforeMaxLength, afterMaxLength ) {
      if ( beforeMaxLength === null && afterMaxLength !== null ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
      else if ( beforeMaxLength !== null && afterMaxLength === null ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    },
    setMaxWidth: function( maxWidth ) {
      assert && assert( maxWidth === null || typeof maxWidth === 'number',
        'maxWidth should be null (no constraint) or a number' );
      if ( this._maxWidth !== maxWidth ) {
        this.onMaxDimensionChange( this._maxWidth, maxWidth );
        this._maxWidth = maxWidth;
        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxWidth( value ) { this.setMaxWidth( value ); },
    getMaxWidth: function() {
      return this._maxWidth;
    },
    get maxWidth() { return this.getMaxWidth(); },
    setMaxHeight: function( maxHeight ) {
      assert && assert( maxHeight === null || typeof maxHeight === 'number',
        'maxHeight should be null (no constraint) or a number' );
      if ( this._maxHeight !== maxHeight ) {
        this.onMaxDimensionChange( this._maxHeight, maxHeight );
        this._maxHeight = maxHeight;
        this.updateMaxDimension( this._localBounds );
      }
    },
    set maxHeight( value ) { this.setMaxHeight( value ); },
    getMaxHeight: function() {
      return this._maxHeight;
    },
    get maxHeight() { return this.getMaxHeight(); },
    setLeft: function( left ) {
      assert && assert( typeof left === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting left is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( left - this.getLeft(), 0, true );
      return this; // allow chaining
    },
    set left( value ) { this.setLeft( value ); },
    getLeft: function() {
      return this.getBounds().minX;
    },
    get left() { return this.getLeft(); },
    setRight: function( right ) {
      assert && assert( typeof right === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting right is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( right - this.getRight(), 0, true );
      return this; // allow chaining
    },
    set right( value ) { this.setRight( value ); },
    getRight: function() {
      return this.getBounds().maxX;
    },
    get right() { return this.getRight(); },
    setCenterX: function( x ) {
      assert && assert( typeof x === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerX is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( x - this.getCenterX(), 0, true );
      return this; // allow chaining
    },
    set centerX( value ) { this.setCenterX( value ); },
    getCenterX: function() {
      return this.getBounds().getCenterX();
    },
    get centerX() { return this.getCenterX(); },
    setCenterY: function( y ) {
      assert && assert( typeof y === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerY is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( 0, y - this.getCenterY(), true );
      return this; // allow chaining
    },
    set centerY( value ) { this.setCenterY( value ); },
    getCenterY: function() {
      return this.getBounds().getCenterY();
    },
    get centerY() { return this.getCenterY(); },
    setTop: function( top ) {
      assert && assert( typeof top === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting top is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( 0, top - this.getTop(), true );
      return this; // allow chaining
    },
    set top( value ) { this.setTop( value ); },
    getTop: function() {
      return this.getBounds().minY;
    },
    get top() { return this.getTop(); },
    setBottom: function( bottom ) {
      assert && assert( typeof bottom === 'number' );
      assert && assert( this.getBounds().isValid(),
        'Setting bottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( 0, bottom - this.getBottom(), true );
      return this; // allow chaining
    },
    set bottom( value ) { this.setBottom( value ); },
    getBottom: function() {
      return this.getBounds().maxY;
    },
    get bottom() { return this.getBottom(); },
    setLeftTop: function( leftTop ) {
      assert && assert( leftTop instanceof Vector2 && leftTop.isFinite(), 'leftTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( leftTop.minus( this.getLeftTop() ), true );
      return this;
    },
    set leftTop( value ) { this.setLeftTop( value ); },
    getLeftTop: function() {
      return this.getBounds().getLeftTop();
    },
    get leftTop() { return this.getLeftTop(); },
    setCenterTop: function( centerTop ) {
      assert && assert( centerTop instanceof Vector2 && centerTop.isFinite(), 'centerTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( centerTop.minus( this.getCenterTop() ), true );
      return this;
    },
    set centerTop( value ) { this.setCenterTop( value ); },
    getCenterTop: function() {
      return this.getBounds().getCenterTop();
    },
    get centerTop() { return this.getCenterTop(); },
    setRightTop: function( rightTop ) {
      assert && assert( rightTop instanceof Vector2 && rightTop.isFinite(), 'rightTop should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightTop is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( rightTop.minus( this.getRightTop() ), true );
      return this;
    },
    set rightTop( value ) { this.setRightTop( value ); },
    getRightTop: function() {
      return this.getBounds().getRightTop();
    },
    get rightTop() { return this.getRightTop(); },
    setLeftCenter: function( leftCenter ) {
      assert && assert( leftCenter instanceof Vector2 && leftCenter.isFinite(), 'leftCenter should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftCenter is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( leftCenter.minus( this.getLeftCenter() ), true );
      return this;
    },
    set leftCenter( value ) { this.setLeftCenter( value ); },
    getLeftCenter: function() {
      return this.getBounds().getLeftCenter();
    },
    get leftCenter() { return this.getLeftCenter(); },
    setCenter: function( center ) {
      assert && assert( center instanceof Vector2 && center.isFinite(), 'center should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting center is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( center.minus( this.getCenter() ), true );
      return this;
    },
    set center( value ) { this.setCenter( value ); },
    getCenter: function() {
      return this.getBounds().getCenter();
    },
    get center() { return this.getCenter(); },
    setRightCenter: function( rightCenter ) {
      assert && assert( rightCenter instanceof Vector2 && rightCenter.isFinite(), 'rightCenter should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightCenter is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( rightCenter.minus( this.getRightCenter() ), true );
      return this;
    },
    set rightCenter( value ) { this.setRightCenter( value ); },
    getRightCenter: function() {
      return this.getBounds().getRightCenter();
    },
    get rightCenter() { return this.getRightCenter(); },
    setLeftBottom: function( leftBottom ) {
      assert && assert( leftBottom instanceof Vector2 && leftBottom.isFinite(), 'leftBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting leftBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( leftBottom.minus( this.getLeftBottom() ), true );
      return this;
    },
    set leftBottom( value ) { this.setLeftBottom( value ); },
    getLeftBottom: function() {
      return this.getBounds().getLeftBottom();
    },
    get leftBottom() { return this.getLeftBottom(); },
    setCenterBottom: function( centerBottom ) {
      assert && assert( centerBottom instanceof Vector2 && centerBottom.isFinite(), 'centerBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting centerBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( centerBottom.minus( this.getCenterBottom() ), true );
      return this;
    },
    set centerBottom( value ) { this.setCenterBottom( value ); },
    getCenterBottom: function() {
      return this.getBounds().getCenterBottom();
    },
    get centerBottom() { return this.getCenterBottom(); },
    setRightBottom: function( rightBottom ) {
      assert && assert( rightBottom instanceof Vector2 && rightBottom.isFinite(), 'rightBottom should be a finite Vector2' );
      assert && assert( this.getBounds().isValid(),
        'Setting rightBottom is invalid when the node has invalid (empty/NaN/infinite) bounds.' );
      this.translate( rightBottom.minus( this.getRightBottom() ), true );
      return this;
    },
    set rightBottom( value ) { this.setRightBottom( value ); },
    getRightBottom: function() {
      return this.getBounds().getRightBottom();
    },
    get rightBottom() { return this.getRightBottom(); },
    getWidth: function() {
      return this.getBounds().getWidth();
    },
    get width() { return this.getWidth(); },
    getHeight: function() {
      return this.getBounds().getHeight();
    },
    get height() { return this.getHeight(); },
    getId: function() {
      return this._id;
    },
    get id() { return this.getId(); },
    setVisible: function( visible ) {
      assert && assert( typeof visible === 'boolean' );
      if ( visible !== this._visible ) {
        this._visible = visible;
        this._picker.onVisibilityChange();
        if ( assertSlow ) { this._picker.audit(); }
        this.trigger0( 'visibility' );
      }
      return this;
    },
    set visible( value ) { this.setVisible( value ); },
    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },
    setOpacity: function( opacity ) {
      assert && assert( typeof opacity === 'number' && isFinite( opacity ), 'opacity should be a finite number' );
      var clampedOpacity = clamp( opacity, 0, 1 );
      if ( clampedOpacity !== this._opacity ) {
        this._opacity = clampedOpacity;
        this.trigger0( 'opacity' );
      }
    },
    set opacity( value ) { this.setOpacity( value ); },
    getOpacity: function() {
      return this._opacity;
    },
    get opacity() { return this.getOpacity(); },
    setPickable: function( pickable ) {
      assert && assert( pickable === null || typeof pickable === 'boolean' );
      if ( this._pickable !== pickable ) {
        var oldPickable = this._pickable;
        this._pickable = pickable;
        this._picker.onPickableChange( oldPickable, pickable );
        if ( assertSlow ) { this._picker.audit(); }
        this.trigger0( 'pickability' );
      }
    },
    set pickable( value ) { this.setPickable( value ); },
    isPickable: function() {
      return this._pickable;
    },
    get pickable() { return this.isPickable(); },
    setInputEnabled: function( inputEnabled ) {
      assert && assert( typeof inputEnabled === 'boolean' );
      if ( this._inputEnabled !== inputEnabled ) {
        this._inputEnabled = inputEnabled;
        this.trigger0( 'inputEnabled' );
      }
    },
    set inputEnabled( value ) { this.setInputEnabled( value ); },
    isInputEnabled: function() {
      return this._inputEnabled;
    },
    get inputEnabled() { return this.isInputEnabled(); },
    setInputListeners: function( inputListeners ) {
      assert && assert( inputListeners instanceof Array );
      while ( this._inputListeners.length ) {
        this.removeInputListener( this._inputListeners[ 0 ] );
      }
      for ( var i = 0; i < inputListeners.length; i++ ) {
        this.addInputListener( inputListeners[ i ] );
      }
      return this;
    },
    set inputListeners( value ) { this.setInputListeners( value ); },
    getInputListeners: function() {
      return this._inputListeners.slice( 0 ); // defensive copy
    },
    get inputListeners() { return this.getInputListeners(); },
    setCursor: function( cursor ) {
      assert && assert( typeof cursor === 'string' || cursor === null );
      this._cursor = cursor === 'auto' ? null : cursor;
    },
    set cursor( value ) { this.setCursor( value ); },
    getCursor: function() {
      return this._cursor;
    },
    get cursor() { return this.getCursor(); },
    setMouseArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'mouseArea needs to be a kite.Shape, dot.Bounds2, or null' );
      if ( this._mouseArea !== area ) {
        this._mouseArea = area; // TODO: could change what is under the mouse, invalidate!
        this._picker.onMouseAreaChange();
        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set mouseArea( value ) { this.setMouseArea( value ); },
    getMouseArea: function() {
      return this._mouseArea;
    },
    get mouseArea() { return this.getMouseArea(); },
    setTouchArea: function( area ) {
      assert && assert( area === null || area instanceof Shape || area instanceof Bounds2, 'touchArea needs to be a kite.Shape, dot.Bounds2, or null' );
      if ( this._touchArea !== area ) {
        this._touchArea = area; // TODO: could change what is under the touch, invalidate!
        this._picker.onTouchAreaChange();
        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set touchArea( value ) { this.setTouchArea( value ); },
    getTouchArea: function() {
      return this._touchArea;
    },
    get touchArea() { return this.getTouchArea(); },
    setClipArea: function( shape ) {
      assert && assert( shape === null || shape instanceof Shape, 'clipArea needs to be a kite.Shape, or null' );
      if ( this._clipArea !== shape ) {
        this._clipArea = shape;
        this.trigger0( 'clip' );
        this.invalidateBounds();
        this._picker.onClipAreaChange();
        if ( assertSlow ) { this._picker.audit(); }
      }
    },
    set clipArea( value ) { this.setClipArea( value ); },
    getClipArea: function() {
      return this._clipArea;
    },
    get clipArea() { return this.getClipArea(); },
    hasClipArea: function() {
      return this._clipArea !== null;
    },
    setAccessibleOrder: function( accessibleOrder ) {
      assert && assert( accessibleOrder === null || accessibleOrder instanceof Array );
      if ( this._accessibleOrder !== accessibleOrder ) {
        this._accessibleOrder = accessibleOrder;
        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleOrder( trail );
          }
        }
        this.trigger0( 'accessibleOrder' );
      }
    },
    set accessibleOrder( value ) { this.setAccessibleOrder( value ); },
    getAccessibleOrder: function() {
      return this._accessibleOrder;
    },
    get accessibleOrder() { return this.getAccessibleOrder(); },
    setAccessibleContent: function( accessibleContent ) {
      assert && assert( accessibleContent === null || accessibleContent instanceof Object );
      if ( this._accessibleContent !== accessibleContent ) {
        var oldAccessibleContent = this._accessibleContent;
        this._accessibleContent = accessibleContent;
        var trails = this.getTrails( hasRootedDisplayPredicate );
        for ( var i = 0; i < trails.length; i++ ) {
          var trail = trails[ i ];
          var rootedDisplays = trail.rootNode()._rootedDisplays;
          for ( var j = 0; j < rootedDisplays.length; j++ ) {
            rootedDisplays[ j ].changedAccessibleContent( trail, oldAccessibleContent, accessibleContent );
          }
        }
        this.trigger0( 'accessibleContent' );
      }
    },
    set accessibleContent( value ) { this.setAccessibleContent( value ); },
    getAccessibleContent: function() {
      return this._accessibleContent;
    },
    get accessibleContent() { return this.getAccessibleContent(); },
    setRendererBitmask: function( bitmask ) {
      assert && assert( typeof bitmask === 'number' && isFinite( bitmask ) );
      if ( bitmask !== this._rendererBitmask ) {
        this._rendererBitmask = bitmask;
        this._rendererSummary.selfChange();
        this.trigger0( 'rendererBitmask' );
      }
    },
    invalidateSupportedRenderers: function() {
    },
    setRenderer: function( renderer ) {
      assert && assert( renderer === null || renderer === 'canvas' || renderer === 'svg' || renderer === 'dom' || renderer === 'webgl',
        'Renderer input should be null, or one of: "canvas", "svg", "dom" or "webgl".' );
      var newRenderer = 0;
      if ( renderer === 'canvas' ) {
        newRenderer = Renderer.bitmaskCanvas;
      }
      else if ( renderer === 'svg' ) {
        newRenderer = Renderer.bitmaskSVG;
      }
      else if ( renderer === 'dom' ) {
        newRenderer = Renderer.bitmaskDOM;
      }
      else if ( renderer === 'webgl' ) {
        newRenderer = Renderer.bitmaskWebGL;
      }
      assert && assert( ( renderer === null ) === ( newRenderer === 0 ),
        'We should only end up with no actual renderer if renderer is null' );
      if ( this._hints.renderer !== newRenderer ) {
        this._hints.renderer = newRenderer;
        this.trigger1( 'hint', 'renderer' );
      }
    },
    set renderer( value ) { this.setRenderer( value ); },
    getRenderer: function() {
      if ( this._hints.renderer === 0 ) {
        return null;
      }
      else if ( this._hints.renderer === Renderer.bitmaskCanvas ) {
        return 'canvas';
      }
      else if ( this._hints.renderer === Renderer.bitmaskSVG ) {
        return 'svg';
      }
      else if ( this._hints.renderer === Renderer.bitmaskDOM ) {
        return 'dom';
      }
      else if ( this._hints.renderer === Renderer.bitmaskWebGL ) {
        return 'webgl';
      }
      assert && assert( false, 'Seems to be an invalid renderer?' );
      return this._hints.renderer;
    },
    get renderer() { return this.getRenderer(); },
    setLayerSplit: function( split ) {
      assert && assert( typeof split === 'boolean' );
      if ( split !== this._hints.layerSplit ) {
        this._hints.layerSplit = split;
        this.trigger1( 'hint', 'layerSplit' );
      }
    },
    set layerSplit( value ) { this.setLayerSplit( value ); },
    isLayerSplit: function() {
      return this._hints.layerSplit;
    },
    get layerSplit() { return this.isLayerSplit(); },
    setUsesOpacity: function( usesOpacity ) {
      assert && assert( typeof usesOpacity === 'boolean' );
      if ( usesOpacity !== this._hints.usesOpacity ) {
        this._hints.usesOpacity = usesOpacity;
        this.trigger1( 'hint', 'usesOpacity' );
      }
    },
    set usesOpacity( value ) { this.setUsesOpacity( value ); },
    getUsesOpacity: function() {
      return this._hints.usesOpacity;
    },
    get usesOpacity() { return this.getUsesOpacity(); },
    setCSSTransform: function( cssTransform ) {
      assert && assert( typeof cssTransform === 'boolean' );
      if ( cssTransform !== this._hints.cssTransform ) {
        this._hints.cssTransform = cssTransform;
        this.trigger1( 'hint', 'cssTransform' );
      }
    },
    set cssTransform( value ) { this.setCSSTransform( value ); },
    isCSSTransformed: function() {
      return this._hints.cssTransform;
    },
    get cssTransform() { return this._hints.cssTransform; },
    setExcludeInvisible: function( excludeInvisible ) {
      assert && assert( typeof excludeInvisible === 'boolean' );
      if ( excludeInvisible !== this._hints.excludeInvisible ) {
        this._hints.excludeInvisible = excludeInvisible;
        this.trigger1( 'hint', 'excludeInvisible' );
      }
    },
    set excludeInvisible( value ) { this.setExcludeInvisible( value ); },
    isExcludeInvisible: function() {
      return this._hints.excludeInvisible;
    },
    get excludeInvisible() { return this.isExcludeInvisible(); },
    setPreventFit: function( preventFit ) {
      assert && assert( typeof preventFit === 'boolean' );
      if ( preventFit !== this._hints.preventFit ) {
        this._hints.preventFit = preventFit;
        this.trigger1( 'hint', 'preventFit' );
      }
    },
    set preventFit( value ) { this.setPreventFit( value ); },
    isPreventFit: function() {
      return this._hints.preventFit;
    },
    get preventFit() { return this.isPreventFit(); },
    setWebGLScale: function( webglScale ) {
      assert && assert( webglScale === null || ( typeof webglScale === 'number' && isFinite( webglScale ) ) );
      if ( webglScale !== this._hints.webglScale ) {
        this._hints.webglScale = webglScale;
        this.trigger1( 'hint', 'webglScale' );
      }
    },
    set webglScale( value ) { this.setWebGLScale( value ); },
    getWebGLScale: function() {
      return this._hints.webglScale;
    },
    get webglScale() { return this.getWebGLScale(); },
    setPhetioType: function( phetioType ) {
      assert && assert( typeof phetioType === 'function', 'phetioValue should be a function' );
      if ( this._phetioType !== TNode ) {
        assert && assert( phetioType === this._phetioType, 'Node cannot be given multiple phetioTypes' );
      }
      this._phetioType = phetioType;
      return this; // for chaining
    },
    set phetioType( value ) { this.setPhetioType( value ); },
    getPhetioType: function() {
      return this._phetioType;
    },
    get phetioType() { return this.getPhetioType(); },
    setTandem: function( tandem ) {
      assert && assert( tandem instanceof Tandem );
      if ( tandem !== this._tandem ) {
        assert && assert( !this._tandem || this._tandem.id === tandem.id,
          'Node cannot be given multiple tandems with different IDs' );
        this._tandem = tandem;
        this._tandem.addInstance( this, this._phetioType );
      }
      return this; // for chaining
    },
    set tandem( value ) { this.setTandem( value ); },
    getTandem: function() {
      return this._tandem;
    },
    get tandem() { return this.getTandem(); },
    getUniqueTrail: function( predicate ) {
      if ( !predicate ) {
        var trail = new scenery.Trail();
        var node = this; // eslint-disable-line consistent-this
        while ( node ) {
          assert && assert( node._parents.length <= 1,
            'getUniqueTrail found a node with ' + node._parents.length + ' parents.' );
          trail.addAncestor( node );
          node = node._parents[ 0 ]; // should be undefined if there aren't any parents
        }
        return trail;
      }
      else {
        var trails = this.getTrails( predicate );
        assert && assert( trails.length === 1,
          'getUniqueTrail found ' + trails.length + ' matching trails for the predicate' );
        return trails[ 0 ];
      }
    },
    getUniqueTrailTo: function( rootNode ) {
      return this.getUniqueTrail( function( node ) {
        return rootNode === node;
      } );
    },
    getTrails: function( predicate ) {
      predicate = predicate || defaultTrailPredicate;
      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendAncestorTrailsWithPredicate( trails, trail, predicate );
      return trails;
    },
    getTrailsTo: function( rootNode ) {
      return this.getTrails( function( node ) {
        return node === rootNode;
      } );
    },
    getLeafTrails: function( predicate ) {
      predicate = predicate || defaultLeafTrailPredicate;
      var trails = [];
      var trail = new scenery.Trail( this );
      scenery.Trail.appendDescendantTrailsWithPredicate( trails, trail, predicate );
      return trails;
    },
    getLeafTrailsTo: function( leafNode ) {
      return this.getLeafTrails( function( node ) {
        return node === leafNode;
      } );
    },
    getUniqueLeafTrail: function( predicate ) {
      var trails = this.getLeafTrails( predicate );
      assert && assert( trails.length === 1,
        'getUniqueLeafTrail found ' + trails.length + ' matching trails for the predicate' );
      return trails[ 0 ];
    },
    getUniqueLeafTrailTo: function( leafNode ) {
      return this.getUniqueLeafTrail( function( node ) {
        return node === leafNode;
      } );
    },
    getConnectedNodes: function() {
      var result = [];
      var fresh = this._children.concat( this._parents ).concat( this );
      while ( fresh.length ) {
        var node = fresh.pop();
        if ( !_.includes( result, node ) ) {
          result.push( node );
          fresh = fresh.concat( node._children, node._parents );
        }
      }
      return result;
    },
    getNestedAccessibleOrder: function() {
      var currentTrail = new scenery.Trail( this );
      var pruneStack = []; // {Array.<Node>} - A list of nodes to prune
      var result = [];
      var nestedChildStack = [ result ];
      function addTrailsForNode( node, overridePruning ) {
        var pruneCount = 0;
        _.each( pruneStack, function( pruneNode ) {
          if ( node === pruneNode ) {
            pruneCount++;
          }
        } );
        if ( pruneCount > 1 || ( pruneCount === 1 && !overridePruning ) ) {
          return;
        }
        if ( node.accessibleContent ) {
          var item = {
            trail: currentTrail.copy(),
            children: []
          };
          nestedChildStack[ nestedChildStack.length - 1 ].push( item );
          nestedChildStack.push( item.children );
        }
        if ( node._accessibleOrder ) {
          pruneStack = pruneStack.concat( node._accessibleOrder );
          _.each( node._accessibleOrder, function( descendant ) {
            _.each( node.getLeafTrailsTo( descendant ), function( descendantTrail ) {
              descendantTrail.removeAncestor(); // strip off 'node', so that we handle only children
              currentTrail.addDescendantTrail( descendantTrail );
              addTrailsForNode( descendant, true ); // 'true' overrides one reference in the prune stack (added above)
              currentTrail.removeDescendantTrail( descendantTrail );
            } );
          } );
        }
        var numChildren = node._children.length;
        for ( var i = 0; i < numChildren; i++ ) {
          var child = node._children[ i ];
          currentTrail.addDescendant( child, i );
          addTrailsForNode( child, false );
          currentTrail.removeDescendant();
        }
        if ( node._accessibleOrder ) {
          _.each( node._accessibleOrder, function( descendant ) {
            pruneStack.pop();
          } );
        }
        if ( node.accessibleContent ) {
          nestedChildStack.pop();
        }
      }
      addTrailsForNode( this, false );
      return result;
    },
    getTopologicallySortedNodes: function() {
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes(), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length ) {
          s.push( node );
        }
      } );
      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          s.push( m );
        }
      }
      while ( s.length ) {
        n = s.pop();
        l.push( n );
        _.each( n._children, handleChild );
      }
      assert && assert( _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } ), 'circular reference check' );
      return l;
    },
    canAddChild: function( child ) {
      if ( this === child || _.includes( this._children, child ) ) {
        return false;
      }
      var edges = {};
      var s = [];
      var l = [];
      var n;
      _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {
        edges[ node.id ] = {};
        _.each( node._children, function( m ) {
          edges[ node.id ][ m.id ] = true;
        } );
        if ( !node.parents.length && node !== child ) {
          s.push( node );
        }
      } );
      edges[ this.id ][ child.id ] = true; // add in our 'new' edge
      function handleChild( m ) {
        delete edges[ n.id ][ m.id ];
        if ( _.every( edges, function( children ) { return !children[ m.id ]; } ) ) {
          s.push( m );
        }
      }
      while ( s.length ) {
        n = s.pop();
        l.push( n );
        _.each( n._children, handleChild );
        if ( n === this ) {
          handleChild( child );
        }
      }
      return _.every( edges, function( children ) {
        return _.every( children, function( final ) { return false; } );
      } );
    },
    canvasPaintSelf: function( wrapper ) {
    },
    renderToCanvasSelf: function( wrapper, matrix ) {
      if ( this.isPainted() && ( this._rendererBitmask & Renderer.bitmaskCanvas ) ) {
        this.canvasPaintSelf( wrapper );
      }
    },
    renderToCanvasSubtree: function( wrapper, matrix ) {
      matrix = matrix || Matrix3.identity();
      wrapper.resetStyles();
      this.renderToCanvasSelf( wrapper, matrix );
      for ( var i = 0; i < this._children.length; i++ ) {
        var child = this._children[ i ];
        if ( child.isVisible() ) {
          var requiresScratchCanvas = child._opacity !== 1 || child._clipArea;
          wrapper.context.save();
          matrix.multiplyMatrix( child._transform.getMatrix() );
          matrix.canvasSetTransform( wrapper.context );
          if ( requiresScratchCanvas ) {
            var canvas = document.createElement( 'canvas' );
            canvas.width = wrapper.canvas.width;
            canvas.height = wrapper.canvas.height;
            var context = canvas.getContext( '2d' );
            var childWrapper = new scenery.CanvasContextWrapper( canvas, context );
            matrix.canvasSetTransform( context );
            child.renderToCanvasSubtree( childWrapper, matrix );
            wrapper.context.save();
            if ( child._clipArea ) {
              wrapper.context.beginPath();
              child._clipArea.writeToContext( wrapper.context );
              wrapper.context.clip();
            }
            wrapper.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
            wrapper.context.globalAlpha = child._opacity;
            wrapper.context.drawImage( canvas, 0, 0 );
            wrapper.context.restore();
          }
          else {
            child.renderToCanvasSubtree( wrapper, matrix );
          }
          matrix.multiplyMatrix( child._transform.getInverse() );
          wrapper.context.restore();
        }
      }
    },
    renderToCanvas: function( canvas, context, callback, backgroundColor ) {
      canvas.width = canvas.width;
      if ( backgroundColor ) {
        context.fillStyle = backgroundColor;
        context.fillRect( 0, 0, canvas.width, canvas.height );
      }
      var wrapper = new scenery.CanvasContextWrapper( canvas, context );
      this.renderToCanvasSubtree( wrapper, Matrix3.identity() );
      callback && callback(); // this was originally asynchronous, so we had a callback
    },
    toCanvas: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      var padding = 2; // padding used if x and y are not set
      var bounds = this.getBounds().union( this.localToParentBounds( this.getSafeSelfBounds() ) );
      assert && assert( !bounds.isEmpty() ||
                        ( x !== undefined && y !== undefined && width !== undefined && height !== undefined ),
        'Should not call toCanvas on a Node with empty bounds, unless all dimensions are provided' );
      x = x !== undefined ? x : Math.ceil( padding - bounds.minX );
      y = y !== undefined ? y : Math.ceil( padding - bounds.minY );
      width = width !== undefined ? width : Math.ceil( bounds.getWidth() + 2 * padding );
      height = height !== undefined ? height : Math.ceil( bounds.getHeight() + 2 * padding );
      var canvas = document.createElement( 'canvas' );
      canvas.width = width;
      canvas.height = height;
      var context = canvas.getContext( '2d' );
      context.translate( x, y );
      this._transform.getMatrix().canvasAppendTransform( context );
      var wrapper = new scenery.CanvasContextWrapper( canvas, context );
      this.renderToCanvasSubtree( wrapper, Matrix3.translation( x, y ).timesMatrix( this._transform.getMatrix() ) );
      callback( canvas, x, y, width, height ); // we used to be asynchronous
    },
    toDataURL: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      this.toCanvas( function( canvas, x, y, width, height ) {
        callback( canvas.toDataURL(), x, y, width, height );
      }, x, y, width, height );
    },
    toImage: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      this.toDataURL( function( url, x, y ) {
        var img = document.createElement( 'img' );
        img.onload = function() {
          callback( img, x, y );
          try {
            delete img.onload;
          }
          catch( e ) {
          } // fails on Safari 5.1
        };
        img.src = url;
      }, x, y, width, height );
    },
    toImageNodeAsynchronous: function( callback, x, y, width, height ) {
      assert && assert( typeof callback === 'function' );
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      this.toImage( function( image, x, y ) {
        callback( new scenery.Node( {
          children: [
            new scenery.Image( image, { x: -x, y: -y } )
          ]
        } ) );
      }, x, y, width, height );
    },
    toCanvasNodeSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      var result = null;
      this.toCanvas( function( canvas, x, y ) {
        result = new scenery.Node( {
          children: [
            new scenery.Image( canvas, { x: -x, y: -y } )
          ]
        } );
      }, x, y, width, height );
      assert && assert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );
      return result;
    },
    toDataURLImageSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      var result;
      this.toDataURL( function( dataURL, x, y, width, height ) {
        result = new scenery.Image( dataURL, { x: -x, y: -y, initialWidth: width, initialHeight: height } );
      }, x, y, width, height );
      assert && assert( result, 'toDataURL failed to return a result synchronously' );
      return result;
    },
    toDataURLNodeSynchronous: function( x, y, width, height ) {
      assert && assert( x === undefined || typeof x === 'number', 'If provided, x should be a number' );
      assert && assert( y === undefined || typeof y === 'number', 'If provided, y should be a number' );
      assert && assert( width === undefined || ( typeof width === 'number' && width >= 0 && ( width % 1 === 0 ) ),
        'If provided, width should be a non-negative integer' );
      assert && assert( height === undefined || ( typeof height === 'number' && height >= 0 && ( height % 1 === 0 ) ),
        'If provided, height should be a non-negative integer' );
      return new scenery.Node( {
        children: [
          this.toDataURLImageSynchronous( x, y, width, height )
        ]
      } );
    },
    createDOMDrawable: function( renderer, instance ) {
      throw new Error( 'createDOMDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },
    createSVGDrawable: function( renderer, instance ) {
      throw new Error( 'createSVGDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },
    createCanvasDrawable: function( renderer, instance ) {
      throw new Error( 'createCanvasDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },
    createWebGLDrawable: function( renderer, instance ) {
      throw new Error( 'createWebGLDrawable is abstract. The subtype should either override this method, or not support the DOM renderer' );
    },
    getInstances: function() {
      return this._instances;
    },
    get instances() { return this.getInstances(); },
    addInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      this._instances.push( instance );
    },
    removeInstance: function( instance ) {
      assert && assert( instance instanceof scenery.Instance );
      var index = _.indexOf( this._instances, instance );
      assert && assert( index !== -1, 'Cannot remove a Instance from a Node if it was not there' );
      this._instances.splice( index, 1 );
    },
    getAccessibleInstances: function() {
      return this._accessibleInstances;
    },
    get accessibleInstances() { return this.getAccessibleInstances(); },
    addAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      this._accessibleInstances.push( accessibleInstance );
    },
    removeAccessibleInstance: function( accessibleInstance ) {
      assert && assert( accessibleInstance instanceof scenery.AccessibleInstance );
      var index = _.indexOf( this._accessibleInstances, accessibleInstance );
      assert && assert( index !== -1, 'Cannot remove an AccessibleInstance from a Node if it was not there' );
      this._accessibleInstances.splice( index, 1 );
    },
    getRootedDisplays: function() {
      return this._rootedDisplays;
    },
    get rootedDisplays() { return this.getRootedDisplays(); },
    addRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      this._rootedDisplays.push( display );
    },
    removeRootedDisplay: function( display ) {
      assert && assert( display instanceof scenery.Display );
      var index = _.indexOf( this._rootedDisplays, display );
      assert && assert( index !== -1, 'Cannot remove a Display from a Node if it was not there' );
      this._rootedDisplays.splice( index, 1 );
    },
    localToParentPoint: function( point ) {
      return this._transform.transformPosition2( point );
    },
    localToParentBounds: function( bounds ) {
      return this._transform.transformBounds2( bounds );
    },
    parentToLocalPoint: function( point ) {
      return this._transform.inversePosition2( point );
    },
    parentToLocalBounds: function( bounds ) {
      return this._transform.inverseBounds2( bounds );
    },
    transformBoundsFromLocalToParent: function( bounds ) {
      return bounds.transform( this._transform.getMatrix() );
    },
    transformBoundsFromParentToLocal: function( bounds ) {
      return bounds.transform( this._transform.getInverse() );
    },
    getLocalToGlobalMatrix: function() {
      var node = this; // eslint-disable-line consistent-this
      var matrices = [];
      while ( node ) {
        matrices.push( node._transform.getMatrix() );
        assert && assert( node._parents[ 1 ] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );
        node = node._parents[ 0 ];
      }
      var matrix = Matrix3.identity(); // will be modified in place
      for ( var i = matrices.length - 1; i >= 0; i-- ) {
        matrix.multiplyMatrix( matrices[ i ] );
      }
      return matrix;
    },
    getUniqueTransform: function() {
      return new Transform3( this.getLocalToGlobalMatrix() );
    },
    getGlobalToLocalMatrix: function() {
      return this.getLocalToGlobalMatrix().invert();
    },
    localToGlobalPoint: function( point ) {
      var node = this; // eslint-disable-line consistent-this
      var resultPoint = point.copy();
      while ( node ) {
        node._transform.getMatrix().multiplyVector2( resultPoint );
        assert && assert( node._parents[ 1 ] === undefined, 'localToGlobalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }
      return resultPoint;
    },
    globalToLocalPoint: function( point ) {
      var node = this; // eslint-disable-line consistent-this
      var transforms = [];
      while ( node ) {
        transforms.push( node._transform );
        assert && assert( node._parents[ 1 ] === undefined, 'globalToLocalPoint unable to work for DAG' );
        node = node._parents[ 0 ];
      }
      var resultPoint = point.copy();
      for ( var i = transforms.length - 1; i >= 0; i-- ) {
        transforms[ i ].getInverse().multiplyVector2( resultPoint );
      }
      return resultPoint;
    },
    localToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getLocalToGlobalMatrix() );
    },
    globalToLocalBounds: function( bounds ) {
      return bounds.transformed( this.getGlobalToLocalMatrix() );
    },
    parentToGlobalPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalPoint( point ) : point;
    },
    parentToGlobalBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].localToGlobalBounds( bounds ) : bounds;
    },
    globalToParentPoint: function( point ) {
      assert && assert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalPoint( point ) : point;
    },
    globalToParentBounds: function( bounds ) {
      assert && assert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );
      return this.parents.length ? this.parents[ 0 ].globalToLocalBounds( bounds ) : bounds;
    },
    getGlobalBounds: function() {
      assert && assert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );
      return this.parentToGlobalBounds( this.getBounds() );
    },
    get globalBounds() { return this.getGlobalBounds(); },
    boundsOf: function( node ) {
      return this.globalToLocalBounds( node.getGlobalBounds() );
    },
    boundsTo: function( node ) {
      return node.globalToLocalBounds( this.getGlobalBounds() );
    },
    attachDrawable: function( drawable ) {
      this._drawables.push( drawable );
      return this; // allow chaining
    },
    detachDrawable: function( drawable ) {
      var index = _.indexOf( this._drawables, drawable );
      assert && assert( index >= 0, 'Invalid operation: trying to detach a non-referenced drawable' );
      this._drawables.splice( index, 1 ); // TODO: replace with a remove() function
      return this;
    },
    mutate: function( options ) {
      if ( !options ) {
        return this;
      }
      assert && assert( Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      if ( assert ) {
        assert && assert( _.filter( [ 'translation', 'x', 'left', 'right', 'centerX', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the x component, check ' + Object.keys( options ).join( ',' ) );
        assert && assert( _.filter( [ 'translation', 'y', 'top', 'bottom', 'centerY', 'centerTop', 'rightTop', 'leftCenter', 'center', 'rightCenter', 'leftBottom', 'centerBottom', 'rightBottom' ], function( key ) { return options[ key ] !== undefined; } ).length <= 1,
          'More than one mutation on this Node set the y component, check ' + Object.keys( options ).join( ',' ) );
      }
      var self = this;
      _.each( this._mutatorKeys, function( key ) {
        assert && assert( !options.hasOwnProperty( key ) || options[ key ] !== undefined || key === 'phetioType',
          'Undefined not allowed for Node key: ' + key );
        if ( options[ key ] !== undefined ) {
          var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );
          if ( descriptor && typeof descriptor.value === 'function' ) {
            self[ key ]( options[ key ] );
          }
          else {
            self[ key ] = options[ key ];
          }
        }
      } );
      return this; // allow chaining
    },
    isDisposed: function() {
      return this._isDisposed;
    },
    get disposed() { return this.isDisposed(); },
    getDebugHTMLExtras: function() {
      return '';
    },
    toString: function( spaces, includeChildren ) {
      spaces = spaces || '';
      var props = this.getPropString( spaces + '  ', includeChildren === undefined ? true : includeChildren );
      return spaces + this.getBasicConstructor( props ? ( '\n' + props + '\n' + spaces ) : '' );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Node( {' + propLines + '} )';
    },
    getPropString: function( spaces, includeChildren ) {
      var result = '';
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        }
        else {
          result += spaces + key + ': ' + value;
        }
      }
      if ( this._children.length && includeChildren ) {
        var childString = '';
        _.each( this._children, function( child ) {
          if ( childString ) {
            childString += ',\n';
          }
          childString += child.toString( spaces + '  ' );
        } );
        addProp( 'children', '[\n' + childString + '\n' + spaces + ']', true );
      }
      if ( this.cursor ) { addProp( 'cursor', this.cursor ); }
      if ( !this.visible ) { addProp( 'visible', this.visible ); }
      if ( this.pickable !== null ) { addProp( 'pickable', this.pickable ); }
      if ( this.opacity !== 1 ) { addProp( 'opacity', this.opacity ); }
      if ( !this.transform.isIdentity() ) {
        var m = this.transform.getMatrix();
        addProp( 'matrix', 'dot.Matrix3.createFromPool(' +
                           m.m00() + ', ' + m.m01() + ', ' + m.m02() + ', ' +
                           m.m10() + ', ' + m.m11() + ', ' + m.m12() + ', ' +
                           m.m20() + ', ' + m.m21() + ', ' + m.m22() + ' )', true );
      }
      if ( this.renderer ) {
        addProp( 'renderer', this.renderer );
      }
      if ( this._hints.layerSplit ) {
        addProp( 'layerSplit', true );
      }
      return result;
    },
    auditInstanceSubtreeForDisplay: function( display ) {
      if ( assertSlow ) {
        var numInstances = this._instances.length;
        for ( var i = 0; i < numInstances; i++ ) {
          var instance = this._instances[ i ];
          if ( instance.display === display ) {
            assertSlow( instance.trail.isValid(),
              'Invalid trail on Instance: ' + instance.toString() + ' with trail ' + instance.trail.toString() );
          }
        }
        this.children.forEach( function( child ) {
          child.auditInstanceSubtreeForDisplay( display );
        } );
      }
    },
    onEventListenerAdded: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( 1 );
        this._boundsEventSelfCount++;
      }
    },
    onEventListenerRemoved: function( eventName, listener ) {
      if ( eventName in eventsRequiringBoundsValidation ) {
        this.changeBoundsEventCount( -1 );
        this._boundsEventSelfCount--;
      }
    }
  }, Events.prototype, {
    on: function onOverride( eventName, listener ) {
      Events.prototype.on.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },
    onStatic: function onStaticOverride( eventName, listener ) {
      Events.prototype.onStatic.call( this, eventName, listener );
      this.onEventListenerAdded( eventName, listener );
    },
    off: function offOverride( eventName, listener ) {
      var index = Events.prototype.off.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.off was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    },
    offStatic: function offStaticOverride( eventName, listener ) {
      var index = Events.prototype.offStatic.call( this, eventName, listener );
      assert && assert( index >= 0, 'Node.offStatic was called but no listener was removed' );
      this.onEventListenerRemoved( eventName, listener );
      return index;
    },
    dispose: function() {
      this._isDisposed = true;
      this.removeAllChildren();
      this.detach();
      Events.prototype.dispose.call( this ); // TODO: don't rely on Events
      if ( this._tandem ) {
        this._tandem.removeInstance( this );
        this._tandem = null;
      }
    },
    disposeSubtree: function() {
      if ( !this.isDisposed() ) {
        var children = this.children;
        this.dispose();
        for ( var i = 0; i < children.length; i++ ) {
          children[ i ].disposeSubtree();
        }
      }
    }
  } ) );
  Accessibility.mixin( Node );
  return Node;
} );
define( 'SCENERY/util/Trail',['require','PHET_CORE/inherit','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/util/TrailPointer','SCENERY/nodes/Node'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/TrailPointer' );
  require( 'SCENERY/nodes/Node' );
  function Trail( nodes ) {
    if ( assert ) {
      this.immutable = undefined;
    }
    if ( nodes instanceof Trail ) {
      var otherTrail = nodes;
      this.nodes = otherTrail.nodes.slice( 0 );
      this.length = otherTrail.length;
      this.uniqueId = otherTrail.uniqueId;
      this.indices = otherTrail.indices.slice( 0 );
      return;
    }
    this.nodes = [];
    this.length = 0;
    this.uniqueId = '';
    this.indices = [];
    var self = this;
    if ( nodes ) {
      if ( nodes instanceof scenery.Node ) {
        var node = nodes;
        self.addDescendant( node );
      }
      else {
        var len = nodes.length;
        for ( var i = 0; i < len; i++ ) {
          self.addDescendant( nodes[ i ] );
        }
      }
    }
    phetAllocation && phetAllocation( 'Trail' );
  }
  scenery.register( 'Trail', Trail );
  inherit( Object, Trail, {
    copy: function() {
      return new Trail( this );
    },
    isPainted: function() {
      return this.lastNode().isPainted();
    },
    isValid: function() {
      this.reindex();
      var indexLength = this.indices.length;
      for ( var i = 0; i < indexLength; i++ ) {
        if ( this.indices[ i ] < 0 ) {
          return false;
        }
      }
      return true;
    },
    isVisible: function() {
      var i = this.nodes.length;
      while ( i-- ) {
        if ( !this.nodes[ i ].isVisible() ) {
          return false;
        }
      }
      return true;
    },
    getOpacity: function() {
      var opacity = 1;
      var i = this.nodes.length;
      while ( i-- ) {
        opacity *= this.nodes[ i ].getOpacity();
      }
      return opacity;
    },
    isPickable: function() {
      if ( _.some( this.nodes, function( node ) { return node.pickable === false || node.visible === false; } ) ) { return false; }
      if ( _.some( this.nodes, function( node ) { return node._inputListeners.length > 0 || node._pickable === true; } ) ) { return true; }
      if ( this.lastNode()._picker._subtreePickableCount > 0 ) {
        return true;
      }
      return false;
    },
    get: function( index ) {
      if ( index >= 0 ) {
        return this.nodes[ index ];
      }
      else {
        return this.nodes[ this.nodes.length + index ];
      }
    },
    slice: function( startIndex, endIndex ) {
      return new Trail( this.nodes.slice( startIndex, endIndex ) );
    },
    subtrailTo: function( node, excludeNode ) {
      return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );
    },
    isEmpty: function() {
      return this.nodes.length === 0;
    },
    getMatrix: function() {
      var matrix = Matrix3.identity();
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },
    getAncestorMatrix: function() {
      var matrix = Matrix3.identity();
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 1; i < length; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },
    getParentMatrix: function() {
      var matrix = Matrix3.identity();
      var nodes = this.nodes;
      var length = nodes.length;
      for ( var i = 0; i < length - 1; i++ ) {
        matrix.multiplyMatrix( nodes[ i ].getMatrix() );
      }
      return matrix;
    },
    getTransform: function() {
      return new Transform3( this.getMatrix() );
    },
    getParentTransform: function() {
      return new Transform3( this.getParentMatrix() );
    },
    addAncestor: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );
      assert && assert( node, 'cannot add falsy value to a Trail' );
      if ( this.nodes.length ) {
        var oldRoot = this.nodes[ 0 ];
        this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );
      }
      this.nodes.unshift( node );
      this.length++;
      this.uniqueId = ( this.uniqueId ? node.id + '-' + this.uniqueId : node.id + '' );
      return this;
    },
    removeAncestor: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );
      this.nodes.shift();
      if ( this.indices.length ) {
        this.indices.shift();
      }
      this.length--;
      this.updateUniqueId();
      return this;
    },
    addDescendant: function( node, index ) {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );
      assert && assert( node, 'cannot add falsy value to a Trail' );
      if ( this.nodes.length ) {
        var parent = this.lastNode();
        this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );
      }
      this.nodes.push( node );
      this.length++;
      this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node.id : node.id + '' );
      return this;
    },
    removeDescendant: function() {
      assert && assert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );
      assert && assert( this.length > 0, 'cannot remove a Node from an empty trail' );
      this.nodes.pop();
      if ( this.indices.length ) {
        this.indices.pop();
      }
      this.length--;
      this.updateUniqueId();
      return this;
    },
    addDescendantTrail: function( trail ) {
      var length = trail.length;
      if ( length ) {
        this.addDescendant( trail.nodes[ 0 ] );
      }
      for ( var i = 1; i < length; i++ ) {
        this.addDescendant( trail.nodes[ i ], this.indices[ i - 1 ] );
      }
    },
    removeDescendantTrail: function( trail ) {
      var length = trail.length;
      for ( var i = length - 1; i >= 0; i-- ) {
        assert && assert( this.lastNode() === trail.nodes[ i ] );
        this.removeDescendant();
      }
    },
    reindex: function() {
      var length = this.length;
      for ( var i = 1; i < length; i++ ) {
        var currentIndex = this.indices[ i - 1 ];
        var baseNode = this.nodes[ i - 1 ];
        if ( baseNode._children[ currentIndex ] !== this.nodes[ i ] ) {
          this.indices[ i - 1 ] = _.indexOf( baseNode._children, this.nodes[ i ] );
        }
      }
    },
    setImmutable: function() {
      if ( assert ) {
        assert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );
        this.immutable = true;
      }
      return this; // allow chaining
    },
    setMutable: function() {
      if ( assert ) {
        assert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );
        this.immutable = false;
      }
      return this; // allow chaining
    },
    areIndicesValid: function() {
      for ( var i = 1; i < this.length; i++ ) {
        var currentIndex = this.indices[ i - 1 ];
        if ( this.nodes[ i - 1 ]._children[ currentIndex ] !== this.nodes[ i ] ) {
          return false;
        }
      }
      return true;
    },
    equals: function( other ) {
      if ( this.length !== other.length ) {
        return false;
      }
      for ( var i = 0; i < this.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }
      return true;
    },
    upToNode: function( node ) {
      var nodeIndex = _.indexOf( this.nodes, node );
      assert && assert( nodeIndex >= 0, 'Trail does not contain the node' );
      return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );
    },
    isExtensionOf: function( other, allowSameTrail ) {
      if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {
        return false;
      }
      for ( var i = 0; i < other.nodes.length; i++ ) {
        if ( this.nodes[ i ] !== other.nodes[ i ] ) {
          return false;
        }
      }
      return true;
    },
    getTransformTo: function( otherTrail ) {
      return new Transform3( this.getMatrixTo( otherTrail ) );
    },
    getMatrixTo: function( otherTrail ) {
      this.reindex();
      otherTrail.reindex();
      var branchIndex = this.getBranchIndexTo( otherTrail );
      var idx;
      var matrix = Matrix3.IDENTITY;
      for ( idx = this.length - 1; idx >= branchIndex; idx-- ) {
        matrix = this.nodes[ idx ].getMatrix().timesMatrix( matrix );
      }
      for ( idx = branchIndex; idx < otherTrail.length; idx++ ) {
        matrix = otherTrail.nodes[ idx ].getTransform().getInverse().timesMatrix( matrix );
      }
      return matrix;
    },
    getBranchIndexTo: function( otherTrail ) {
      assert && assert( this.nodes[ 0 ] === otherTrail.nodes[ 0 ], 'To get a branch index, the trails must have the same root' );
      var branchIndex;
      var min = Math.min( this.length, otherTrail.length );
      for ( branchIndex = 0; branchIndex < min; branchIndex++ ) {
        if ( this.nodes[ branchIndex ] !== otherTrail.nodes[ branchIndex ] ) {
          break;
        }
      }
      return branchIndex;
    },
    getLastInputEnabledIndex: function() {
      var trailStartIndex = -1;
      for ( var j = 0; j < this.length; j++ ) {
        if ( !this.nodes[ j ]._inputEnabled ) {
          break;
        }
        trailStartIndex = j;
      }
      return trailStartIndex;
    },
    getCursorCheckIndex: function() {
      var lastInputEnabledIndex = this.getLastInputEnabledIndex();
      if ( lastInputEnabledIndex + 1 < this.length ) {
        return lastInputEnabledIndex + 1;
      }
      else {
        return lastInputEnabledIndex;
      }
    },
    nodeFromTop: function( offset ) {
      return this.nodes[ this.length - 1 - offset ];
    },
    lastNode: function() {
      return this.nodeFromTop( 0 );
    },
    rootNode: function() {
      return this.nodes[ 0 ];
    },
    previous: function() {
      if ( this.nodes.length <= 1 ) {
        return null;
      }
      var top = this.nodeFromTop( 0 );
      var parent = this.nodeFromTop( 1 );
      var parentIndex = _.indexOf( parent._children, top );
      assert && assert( parentIndex !== -1 );
      var arr = this.nodes.slice( 0, this.nodes.length - 1 );
      if ( parentIndex === 0 ) {
        return new Trail( arr );
      }
      else {
        arr.push( parent._children[ parentIndex - 1 ] );
        while ( arr[ arr.length - 1 ]._children.length !== 0 ) {
          var last = arr[ arr.length - 1 ];
          arr.push( last._children[ last._children.length - 1 ] );
        }
        return new Trail( arr );
      }
    },
    previousPainted: function() {
      var result = this.previous();
      while ( result && !result.isPainted() ) {
        result = result.previous();
      }
      return result;
    },
    next: function() {
      var arr = this.nodes.slice( 0 );
      var top = this.nodeFromTop( 0 );
      if ( top._children.length > 0 ) {
        arr.push( top._children[ 0 ] );
        return new Trail( arr );
      }
      else {
        var depth = this.nodes.length - 1;
        while ( depth > 0 ) {
          var node = this.nodes[ depth ];
          var parent = this.nodes[ depth - 1 ];
          arr.pop(); // take off the node so we can add the next sibling if it exists
          var index = _.indexOf( parent._children, node );
          if ( index !== parent._children.length - 1 ) {
            arr.push( parent._children[ index + 1 ] );
            return new Trail( arr );
          }
          else {
            depth--;
          }
        }
        return null;
      }
    },
    nextPainted: function() {
      var result = this.next();
      while ( result && !result.isPainted() ) {
        result = result.next();
      }
      return result;
    },
    eachTrailUnder: function( callback ) {
      new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );
    },
    compare: function( other ) {
      assert && assert( !this.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( !other.isEmpty(), 'cannot compare with an empty trail' );
      assert && assert( this.nodes[ 0 ] === other.nodes[ 0 ], 'for Trail comparison, trails must have the same root node' );
      assertSlow && assertSlow( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );
      assertSlow && assertSlow( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );
      var minNodeIndex = Math.min( this.indices.length, other.indices.length );
      for ( var i = 0; i < minNodeIndex; i++ ) {
        if ( this.indices[ i ] !== other.indices[ i ] ) {
          if ( this.indices[ i ] < other.indices[ i ] ) {
            return -1;
          }
          else {
            return 1;
          }
        }
      }
      if ( this.nodes.length < other.nodes.length ) {
        return -1;
      }
      else if ( this.nodes.length > other.nodes.length ) {
        return 1;
      }
      else {
        return 0;
      }
    },
    isBefore: function( other ) {
      return this.compare( other ) === -1;
    },
    isAfter: function( other ) {
      return this.compare( other ) === 1;
    },
    localToGlobalPoint: function( point ) {
      return this.getMatrix().timesVector2( point );
    },
    localToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getMatrix() );
    },
    globalToLocalPoint: function( point ) {
      return this.getTransform().inversePosition2( point );
    },
    globalToLocalBounds: function( bounds ) {
      return this.getTransform().inverseBounds2( bounds );
    },
    parentToGlobalPoint: function( point ) {
      return this.getParentMatrix().timesVector2( point );
    },
    parentToGlobalBounds: function( bounds ) {
      return bounds.transformed( this.getParentMatrix() );
    },
    globalToParentPoint: function( point ) {
      return this.getParentTransform().inversePosition2( point );
    },
    globalToParentBounds: function( bounds ) {
      return this.getParentTransform().inverseBounds2( bounds );
    },
    updateUniqueId: function() {
      var result = '';
      var len = this.nodes.length;
      if ( len > 0 ) {
        result += this.nodes[ 0 ]._id;
      }
      for ( var i = 1; i < len; i++ ) {
        result += '-' + this.nodes[ i ]._id;
      }
      this.uniqueId = result;
    },
    getUniqueId: function() {
      if ( assert ) {
        var oldUniqueId = this.uniqueId;
        this.updateUniqueId();
        assert( oldUniqueId === this.uniqueId );
      }
      return this.uniqueId;
    },
    toString: function() {
      this.reindex();
      if ( !this.length ) {
        return 'Empty Trail';
      }
      return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';
    },
    toPathString: function() {
      var specialNodes = _.filter( this.nodes, function( n ) { return n.constructor.name !== 'Node'; } );
      return _.map( specialNodes, function( n ) { return n.constructor.name; } ).join( '/' );
    }
  } );
  Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    Trail.eachTrailBetween( a, b, function( trail ) {
      if ( trail && trail.isPainted() ) {
        return callback( trail );
      }
    }, excludeEndTrails, rootNode );
  };
  Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, rootNode ) {
    var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), true );
    var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( rootNode ), false );
    if ( excludeEndTrails ) {
      aPointer.nestedForwards();
      bPointer.nestedBackwards();
      if ( aPointer.compareNested( bPointer ) === 1 ) {
        return;
      }
    }
    aPointer.depthFirstUntil( bPointer, function( pointer ) {
      if ( pointer.isBefore ) {
        return callback( pointer.trail );
      }
    }, false );
  };
  Trail.branchIndex = function( a, b ) {
    assert && assert( a.nodes[ 0 ] === b.nodes[ 0 ], 'Branch changes require roots to be the same' );
    var branchIndex;
    var shortestLength = Math.min( a.length, b.length );
    for ( branchIndex = 0; branchIndex < shortestLength; branchIndex++ ) {
      if ( a.nodes[ branchIndex ] !== b.nodes[ branchIndex ] ) {
        break;
      }
    }
    return branchIndex;
  };
  Trail.sharedTrail = function( a, b ) {
    return a.slice( 0, Trail.branchIndex( a, b ) );
  };
  Trail.appendAncestorTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var root = trail.rootNode();
    if ( predicate( root ) ) {
      trailResults.push( trail.copy() );
    }
    var parentCount = root._parents.length;
    for ( var i = 0; i < parentCount; i++ ) {
      var parent = root._parents[ i ];
      trail.addAncestor( parent );
      Trail.appendAncestorTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeAncestor();
    }
  };
  Trail.appendDescendantTrailsWithPredicate = function( trailResults, trail, predicate ) {
    var lastNode = trail.lastNode();
    if ( predicate( lastNode ) ) {
      trailResults.push( trail.copy() );
    }
    var childCount = lastNode._children.length;
    for ( var i = 0; i < childCount; i++ ) {
      var child = lastNode._children[ i ];
      trail.addDescendant( child, i );
      Trail.appendDescendantTrailsWithPredicate( trailResults, trail, predicate );
      trail.removeDescendant();
    }
  };
  Trail.spannedSubtrees = function( a, b ) {
  };
  return Trail;
} );
define( 'SCENERY/input/BatchedDOMEvent',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  function BatchedDOMEvent( domEvent, type, callback ) {
    assert && assert( domEvent, 'for some reason, there is no DOM event?' );
    this.domEvent = domEvent;
    this.type = type;
    this.callback = callback;
  }
  scenery.register( 'BatchedDOMEvent', BatchedDOMEvent );
  BatchedDOMEvent.POINTER_TYPE = 1;
  BatchedDOMEvent.MS_POINTER_TYPE = 2;
  BatchedDOMEvent.TOUCH_TYPE = 3;
  BatchedDOMEvent.MOUSE_TYPE = 4;
  BatchedDOMEvent.WHEEL_TYPE = 5;
  inherit( Object, BatchedDOMEvent, {
    run: function( input ) {
      var domEvent = this.domEvent;
      var callback = this.callback;
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'validatePointers from batched event' );
      input.validatePointers();
      if ( input.logEvents ) { input.emitter.emit1( 'validatePointers();' );}
      if ( this.type === BatchedDOMEvent.POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, domEvent.pointerType, input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.MS_POINTER_TYPE ) {
        callback.call( input, domEvent.pointerId, scenery.Input.msPointerType( domEvent ), input.pointFromEvent( domEvent ), domEvent );
      }
      else if ( this.type === BatchedDOMEvent.TOUCH_TYPE ) {
        for ( var i = 0; i < domEvent.changedTouches.length; i++ ) {
          var touch = domEvent.changedTouches.item( i );
          callback.call( input, touch.identifier, input.pointFromEvent( touch ), domEvent );
        }
      }
      else if ( this.type === BatchedDOMEvent.MOUSE_TYPE ) {
        if ( callback === input.mouseDown ) {
          callback.call( input, null, input.pointFromEvent( domEvent ), domEvent );
        }
        else {
          callback.call( input, input.pointFromEvent( domEvent ), domEvent );
        }
      }
      else if ( this.type === BatchedDOMEvent.WHEEL_TYPE ) {
        callback.call( input, domEvent );
      }
      else {
        throw new Error( 'bad type value: ' + this.type );
      }
    },
    dispose: function() {
      this.domEvent = null;
      this.callback = null;
      this.freeToPool();
    }
  } );
  BatchedDOMEvent.fromPointerEvent = function( domEvent, pointFromEvent ) {
    return BatchedDOMEvent.createFromPool( domEvent, pointFromEvent( domEvent ), domEvent.pointerId );
  };
  Poolable.mixin( BatchedDOMEvent, {
    constructorDuplicateFactory: function( pool ) {
      return function( domEvent, type, callback ) {
        if ( pool.length ) {
          var result = pool.pop();
          BatchedDOMEvent.call( result, domEvent, type, callback );
          return result;
        }
        else {
          return new BatchedDOMEvent( domEvent, type, callback );
        }
      };
    }
  } );
  return BatchedDOMEvent;
} );
define( 'PHET_CORE/arrayRemove',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function arrayRemove( arr, item ) {
    assert && assert( arr instanceof Array, 'arrayRemove either takes an Array' );
    var index = _.indexOf( arr, item );
    assert && assert( index >= 0, 'item not found in Array' );
    arr.splice( index, 1 );
  }
  phetCore.register( 'arrayRemove', arrayRemove );
  return arrayRemove;
} );
define( 'PHET_CORE/detectPrefix',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function detectPrefix( obj, name ) {
    if ( obj[ name ] !== undefined ) { return name; }
    name = name.charAt( 0 ).toUpperCase() + name.slice( 1 );
    if ( obj[ 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }
  phetCore.register( 'detectPrefix', detectPrefix );
  return detectPrefix;
} );
define( 'SCENERY/util/Features',['require','PHET_CORE/detectPrefix','SCENERY/scenery'],function( require ) {
  'use strict';
  var detectPrefix = require( 'PHET_CORE/detectPrefix' );
  var scenery = require( 'SCENERY/scenery' );
  var Features = {};
  scenery.register( 'Features', Features );
  function supportsDataURLFormatOutput( format ) {
    try {
      var canvas = document.createElement( 'canvas' );
      canvas.width = 1;
      canvas.height = 1;
      var context = canvas.getContext( '2d' );
      context.fillStyle = 'black';
      context.fillRect( 0, 0, 1, 1 );
      var url = canvas.toDataURL( [ format ] );
      var target = 'data:' + format;
      return url.slice( 0, target.length ) === target;
    }
    catch( e ) {
      return false;
    }
  }
  function supportsDataURLFormatOrigin( name, black1x1Url ) {
    var canvas = document.createElement( 'canvas' );
    canvas.width = 1;
    canvas.height = 1;
    var context = canvas.getContext( '2d' );
    var img = document.createElement( 'img' );
    img.crossOrigin = 'Anonymous'; // maybe setting the CORS attribute will help?
    var loadCall = function() {
      try {
        context.drawImage( img, 0, 0 );
        canvas.toDataURL();
        Features[ name ] = true;
      }
      catch( e ) {
        Features[ name ] = false;
      }
    };
    img.onload = loadCall;
    try {
      img.src = black1x1Url;
      if ( img.complete ) {
        loadCall();
      }
    }
    catch( e ) {
      Features[ name ] = false;
    }
  }
  Features.canvasPNGOutput = supportsDataURLFormatOutput( 'image/png' );
  Features.canvasJPEGOutput = supportsDataURLFormatOutput( 'image/jpeg' );
  Features.canvasGIFOutput = supportsDataURLFormatOutput( 'image/gif' );
  Features.canvasICONOutput = supportsDataURLFormatOutput( 'image/x-icon' );
  supportsDataURLFormatOrigin( 'canvasPNGInput', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==' );
  supportsDataURLFormatOrigin( 'canvasJPEGInput', 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAABAAEDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD8qqKKKAP/2Q==' );
  supportsDataURLFormatOrigin( 'canvasSVGInput', 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIj8+DQo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3cG9ydD0iMCAwIDEgMSIgd2lkdGg9IjEiIGhlaWdodD0iMSIgPg0KICA8cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0iMSIgaGVpZ2h0PSIxIiByeD0iMCIgcnk9IjAiIHN0eWxlPSJmaWxsOiBibGFjazsgc3Ryb2tlOiBub25lOyI+PC9yZWN0Pg0KPC9zdmc+DQo=' );
  supportsDataURLFormatOrigin( 'canvasGIFInput', 'data:image/gif;base64,R0lGODlhAQABAJEAAAAAAP///////wAAACH5BAEAAAIALAAAAAABAAEAAAICRAEAOw==' );
  var canvas = document.createElement( 'canvas' );
  var ctx = canvas.getContext( '2d' );
  Features.toDataURLHD = detectPrefix( canvas, 'toDataURLHD' );
  Features.createImageDataHD = detectPrefix( ctx, 'createImageDataHD' );
  Features.getImageDataHD = detectPrefix( ctx, 'getImageDataHD' );
  Features.putImageDataHD = detectPrefix( ctx, 'putImageDataHD' );
  Features.currentTransform = detectPrefix( ctx, 'currentTransform' );
  var span = document.createElement( 'span' );
  var div = document.createElement( 'div' );
  Features.textStroke = detectPrefix( span.style, 'textStroke' );
  Features.textStrokeColor = detectPrefix( span.style, 'textStrokeColor' );
  Features.textStrokeWidth = detectPrefix( span.style, 'textStrokeWidth' );
  Features.transform = detectPrefix( div.style, 'transform' );
  Features.transformOrigin = detectPrefix( div.style, 'transformOrigin' );
  Features.backfaceVisibility = detectPrefix( div.style, 'backfaceVisibility' );
  Features.borderRadius = detectPrefix( div.style, 'borderRadius' );
  Features.userSelect = detectPrefix( div.style, 'userSelect' );
  Features.touchAction = detectPrefix( div.style, 'touchAction' );
  Features.touchCallout = detectPrefix( div.style, 'touchCallout' );
  Features.userDrag = detectPrefix( div.style, 'userDrag' );
  Features.tapHighlightColor = detectPrefix( div.style, 'tapHighlightColor' );
  Features.fontSmoothing = detectPrefix( div.style, 'fontSmoothing' );
  Features.requestAnimationFrame = detectPrefix( window, 'requestAnimationFrame' );
  Features.cancelAnimationFrame = detectPrefix( window, 'cancelAnimationFrame' );
  Features.setStyle = function( domElement, optionalKey, value ) {
    if ( optionalKey !== undefined ) {
      domElement.style[ optionalKey ] = value;
    }
  };
  Features.passive = false;
  window.addEventListener( 'test', null, Object.defineProperty( {}, 'passive', {
    get: function() {
      Features.passive = true;
    }
  } ) );
  return Features;
} );
define( 'PHET_CORE/platform',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  var ua = navigator.userAgent;
  function isIE( version ) {
    return getInternetExplorerVersion() === version;
  }
  function isMobileSafari() {
    return !!(
      ( window.phet && phet.chipper && phet.chipper.queryParameters && phet.chipper.queryParameters[ 'phet-app' ] ) ||
      ( ( ua.match( /(iPod|iPhone|iPad)/ ) || ( navigator.platform === 'MacIntel' && navigator.maxTouchPoints >= 2 ) ) && ua.match( /AppleWebKit/ ) )
    );
  }
  function getInternetExplorerVersion() {
    var rv = -1;
    var re = null;
    if ( navigator.appName === 'Microsoft Internet Explorer' ) {
      re = new RegExp( 'MSIE ([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    else if ( navigator.appName === 'Netscape' ) {
      re = new RegExp( 'Trident/.*rv:([0-9]{1,}[.0-9]{0,})' );
      if ( re.exec( ua ) !== null ) {
        rv = parseFloat( RegExp.$1 );
      }
    }
    return rv;
  }
  var platform = {
    firefox: ua.toLowerCase().indexOf( 'firefox' ) > -1,
    mobileSafari: isMobileSafari(),
    safari5: !!( ua.match( /Version\/5\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari6: !!( ua.match( /Version\/6\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari7: !!( ua.match( /Version\/7\./ ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    safari: isMobileSafari() || !!( ua.match( /Version\// ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) ),
    ie: getInternetExplorerVersion() !== -1,
    ie9: isIE( 9 ),
    ie10: isIE( 10 ),
    ie11: isIE( 11 ),
    android: ua.indexOf( 'Android' ) > 0,
    edge: !!ua.match( /Edge\// ),
    chromium: (/chrom(e|ium)/).test( ua.toLowerCase() ) && !ua.match( /Edge\// )
  };
  phetCore.register( 'platform', platform );
  return platform;
} );
define( 'SCENERY/input/BrowserEvents',['require','PHET_CORE/arrayRemove','SCENERY/util/Features','PHET_CORE/platform','SCENERY/scenery','SCENERY/input/BatchedDOMEvent'],function( require ) {
  'use strict';
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var Features = require( 'SCENERY/util/Features' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var BatchedDOMEvent = require( 'SCENERY/input/BatchedDOMEvent' );
  var noop = function noop() {};
  var BrowserEvents = {
    addDisplay: function( display, attachToWindow, passiveEvents ) {
      assert && assert( display instanceof scenery.Display );
      assert && assert( typeof attachToWindow === 'boolean' );
      assert && assert( !_.includes( this.attachedDisplays, display ),
        'A display cannot be concurrently attached to events more than one time' );
      this.attachedDisplays.push( display );
      if ( attachToWindow ) {
        if ( this.attachedDisplays.length === 1 ) {
          this.connectWindowListeners( passiveEvents );
        }
      }
      else {
        this.addOrRemoveListeners( display.domElement, true, passiveEvents );
      }
      display.domElement.addEventListener( 'wheel', this.onwheel, BrowserEvents.getEventOptions( passiveEvents, true ) );
    },
    removeDisplay: function( display, attachToWindow, passiveEvents ) {
      assert && assert( display instanceof scenery.Display );
      assert && assert( typeof attachToWindow === 'boolean' );
      assert && assert( _.includes( this.attachedDisplays, display ),
        'This display was not already attached to listen for window events' );
      arrayRemove( this.attachedDisplays, display );
      if ( attachToWindow ) {
        if ( this.attachedDisplays.length === 0 ) {
          this.disconnectWindowListeners( passiveEvents );
        }
      }
      else {
        this.addOrRemoveListeners( display.domElement, false, passiveEvents );
      }
      display.domElement.removeEventListener( 'wheel', this.onwheel, BrowserEvents.getEventOptions( passiveEvents, true ) );
    },
    getEventOptions: function( passiveEvents, isMain ) {
      var passDirectPassiveFlag = Features.passive && passiveEvents !== null;
      if ( !passDirectPassiveFlag ) {
        return false;
      }
      if ( isMain ) {
        return {
          useCapture: false,
          passive: passiveEvents
        };
      }
      else {
        return {
          passive: passiveEvents
        };
      }
    },
    listenersAttachedToWindow: 0,
    listenersAttachedToElement: 0,
    attachedDisplays: [],
    canUsePointerEvents: !!( ( window.navigator && window.navigator.pointerEnabled ) || window.PointerEvent ) && !platform.firefox,
    canUseMSPointerEvents: window.navigator && window.navigator.msPointerEnabled,
    pointerListenerTypes: [
      'pointerdown',
      'pointerup',
      'pointermove',
      'pointerover',
      'pointerout',
      'pointercancel',
      'gotpointercapture',
      'lostpointercapture'
    ],
    msPointerListenerTypes: [
      'MSPointerDown',
      'MSPointerUp',
      'MSPointerMove',
      'MSPointerOver',
      'MSPointerOut',
      'MSPointerCancel'
    ],
    touchListenerTypes: [
      'touchstart',
      'touchend',
      'touchmove',
      'touchcancel'
    ],
    mouseListenerTypes: [
      'mousedown',
      'mouseup',
      'mousemove',
      'mouseover',
      'mouseout'
    ],
    wheelListenerTypes: [
      'wheel'
    ],
    getNonWheelUsedTypes: function() {
      var eventTypes;
      if ( this.canUsePointerEvents ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected pointer events support, using that instead of mouse/touch events' );
        eventTypes = this.pointerListenerTypes;
      }
      else if ( this.canUseMSPointerEvents ) {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'Detected MS pointer events support, using that instead of mouse/touch events' );
        eventTypes = this.msPointerListenerTypes;
      }
      else {
        sceneryLog && sceneryLog.Input && sceneryLog.Input( 'No pointer events support detected, using mouse/touch events' );
        eventTypes = this.touchListenerTypes.concat( this.mouseListenerTypes );
      }
      assert && assert( !_.includes( eventTypes, 'keydown' ),
        'Make sure not to preventDefault key events in the future.' );
      return eventTypes;
    },
    connectWindowListeners: function( passiveEvents ) {
      this.addOrRemoveListeners( window, true, passiveEvents );
    },
    disconnectWindowListeners: function( passiveEvents ) {
      this.addOrRemoveListeners( window, false, passiveEvents );
    },
    addOrRemoveListeners: function( element, addOrRemove, passiveEvents ) {
      var documentOptions = BrowserEvents.getEventOptions( passiveEvents, false );
      var mainOptions = BrowserEvents.getEventOptions( passiveEvents, true );
      assert && assert( typeof addOrRemove === 'boolean' );
      var forWindow = element === window;
      assert && assert( !forWindow || ( this.listenersAttachedToWindow > 0 ) === !addOrRemove,
        'Do not add listeners to the window when already attached, or remove listeners when none are attached' );
      var delta = addOrRemove ? 1 : -1;
      if ( forWindow ) {
        this.listenersAttachedToWindow += delta;
      }
      else {
        this.listenersAttachedToElement += delta;
      }
      assert && assert( this.listenersAttachedToWindow === 0 || this.listenersAttachedToElement === 0,
        'Listeners should not be added both with addDisplayToWindow and addDisplayToElement. Use only one.' );
      var method = addOrRemove ? 'addEventListener' : 'removeEventListener';
      var eventTypes = this.getNonWheelUsedTypes();
      for ( var i = 0; i < eventTypes.length; i++ ) {
        var type = eventTypes[ i ];
        if ( forWindow ) {
          document[ method ]( type, noop, documentOptions );
        }
        var callback = this[ 'on' + type ];
        assert && assert( !!callback );
        element[ method ]( type, callback, mainOptions ); // false: don't use event capture for now
      }
    },
    batchWindowEvent: function( domEvent, batchType, inputCallbackName, triggerImmediate ) {
      for ( var i = 0; i < this.attachedDisplays.length; i++ ) {
        var display = this.attachedDisplays[ i ];
        var input = display._input;
        input.batchEvent( domEvent, batchType, input[ inputCallbackName ], triggerImmediate );
      }
    },
    onpointerdown: function onpointerdown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerdown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      if ( domEvent.pointerType === 'mouse' ) {
        scenery.Display.userGestureEmitter.emit();
      }
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerDown', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onpointerup: function onpointerup( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerup' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      scenery.Display.userGestureEmitter.emit();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerUp', true );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onpointermove: function onpointermove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointermove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerMove', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onpointerover: function onpointerover( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerover' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerOver', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onpointerout: function onpointerout( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointerout' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerOut', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onpointercancel: function onpointercancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'pointercancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'pointerCancel', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    ongotpointercapture: function ongotpointercapture( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'gotpointercapture' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'gotPointerCapture', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onlostpointercapture: function onlostpointercapture( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'lostpointercapture' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.POINTER_TYPE, 'lostPointerCapture', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerDown: function onMSPointerDown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerDown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerDown', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerUp: function onMSPointerUp( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerUp' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerUp', true );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerMove: function onMSPointerMove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerMove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerMove', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerOver: function onMSPointerOver( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerOver' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerOver', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerOut: function onMSPointerOut( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerOut' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerOut', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onMSPointerCancel: function onMSPointerCancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'MSPointerCancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MS_POINTER_TYPE, 'pointerCancel', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    ontouchstart: function ontouchstart( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchstart' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchStart', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    ontouchend: function ontouchend( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchend' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      scenery.Display.userGestureEmitter.emit();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchEnd', true );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    ontouchmove: function ontouchmove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchmove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchMove', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    ontouchcancel: function ontouchcancel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'touchcancel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.TOUCH_TYPE, 'touchCancel', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onmousedown: function onmousedown( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mousedown' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      scenery.Display.userGestureEmitter.emit();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseDown', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onmouseup: function onmouseup( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseup' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      scenery.Display.userGestureEmitter.emit();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseUp', true );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onmousemove: function onmousemove( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mousemove' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseMove', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onmouseover: function onmouseover( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseover' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseOver', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onmouseout: function onmouseout( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'mouseout' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.MOUSE_TYPE, 'mouseOut', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    },
    onwheel: function onwheel( domEvent ) {
      sceneryLog && sceneryLog.OnInput && sceneryLog.OnInput( 'wheel' );
      sceneryLog && sceneryLog.OnInput && sceneryLog.push();
      BrowserEvents.batchWindowEvent( domEvent, BatchedDOMEvent.WHEEL_TYPE, 'wheel', false );
      sceneryLog && sceneryLog.OnInput && sceneryLog.pop();
    }
  };
  scenery.register( 'BrowserEvents', BrowserEvents );
  return BrowserEvents;
} );
define( 'AXON/BooleanProperty',['require','PHET_CORE/inherit','AXON/Property','AXON/axon','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var IS_BOOLEAN = function( value ) {
    return typeof value === 'boolean';
  };
  function BooleanProperty( value, options ) {
    assert && assert( !options || !options.phetioValueType, 'phetioValueType is provided by BooleanProperty' );
    options = _.extend( {
      phetioValueType: TBoolean
    }, options );
    assert && assert( !options.validValues, 'BooleanProperty cannot use validValues' );
    assert && assert( !options.isValidValue, 'BooleanProperty implements its own isValidValue' );
    options.isValidValue = IS_BOOLEAN;
    Property.call( this, value, options );
  }
  axon.register( 'BooleanProperty', BooleanProperty );
  return inherit( Property, BooleanProperty );
} );
define( 'SCENERY/input/Pointer',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','AXON/BooleanProperty'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  function Pointer( initialPoint, initialDownState ) {
    assert && assert( initialPoint === null || initialPoint instanceof Vector2 );
    assert && assert( typeof initialDownState === 'boolean' );
    this.point = initialPoint;
    this.trail = null;
    this.isDownProperty = new BooleanProperty( initialDownState );
    this.attachedProperty = new BooleanProperty( false );
    this._listeners = [];
    this._attachedListener = null;
    this._cursor = null;
    phetAllocation && phetAllocation( 'Pointer' );
    this._pointerCaptured = false;
  }
  scenery.register( 'Pointer', Pointer );
  inherit( Object, Pointer, {
    setCursor: function( cursor ) {
      this._cursor = cursor;
      return this; // TODO: is chaining actually used? Not that helpful of a pattern with pointers.
    },
    set cursor( value ) { return this.setCursor( value ); },
    getCursor: function() {
      return this._cursor;
    },
    get cursor() { return this.getCursor(); },
    getListeners: function() {
      return this._listeners.slice();
    },
    get listeners() { return this.getListeners(); },
    addInputListener: function( listener, attach ) {
      assert && assert( listener, 'A listener must be provided' );
      assert && assert( attach === undefined || typeof attach === 'boolean',
        'If provided, the attach parameter should be a boolean value' );
      assert && assert( !_.includes( this._listeners, listener ),
        'Attempted to add an input listener that was already added' );
      this._listeners.push( listener );
      if ( attach ) {
        this.attach( listener );
      }
    },
    removeInputListener: function( listener ) {
      assert && assert( listener, 'A listener must be provided' );
      var index = _.indexOf( this._listeners, listener );
      assert && assert( index !== -1, 'Could not find the input listener to remove' );
      if ( this.isAttached() && listener === this._attachedListener ) {
        this.detach( listener );
      }
      this._listeners.splice( index, 1 );
    },
    isAttached: function() {
      return this.attachedProperty.value;
    },
    set isDown( value ) {
      this.isDownProperty.value = value;
    },
    get isDown() {
      return this.isDownProperty.value;
    },
    interruptAttached: function() {
      if ( this.isAttached() ) {
        this._attachedListener.interrupt(); // Any listener that uses the 'attach' API should have interrupt()
      }
    },
    interruptAll: function() {
      var listeners = this._listeners.slice();
      for ( var i = 0; i < listeners.length; i++ ) {
        var listener = listeners[ i ];
        listener.interrupt && listener.interrupt();
      }
    },
    attach: function( listener ) {
      assert && assert( !this.isAttached(), 'Attempted to attach to an already attached pointer' );
      this.attachedProperty.value = true;
      this._attachedListener = listener;
    },
    detach: function( listener ) {
      assert && assert( this.isAttached(), 'Cannot detach a listener if one is not attached' );
      assert && assert( this._attachedListener === listener, 'Cannot detach a different listener' );
      this.attachedProperty.value = false;
      this._attachedListener = null;
    },
    hasPointChanged: function( point ) {
      return this.point !== point && ( !point || !this.point || !this.point.equals( point ) );
    },
    onGotPointerCapture() {
      this._pointerCaptured = true;
    },
    onLostPointerCapture() {
      if ( this._pointerCaptured ) {
        this.interruptAll();
      }
      this._pointerCaptured = false;
    },
    dispose: function() {
      sceneryLog && sceneryLog.Pointer && sceneryLog.Pointer( 'Disposing ' + this.toString() );
      assert && assert( this._attachedListener === null, 'Attached listeners should be cleared before pointer disposal' );
      assert && assert( this._listeners.length === 0, 'Should not have listeners when a pointer is disposed' );
    }
  } );
  return Pointer;
} );
define( 'SCENERY/input/Event',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Pointer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Trail = require( 'SCENERY/util/Trail' );
  var Pointer = require( 'SCENERY/input/Pointer' );
  function Event( trail, type, pointer, domEvent ) {
    assert && assert( trail instanceof Trail, 'Event\'s trail parameter should be a {Trail}' );
    assert && assert( typeof type === 'string', 'Event\'s type should be a {string}' );
    assert && assert( pointer instanceof Pointer, 'Event\'s pointer parameter should be a {Pointer}' );
    this.handled = false;
    this.aborted = false;
    this.trail = trail;
    this.type = type;
    this.pointer = pointer;
    this.domEvent = domEvent;
    this.currentTarget = null;
    this.target = trail.lastNode();
    this.isPrimary = !pointer.isMouse || !domEvent || domEvent.button === 0;
  }
  scenery.register( 'Event', Event );
  inherit( Object, Event, {
    handle: function() {
      this.handled = true;
    },
    abort: function() {
      this.handled = true;
      this.aborted = true;
    },
    canStartPress: function() {
      return !this.pointer.isAttached() && ( !this.pointer.isMouse || this.domEvent.button === 0 );
    }
  } );
  return Event;
} );
define( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector3','SCENERY/input/Pointer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector3 = require( 'DOT/Vector3' );
  var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer
  function Mouse() {
    Pointer.call( this, null, false );
    this.leftDown = false;
    this.middleDown = false;
    this.rightDown = false;
    this.wheelDelta = new Vector3();
    this.wheelDeltaMode = 0; // 0: pixels, 1: lines, 2: pages
  }
  scenery.register( 'Mouse', Mouse );
  inherit( Pointer, Mouse, {
    type: 'mouse',
    isMouse: true,
    down: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse down at ' + point.toString() );
      this.point = point;
      this.isDown = true;
      switch( event.button ) {
        case 0:
          this.leftDown = true;
          break;
        case 1:
          this.middleDown = true;
          break;
        case 2:
          this.rightDown = true;
          break;
        default:
          throw new Error( 'invalid button: ' + event.button );
      }
      return pointChanged;
    },
    up: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse up at ' + point.toString() );
      this.point = point;
      this.isDown = false;
      switch( event.button ) {
        case 0:
          this.leftDown = false;
          break;
        case 1:
          this.middleDown = false;
          break;
        case 2:
          this.rightDown = false;
          break;
        default:
          throw new Error( 'invalid button: ' + event.button );
      }
      return pointChanged;
    },
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse move at ' + point.toString() );
      this.point = point;
      return pointChanged;
    },
    over: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse over at ' + point.toString() );
      this.point = point;
      return pointChanged;
    },
    out: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      point && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'mouse out at ' + point.toString() );
      this.point = null;
      return pointChanged;
    },
    wheel: function( event ) {
      this.wheelDelta.setXYZ( event.deltaX, event.deltaY, event.deltaZ );
      this.wheelDeltaMode = event.deltaMode;
    },
    toString: function() {
      return 'Mouse';
    }
  } );
  return Mouse;
} );
define( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
  function Pen( id, point, event ) {
    Pointer.call( this, point, true ); // true: pen pointers always start in the down state
    this.id = id;
  }
  scenery.register( 'Pen', Pen );
  inherit( Pointer, Pen, {
    type: 'pen',
    isPen: true,
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      return pointChanged;
    },
    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    toString: function() {
      return 'Pen#' + this.id;
    }
  } );
  return Pen;
} );
define( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer
  function Touch( id, point, event ) {
    Pointer.call( this, point, true ); // true: touches always start in the down state
    this.id = id;
  }
  scenery.register( 'Touch', Touch );
  inherit( Pointer, Touch, {
    type: 'touch',
    isTouch: true,
    move: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      return pointChanged;
    },
    end: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    cancel: function( point, event ) {
      var pointChanged = this.hasPointChanged( point );
      this.point = point;
      this.isDown = false;
      return pointChanged;
    },
    toString: function() {
      return 'Touch#' + this.id;
    }
  } );
  return Touch;
} );
define( 'SCENERY/input/Input',['require','SCENERY/input/BatchedDOMEvent','SCENERY/input/BrowserEvents','PHET_CORE/cleanArray','AXON/Emitter','SCENERY/input/Event','PHET_CORE/inherit','SCENERY/input/Mouse','SCENERY/input/Pen','PHET_CORE/platform','SCENERY/scenery','SCENERY/input/Touch','SCENERY/util/Trail','DOT/Vector2'],function( require ) {
  'use strict';
  var BatchedDOMEvent = require( 'SCENERY/input/BatchedDOMEvent' );
  var BrowserEvents = require( 'SCENERY/input/BrowserEvents' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Emitter = require( 'AXON/Emitter' );
  var Event = require( 'SCENERY/input/Event' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Mouse = require( 'SCENERY/input/Mouse' );
  var Pen = require( 'SCENERY/input/Pen' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var Touch = require( 'SCENERY/input/Touch' );
  var Trail = require( 'SCENERY/util/Trail' );
  var Vector2 = require( 'DOT/Vector2' );
  var domEventPropertiesToSerialize = {
    button: true, keyCode: true,
    deltaX: true, deltaY: true, deltaZ: true, deltaMode: true, pointerId: true,
    pointerType: true, charCode: true, which: true, clientX: true, clientY: true, changedTouches: true
  };
  function Input( display, attachToWindow, batchDOMEvents, assumeFullWindow, passiveEvents ) {
    assert && assert( display instanceof scenery.Display );
    assert && assert( typeof attachToWindow === 'boolean' );
    assert && assert( typeof batchDOMEvents === 'boolean' );
    assert && assert( typeof assumeFullWindow === 'boolean' );
    this.display = display;
    this.rootNode = display.rootNode;
    this.attachToWindow = attachToWindow;
    this.batchDOMEvents = batchDOMEvents;
    this.assumeFullWindow = assumeFullWindow;
    this.passiveEvents = passiveEvents;
    this.displayUpdateOnEvent = false;
    this.batchedEvents = [];
    this.mouse = null;
    this.pointers = [];
    this.emitter = new Emitter();
    this.pointerAddedListeners = [];
  }
  scenery.register( 'Input', Input );
  inherit( Object, Input, {
    batchEvent: function( domEvent, batchType, callback, triggerImmediate ) {
      if ( this.display.interactive ) {
        this.batchedEvents.push( BatchedDOMEvent.createFromPool( domEvent, batchType, callback ) );
        if ( triggerImmediate || !this.batchDOMEvents ) {
          this.fireBatchedEvents();
        }
        if ( this.displayUpdateOnEvent ) {
        }
      }
      if ( !( this.passiveEvents === true ) && ( callback !== this.mouseDown || platform.ie || platform.edge ) ) {
        domEvent.preventDefault();
      }
    },
    fireBatchedEvents: function() {
      if ( this.batchedEvents.length ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'Input.fireBatchedEvents length:' + this.batchedEvents.length );
        var len = this.batchedEvents.length;
        for ( var i = 0; i < len; i++ ) {
          var batchedEvent = this.batchedEvents[ i ];
          batchedEvent.run( this );
          batchedEvent.dispose();
        }
        cleanArray( this.batchedEvents );
      }
    },
    clearBatchedEvents: function() {
      this.batchedEvents.length = 0;
    },
    removeTemporaryPointers: function() {
      var fakeDomEvent = {
      };
      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
        var pointer = this.pointers[ i ];
        if ( !pointer.isMouse ) {
          this.pointers.splice( i, 1 );
          var exitTrail = pointer.trail || new Trail( this.rootNode );
          this.exitEvents( pointer, fakeDomEvent, exitTrail, 0, true );
        }
      }
    },
    connectListeners: function() {
      BrowserEvents.addDisplay( this.display, this.attachToWindow, this.passiveEvents );
    },
    disconnectListeners: function() {
      BrowserEvents.removeDisplay( this.display, this.attachToWindow, this.passiveEvents );
    },
    pointFromEvent: function( domEvent ) {
      var position = Vector2.createFromPool( domEvent.clientX, domEvent.clientY );
      if ( !this.assumeFullWindow ) {
        var domBounds = this.display.domElement.getBoundingClientRect();
        if ( domBounds.width > 0 && domBounds.height > 0 ) {
          position.subtractXY( domBounds.left, domBounds.top );
          if ( domBounds.width !== this.display.width || domBounds.height !== this.display.height ) {
            position.x *= this.display.width / domBounds.width;
            position.y *= this.display.height / domBounds.height;
          }
        }
      }
      return position;
    },
    addPointer: function( pointer ) {
      this.pointers.push( pointer );
      if ( this.pointerAddedListeners.length ) {
        for ( var i = 0; i < this.pointerAddedListeners.length; i++ ) {
          this.pointerAddedListeners[ i ]( pointer );
        }
      }
    },
    addPointerAddedListener: function( listener ) {
      this.pointerAddedListeners.push( listener );
    },
    removePointerAddedListener: function( listener ) {
      var index = this.pointerAddedListeners.indexOf( listener );
      if ( index !== -1 ) {
        this.pointerAddedListeners.splice( index, index + 1 );
      }
    },
    removePointer: function( pointer ) {
      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {
        if ( this.pointers[ i ] === pointer ) {
          this.pointers.splice( i, 1 );
        }
      }
    },
    findPointerById: function( id ) {
      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[ i ];
        if ( pointer.id === id ) {
          return pointer;
        }
      }
      return undefined;
    },
    initMouse: function() {
      this.mouse = new Mouse();
      this.addPointer( this.mouse );
    },
    mouseDown: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseDown(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.id = id;
      var pointChanged = this.mouse.down( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.downEvent( this.mouse, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    mouseUp: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseUp(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.id = null;
      var pointChanged = this.mouse.up( point, event );
      if ( pointChanged ) {
        this.moveEvent( this.mouse, event );
      }
      this.upEvent( this.mouse, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    mouseMove: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseMove(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.move( point, event );
      this.moveEvent( this.mouse, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    mouseOver: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOver(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.over( point, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    mouseOut: function( point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'mouseOut(' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.out( point, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    wheel: function( event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'wheel(' + Input.debugKeyEvent( event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'wheel(' + Input.serializeDomEvent( event ) + ');' ); }
      if ( !this.mouse ) { this.initMouse(); }
      this.mouse.wheel( event );
      if ( this.mouse.point ) {
        var trail = this.rootNode.trailUnderPointer( this.mouse ) || new Trail( this.rootNode );
        this.dispatchEvent( trail, 'wheel', this.mouse, event, true );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    touchStart: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = new Touch( id, point, event );
      this.addPointer( touch );
      this.downEvent( touch, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    touchEnd: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        var pointChanged = touch.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.upEvent( touch, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    touchMove: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        touch.move( point, event );
        this.moveEvent( touch, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    touchCancel: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'touchCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'touchCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var touch = this.findPointerById( id );
      if ( touch ) {
        var pointChanged = touch.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( touch, event );
        }
        this.removePointer( touch );
        this.cancelEvent( touch, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    penStart: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penStart(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penStart(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = new Pen( id, point, event );
      this.addPointer( pen );
      this.downEvent( pen, event );
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    penEnd: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penEnd(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penEnd(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        var pointChanged = pen.end( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.upEvent( pen, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    penMove: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penMove(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penMove(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        pen.move( point, event );
        this.moveEvent( pen, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    penCancel: function( id, point, event ) {
      sceneryLog && sceneryLog.Input && sceneryLog.Input( 'penCancel(\'' + id + '\',' + Input.debugText( point, event ) + ');' );
      sceneryLog && sceneryLog.Input && sceneryLog.push();
      if ( this.emitter.hasListeners() ) { this.emitter.emit1( 'penCancel(\'' + id + '\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }
      var pen = this.findPointerById( id );
      if ( pen ) {
        var pointChanged = pen.cancel( point, event );
        if ( pointChanged ) {
          this.moveEvent( pen, event );
        }
        this.removePointer( pen );
        this.cancelEvent( pen, event );
      }
      sceneryLog && sceneryLog.Input && sceneryLog.pop();
    },
    pointerDown: function( id, type, point, event ) {
      var target = this.attachToWindow ? document.body : this.display.domElement;
      if ( target.setPointerCapture && event.pointerId ) {
        target.setPointerCapture( event.pointerId );
      }
      switch( type ) {
        case 'mouse':
          this.mouseDown( id, point, event );
          break;
        case 'touch':
          this.touchStart( id, point, event );
          break;
        case 'pen':
          this.penStart( id, point, event );
          break;
        default:
          if ( assert ) {
            throw new Error( 'Unknown pointer type: ' + type );
          }
      }
    },
    pointerUp: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          this.mouseUp( point, event );
          break;
        case 'touch':
          this.touchEnd( id, point, event );
          break;
        case 'pen':
          this.penEnd( id, point, event );
          break;
        default:
          if ( assert ) {
            throw new Error( 'Unknown pointer type: ' + type );
          }
      }
    },
    pointerCancel: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          if ( console && console.log ) {
            console.log( 'WARNING: Pointer mouse cancel was received' );
          }
          break;
        case 'touch':
          this.touchCancel( id, point, event );
          break;
        case 'pen':
          this.penCancel( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    pointerMove: function( id, type, point, event ) {
      switch( type ) {
        case 'mouse':
          this.mouseMove( point, event );
          break;
        case 'touch':
          this.touchMove( id, point, event );
          break;
        case 'pen':
          this.penMove( id, point, event );
          break;
        default:
          if ( console.log ) {
            console.log( 'Unknown pointer type: ' + type );
          }
      }
    },
    gotPointerCapture( id, type, point, event ) {
      const pointer = this.findPointerById( id );
      if ( pointer ) {
        pointer.onGotPointerCapture();
      }
    },
    lostPointerCapture( id, type, point, event ) {
      const pointer = this.findPointerById( id );
      if ( pointer ) {
        pointer.onLostPointerCapture();
      }
    },
    pointerOver( id, type, point, event ) {
    },
    pointerOut: function( id, type, point, event ) {
    },
    pointerEnter: function( id, type, point, event ) {
    },
    pointerLeave: function( id, type, point, event ) {
    },
    upEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );
      this.dispatchEvent( trail, 'up', pointer, event, true );
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }
      pointer.trail = trail;
    },
    downEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );
      if ( pointer.isTouch ) {
        this.enterEvents( pointer, event, trail, 0, true );
      }
      this.dispatchEvent( trail, 'down', pointer, event, true );
      pointer.trail = trail;
    },
    moveEvent: function( pointer, event ) {
      var changed = this.branchChangeEvents( pointer, event, true );
      if ( changed ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due to move event' );
      }
    },
    cancelEvent: function( pointer, event ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );
      this.dispatchEvent( trail, 'cancel', pointer, event, true );
      if ( pointer.isTouch ) {
        this.exitEvents( pointer, event, trail, 0, true );
      }
      pointer.trail = trail;
    },
    branchChangeEvents: function( pointer, event, isMove ) {
      var trail = this.rootNode.trailUnderPointer( pointer ) || new Trail( this.rootNode );
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'checking branch change: ' + trail.toString() + ' at ' + pointer.point.toString() );
      var oldTrail = pointer.trail || new Trail( this.rootNode ); // TODO: consider a static trail reference
      var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();
      var branchIndex = Trail.branchIndex( trail, oldTrail );
      var isBranchChange = branchIndex !== trail.length || branchIndex !== oldTrail.length;
      isBranchChange && sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'branch change from ' + oldTrail.toString() + ' to ' + trail.toString() );
      if ( isMove ) {
        this.dispatchEvent( trail, 'move', pointer, event, true );
      }
      if ( isBranchChange ) {
        this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );
        this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );
      }
      pointer.trail = trail;
      return isBranchChange;
    },
    enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( trail.length > branchIndex ) {
        for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {
          this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );
        }
      }
      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'over', pointer, event, true );
      }
    },
    exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {
      if ( lastNodeChanged ) {
        this.dispatchEvent( trail, 'out', pointer, event, true );
      }
      if ( trail.length > branchIndex ) {
        for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {
          this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );
        }
      }
    },
    validatePointers: function() {
      var self = this;
      var i = this.pointers.length;
      while ( i-- ) {
        var pointer = this.pointers[ i ];
        if ( pointer.point ) {
          var changed = self.branchChangeEvents( pointer, null, false );
          if ( changed ) {
            sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'branch change due validatePointers' );
          }
        }
      }
    },
    dispatchEvent: function( trail, type, pointer, event, bubbles ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() + ' at ' + pointer.point.toString() );
      assert && assert( trail, 'Falsy trail for dispatchEvent' );
      var inputEvent = new Event( trail, type, pointer, event );
      this.dispatchToPointer( type, pointer, inputEvent );
      this.dispatchToTargets( trail, pointer, type, inputEvent, bubbles );
    },
    dispatchToPointer: function( type, pointer, inputEvent ) {
      if ( inputEvent.aborted || inputEvent.handled ) {
        return;
      }
      var specificType = pointer.type + type; // e.g. mouseup, touchup
      var pointerListeners = pointer.getListeners(); // defensive copy
      for ( var i = 0; i < pointerListeners.length; i++ ) {
        var listener = pointerListeners[ i ];
        var aborted = false;
        if ( !aborted && listener[ specificType ] ) {
          listener[ specificType ]( inputEvent );
          aborted = inputEvent.aborted;
        }
        if ( !aborted && listener[ type ] ) {
          listener[ type ]( inputEvent );
          aborted = inputEvent.aborted;
        }
        if ( aborted ) {
          return;
        }
      }
    },
    dispatchToTargets: function( trail, pointer, type, inputEvent, bubbles ) {
      if ( inputEvent.aborted || inputEvent.handled ) {
        return;
      }
      var specificType = pointer.type + type; // e.g. mouseup, touchup
      for ( var i = trail.getLastInputEnabledIndex(); i >= 0; bubbles ? i-- : i = -1 ) {
        var target = trail.nodes[ i ];
        if ( target.isDisposed() ) {
          continue;
        }
        inputEvent.currentTarget = target;
        var listeners = target.getInputListeners();
        for ( var k = 0; k < listeners.length; k++ ) {
          var listener = listeners[ k ];
          var aborted = false;
          if ( !aborted && listener[ specificType ] ) {
            listener[ specificType ]( inputEvent );
            aborted = inputEvent.aborted;
          }
          if ( !aborted && listener[ type ] ) {
            listener[ type ]( inputEvent );
            aborted = inputEvent.aborted;
          }
          if ( aborted ) {
            return;
          }
        }
        if ( inputEvent.handled ) {
          return;
        }
      }
    }
  }, {
    serializeDomEvent: function serializeDomEvent( domEvent ) {
      var lines = [];
      for ( var prop in domEvent ) {
        if ( domEventPropertiesToSerialize[ prop ] ) {
          if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {
            var arr = [];
            for ( var i = 0; i < domEvent[ prop ].length; i++ ) {
              var touch = domEvent[ prop ].item( i );
              arr.push( serializeDomEvent( touch ) );
            }
            lines.push( prop + ':[' + arr.join( ',' ) + ']' );
          }
          else {
            lines.push( prop + ':' + ( ( typeof domEvent[ prop ] === 'object' ) && ( domEvent[ prop ] !== null ) ? '{}' : JSON.stringify( domEvent[ prop ] ) ) );
          }
        }
      }
      return '{' + lines.join( ',' ) + '}';
    },
    serializeVector2: function( vector ) {
      return 'new dot.Vector2(' + vector.x + ',' + vector.y + ')';
    },
    debugKeyEvent: function( domEvent ) {
      return domEvent.timeStamp + ' ' + domEvent.type;
    },
    debugText: function( vector, domEvent ) {
      return vector.x + ',' + vector.y + ' ' + domEvent.timeStamp + ' ' + domEvent.type;
    },
    msPointerType: function( evt ) {
      if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {
        return 'touch';
      }
      else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {
        return 'pen';
      }
      else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {
        return 'mouse';
      }
      else {
        return evt.pointerType; // hope for the best
      }
    },
    KEY_SPACE: 32,
    KEY_ENTER: 13,
    KEY_TAB: 9,
    KEY_RIGHT_ARROW: 39,
    KEY_LEFT_ARROW: 37,
    KEY_UP_ARROW: 38,
    KEY_DOWN_ARROW: 40,
    KEY_SHIFT: 16,
    KEY_ESCAPE: 27,
    KEY_DELETE: 46,
    KEY_BACKSPACE: 8,
    KEY_PAGE_UP: 33,
    KEY_PAGE_DOWN: 34,
    KEY_END: 35,
    KEY_HOME: 36,
    KEY_S: 83,
    KEY_W: 87,
    KEY_A: 65,
    KEY_D: 68,
    KEY_J: 74,
    KEY_C: 67,
    KEY_N: 78,
    KEY_0: 48,
    KEY_9: 57,
    isArrowKey: function( keyCode ) {
      return ( keyCode === Input.KEY_RIGHT_ARROW || keyCode === Input.KEY_LEFT_ARROW ||
               keyCode === Input.KEY_UP_ARROW || keyCode === Input.KEY_DOWN_ARROW );
    },
    isRangeKey: function( keyCode ) {
      return ( keyCode >= Input.KEY_PAGE_UP && keyCode <= Input.KEY_DOWN_ARROW );
    },
    isNumberKey: function( keyCode ) {
      return ( keyCode > Input.KEY_0 && keyCode < Input.KEY_9 );
    }
  } );
  Input.BASIC_EVENT_TYPES = [ 'down', 'up', 'cancel', 'move', 'wheel', 'enter', 'exit', 'over', 'out' ];
  Input.EVENT_PREFIXES = [ '', 'mouse', 'touch', 'pen' ];
  Input.ALL_EVENT_TYPES = Input.EVENT_PREFIXES.map( function( prefix ) {
    return Input.BASIC_EVENT_TYPES.map( function( eventName ) {
      return prefix + eventName;
    } );
  } );
  return Input;
} );
define( 'SCENERY/input/DownUpListener',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Input','SCENERY/util/Trail'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var Input = require( 'SCENERY/input/Input' );
  var Trail = require( 'SCENERY/util/Trail' );
  function DownUpListener( options ) {
    var self = this;
    options = _.extend( {
      mouseButton: 0 // allow a different mouse button
    }, options );
    this.options = options; // @private
    this.isDown = false;   // public, whether this listener is down
    this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget
    this.downTrail = null;
    this.pointer = null;
    this.interrupted = false;
    this.downListener = {
      up: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) up for ' + self.downTrail.toString() );
        assert && assert( event.pointer === self.pointer );
        if ( !event.pointer.isMouse || event.domEvent.button === self.options.mouseButton ) {
          self.buttonUp( event );
        }
      },
      interrupt: function() {
        self.interrupt();
      },
      cancel: function( event ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener (pointer) cancel for ' + self.downTrail.toString() );
        assert && assert( event.pointer === self.pointer );
        self.buttonUp( event );
      },
      keyup: function( event ) {
        var keyCode = event.domEvent.keyCode;
        if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
          self.buttonUp( event );
        }
      }
    };
  }
  scenery.register( 'DownUpListener', DownUpListener );
  inherit( Object, DownUpListener, {
    buttonDown: function( event ) {
      if ( this.isDown ) { return; }
      if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }
      event.pointer.addInputListener( this.downListener );
      this.isDown = true;
      this.downCurrentTarget = event.currentTarget;
      this.downTrail = event.trail.subtrailTo( event.currentTarget, false );
      this.pointer = event.pointer;
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonDown for ' + this.downTrail.toString() );
      if ( this.options.down ) {
        this.options.down( event, this.downTrail );
      }
    },
    buttonUp: function( event ) {
      this.isDown = false;
      this.pointer.removeInputListener( this.downListener );
      var currentTargetSave = event.currentTarget;
      event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.
      if ( this.options.upInside || this.options.upOutside ) {
        var trailUnderPointer = event.trail;
        var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true ) && !this.interrupted;
        if ( isInside && this.options.upInside ) {
          this.options.upInside( event, this.downTrail );
        }
        else if ( !isInside && this.options.upOutside ) {
          this.options.upOutside( event, this.downTrail );
        }
      }
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent( 'DownUpListener buttonUp for ' + this.downTrail.toString() );
      if ( this.options.up ) {
        this.options.up( event, this.downTrail );
      }
      event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget
    },
    down: function( event ) {
      this.buttonDown( event );
    },
    interrupt: function() {
      if ( this.isDown ) {
        this.interrupted = true;
        this.buttonUp( {
          trail: new Trail(),
          currentTarget: this.downCurrentTarget,
          pointer: this.pointer
        } );
        this.interrupted = false;
      }
    },
    keydown: function( event ) {
      var keyCode = event.domEvent.keyCode;
      if ( keyCode === Input.KEY_ENTER || keyCode === Input.KEY_SPACE ) {
        this.buttonDown( event );
      }
    }
  } );
  return DownUpListener;
} );
define( 'SCENERY/input/TButtonListener',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TButtonListener( buttonListener, phetioID ) {
    TObject.call( this, buttonListener, phetioID );
    assertInstanceOf( buttonListener, phet.scenery.ButtonListener );
    toEventOnEmit( buttonListener.callbackEmitters.up.startedEmitter, buttonListener.callbackEmitters.up.endedEmitter, 'user', phetioID, this.constructor, 'up' );
    toEventOnEmit( buttonListener.callbackEmitters.over.startedEmitter, buttonListener.callbackEmitters.over.endedEmitter, 'user', phetioID, this.constructor, 'over' );
    toEventOnEmit( buttonListener.callbackEmitters.down.startedEmitter, buttonListener.callbackEmitters.down.endedEmitter, 'user', phetioID, this.constructor, 'down' );
    toEventOnEmit( buttonListener.callbackEmitters.out.startedEmitter, buttonListener.callbackEmitters.out.endedEmitter, 'user', phetioID, this.constructor, 'out' );
    toEventOnEmit( buttonListener.startedCallbacksForFireEmitter, buttonListener.endedCallbacksForFireEmitter, 'user', phetioID, this.constructor, 'fire' );
  }
  phetioInherit( TObject, 'TButtonListener', TButtonListener, {}, {
    documentation: 'Button listener',
    events: [ 'up', 'over', 'down', 'out', 'fire' ]
  } );
  scenery.register( 'TButtonListener', TButtonListener );
  return TButtonListener;
} );
define( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','AXON/Emitter','TANDEM/Tandem','SCENERY/input/DownUpListener','SCENERY/input/TButtonListener'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var Tandem = require( 'TANDEM/Tandem' );
  var DownUpListener = require( 'SCENERY/input/DownUpListener' );
  var TButtonListener = require( 'SCENERY/input/TButtonListener' );
  function ButtonListener( options ) {
    var self = this;
    options = _.extend( {
      tandem: Tandem.tandemOptional()
    }, options );
    this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'
    this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)
    this._buttonOptions = options; // store the options object so we can call the callbacks
    var states = [ 'up', 'over', 'down', 'out' ];
    this.callbackEmitters = {};
    states.forEach( function( state ) {
      self.callbackEmitters[ state ] = {
        startedEmitter: new Emitter(),
        endedEmitter: new Emitter()
      };
    } );
    this.startedCallbacksForFireEmitter = new Emitter();
    this.endedCallbacksForFireEmitter = new Emitter();
    DownUpListener.call( this, {
      mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)
      down: function( event, trail ) {
        if ( event.pointer.isKey ) {
          self.enter( event );
        }
        self.setButtonState( event, 'down' );
      },
      up: function( event, trail ) {
        self.setButtonState( event, self._overCount > 0 ? 'over' : 'up' );
        if ( event.pointer.isKey ) {
          self.exit( event );
        }
      }
    } );
    options.tandem.addInstance( this, TButtonListener );
  }
  scenery.register( 'ButtonListener', ButtonListener );
  inherit( DownUpListener, ButtonListener, {
    setButtonState: function( event, state ) {
      if ( state !== this.buttonState ) {
        sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
          'ButtonListener state change to ' + state + ' from ' + this.buttonState + ' for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
        var oldState = this.buttonState;
        this.buttonState = state;
        if ( this._buttonOptions[ state ] ) {
          this.callbackEmitters[ state ].startedEmitter.emit();
          this._buttonOptions[ state ]( event, oldState );
          this.callbackEmitters[ state ].endedEmitter.emit();
        }
        if ( this._buttonOptions.fire &&
             this._overCount > 0 &&
             ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {
          this.startedCallbacksForFireEmitter.emit();
          this._buttonOptions.fire( event );
          this.endedCallbacksForFireEmitter.emit();
        }
      }
    },
    enter: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener enter for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      this._overCount++;
      if ( this._overCount === 1 ) {
        this.setButtonState( event, this.isDown ? 'down' : 'over' );
      }
    },
    exit: function( event ) {
      sceneryLog && sceneryLog.InputEvent && sceneryLog.InputEvent(
        'ButtonListener exit for ' + ( this.downTrail ? this.downTrail.toString() : this.downTrail ) );
      assert && assert( this._overCount > 0, 'Exit events not matched by an enter' );
      this._overCount--;
      if ( this._overCount === 0 ) {
        this.setButtonState( event, this.isDown ? 'out' : 'up' );
      }
    }
  } );
  return ButtonListener;
} );
define( 'PHET_CORE/extendDefined',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function extendDefined( obj ) {
    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {
      if ( source ) {
        for ( var prop in source ) {
          var descriptor = Object.getOwnPropertyDescriptor( source, prop );
          if ( descriptor && ( typeof descriptor.get === 'function' || source[ prop ] !== undefined ) ) {
            Object.defineProperty( obj, prop, descriptor );
          }
        }
      }
    } );
    return obj;
  }
  phetCore.register( 'extendDefined', extendDefined );
  return extendDefined;
} );
define( 'SCENERY/util/Color',['require','PHET_CORE/inherit','SCENERY/scenery','AXON/Property','DOT/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Property = require( 'AXON/Property' );
  var Util = require( 'DOT/Util' );
  var clamp = Util.clamp;
  var linear = Util.linear;
  function Color( r, g, b, a ) {
    this.listeners = [];
    this.set( r, g, b, a );
    phetAllocation && phetAllocation( 'Color' );
  }
  scenery.register( 'Color', Color );
  var rgbNumber = '(-?\\d{1,3}%?)'; // syntax allows negative integers and percentages
  var aNumber = '(\\d+|\\d*\\.\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.
  var rawNumber = '(\\d{1,3})'; // a 1-3 digit number
  function parseRGBNumber( str ) {
    var multiplier = 1;
    if ( str.charAt( str.length - 1 ) === '%' ) {
      multiplier = 2.55;
      str = str.slice( 0, str.length - 1 );
    }
    return Math.round( parseInt( str, 10 ) * multiplier );
  }
  Color.formatParsers = [
    {
      regexp: /^transparent$/,
      apply: function( color, matches ) {
        color.setRGBA( 0, 0, 0, 0 );
      }
    },
    {
      regexp: /^#(\w{1})(\w{1})(\w{1})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ] + matches[ 1 ], 16 ),
          parseInt( matches[ 2 ] + matches[ 2 ], 16 ),
          parseInt( matches[ 3 ] + matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      regexp: /^#(\w{2})(\w{2})(\w{2})$/,
      apply: function( color, matches ) {
        color.setRGBA(
          parseInt( matches[ 1 ], 16 ),
          parseInt( matches[ 2 ], 16 ),
          parseInt( matches[ 3 ], 16 ),
          1 );
      }
    },
    {
      regexp: new RegExp( '^rgb\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          1 );
      }
    },
    {
      regexp: new RegExp( '^rgba\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setRGBA(
          parseRGBNumber( matches[ 1 ] ),
          parseRGBNumber( matches[ 2 ] ),
          parseRGBNumber( matches[ 3 ] ),
          parseFloat( matches[ 4 ] ) );
      }
    },
    {
      regexp: new RegExp( '^hsl\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          1 );
      }
    },
    {
      regexp: new RegExp( '^hsla\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\)$' ),
      apply: function( color, matches ) {
        color.setHSLA(
          parseInt( matches[ 1 ], 10 ),
          parseInt( matches[ 2 ], 10 ),
          parseInt( matches[ 3 ], 10 ),
          parseFloat( matches[ 4 ] ) );
      }
    }
  ];
  Color.hueToRGB = function( m1, m2, h ) {
    if ( h < 0 ) {
      h = h + 1;
    }
    if ( h > 1 ) {
      h = h - 1;
    }
    if ( h * 6 < 1 ) {
      return m1 + ( m2 - m1 ) * h * 6;
    }
    if ( h * 2 < 1 ) {
      return m2;
    }
    if ( h * 3 < 2 ) {
      return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;
    }
    return m1;
  };
  Color.toColor = function( colorSpec ) {
    return colorSpec instanceof Color ? colorSpec : new Color( colorSpec );
  };
  inherit( Object, Color, {
    copy: function() {
      return new Color( this.r, this.g, this.b, this.a );
    },
    set: function( r, g, b, a ) {
      assert && assert( r !== undefined, 'Can\'t call Color.set( undefined )' );
      if ( typeof r === 'string' ) {
        this.setCSS( r );
      }
      else if ( r instanceof Color ) {
        this.setRGBA( r.r, r.g, r.b, r.a );
      }
      else if ( b === undefined ) {
        assert && assert( typeof r === 'number' );
        assert && assert( g === undefined || typeof g === 'number' );
        var red = ( r >> 16 ) & 0xFF;
        var green = ( r >> 8 ) & 0xFF;
        var blue = ( r >> 0 ) & 0xFF;
        var alpha = ( g === undefined ) ? 1 : g;
        this.setRGBA( red, green, blue, alpha );
      }
      else {
        assert && assert( typeof r === 'number' );
        assert && assert( typeof g === 'number' );
        assert && assert( typeof b === 'number' );
        assert && assert( a === undefined || typeof a === 'number' );
        this.setRGBA( r, g, b, ( a === undefined ) ? 1 : a );
      }
      return this; // support chaining
    },
    getRed: function() { return this.r; },
    setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },
    get red() { return this.getRed(); },
    set red( value ) { return this.setRed( value ); },
    getGreen: function() { return this.g; },
    setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },
    get green() { return this.getGreen(); },
    set green( value ) { return this.setGreen( value ); },
    getBlue: function() { return this.b; },
    setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },
    get blue() { return this.getBlue(); },
    set blue( value ) { return this.setBlue( value ); },
    getAlpha: function() { return this.a; },
    setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },
    get alpha() { return this.getAlpha(); },
    set alpha( value ) { return this.setAlpha( value ); },
    setRGBA: function( red, green, blue, alpha ) {
      this.r = Math.round( clamp( red, 0, 255 ) );
      this.g = Math.round( clamp( green, 0, 255 ) );
      this.b = Math.round( clamp( blue, 0, 255 ) );
      this.a = clamp( alpha, 0, 1 );
      this.updateColor(); // update the cached value
      return this; // allow chaining
    },
    computeCSS: function() {
      if ( this.a === 1 ) {
        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
      }
      else {
        var alpha = this.a.toFixed( 20 );
        while ( alpha.length >= 2 && alpha[ alpha.length - 1 ] === '0' && alpha[ alpha.length - 2 ] !== '.' ) {
          alpha = alpha.slice( 0, alpha.length - 1 );
        }
        var alphaString = this.a === 0 || this.a === 1 ? this.a : alpha;
        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';
      }
    },
    toCSS: function() {
      assert && assert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );
      return this._css;
    },
    setCSS: function( cssString ) {
      var str = cssString.replace( / /g, '' ).toLowerCase();
      var success = false;
      var keywordMatch = Color.colorKeywords[ str ];
      if ( keywordMatch ) {
        str = '#' + keywordMatch;
      }
      for ( var i = 0; i < Color.formatParsers.length; i++ ) {
        var parser = Color.formatParsers[ i ];
        var matches = parser.regexp.exec( str );
        if ( matches ) {
          parser.apply( this, matches );
          success = true;
          break;
        }
      }
      if ( !success ) {
        throw new Error( 'scenery.Color unable to parse color string: ' + cssString );
      }
      this.updateColor(); // update the cached value
    },
    toNumber: function() {
      return ( this.r << 16 ) + ( this.g << 8 ) + this.b;
    },
    updateColor: function() {
      assert && assert( !this.immutable, 'Cannot modify an immutable color' );
      assert && assert( typeof this.red === 'number' &&
                        typeof this.green === 'number' &&
                        typeof this.blue === 'number' &&
                        typeof this.alpha === 'number',
        'Ensure color components are numeric: ' + this.toString() );
      assert && assert( isFinite( this.red ) && isFinite( this.green ) && isFinite( this.blue ) && isFinite( this.alpha ),
        'Ensure color components are finite and not NaN' );
      assert && assert( this.red >= 0 && this.red <= 255 &&
                        this.green >= 0 && this.green <= 255 &&
                        this.red >= 0 && this.red <= 255 &&
                        this.alpha >= 0 && this.alpha <= 1,
        'Ensure color components are in the proper ranges: ' + this.toString() );
      var oldCSS = this._css;
      this._css = this.computeCSS();
      if ( oldCSS !== this._css && this.listeners.length ) {
        var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?
        var length = listeners.length;
        for ( var i = 0; i < length; i++ ) {
          listeners[ i ]();
        }
      }
    },
    setImmutable: function() {
      if ( assert ) {
        this.immutable = true;
      }
      return this; // allow chaining
    },
    getCanvasStyle: function() {
      return this.toCSS(); // should be inlined, leave like this for future maintainability
    },
    setHSLA: function( hue, saturation, lightness, alpha ) {
      hue = ( hue % 360 ) / 360;                    // integer modulo 360
      saturation = clamp( saturation / 100, 0, 1 ); // percentage
      lightness = clamp( lightness / 100, 0, 1 );   // percentage
      var m1;
      var m2;
      if ( lightness < 0.5 ) {
        m2 = lightness * ( saturation + 1 );
      }
      else {
        m2 = lightness + saturation - lightness * saturation;
      }
      m1 = lightness * 2 - m2;
      this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1 / 3 ) * 255 );
      this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );
      this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1 / 3 ) * 255 );
      this.a = clamp( alpha, 0, 1 );
      this.updateColor(); // update the cached value
      return this; // allow chaining
    },
    equals: function( color ) {
      return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
    },
    withAlpha: function( alpha ) {
      return new Color( this.r, this.g, this.b, alpha );
    },
    checkFactor: function( factor ) {
      if ( factor < 0 || factor > 1 ) {
        throw new Error( 'factor must be between 0 and 1: ' + factor );
      }
      return ( factor === undefined ) ? 0.7 : factor;
    },
    brighterColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, Math.floor( this.r / factor ) );
      var green = Math.min( 255, Math.floor( this.g / factor ) );
      var blue = Math.min( 255, Math.floor( this.b / factor ) );
      return new Color( red, green, blue, this.a );
    },
    colorUtilsBrighter: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.min( 255, this.getRed() + Math.floor( factor * ( 255 - this.getRed() ) ) );
      var green = Math.min( 255, this.getGreen() + Math.floor( factor * ( 255 - this.getGreen() ) ) );
      var blue = Math.min( 255, this.getBlue() + Math.floor( factor * ( 255 - this.getBlue() ) ) );
      return new Color( red, green, blue, this.getAlpha() );
    },
    darkerColor: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, Math.floor( factor * this.r ) );
      var green = Math.max( 0, Math.floor( factor * this.g ) );
      var blue = Math.max( 0, Math.floor( factor * this.b ) );
      return new Color( red, green, blue, this.a );
    },
    colorUtilsDarker: function( factor ) {
      factor = this.checkFactor( factor );
      var red = Math.max( 0, this.getRed() - Math.floor( factor * this.getRed() ) );
      var green = Math.max( 0, this.getGreen() - Math.floor( factor * this.getGreen() ) );
      var blue = Math.max( 0, this.getBlue() - Math.floor( factor * this.getBlue() ) );
      return new Color( red, green, blue, this.getAlpha() );
    },
    colorUtilsBrightness: function( factor ) {
      if ( factor === 0 ) {
        return this;
      }
      else if ( factor > 0 ) {
        return this.colorUtilsBrighter( factor );
      }
      else {
        return this.colorUtilsDarker( -factor );
      }
    },
    addChangeListener: function( listener ) {
      assert && assert( listener !== undefined && listener !== null, 'Verify that the listener exists' );
      this.listeners.push( listener );
    },
    removeChangeListener: function( listener ) {
      assert && assert( _.includes( this.listeners, listener ) );
      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );
    },
    getListenerCount: function() {
      return this.listeners.length;
    },
    toString: function() {
      return this.constructor.name + '[r:' + this.r + ' g:' + this.g + ' b:' + this.b + ' a:' + this.a + ']';
    },
    toStateObject: function() {
      return {
        r: this.r,
        g: this.g,
        b: this.b,
        a: this.a
      };
    }
  } );
  Color.basicColorKeywords = {
    aqua: '00ffff',
    black: '000000',
    blue: '0000ff',
    fuchsia: 'ff00ff',
    gray: '808080',
    green: '008000',
    lime: '00ff00',
    maroon: '800000',
    navy: '000080',
    olive: '808000',
    purple: '800080',
    red: 'ff0000',
    silver: 'c0c0c0',
    teal: '008080',
    white: 'ffffff',
    yellow: 'ffff00'
  };
  Color.colorKeywords = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '00ffff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000000',
    blanchedalmond: 'ffebcd',
    blue: '0000ff',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '00ffff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'ff00ff',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '778899',
    lightslategrey: '778899',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '00ff00',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'ff00ff',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    red: 'ff0000',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'ffffff',
    whitesmoke: 'f5f5f5',
    yellow: 'ffff00',
    yellowgreen: '9acd32'
  };
  Color.BLACK = Color.black = new Color( 0, 0, 0 ).setImmutable();
  Color.BLUE = Color.blue = new Color( 0, 0, 255 ).setImmutable();
  Color.CYAN = Color.cyan = new Color( 0, 255, 255 ).setImmutable();
  Color.DARK_GRAY = Color.darkGray = new Color( 64, 64, 64 ).setImmutable();
  Color.GRAY = Color.gray = new Color( 128, 128, 128 ).setImmutable();
  Color.GREEN = Color.green = new Color( 0, 255, 0 ).setImmutable();
  Color.LIGHT_GRAY = Color.lightGray = new Color( 192, 192, 192 ).setImmutable();
  Color.MAGENTA = Color.magenta = new Color( 255, 0, 255 ).setImmutable();
  Color.ORANGE = Color.orange = new Color( 255, 200, 0 ).setImmutable();
  Color.PINK = Color.pink = new Color( 255, 175, 175 ).setImmutable();
  Color.RED = Color.red = new Color( 255, 0, 0 ).setImmutable();
  Color.WHITE = Color.white = new Color( 255, 255, 255 ).setImmutable();
  Color.YELLOW = Color.yellow = new Color( 255, 255, 0 ).setImmutable();
  Color.interpolateRGBA = function( color1, color2, distance ) {
    if ( distance < 0 || distance > 1 ) {
      throw new Error( 'distance must be between 0 and 1: ' + distance );
    }
    var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );
    var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );
    var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );
    var a = linear( 0, 1, color1.a, color2.a, distance );
    return new Color( r, g, b, a );
  };
  Color.fromStateObject = function( stateObject ) {
    return new Color( stateObject.r, stateObject.g, stateObject.b, stateObject.a );
  };
  Color.hsla = function( hue, saturation, lightness, alpha ) {
    return new Color( 0, 0, 0, 1 ).setHSLA( hue, saturation, lightness, alpha );
  };
  var scratchColor = new Color( 'blue' );
  Color.checkPaintString = function( cssString ) {
    if ( assert ) {
      try {
        scratchColor.setCSS( cssString );
      }
      catch( e ) {
        assert( false, 'The CSS string is an invalid color: ' + cssString );
      }
    }
  };
  Color.checkPaint = function( paint ) {
    if ( typeof paint === 'string' ) {
      Color.checkPaintString( paint );
    }
    else if ( ( paint instanceof Property ) && ( typeof paint.value === 'string' ) ) {
      Color.checkPaintString( paint.value );
    }
  };
  return Color;
} );
define( 'SCENERY/nodes/Paintable',['require','SCENERY/scenery','SCENERY/util/Color','KITE/util/LineStyles','SCENERY/display/Renderer','PHET_CORE/extend','PHET_CORE/platform','PHET_CORE/arrayRemove','AXON/Property'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var Color = require( 'SCENERY/util/Color' );
  var LineStyles = require( 'KITE/util/LineStyles' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var extend = require( 'PHET_CORE/extend' );
  var platform = require( 'PHET_CORE/platform' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var Property = require( 'AXON/Property' );
  var isSafari5 = platform.safari5;
  var isIE9 = platform.ie9;
  var PAINTABLE_OPTION_KEYS = [
    'fill', // Sets the fill of this node, see setFill() for documentation.
    'fillPickable', // Sets whether the filled area of the node will be treated as 'inside'. See setFillPickable()
    'stroke', // Sets the stroke of this node, see setStroke() for documentation.
    'strokePickable', // Sets whether the stroked area of the node will be treated as 'inside'. See setStrokePickable()
    'lineWidth', // Sets the width of the stroked area, see setLineWidth for documentation.
    'lineCap', // Sets the shape of the stroked area at the start/end of the path, see setLineCap() for documentation.
    'lineJoin', // Sets the shape of the stroked area at joints, see setLineJoin() for documentation.
    'miterLimit', // Sets when lineJoin will switch from miter to bevel, see setMiterLimit() for documentation.
    'lineDash', // Sets a line-dash pattern for the stroke, see setLineDash() for documentation
    'lineDashOffset', // Sets the offset of the line-dash from the start of the stroke, see setLineDashOffset()
    'cachedPaints' // Sets which paints should be cached, even if not displayed. See setCachedPaints()
  ];
  var Paintable = {
    mixin: function( type ) {
      var proto = type.prototype;
      extend( proto, {
        drawableMarkFlags: proto.drawableMarkFlags.concat( [ 'fill', 'stroke', 'lineWidth', 'lineOptions', 'cachedPaints' ] ),
        _mutatorKeys: PAINTABLE_OPTION_KEYS.concat( proto._mutatorKeys ),
        initializePaintable: function() {
          this._fill = null;
          this._fillPickable = true;
          this._stroke = null;
          this._strokePickable = false;
          this._cachedPaints = [];
          this._lineDrawingStyles = new LineStyles();
        },
        setFill: function( fill ) {
          assert && assert( fill === null ||
                            typeof fill === 'string' ||
                            fill instanceof Color ||
                            fill.isPaint ||
                            ( ( fill instanceof Property ) && (
                              typeof fill.value === 'string' ||
                              fill.value instanceof Color
                            ) ),
            'Invalid fill type' );
          if ( assert && typeof fill === 'string' ) {
            Color.checkPaintString( fill );
          }
          if ( this._fill !== fill ) {
            this._fill = fill;
            this.invalidateFill();
          }
          return this;
        },
        set fill( value ) { this.setFill( value ); },
        getFill: function() {
          return this._fill;
        },
        get fill() { return this.getFill(); },
        hasFill: function() {
          return this._fill !== null;
        },
        getFillValue: function() {
          var fill = this.getFill();
          if ( fill instanceof Property ) {
            fill = fill.get();
          }
          return fill;
        },
        get fillValue() { return this.getFillValue(); },
        setStroke: function( stroke ) {
          assert && assert( stroke === null ||
                            typeof stroke === 'string' ||
                            stroke instanceof Color ||
                            stroke.isPaint ||
                            ( ( stroke instanceof Property ) && (
                              typeof stroke.value === 'string' ||
                              stroke.value instanceof Color
                            ) ),
            'Invalid stroke type' );
          if ( assert && typeof stroke === 'string' ) {
            Color.checkPaintString( stroke );
          }
          if ( this._stroke !== stroke ) {
            this._stroke = stroke;
            this.invalidateStroke();
          }
          return this;
        },
        set stroke( value ) { this.setStroke( value ); },
        getStroke: function() {
          return this._stroke;
        },
        get stroke() { return this.getStroke(); },
        hasStroke: function() {
          return this._stroke !== null;
        },
        getStrokeValue: function() {
          var stroke = this.getStroke();
          if ( stroke instanceof Property ) {
            stroke = stroke.get();
          }
          return stroke;
        },
        get strokeValue() { return this.getStrokeValue(); },
        setFillPickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean' );
          if ( this._fillPickable !== pickable ) {
            this._fillPickable = pickable;
            this.invalidateFill();
          }
          return this;
        },
        set fillPickable( value ) { this.setFillPickable( value ); },
        isFillPickable: function() {
          return this._fillPickable;
        },
        get fillPickable() { return this.isFillPickable(); },
        setStrokePickable: function( pickable ) {
          assert && assert( typeof pickable === 'boolean', 'strokePickable should be a boolean, not ' + pickable );
          if ( this._strokePickable !== pickable ) {
            this._strokePickable = pickable;
            this.invalidateStroke();
          }
          return this;
        },
        set strokePickable( value ) { this.setStrokePickable( value ); },
        isStrokePickable: function() {
          return this._strokePickable;
        },
        get strokePickable() { return this.isStrokePickable(); },
        setLineWidth: function( lineWidth ) {
          assert && assert( typeof lineWidth === 'number', 'lineWidth should be a number, not ' + lineWidth );
          assert && assert( lineWidth >= 0, 'lineWidth should be non-negative instead of ' + lineWidth );
          if ( this.getLineWidth() !== lineWidth ) {
            this._lineDrawingStyles.lineWidth = lineWidth;
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineWidth();
            }
          }
          return this;
        },
        set lineWidth( value ) { this.setLineWidth( value ); },
        getLineWidth: function() {
          return this._lineDrawingStyles.lineWidth;
        },
        get lineWidth() { return this.getLineWidth(); },
        setLineCap: function( lineCap ) {
          assert && assert( lineCap === 'butt' || lineCap === 'round' || lineCap === 'square',
            'lineCap should be one of "butt", "round" or "square", not ' + lineCap );
          if ( this._lineDrawingStyles.lineCap !== lineCap ) {
            this._lineDrawingStyles.lineCap = lineCap;
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineCap( value ) { this.setLineCap( value ); },
        getLineCap: function() {
          return this._lineDrawingStyles.lineCap;
        },
        get lineCap() { return this.getLineCap(); },
        setLineJoin: function( lineJoin ) {
          assert && assert( lineJoin === 'miter' || lineJoin === 'round' || lineJoin === 'bevel',
            'lineJoin should be one of "miter", "round" or "bevel", not ' + lineJoin );
          if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {
            this._lineDrawingStyles.lineJoin = lineJoin;
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineJoin( value ) { this.setLineJoin( value ); },
        getLineJoin: function() {
          return this._lineDrawingStyles.lineJoin;
        },
        get lineJoin() { return this.getLineJoin(); },
        setMiterLimit: function( miterLimit ) {
          assert && assert( typeof miterLimit === 'number' && isFinite( miterLimit ), 'miterLimit should be a finite number' );
          if ( this._lineDrawingStyles.miterLimit !== miterLimit ) {
            this._lineDrawingStyles.miterLimit = miterLimit;
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set miterLimit( value ) { this.setMiterLimit( value ); },
        getMiterLimit: function() {
          return this._lineDrawingStyles.miterLimit;
        },
        get miterLimit() { return this.getMiterLimit(); },
        setLineDash: function( lineDash ) {
          assert && assert( lineDash instanceof Array && lineDash.every( function( n ) { return typeof n === 'number' && isFinite( n ) && n >= 0; } ),
            'lineDash should be an array of finite non-negative numbers' );
          if ( this._lineDrawingStyles.lineDash !== lineDash ) {
            this._lineDrawingStyles.lineDash = lineDash || [];
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDash( value ) { this.setLineDash( value ); },
        getLineDash: function() {
          return this._lineDrawingStyles.lineDash;
        },
        get lineDash() { return this.getLineDash(); },
        hasLineDash: function() {
          return !!this._lineDrawingStyles.lineDash.length;
        },
        setLineDashOffset: function( lineDashOffset ) {
          assert && assert( typeof lineDashOffset === 'number' && isFinite( lineDashOffset ),
            'lineDashOffset should be a number, not ' + lineDashOffset );
          if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {
            this._lineDrawingStyles.lineDashOffset = lineDashOffset;
            this.invalidateStroke();
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyLineOptions();
            }
          }
          return this;
        },
        set lineDashOffset( value ) { this.setLineDashOffset( value ); },
        getLineDashOffset: function() {
          return this._lineDrawingStyles.lineDashOffset;
        },
        get lineDashOffset() { return this.getLineDashOffset(); },
        setLineStyles: function( lineStyles ) {
          assert && assert( lineStyles instanceof LineStyles );
          this._lineDrawingStyles = lineStyles;
          this.invalidateStroke();
          return this;
        },
        set lineStyles( value ) { this.setLineStyles( value ); },
        getLineStyles: function() {
          return this._lineDrawingStyles;
        },
        get lineStyles() { return this.getLineStyles(); },
        setCachedPaints: function( paints ) {
          this._cachedPaints = paints.filter( function( paint ) { return paint && paint.isPaint; } );
          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyCachedPaints();
          }
          return this;
        },
        set cachedPaints( value ) { this.setCachedPaints( value ); },
        getCachedPaints: function() {
          return this._cachedPaints;
        },
        get cachedPaints() { return this.getCachedPaints(); },
        addCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            this._cachedPaints.push( paint );
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },
        removeCachedPaint: function( paint ) {
          if ( paint && paint.isPaint ) {
            assert && assert( _.includes( this._cachedPaints, paint ) );
            arrayRemove( this._cachedPaints, paint );
            var stateLen = this._drawables.length;
            for ( var i = 0; i < stateLen; i++ ) {
              this._drawables[ i ].markDirtyCachedPaints();
            }
          }
        },
        beforeCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();
          wrapper.setFillStyle( fillValue );
          if ( fillValue.transformMatrix ) {
            wrapper.context.save();
            fillValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },
        afterCanvasFill: function( wrapper ) {
          var fillValue = this.getFillValue();
          if ( fillValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },
        beforeCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();
          wrapper.setStrokeStyle( this._stroke );
          wrapper.setLineWidth( this.getLineWidth() );
          wrapper.setLineCap( this.getLineCap() );
          wrapper.setLineJoin( this.getLineJoin() );
          wrapper.setMiterLimit( this.getMiterLimit() );
          wrapper.setLineDash( this.getLineDash() );
          wrapper.setLineDashOffset( this.getLineDashOffset() );
          if ( strokeValue.transformMatrix ) {
            wrapper.context.save();
            strokeValue.transformMatrix.canvasAppendTransform( wrapper.context );
          }
        },
        afterCanvasStroke: function( wrapper ) {
          var strokeValue = this.getStrokeValue();
          if ( strokeValue.transformMatrix ) {
            wrapper.context.restore();
          }
        },
        getCSSFill: function() {
          var fillValue = this.getFillValue();
          return fillValue ? ( fillValue.toCSS ? fillValue.toCSS() : fillValue ) : 'transparent';
        },
        getSimpleCSSStroke: function() {
          var strokeValue = this.getStrokeValue();
          return strokeValue ? ( strokeValue.toCSS ? strokeValue.toCSS() : strokeValue ) : 'transparent';
        },
        appendFillablePropString: function( spaces, result ) {
          if ( this._fill ) {
            if ( result ) {
              result += ',\n';
            }
            if ( typeof this.getFillValue() === 'string' ) {
              result += spaces + 'fill: \'' + this.getFillValue() + '\'';
            }
            else {
              result += spaces + 'fill: ' + this.getFillValue().toString();
            }
          }
          return result;
        },
        appendStrokablePropString: function( spaces, result ) {
          var self = this;
          function addProp( key, value, nowrap ) {
            if ( result ) {
              result += ',\n';
            }
            if ( !nowrap && typeof value === 'string' ) {
              result += spaces + key + ': \'' + value + '\'';
            }
            else {
              result += spaces + key + ': ' + value;
            }
          }
          if ( this._stroke ) {
            var defaultStyles = new LineStyles();
            if ( typeof this.getStrokeValue() === 'string' ) {
              addProp( 'stroke', this.getStrokeValue() );
            }
            else {
              addProp( 'stroke', this.getStrokeValue().toString(), true );
            }
            _.each( [ 'lineWidth', 'lineCap', 'miterLimit', 'lineJoin', 'lineDashOffset' ], function( prop ) {
              if ( self[ prop ] !== defaultStyles[ prop ] ) {
                addProp( prop, self[ prop ] );
              }
            } );
            if ( this.lineDash.length ) {
              addProp( 'lineDash', JSON.stringify( this.lineDash ), true );
            }
          }
          return result;
        },
        getFillRendererBitmask: function() {
          var bitmask = 0;
          if ( !( isSafari5 && this._fill && this._fill.isGradient ) ) {
            bitmask |= Renderer.bitmaskSVG;
          }
          bitmask |= Renderer.bitmaskCanvas;
          if ( !this.hasFill() ) {
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }
          else if ( this._fill.isPattern ) {
          }
          else if ( this._fill.isGradient ) {
          }
          else {
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }
          return bitmask;
        },
        getStrokeRendererBitmask: function() {
          var bitmask = 0;
          if ( !( isIE9 && this.hasStroke() && this.hasLineDash() ) ) {
            bitmask |= Renderer.bitmaskCanvas;
          }
          bitmask |= Renderer.bitmaskSVG;
          if ( !this.hasStroke() ) {
            bitmask |= Renderer.bitmaskDOM;
            bitmask |= Renderer.bitmaskWebGL;
          }
          return bitmask;
        }
      } );
      function invalidateFill() {
        this.invalidateSupportedRenderers();
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFill();
        }
      }
      if ( proto.invalidateFill ) {
        var subtypeInvalidateFill = proto.invalidateFill;
        proto.invalidateFill = function() {
          subtypeInvalidateFill.call( this );
          invalidateFill.call( this );
        };
      }
      else {
        proto.invalidateFill = invalidateFill;
      }
      function invalidateStroke() {
        this.invalidateSupportedRenderers();
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyStroke();
        }
      }
      if ( proto.invalidateStroke ) {
        var subtypeInvalidateStroke = proto.invalidateStroke;
        proto.invalidateStroke = function() {
          subtypeInvalidateStroke.call( this );
          invalidateStroke.call( this );
        };
      }
      else {
        proto.invalidateStroke = invalidateStroke;
      }
    }
  };
  scenery.register( 'Paintable', Paintable );
  return Paintable;
} );
define( 'SCENERY/display/Drawable',['require','PHET_CORE/inherit','AXON/Events','SCENERY/scenery','SCENERY/display/Renderer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var globalId = 1;
  function Drawable( renderer ) {
    this.initializeDrawable( renderer );
  }
  scenery.register( 'Drawable', Drawable );
  inherit( Events, Drawable, {
    initializeDrawable: function( renderer ) {
      Events.call( this );
      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );
      this.id = this.id || globalId++;
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] initialize ' + this.toString() );
      this.cleanDrawable();
      this.renderer = renderer;
      this.dirty = true;
      this.disposed = false;
      this.linksDirty = false;
      this._visible = true; // {boolean}, ES5 getter/setter provided
      this._fittable = true;
      return this;
    },
    cleanDrawable: function() {
      this.parentDrawable = null;
      this.backbone = null; // a backbone reference (if applicable).
      this.pendingParentDrawable = null; // what our parent drawable will be after the stitch is finished
      this.pendingBackbone = null;       // what our backbone will be after the stitch is finished (if applicable)
      this.pendingAddition = false;      // whether we are to be added to a block/backbone in our updateBlock() call
      this.pendingRemoval = false;       // whether we are to be removed from a block/backbone in our updateBlock() call
      assert && assert( !this.previousDrawable && !this.nextDrawable,
        'By cleaning (disposal or fresh creation), we should have disconnected from the linked list' );
      this.previousDrawable = null;
      this.nextDrawable = null;
      this.oldPreviousDrawable = null;
      this.oldNextDrawable = null;
      this.removeAllEventListeners();
    },
    setVisible: function( visible ) {
      if ( this._visible !== visible ) {
        this._visible = visible;
        this.trigger0( 'visibility' );
      }
    },
    set visible( value ) { this.setVisible( value ); },
    isVisible: function() {
      return this._visible;
    },
    get visible() { return this.isVisible(); },
    setFittable: function( fittable ) {
      if ( this._fittable !== fittable ) {
        this._fittable = fittable;
        this.trigger1( 'fittability', this );
      }
    },
    set fittable( value ) { this.setFittable( value ); },
    isFittable: function() {
      return this._fittable;
    },
    get fittable() { return this.isFittable(); },
    setBlockBackbone: function( backboneInstance ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] setBlockBackbone ' +
                                                                this.toString() + ' with ' + backboneInstance.toString() );
      assert && assert( this instanceof scenery.Block );
      this.parentDrawable = backboneInstance;
      this.backbone = backboneInstance;
      this.pendingParentDrawable = backboneInstance;
      this.pendingBackbone = backboneInstance;
      this.pendingAddition = false;
      this.pendingRemoval = false;
    },
    notePendingAddition: function( display, block, backbone ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingAddition ' +
                                                                this.toString() + ' with ' + block.toString() + ', ' +
                                                                ( backbone ? backbone.toString() : '-' ) );
      assert && assert( backbone !== undefined, 'backbone can be either null or a backbone' );
      assert && assert( block instanceof scenery.Block );
      this.pendingParentDrawable = block;
      this.pendingBackbone = backbone;
      this.pendingAddition = true;
      if ( !this.pendingRemoval ) {
        display.markDrawableChangedBlock( this );
      }
    },
    notePendingRemoval: function( display ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingRemoval ' +
                                                                this.toString() );
      this.pendingRemoval = true;
      if ( !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }
    },
    notePendingMove: function( display, block ) {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] notePendingMove ' +
                                                                this.toString() + ' with ' + block.toString() );
      assert && assert( block instanceof scenery.Block );
      this.pendingParentDrawable = block;
      if ( !this.pendingRemoval || !this.pendingAddition ) {
        display.markDrawableChangedBlock( this );
      }
      this.pendingAddition = true;
      this.pendingRemoval = true;
    },
    updateBlock: function() {
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] updateBlock ' + this.toString() +
                                                                ' with add:' + this.pendingAddition +
                                                                ' remove:' + this.pendingRemoval +
                                                                ' old:' + ( this.parentDrawable ? this.parentDrawable.toString() : '-' ) +
                                                                ' new:' + ( this.pendingParentDrawable ? this.pendingParentDrawable.toString() : '-' ) );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();
      var changed = false;
      if ( this.pendingRemoval || this.pendingAddition ) {
        changed = !this.pendingRemoval || !this.pendingAddition ||
                  this.parentDrawable !== this.pendingParentDrawable ||
                  this.backbone !== this.pendingBackbone;
        if ( changed ) {
          if ( this.pendingRemoval ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'removing from ' + this.parentDrawable.toString() );
            this.parentDrawable.removeDrawable( this );
            if ( !this.pendingAddition ) {
              this.pendingParentDrawable = null;
              this.pendingBackbone = null;
            }
          }
          this.parentDrawable = this.pendingParentDrawable;
          this.backbone = this.pendingBackbone;
          if ( this.pendingAddition ) {
            sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'adding to ' + this.parentDrawable.toString() );
            this.parentDrawable.addDrawable( this );
          }
        }
        else {
          sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( 'unchanged' );
          if ( this.pendingAddition && Renderer.isCanvas( this.renderer ) ) {
            this.parentDrawable.onPotentiallyMovedDrawable( this );
          }
        }
        this.pendingAddition = false;
        this.pendingRemoval = false;
      }
      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();
      return changed;
    },
    updateLinks: function() {
      this.oldNextDrawable = this.nextDrawable;
      this.oldPreviousDrawable = this.previousDrawable;
      this.linksDirty = false;
    },
    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;
        if ( this.parentDrawable ) {
          this.parentDrawable.markDirtyDrawable( this );
        }
      }
    },
    markLinksDirty: function( display ) {
      if ( !this.linksDirty ) {
        this.linksDirty = true;
        display.markDrawableForLinksUpdate( this );
      }
    },
    markForDisposal: function( display ) {
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );
      display.markDrawableForDisposal( this );
    },
    disposeImmediately: function( display ) {
      Drawable.disconnectBefore( this, display );
      Drawable.disconnectAfter( this, display );
      this.dispose();
    },
    dispose: function() {
      assert && assert( !this.disposed, 'We should not re-dispose drawables' );
      sceneryLog && sceneryLog.Drawable && sceneryLog.Drawable( '[' + this.constructor.name + '*] dispose ' + this.toString() );
      sceneryLog && sceneryLog.Drawable && sceneryLog.push();
      this.cleanDrawable();
      this.disposed = true;
      this.freeToPool();
      sceneryLog && sceneryLog.Drawable && sceneryLog.pop();
    },
    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        assertSlow && assertSlow( !this.disposed,
          'If we are being audited, we assume we are in the drawable display tree, and we should not be marked as disposed' );
        assertSlow && assertSlow( this.renderer, 'Should not have a 0 (no) renderer' );
        assertSlow && assertSlow( !this.backbone || this.parentDrawable,
          'If we have a backbone reference, we must have a parentDrawable (our block)' );
        if ( !allowPendingBlock ) {
          assertSlow && assertSlow( !this.pendingAddition );
          assertSlow && assertSlow( !this.pendingRemoval );
          assertSlow && assertSlow( this.parentDrawable === this.pendingParentDrawable,
            'Assure our parent and pending parent match, if we have updated blocks' );
          assertSlow && assertSlow( this.backbone === this.pendingBackbone,
            'Assure our backbone and pending backbone match, if we have updated blocks' );
        }
        if ( !allowPendingList ) {
          assertSlow && assertSlow( this.oldPreviousDrawable === this.previousDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( this.oldNextDrawable === this.nextDrawable,
            'Pending linked-list references should be cleared by now' );
          assertSlow && assertSlow( !this.linksDirty, 'Links dirty flag should be clean' );
        }
        if ( !allowDirty ) {
          assertSlow && assertSlow( !this.dirty,
            'Should not be dirty at this phase, if we are in the drawable display tree' );
        }
      }
    },
    toString: function() {
      return this.constructor.name + '#' + this.id;
    },
    toDetailedString: function() {
      return this.toString();
    }
  } );
  Drawable.connectDrawables = function( a, b, display ) {
    if ( a.nextDrawable !== b ) {
      if ( a.nextDrawable ) {
        a.nextDrawable.markLinksDirty( display );
        a.nextDrawable.previousDrawable = null;
      }
      if ( b.previousDrawable ) {
        b.previousDrawable.markLinksDirty( display );
        b.previousDrawable.nextDrawable = null;
      }
      a.nextDrawable = b;
      b.previousDrawable = a;
      a.markLinksDirty( display );
      b.markLinksDirty( display );
    }
  };
  Drawable.disconnectBefore = function( a, display ) {
    if ( a.previousDrawable ) {
      a.markLinksDirty( display );
      a.previousDrawable.markLinksDirty( display );
      a.previousDrawable.nextDrawable = null;
      a.previousDrawable = null;
    }
  };
  Drawable.disconnectAfter = function( a, display ) {
    if ( a.nextDrawable ) {
      a.markLinksDirty( display );
      a.nextDrawable.markLinksDirty( display );
      a.nextDrawable.previousDrawable = null;
      a.nextDrawable = null;
    }
  };
  Drawable.listToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];
    for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
      arr.push( drawable );
      if ( drawable === lastDrawable ) {
        break;
      }
    }
    return arr;
  };
  Drawable.oldListToArray = function( firstDrawable, lastDrawable ) {
    var arr = [];
    for ( var drawable = firstDrawable; ; drawable = drawable.oldNextDrawable ) {
      arr.push( drawable );
      if ( drawable === lastDrawable ) {
        break;
      }
    }
    return arr;
  };
  return Drawable;
} );
define( 'SCENERY/display/SelfDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  function SelfDrawable( renderer, instance ) {
    this.initializeSelfDrawable( renderer, instance );
  }
  scenery.register( 'SelfDrawable', SelfDrawable );
  inherit( scenery.Drawable, SelfDrawable, {
    initializeSelfDrawable: function( renderer, instance ) {
      this.drawableVisibilityListener = this.drawableVisibilityListener || this.updateSelfVisibility.bind( this );
      this.initializeDrawable( renderer );
      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.node.attachDrawable( this );
      this.instance.onStatic( 'selfVisibility', this.drawableVisibilityListener );
      this.updateSelfVisibility();
      return this;
    },
    dispose: function() {
      this.instance.offStatic( 'selfVisibility', this.drawableVisibilityListener );
      this.node.detachDrawable( this );
      this.instance = null;
      this.node = null;
      Drawable.prototype.dispose.call( this );
    },
    updateSelfVisibility: function() {
      this.visible = this.instance.selfVisible;
    },
    toDetailedString: function() {
      return this.toString() + ' (' + this.instance.trail.toPathString() + ')';
    }
  } );
  SelfDrawable.Poolable = {
    mixin: function( selfDrawableType ) {
      Poolable.mixin( selfDrawableType, {
        defaultFactory: function() {
          return new selfDrawableType();
        },
        constructorDuplicateFactory: function( pool ) {
          return function( renderer, instance ) {
            if ( pool.length ) {
              return pool.pop().initialize( renderer, instance );
            }
            else {
              return new selfDrawableType( renderer, instance );
            }
          };
        }
      } );
    }
  };
  return SelfDrawable;
} );
define( 'SCENERY/util/Paint',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var globalId = 1;
  function Paint() {
    this.id = 'paint' + globalId++;
    this.transformMatrix = null;
  }
  scenery.register( 'Paint', Paint );
  inherit( Object, Paint, {
    isPaint: true,
    getCanvasStyle: function() {
      throw new Error( 'abstract method' );
    },
    setTransformMatrix: function( transformMatrix ) {
      if ( this.transformMatrix !== transformMatrix ) {
        this.transformMatrix = transformMatrix;
      }
      return this;
    }
  } );
  return Paint;
} );
define( 'SCENERY/util/Gradient',['require','PHET_CORE/cleanArray','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/util/Paint','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Paint = require( 'SCENERY/util/Paint' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );
  function Gradient() {
    assert && assert( this.constructor.name !== 'Gradient',
      'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );
    Paint.call( this );
    this.stops = [];
    this.lastStopRatio = 0;
    this.canvasGradient = null;
    this.colorStopsDirty = false;
    this.lastColorStopValues = [];
  }
  scenery.register( 'Gradient', Gradient );
  inherit( Paint, Gradient, {
    isGradient: true,
    addColorStop: function( ratio, color ) {
      assert && assert( typeof ratio === 'number', 'Ratio needs to be a number' );
      assert && assert( ratio >= 0 && ratio <= 1, 'Ratio needs to be between 0,1 inclusively' );
      assert && assert( color === null ||
                        typeof color === 'string' ||
                        color instanceof Color ||
                        ( color instanceof Property && ( color.value === null ||
                                                         typeof color.value === 'string' ||
                                                         color.value instanceof Color ) ),
        'Color should match the addColorStop type specification' );
      if ( this.lastStopRatio > ratio ) {
        throw new Error( 'Color stops not specified in the order of increasing ratios' );
      }
      else {
        this.lastStopRatio = ratio;
      }
      this.stops.push( {
        ratio: ratio,
        color: color
      } );
      this.lastColorStopValues.push( '' );
      return this;
    },
    createCanvasGradient: function() {
      throw new Error( 'abstract method' );
    },
    getSVGStops: function() {
      return this.stops;
    },
    invalidateCanvasGradient: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'Invalidated Canvas Gradient for #' + this.id );
      this.colorStopsDirty = true;
    },
    haveCanvasColorStopsChanged: function() {
      if ( this.lastColorStopValues === null ) {
        return true;
      }
      for ( var i = 0; i < this.stops.length; i++ ) {
        if ( Gradient.colorToString( this.stops[ i ].color ) !== this.lastColorStopValues[ i ] ) {
          return true;
        }
      }
      return false;
    },
    getCanvasStyle: function() {
      if ( !this.canvasGradient || ( this.colorStopsDirty && this.haveCanvasColorStopsChanged() ) ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'Regenerating Canvas Gradient for #' + this.id );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        this.colorStopsDirty = false;
        cleanArray( this.lastColorStopValues );
        this.canvasGradient = this.createCanvasGradient();
        for ( var i = 0; i < this.stops.length; i++ ) {
          var stop = this.stops[ i ];
          var colorString = Gradient.colorToString( stop.color );
          this.canvasGradient.addColorStop( stop.ratio, colorString );
          this.lastColorStopValues.push( colorString );
        }
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      return this.canvasGradient;
    }
  } );
  Gradient.colorToString = function( color ) {
    if ( color instanceof Property ) {
      color = color.value;
    }
    if ( color === null ) {
      color = 'transparent';
    }
    if ( color instanceof Color ) {
      color = color.toCSS();
    }
    return color;
  };
  return Gradient;
} );
define( 'SCENERY/display/PaintObserver',['require','SCENERY/util/Color','SCENERY/util/Gradient','PHET_CORE/inherit','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );
  function PaintObserver( type, changeCallback ) {
    assert && assert( type === 'fill' || type === 'stroke' );
    this.type = type;
    this.name = '_' + type;
    this.changeCallback = changeCallback;
    this.notifyChangeCallback = this.notifyChanged.bind( this );
    this.primary = null;
    this.updateSecondaryListener = this.updateSecondary.bind( this );
  }
  scenery.register( 'PaintObserver', PaintObserver );
  inherit( Object, PaintObserver, {
    initialize: function( node ) {
      assert && assert( node !== null );
      this.node = node;
      this.updatePrimary();
    },
    notifyChanged: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] changed ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      var primary = this.node[ this.name ];
      if ( primary instanceof Gradient ) {
        primary.invalidateCanvasGradient();
      }
      this.changeCallback();
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    updatePrimary: function() {
      var primary = this.node[ this.name ];
      if ( primary !== this.primary ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] primary update ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        this.detachPrimary( this.primary );
        this.primary = primary;
        this.attachPrimary( primary );
        this.notifyChangeCallback();
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
    },
    updateSecondary: function( newPaint, oldPaint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] secondary update ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      this.detachSecondary( oldPaint );
      this.attachSecondary( newPaint );
      this.notifyChangeCallback();
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    attachPrimary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] attachPrimary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      if ( paint instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Property listener ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        paint.lazyLink( this.updateSecondaryListener );
        this.attachSecondary( paint.get() );
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      else if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Color listener ' + this.node.id + '.' + this.name );
        paint.addChangeListener( this.notifyChangeCallback );
      }
      else if ( paint instanceof Gradient ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Gradient listeners ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        for ( var i = 0; i < paint.stops.length; i++ ) {
          this.attachPrimary( paint.stops[ i ].color );
        }
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    detachPrimary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] detachPrimary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      if ( paint instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Property listener ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        paint.unlink( this.updateSecondaryListener );
        this.detachSecondary( paint.get() );
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      else if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Color listener ' + this.node.id + '.' + this.name );
        paint.removeChangeListener( this.notifyChangeCallback );
      }
      else if ( paint instanceof Gradient ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Gradient listeners ' + this.node.id + '.' + this.name );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        for ( var i = 0; i < paint.stops.length; i++ ) {
          this.detachPrimary( paint.stops[ i ].color );
        }
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    attachSecondary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] attachSecondary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] add Color listener ' + this.node.id + '.' + this.name );
        paint.addChangeListener( this.notifyChangeCallback );
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    detachSecondary: function( paint ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] detachSecondary ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      if ( paint instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] remove Color listener ' + this.node.id + '.' + this.name );
        paint.removeChangeListener( this.notifyChangeCallback );
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    clean: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[PaintObserver] clean ' + this.node.id + '.' + this.name );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      this.detachPrimary( this.primary );
      this.primary = null;
      this.node = null;
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );
  return PaintObserver;
} );
define( 'SCENERY/display/drawables/PaintableStatelessDrawable',['require','SCENERY/scenery','SCENERY/display/PaintObserver','SCENERY/util/Color'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintObserver = require( 'SCENERY/display/PaintObserver' );
  var Color = require( 'SCENERY/util/Color' );
  var PaintableStatelessDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializePaintableStateless = function( renderer, instance ) {
        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );
        this.fillObserver = this.fillObserver || new PaintObserver( 'fill', this.fillCallback );
        this.strokeObserver = this.strokeObserver || new PaintObserver( 'stroke', this.strokeCallback );
        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );
        return this;
      };
      proto.disposePaintableStateless = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };
      proto.markDirtyFill = function() {
        assert && Color.checkPaint( this.instance.node._fill );
        this.markPaintDirty();
        this.fillObserver.updatePrimary(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };
      proto.markDirtyStroke = function() {
        assert && Color.checkPaint( this.instance.node._stroke );
        this.markPaintDirty();
        this.strokeObserver.updatePrimary(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };
      proto.markDirtyLineWidth = function() {
        this.markPaintDirty();
      };
      proto.markDirtyLineOptions = function() {
        this.markPaintDirty();
      };
      proto.markDirtyCachedPaints = function() {
        this.markPaintDirty();
      };
    }
  };
  scenery.register( 'PaintableStatelessDrawable', PaintableStatelessDrawable );
  return PaintableStatelessDrawable;
} );
define( 'SCENERY/display/CanvasSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function CanvasSelfDrawable( renderer, instance ) {
    this.initializeCanvasSelfDrawable( renderer, instance );
    throw new Error( 'Should use initialization and pooling' );
  }
  scenery.register( 'CanvasSelfDrawable', CanvasSelfDrawable );
  inherit( SelfDrawable, CanvasSelfDrawable, {
    initializeCanvasSelfDrawable: function( renderer, instance ) {
      this.initializeSelfDrawable( renderer, instance );
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
      return this;
    },
    markTransformDirty: function() {
      this.markDirty();
    },
    markPaintDirty: function() {
      this.markDirty();
    },
    update: function() {
      this.dirty = false;
    },
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );
      this.markDirty();
    },
    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();
      SelfDrawable.prototype.dispose.call( this );
    }
  } );
  function canvasSelfDirty() {
    this.markDirty();
  }
  CanvasSelfDrawable.createDrawable = function( options ) {
    var type = options.type;
    var paintCanvas = options.paintCanvas;
    var usesPaint = options.usesPaint;
    assert && assert( typeof type === 'function' );
    assert && assert( typeof paintCanvas === 'function' );
    assert && assert( typeof usesPaint === 'boolean' );
    inherit( CanvasSelfDrawable, type, {
      initialize: function( renderer, instance ) {
        this.initializeCanvasSelfDrawable( renderer, instance );
        if ( usesPaint ) {
          this.initializePaintableStateless( renderer, instance );
        }
        return this; // allow for chaining
      },
      paintCanvas: paintCanvas,
      update: function() {
        this.dirty = false;
      },
      dispose: function() {
        CanvasSelfDrawable.prototype.dispose.call( this );
        if ( usesPaint ) {
          this.disposePaintableStateless();
        }
      }
    } );
    if ( usesPaint ) {
      PaintableStatelessDrawable.mixin( type );
    }
    SelfDrawable.Poolable.mixin( type );
    if ( options.dirtyMethods ) {
      for ( var i = 0; i < options.dirtyMethods.length; i++ ) {
        type.prototype[ options.dirtyMethods[ i ] ] = canvasSelfDirty;
      }
    }
    return type;
  };
  return CanvasSelfDrawable;
} );
define( 'SCENERY/display/drawables/PathCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function PathCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'PathCanvasDrawable', PathCanvasDrawable );
  inherit( CanvasSelfDrawable, PathCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },
    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;
      if ( node.hasShape() ) {
        context.beginPath();
        node._shape.writeToContext( context );
        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }
        if ( node.hasStroke() && node.getLineWidth() > 0 ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
    },
    markDirtyShape: function() { this.markPaintDirty(); },
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  PaintableStatelessDrawable.mixin( PathCanvasDrawable );
  SelfDrawable.Poolable.mixin( PathCanvasDrawable );
  return PathCanvasDrawable;
} );
define( 'SCENERY/display/PaintSVGState',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  function paintToSVGStyle( paint, svgBlock ) {
    if ( !paint ) {
      return 'none';
    }
    else if ( paint.toCSS ) {
      return paint.toCSS();
    }
    else if ( paint.isPaint ) {
      return 'url(#' + paint.id + '-' + ( svgBlock ? svgBlock.id : 'noblock' ) + ')';
    }
    else {
      return paint;
    }
  }
  function PaintSVGState() {
    this.initialize();
  }
  scenery.register( 'PaintSVGState', PaintSVGState );
  inherit( Object, PaintSVGState, {
    initialize: function() {
      this.svgBlock = null; // {SVGBlock | null}
      this.fillStyle = 'none';
      this.strokeStyle = 'none';
      this.fillPaint = null;
      this.strokePaint = null;
      this.updateBaseStyle(); // the main style CSS
      this.strokeDetailStyle = ''; // width/dash/cap/join CSS
    },
    dispose: function() {
      this.releaseFillPaint();
      this.releaseStrokePaint();
    },
    releaseFillPaint: function() {
      if ( this.fillPaint ) {
        this.svgBlock.decrementPaint( this.fillPaint );
        this.fillPaint = null;
      }
    },
    releaseStrokePaint: function() {
      if ( this.strokePaint ) {
        this.svgBlock.decrementPaint( this.strokePaint );
        this.strokePaint = null;
      }
    },
    updateFill: function( svgBlock, fill ) {
      assert && assert( this.svgBlock === svgBlock );
      var fillStyle = paintToSVGStyle( fill, svgBlock );
      if ( fill !== this.fillPaint ) {
        this.releaseFillPaint();
        if ( fill && fill.isPaint ) {
          this.fillPaint = fill;
          svgBlock.incrementPaint( fill );
        }
      }
      if ( fillStyle !== this.fillStyle ) {
        this.fillStyle = fillStyle;
        this.updateBaseStyle();
      }
    },
    updateStroke: function( svgBlock, stroke ) {
      assert && assert( this.svgBlock === svgBlock );
      var strokeStyle = paintToSVGStyle( stroke, svgBlock );
      if ( stroke !== this.strokePaint ) {
        this.releaseStrokePaint();
        if ( stroke && stroke.isPaint ) {
          this.strokePaint = stroke;
          svgBlock.incrementPaint( stroke );
        }
      }
      if ( strokeStyle !== this.strokeStyle ) {
        this.strokeStyle = strokeStyle;
        this.updateBaseStyle();
      }
    },
    updateBaseStyle: function() {
      this.baseStyle = 'fill: ' + this.fillStyle + '; stroke: ' + this.strokeStyle + ';';
    },
    updateStrokeDetailStyle: function( node ) {
      var strokeDetailStyle = '';
      var lineWidth = node.getLineWidth();
      if ( lineWidth !== 1 ) {
        strokeDetailStyle += 'stroke-width: ' + lineWidth + ';';
      }
      var lineCap = node.getLineCap();
      if ( lineCap !== 'butt' ) {
        strokeDetailStyle += 'stroke-linecap: ' + lineCap + ';';
      }
      var lineJoin = node.getLineJoin();
      if ( lineJoin !== 'miter' ) {
        strokeDetailStyle += 'stroke-linejoin: ' + lineJoin + ';';
      }
      var miterLimit = node.getMiterLimit();
      strokeDetailStyle += 'stroke-miterlimit: ' + miterLimit + ';';
      if ( node.hasLineDash() ) {
        strokeDetailStyle += 'stroke-dasharray: ' + node.getLineDash().join( ',' ) + ';';
        strokeDetailStyle += 'stroke-dashoffset: ' + node.getLineDashOffset() + ';';
      }
      this.strokeDetailStyle = strokeDetailStyle;
    },
    updateSVGBlock: function( svgBlock ) {
      var oldSvgBlock = this.svgBlock;
      if ( oldSvgBlock ) {
        if ( this.fillPaint ) {
          oldSvgBlock.decrementPaint( this.fillPaint );
        }
        if ( this.strokePaint ) {
          oldSvgBlock.decrementPaint( this.strokePaint );
        }
      }
      this.svgBlock = svgBlock;
      if ( this.fillPaint ) {
        svgBlock.incrementPaint( this.fillPaint );
      }
      if ( this.strokePaint ) {
        svgBlock.incrementPaint( this.strokePaint );
      }
    }
  } );
  return PaintSVGState;
} );
define( 'SCENERY/display/SVGSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/PaintSVGState'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintSVGState = require( 'SCENERY/display/PaintSVGState' );
  function SVGSelfDrawable( renderer, instance ) {
    this.initializeSVGSelfDrawable( renderer, instance );
    throw new Error( 'Should use initialization and pooling' );
  }
  scenery.register( 'SVGSelfDrawable', SVGSelfDrawable );
  inherit( SelfDrawable, SVGSelfDrawable, {
    initializeSVGSelfDrawable: function( renderer, instance, usesPaint, keepElements ) {
      this.initializeSelfDrawable( renderer, instance );
      this.usesPaint = usesPaint;
      this.keepElements = keepElements;
      this.svgElement = null; // should be filled in by subtype
      this.svgBlock = null; // will be updated by updateSVGBlock()
      this.initializeState( renderer, instance ); // assumes we have a state mixin
      if ( this.usesPaint ) {
        if ( !this.paintState ) {
          this.paintState = new PaintSVGState();
        }
        else {
          this.paintState.initialize();
        }
      }
      return this; // allow chaining
    },
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateSVG();
      }
    },
    updateSVG: function() {
      if ( this.paintDirty ) {
        this.updateSVGSelf( this.node, this.svgElement );
      }
      if ( this.usesPaint && this.dirtyCachedPaints ) {
        var newCachedPaints = this.node._cachedPaints.slice(); // defensive copy for now
        var i;
        var j;
        for ( i = 0; i < newCachedPaints.length; i++ ) {
          var newPaint = newCachedPaints[ i ];
          var isNew = true;
          for ( j = 0; j < this.lastCachedPaints.length; j++ ) {
            if ( newPaint === this.lastCachedPaints[ j ] ) {
              isNew = false;
              break;
            }
          }
          if ( isNew ) {
            this.svgBlock.incrementPaint( newPaint );
          }
        }
        for ( i = 0; i < this.lastCachedPaints.length; i++ ) {
          var oldPaint = this.lastCachedPaints[ i ];
          var isRemoved = true;
          for ( j = 0; j < newCachedPaints.length; j++ ) {
            if ( oldPaint === newCachedPaints[ j ] ) {
              isRemoved = false;
              break;
            }
          }
          if ( isRemoved ) {
            this.svgBlock.decrementPaint( oldPaint );
          }
        }
        this.lastCachedPaints = newCachedPaints;
      }
      this.setToCleanState();
    },
    updateFillStrokeStyle: function( element ) {
      if ( !this.usesPaint ) {
        return;
      }
      if ( this.dirtyFill ) {
        this.paintState.updateFill( this.svgBlock, this.node.getFillValue() );
      }
      if ( this.dirtyStroke ) {
        this.paintState.updateStroke( this.svgBlock, this.node.getStrokeValue() );
      }
      var strokeDetailDirty = this.dirtyLineWidth || this.dirtyLineOptions;
      if ( strokeDetailDirty ) {
        this.paintState.updateStrokeDetailStyle( this.node );
      }
      if ( this.dirtyFill || this.dirtyStroke || strokeDetailDirty ) {
        element.setAttribute( 'style', this.paintState.baseStyle + this.paintState.strokeDetailStyle );
      }
      this.cleanPaintableState();
    },
    updateSVGBlock: function( svgBlock ) {
      var oldSvgBlock = this.svgBlock;
      if ( this.usesPaint && oldSvgBlock ) {
        for ( var i = 0; i < this.lastCachedPaints.length; i++ ) {
          oldSvgBlock.decrementPaint( this.lastCachedPaints[ i ] );
        }
      }
      this.svgBlock = svgBlock;
      if ( this.usesPaint ) {
        for ( var j = 0; j < this.lastCachedPaints.length; j++ ) {
          svgBlock.incrementPaint( this.lastCachedPaints[ j ] );
        }
      }
      this.updateDefsSelf && this.updateDefsSelf( svgBlock );
      this.usesPaint && this.paintState.updateSVGBlock( svgBlock );
      this.usesPaint && this.markDirtyFill();
      this.usesPaint && this.markDirtyStroke();
    },
    dispose: function() {
      this.disposeState(); // assumes subtype existence
      if ( !this.keepElements ) {
        this.svgElement = null;
      }
      this.updateDefsSelf && this.updateDefsSelf( null );
      this.usesPaint && this.paintState.dispose();
      this.defs = null;
      this.svgBlock = null;
      SelfDrawable.prototype.dispose.call( this );
    }
  } );
  return SVGSelfDrawable;
} );
define( 'SCENERY/display/drawables/PaintableStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/PaintObserver','SCENERY/util/Color'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintObserver = require( 'SCENERY/display/PaintObserver' );
  var Color = require( 'SCENERY/util/Color' );
  var PaintableStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializePaintableState = function( renderer, instance ) {
        this.dirtyFill = true;
        this.hadStroke = false;
        this.dirtyStroke = true;
        this.dirtyLineWidth = true;
        this.dirtyLineOptions = true;
        this.dirtyCachedPaints = true;
        this.lastCachedPaints = [];
        this.fillCallback = this.fillCallback || this.markDirtyFill.bind( this );
        this.strokeCallback = this.strokeCallback || this.markDirtyStroke.bind( this );
        this.fillObserver = this.fillObserver || new PaintObserver( 'fill', this.fillCallback );
        this.strokeObserver = this.strokeObserver || new PaintObserver( 'stroke', this.strokeCallback );
        this.fillObserver.initialize( instance.node );
        this.strokeObserver.initialize( instance.node );
        return this;
      };
      proto.cleanPaintableState = function() {
        this.dirtyFill = false;
        this.dirtyStroke = false;
        this.dirtyLineWidth = false;
        this.dirtyLineOptions = false;
        this.dirtyCachedPaints = false;
        this.hadStroke = this.node.getStroke() !== null;
      };
      proto.disposePaintableState = function() {
        this.fillObserver.clean();
        this.strokeObserver.clean();
      };
      proto.markDirtyFill = function() {
        assert && Color.checkPaint( this.instance.node._fill );
        this.dirtyFill = true;
        this.markPaintDirty();
        this.fillObserver.updatePrimary(); // TODO: look into having the fillObserver be notified of Node changes as our source
      };
      proto.markDirtyStroke = function() {
        assert && Color.checkPaint( this.instance.node._stroke );
        this.dirtyStroke = true;
        this.markPaintDirty();
        this.strokeObserver.updatePrimary(); // TODO: look into having the strokeObserver be notified of Node changes as our source
      };
      proto.markDirtyLineWidth = function() {
        this.dirtyLineWidth = true;
        this.markPaintDirty();
      };
      proto.markDirtyLineOptions = function() {
        this.dirtyLineOptions = true;
        this.markPaintDirty();
      };
      proto.markDirtyCachedPaints = function() {
        this.dirtyCachedPaints = true;
        this.markPaintDirty();
      };
    }
  };
  scenery.register( 'PaintableStatefulDrawable', PaintableStatefulDrawable );
  return PaintableStatefulDrawable;
} );
define( 'SCENERY/display/drawables/PathStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  var PathStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyShape = true;
        this.initializePaintableState( renderer, instance );
        return this; // allow for chaining
      };
      proto.disposeState = function() {
        this.disposePaintableState();
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyShape = function() {
        this.dirtyShape = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyShape = false;
      };
      PaintableStatefulDrawable.mixin( drawableType );
    }
  };
  scenery.register( 'PathStatefulDrawable', PathStatefulDrawable );
  return PathStatefulDrawable;
} );
define( 'SCENERY/display/drawables/PathSVGDrawable',['require','PHET_CORE/inherit','PHET_CORE/platform','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PathStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PathStatefulDrawable = require( 'SCENERY/display/drawables/PathStatefulDrawable' );
  var keepSVGPathElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  function PathSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'PathSVGDrawable', PathSVGDrawable );
  inherit( SVGSelfDrawable, PathSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGPathElements ); // usesPaint: true
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'path' );
      return this;
    },
    updateSVGSelf: function() {
      assert && assert( !this.node.requiresSVGBoundsWorkaround(),
        'No workaround for https://github.com/phetsims/scenery/issues/196 is provided at this time, please add an epsilon' );
      var path = this.svgElement;
      if ( this.dirtyShape ) {
        var svgPath = this.node.hasShape() ? this.node._shape.getSVGPath() : '';
        if ( !svgPath ) { svgPath = 'M0 0'; }
        path.setAttribute( 'd', svgPath + ( platform.safari ? ' M0 0' : '' ) );
      }
      this.updateFillStrokeStyle( path );
    }
  } );
  PathStatefulDrawable.mixin( PathSVGDrawable );
  SelfDrawable.Poolable.mixin( PathSVGDrawable );
  return PathSVGDrawable;
} );
define( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','KITE/Shape','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/display/drawables/PathCanvasDrawable','SCENERY/display/drawables/PathSVGDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var PathCanvasDrawable = require( 'SCENERY/display/drawables/PathCanvasDrawable' );
  var PathSVGDrawable = require( 'SCENERY/display/drawables/PathSVGDrawable' );
  var PATH_OPTION_KEYS = [
    'boundsMethod', // Sets how bounds are determined, see setBoundsMethod() for more documentation.
    'shape' // Sets the shape of the Path, see  setShape() for more documentation.
  ];
  function Path( shape, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    this._shape = null;
    this._strokedShape = null;
    this._boundsMethod = 'accurate';
    this._invalidShapeListener = this.invalidateShape.bind( this );
    this._invalidShapeListenerAttached = false;
    this.initializePaintable();
    Node.call( this );
    this.invalidateSupportedRenderers();
    options = extendDefined( {
      shape: shape
    }, options );
    this.mutate( options );
  }
  scenery.register( 'Path', Path );
  inherit( Node, Path, {
    _mutatorKeys: PATH_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'shape' ] ),
    setShape: function( shape ) {
      assert && assert( shape === null || typeof shape === 'string' || shape instanceof Shape,
        'A path\'s shape should either be null, a string, or a Shape' );
      if ( this._shape !== shape ) {
        if ( this._invalidShapeListenerAttached ) {
          this.detachShapeListener();
        }
        if ( typeof shape === 'string' ) {
          shape = new Shape( shape );
        }
        this._shape = shape;
        this.invalidateShape();
        if ( this._shape && !this._shape.isImmutable() ) {
          this.attachShapeListener();
        }
      }
      return this;
    },
    set shape( value ) { this.setShape( value ); },
    getShape: function() {
      return this._shape;
    },
    get shape() { return this.getShape(); },
    getStrokedShape: function() {
      assert && assert( this.hasShape(), 'We cannot stroke a non-existing shape' );
      if ( !this._strokedShape ) {
        this._strokedShape = this.getShape().getStrokedShape( this._lineDrawingStyles );
      }
      return this._strokedShape;
    },
    getPathRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG;
    },
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getPathRendererBitmask() );
    },
    invalidateShape: function() {
      this.invalidatePath();
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyShape(); // subtypes of Path may not have this, but it's called during construction
      }
      if ( this._invalidShapeListenerAttached && this._shape && this._shape.isImmutable() ) {
        this.detachShapeListener();
      }
    },
    invalidatePath: function() {
      this._strokedShape = null;
      this.invalidateSelf(); // We don't immediately compute the bounds
    },
    attachShapeListener: function() {
      assert && assert( !this._invalidShapeListenerAttached, 'We do not want to have two listeners attached!' );
      if ( !this._isDisposed ) {
        this._shape.onStatic( 'invalidated', this._invalidShapeListener );
        this._invalidShapeListenerAttached = true;
      }
    },
    detachShapeListener: function() {
      assert && assert( this._invalidShapeListenerAttached, 'We cannot detach an unattached listener' );
      this._shape.offStatic( 'invalidated', this._invalidShapeListener );
      this._invalidShapeListenerAttached = false;
    },
    updateSelfBounds: function() {
      var selfBounds = this.hasShape() ? this.computeShapeBounds() : Bounds2.NOTHING;
      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },
    setBoundsMethod: function( boundsMethod ) {
      assert && assert( boundsMethod === 'accurate' ||
                        boundsMethod === 'unstroked' ||
                        boundsMethod === 'tightPadding' ||
                        boundsMethod === 'safePadding' ||
                        boundsMethod === 'none' );
      if ( this._boundsMethod !== boundsMethod ) {
        this._boundsMethod = boundsMethod;
        this.invalidatePath();
        this.trigger0( 'boundsMethod' );
        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },
    set boundsMethod( value ) { return this.setBoundsMethod( value ); },
    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    get boundsMethod() { return this.getBoundsMethod(); },
    computeShapeBounds: function() {
      if ( this._boundsMethod === 'none' ) {
        return Bounds2.NOTHING;
      }
      else {
        if ( !this.hasStroke() || this.getLineWidth() === 0 || this._boundsMethod === 'unstroked' ) {
          return this.getShape().bounds;
        }
        else {
          if ( this._boundsMethod === 'accurate' ) {
            return this.getShape().getStrokedBounds( this.getLineStyles() );
          }
          else {
            var factor;
            if ( this._boundsMethod === 'safePadding' && this.getLineJoin() === 'miter' ) {
              factor = this.getMiterLimit();
            }
            else if ( this.getLineCap() === 'square' ) {
              factor = Math.SQRT2;
            }
            else {
              factor = 1;
            }
            return this.getShape().bounds.dilated( factor * this.getLineWidth() / 2 );
          }
        }
      }
    },
    areSelfBoundsValid: function() {
      if ( this._boundsMethod === 'accurate' || this._boundsMethod === 'safePadding' ) {
        return true;
      }
      else if ( this._boundsMethod === 'none' ) {
        return false;
      }
      else {
        return !this.hasStroke(); // 'tightPadding' and 'unstroked' options
      }
    },
    getTransformedSelfBounds: function( matrix ) {
      return ( this._stroke ? this.getStrokedShape() : this.getShape() ).getBoundsWithTransform( matrix );
    },
    invalidateStroke: function() {
      this.invalidatePath();
      this.trigger0( 'selfBoundsValid' ); // Stroke changing could have changed our self-bounds-validitity (unstroked/etc)
    },
    hasShape: function() {
      return !!this._shape;
    },
    canvasPaintSelf: function( wrapper ) {
      PathCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    createSVGDrawable: function( renderer, instance ) {
      return PathSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return PathCanvasDrawable.createFromPool( renderer, instance );
    },
    isPainted: function() {
      return true;
    },
    containsPointSelf: function( point ) {
      var result = false;
      if ( !this.hasShape() ) {
        return result;
      }
      if ( this._fillPickable ) {
        result = this.getShape().containsPoint( point );
      }
      if ( !result && this._strokePickable ) {
        result = this.getStrokedShape().containsPoint( point );
      }
      return result;
    },
    intersectsBoundsSelf: function( bounds ) {
      return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;
    },
    requiresSVGBoundsWorkaround: function() {
      if ( !this._stroke || !this._stroke.isPaint || !this.hasShape() ) {
        return false;
      }
      var bounds = this.computeShapeBounds();
      return bounds.x * bounds.y === 0; // at least one of them was zero, so the bounding box has no area
    },
    getDebugHTMLExtras: function() {
      return this._shape ? ' (<span style="color: #88f" onclick="window.open( \'data:text/plain;charset=utf-8,\' + encodeURIComponent( \'' + this._shape.getSVGPath() + '\' ) );">path</span>)' : '';
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Path( ' + ( this._shape ? this._shape.toString() : this._shape ) + ', {' + propLines + '} )';
    },
    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );
      return result;
    },
    dispose: function() {
      if ( this._invalidShapeListenerAttached ) {
        this.detachShapeListener();
      }
      Node.prototype.dispose.call( this );
    }
  } );
  Paintable.mixin( Path );
  return Path;
} );
define( 'SUN/sun',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'sun' );
} );
define( 'SUN/ExpandCollapseButton',['require','SCENERY/input/ButtonListener','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SUN/sun','TANDEM/Tandem'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  function ExpandCollapseButton( expandedProperty, options ) {
    options = _.extend( {
      sideLength: 25,  // length of one side of the square button
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this );
    var cornerRadius = 0.1 * options.sideLength;
    var buttonShape = Shape.roundRectangle( 0, 0, options.sideLength, options.sideLength, cornerRadius, cornerRadius );
    var symbolLength = 0.6 * options.sideLength;
    var symbolLineWidth = 0.15 * options.sideLength;
    var symbolOptions = {
      lineWidth: symbolLineWidth,
      stroke: 'white',
      centerX: options.sideLength / 2,
      centerY: options.sideLength / 2,
      pickable: false
    };
    var expandButton = new Path( buttonShape, {
      fill: 'rgb(0, 179, 0 )',
      stroke: 'black',
      lineWidth: 0.5,
      tandem: options.tandem.createTandem( 'expandButton' )
    } );
    var plusSymbolShape = new Shape()
      .moveTo( symbolLength / 2, 0 )
      .lineTo( symbolLength / 2, symbolLength )
      .moveTo( 0, symbolLength / 2 )
      .lineTo( symbolLength, symbolLength / 2 );
    expandButton.addChild( new Path(
      plusSymbolShape,
      _.extend( { tandem: options.tandem.createTandem( 'plusSymbol' ) }, symbolOptions )
    ) );
    var collapseButton = new Path( buttonShape, {
      fill: 'rgb( 255, 85, 0 )',
      stroke: 'black',
      lineWidth: 0.5,
      tandem: options.tandem.createTandem( 'collapseButton' )
    } );
    var minusSymbolShape = new Shape()
      .moveTo( -symbolLength / 2, 0 )
      .lineTo( symbolLength / 2, 0 );
    collapseButton.addChild( new Path(
      minusSymbolShape,
      _.extend( { tandem: options.tandem.createTandem( 'minusSymbol' ) }, symbolOptions )
    ) );
    this.addChild( expandButton );
    this.addChild( collapseButton );
    this.cursor = 'pointer';
    this.addInputListener( new ButtonListener( {
      fire: function() {
        expandedProperty.set( !expandedProperty.get() );
      },
      tandem: options.tandem.createTandem( 'buttonListener' )
    } ) );
    this.expandedPropertyObserver = function( expanded ) {
      expandButton.visible = !expanded;
      collapseButton.visible = expanded;
    };
    this.expandedProperty = expandedProperty; // @private
    this.expandedProperty.link( this.expandedPropertyObserver ); // must be unlinked in dispose
    this.mutate( options );
  }
  sun.register( 'ExpandCollapseButton', ExpandCollapseButton );
  return inherit( Node, ExpandCollapseButton, {
    dispose: function() {
      this.expandedProperty.unlink( this.expandedPropertyObserver );
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'DOT/Dimension2',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  require( 'DOT/Bounds2' );
  function Dimension2( width, height ) {
    this.width = width;
    this.height = height;
  }
  dot.register( 'Dimension2', Dimension2 );
  inherit( Object, Dimension2, {
    toString: function() {
      return '[' + this.width + 'w, ' + this.height + 'h]';
    },
    set: function( dimension ) {
      this.width = dimension.width;
      this.height = dimension.height;
      return this;
    },
    setWidth: function( width ) {
      this.width = width;
      return this;
    },
    setHeight: function( height ) {
      this.height = height;
      return this;
    },
    copy: function( dimension ) {
      if ( dimension ) {
        return dimension.set( this );
      }
      else {
        return new Dimension2( this.width, this.height );
      }
    },
    toBounds: function( x, y ) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      return new dot.Bounds2( x, y, this.width + x, this.height + y );
    },
    equals: function( other ) {
      return this.width === other.width && this.height === other.height;
    }
  } );
  return Dimension2;
} );
define( 'SCENERY/display/drawables/RectangleCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function RectangleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'RectangleCanvasDrawable', RectangleCanvasDrawable );
  inherit( CanvasSelfDrawable, RectangleCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },
    writeRectangularPath: function( context, node ) {
      context.beginPath();
      context.moveTo( node._rectX, node._rectY );
      context.lineTo( node._rectX + node._rectWidth, node._rectY );
      context.lineTo( node._rectX + node._rectWidth, node._rectY + node._rectHeight );
      context.lineTo( node._rectX, node._rectY + node._rectHeight );
      context.closePath();
    },
    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;
      if ( node.isRounded() ) {
        context.beginPath();
        var maximumArcSize = node.getMaximumArcSize();
        var arcw = Math.min( node._cornerXRadius, maximumArcSize );
        var arch = Math.min( node._cornerYRadius, maximumArcSize );
        var lowX = node._rectX + arcw;
        var highX = node._rectX + node._rectWidth - arcw;
        var lowY = node._rectY + arch;
        var highY = node._rectY + node._rectHeight - arch;
        if ( arcw === arch ) {
          context.arc( highX, lowY, arcw, -Math.PI / 2, 0, false );
          context.arc( highX, highY, arcw, 0, Math.PI / 2, false );
          context.arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false );
          context.arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false );
        }
        else {
          context.ellipse( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false );
          context.ellipse( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false );
          context.ellipse( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false );
          context.ellipse( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false );
        }
        context.closePath();
        if ( node.hasFill() ) {
          node.beforeCanvasFill( wrapper ); // defined in Paintable
          context.fill();
          node.afterCanvasFill( wrapper ); // defined in Paintable
        }
        if ( node.hasStroke() ) {
          node.beforeCanvasStroke( wrapper ); // defined in Paintable
          context.stroke();
          node.afterCanvasStroke( wrapper ); // defined in Paintable
        }
      }
      else {
        if ( node.hasFill() ) {
          if ( node.getFillValue().transformMatrix ) {
            this.writeRectangularPath( context, node );
            node.beforeCanvasFill( wrapper ); // defined in Paintable
            context.fill();
            node.afterCanvasFill( wrapper ); // defined in Paintable
          }
          else {
            node.beforeCanvasFill( wrapper ); // defined in Paintable
            context.fillRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
            node.afterCanvasFill( wrapper ); // defined in Paintable
          }
        }
        if ( node.hasStroke() ) {
          if ( node.getStrokeValue().transformMatrix ) {
            this.writeRectangularPath( context, node );
            node.beforeCanvasStroke( wrapper ); // defined in Paintable
            context.stroke();
            node.afterCanvasStroke( wrapper ); // defined in Paintable
          }
          else {
            node.beforeCanvasStroke( wrapper ); // defined in Paintable
            context.strokeRect( node._rectX, node._rectY, node._rectWidth, node._rectHeight );
            node.afterCanvasStroke( wrapper ); // defined in Paintable
          }
        }
      }
    },
    markDirtyRectangle: function() { this.markPaintDirty(); },
    markDirtyX: function() {
      this.markDirtyRectangle();
    },
    markDirtyY: function() {
      this.markDirtyRectangle();
    },
    markDirtyWidth: function() {
      this.markDirtyRectangle();
    },
    markDirtyHeight: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerXRadius: function() {
      this.markDirtyRectangle();
    },
    markDirtyCornerYRadius: function() {
      this.markDirtyRectangle();
    },
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  PaintableStatelessDrawable.mixin( RectangleCanvasDrawable );
  SelfDrawable.Poolable.mixin( RectangleCanvasDrawable );
  return RectangleCanvasDrawable;
} );
define( 'SCENERY/display/DOMSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/Renderer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  require( 'SCENERY/display/Renderer' );
  function DOMSelfDrawable( renderer, instance ) {
    this.initializeDOMSelfDrawable( renderer, instance );
    throw new Error( 'Should use initialization and pooling' );
  }
  scenery.register( 'DOMSelfDrawable', DOMSelfDrawable );
  inherit( SelfDrawable, DOMSelfDrawable, {
    initializeDOMSelfDrawable: function( renderer, instance ) {
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      this.initializeSelfDrawable( renderer, instance );
      this.forceAcceleration = false; // TODO: for now, check to see if this is used and how to use it
      this.markTransformDirty();
      this.visibilityDirty = true;
      instance.relativeTransform.addListener( this.transformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
      instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
      return this;
    },
    markTransformDirty: function() {
      this.transformDirty = true;
      this.markDirty();
    },
    getTransformMatrix: function() {
      this.instance.relativeTransform.validate();
      return this.instance.relativeTransform.matrix;
    },
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.updateDOM();
        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;
          this.domElement.style.visibility = this.visible ? '' : 'hidden';
        }
        this.cleanPaintableState && this.cleanPaintableState();
      }
    },
    updateDOM: function() {
    },
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );
      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },
    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();
      SelfDrawable.prototype.dispose.call( this );
    }
  } );
  return DOMSelfDrawable;
} );
define( 'SCENERY/display/drawables/RectangleStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  var RectangleStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;
        this.initializePaintableState( renderer, instance );
        return this; // allow for chaining
      };
      proto.disposeState = function() {
        this.disposePaintableState();
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyRectangle = function() {
        this.dirtyX = true;
        this.dirtyY = true;
        this.dirtyWidth = true;
        this.dirtyHeight = true;
        this.dirtyCornerXRadius = true;
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };
      proto.markDirtyX = function() {
        this.dirtyX = true;
        this.markPaintDirty();
      };
      proto.markDirtyY = function() {
        this.dirtyY = true;
        this.markPaintDirty();
      };
      proto.markDirtyWidth = function() {
        this.dirtyWidth = true;
        this.markPaintDirty();
      };
      proto.markDirtyHeight = function() {
        this.dirtyHeight = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerXRadius = function() {
        this.dirtyCornerXRadius = true;
        this.markPaintDirty();
      };
      proto.markDirtyCornerYRadius = function() {
        this.dirtyCornerYRadius = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX = false;
        this.dirtyY = false;
        this.dirtyWidth = false;
        this.dirtyHeight = false;
        this.dirtyCornerXRadius = false;
        this.dirtyCornerYRadius = false;
      };
      PaintableStatefulDrawable.mixin( drawableType );
    }
  };
  scenery.register( 'RectangleStatefulDrawable', RectangleStatefulDrawable );
  return RectangleStatefulDrawable;
} );
define( 'SCENERY/display/drawables/RectangleDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/util/Features','SCENERY/display/DOMSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Features = require( 'SCENERY/util/Features' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var keepDOMRectangleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var scratchMatrix = Matrix3.dirtyFromPool();
  function RectangleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'RectangleDOMDrawable', RectangleDOMDrawable );
  inherit( DOMSelfDrawable, RectangleDOMDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );
      if ( !this.fillElement || !this.strokeElement ) {
        var fillElement = this.fillElement = document.createElement( 'div' );
        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';
        var strokeElement = this.strokeElement = document.createElement( 'div' );
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';
        fillElement.appendChild( strokeElement );
      }
      this.domElement = this.fillElement;
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );
      return this; // allow for chaining
    },
    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;
      if ( this.paintDirty ) {
        var borderRadius = Math.min( node._cornerXRadius, node._cornerYRadius );
        var borderRadiusDirty = this.dirtyCornerXRadius || this.dirtyCornerYRadius;
        if ( this.dirtyWidth ) {
          fillElement.style.width = node._rectWidth + 'px';
        }
        if ( this.dirtyHeight ) {
          fillElement.style.height = node._rectHeight + 'px';
        }
        if ( borderRadiusDirty ) {
          fillElement.style[ Features.borderRadius ] = borderRadius + 'px'; // if one is zero, we are not rounded, so we do the min here
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }
        if ( this.dirtyStroke ) {
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }
        if ( node.hasStroke() ) {
          var hadNoStrokeBefore = !this.hadStroke;
          if ( hadNoStrokeBefore || this.dirtyWidth || this.dirtyLineWidth ) {
            strokeElement.style.width = ( node._rectWidth - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyHeight || this.dirtyLineWidth ) {
            strokeElement.style.height = ( node._rectHeight - node.getLineWidth() ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }
          if ( hadNoStrokeBefore || borderRadiusDirty || this.dirtyLineWidth || this.dirtyLineOptions ) {
            strokeElement.style[ Features.borderRadius ] = ( node.isRounded() || node.getLineJoin() === 'round' ) ? ( borderRadius + node.getLineWidth() / 2 ) + 'px' : '0';
          }
        }
      }
      if ( this.transformDirty || this.dirtyX || this.dirtyY ) {
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( node._rectX, node._rectY );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, this.fillElement, this.forceAcceleration );
      }
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },
    dispose: function() {
      this.disposeState();
      if ( !keepDOMRectangleElements ) {
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }
      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  RectangleStatefulDrawable.mixin( RectangleDOMDrawable );
  SelfDrawable.Poolable.mixin( RectangleDOMDrawable );
  return RectangleDOMDrawable;
} );
define( 'SCENERY/display/drawables/RectangleSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var keepSVGRectangleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  function RectangleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'RectangleSVGDrawable', RectangleSVGDrawable );
  inherit( SVGSelfDrawable, RectangleSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGRectangleElements ); // usesPaint: true
      this.lastArcW = -1; // invalid on purpose
      this.lastArcH = -1; // invalid on purpose
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'rect' );
      return this;
    },
    updateSVGSelf: function() {
      var rect = this.svgElement;
      if ( this.dirtyX ) {
        rect.setAttribute( 'x', this.node._rectX );
      }
      if ( this.dirtyY ) {
        rect.setAttribute( 'y', this.node._rectY );
      }
      if ( this.dirtyWidth ) {
        rect.setAttribute( 'width', this.node._rectWidth );
      }
      if ( this.dirtyHeight ) {
        rect.setAttribute( 'height', this.node._rectHeight );
      }
      if ( this.dirtyCornerXRadius || this.dirtyCornerYRadius || this.dirtyWidth || this.dirtyHeight ) {
        var arcw = 0;
        var arch = 0;
        if ( this.node.isRounded() ) {
          var maximumArcSize = this.node.getMaximumArcSize();
          arcw = Math.min( this.node._cornerXRadius, maximumArcSize );
          arch = Math.min( this.node._cornerYRadius, maximumArcSize );
        }
        if ( arcw !== this.lastArcW ) {
          this.lastArcW = arcw;
          rect.setAttribute( 'rx', arcw );
        }
        if ( arch !== this.lastArcH ) {
          this.lastArcH = arch;
          rect.setAttribute( 'ry', arch );
        }
      }
      this.updateFillStrokeStyle( rect );
    }
  } );
  RectangleStatefulDrawable.mixin( RectangleSVGDrawable );
  SelfDrawable.Poolable.mixin( RectangleSVGDrawable );
  return RectangleSVGDrawable;
} );
define( 'SCENERY/display/WebGLSelfDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  function WebGLSelfDrawable( renderer, instance ) {
    this.initializeWebGLSelfDrawable( renderer, instance );
    throw new Error( 'Should use initialization and pooling' );
  }
  scenery.register( 'WebGLSelfDrawable', WebGLSelfDrawable );
  inherit( SelfDrawable, WebGLSelfDrawable, {
    initializeWebGLSelfDrawable: function( renderer, instance ) {
      this.initializeSelfDrawable( renderer, instance );
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      instance.relativeTransform.addListener( this.transformListener );
      instance.relativeTransform.addPrecompute();
      return this;
    },
    markTransformDirty: function() {
      this.markDirty();
    },
    updateSelfVisibility: function() {
      SelfDrawable.prototype.updateSelfVisibility.call( this );
      this.markDirty();
    },
    dispose: function() {
      this.instance.relativeTransform.removeListener( this.transformListener );
      this.instance.relativeTransform.removePrecompute();
      SelfDrawable.prototype.dispose.call( this );
    }
  } );
  return WebGLSelfDrawable;
} );
define( 'SCENERY/display/drawables/RectangleWebGLDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','AXON/Property','SCENERY/display/WebGLSelfDrawable','SCENERY/display/drawables/RectangleStatefulDrawable','SCENERY/display/SelfDrawable','SCENERY/display/Renderer','SCENERY/util/Color'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Property = require( 'AXON/Property' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var RectangleStatefulDrawable = require( 'SCENERY/display/drawables/RectangleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Color = require( 'SCENERY/util/Color' );
  var scratchColor = new Color( 'transparent' );
  function RectangleWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'RectangleWebGLDrawable', RectangleWebGLDrawable );
  inherit( WebGLSelfDrawable, RectangleWebGLDrawable, {
    webglRenderer: Renderer.webglVertexColorPolygons,
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );
      if ( !this.vertexArray ) {
        this.vertexArray = new Float32Array( 6 * 6 ); // 6-length components for 6 vertices (2 tris).
      }
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();
      this.transformDirty = true;
      this.includeVertices = true; // used by the processor
      return this;
    },
    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();
    },
    onRemoveFromBlock: function( webglBlock ) {
    },
    markTransformDirty: function() {
      this.transformDirty = true;
      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        if ( this.dirtyFill ) {
          this.includeVertices = this.node.hasFill();
          if ( this.includeVertices ) {
            var fill = ( this.node.fill instanceof Property ) ? this.node.fill.value : this.node.fill;
            var color =  scratchColor.set( fill );
            var red = color.red / 255;
            var green = color.green / 255;
            var blue = color.blue / 255;
            var alpha = color.alpha;
            for ( var i = 0; i < 6; i++ ) {
              var offset = i * 6;
              this.vertexArray[ 2 + offset ] = red;
              this.vertexArray[ 3 + offset ] = green;
              this.vertexArray[ 4 + offset ] = blue;
              this.vertexArray[ 5 + offset ] = alpha;
            }
          }
        }
        if ( this.transformDirty || this.dirtyX || this.dirtyY || this.dirtyWidth || this.dirtyHeight ) {
          this.transformDirty = false;
          var x = this.node._rectX;
          var y = this.node._rectY;
          var width = this.node._rectWidth;
          var height = this.node._rectHeight;
          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( x, y ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( x, y + height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( x + width, y ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( x + width, y + height ) );
          this.vertexArray[ 0 ] = this.upperLeft.x;
          this.vertexArray[ 1 ] = this.upperLeft.y;
          this.vertexArray[ 6 ] = this.lowerLeft.x;
          this.vertexArray[ 7 ] = this.lowerLeft.y;
          this.vertexArray[ 12 ] = this.upperRight.x;
          this.vertexArray[ 13 ] = this.upperRight.y;
          this.vertexArray[ 18 ] = this.upperRight.x;
          this.vertexArray[ 19 ] = this.upperRight.y;
          this.vertexArray[ 24 ] = this.lowerLeft.x;
          this.vertexArray[ 25 ] = this.lowerLeft.y;
          this.vertexArray[ 30 ] = this.lowerRight.x;
          this.vertexArray[ 31 ] = this.lowerRight.y;
        }
      }
      this.setToCleanState();
      this.cleanPaintableState();
    },
    dispose: function() {
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );
  RectangleStatefulDrawable.mixin( RectangleWebGLDrawable );
  SelfDrawable.Poolable.mixin( RectangleWebGLDrawable );
  return RectangleWebGLDrawable;
} );
define( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Dimension2','SCENERY/util/Features','SCENERY/display/Renderer','SCENERY/display/drawables/RectangleCanvasDrawable','SCENERY/display/drawables/RectangleDOMDrawable','SCENERY/display/drawables/RectangleSVGDrawable','SCENERY/display/drawables/RectangleWebGLDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Features = require( 'SCENERY/util/Features' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RectangleCanvasDrawable = require( 'SCENERY/display/drawables/RectangleCanvasDrawable' );
  var RectangleDOMDrawable = require( 'SCENERY/display/drawables/RectangleDOMDrawable' );
  var RectangleSVGDrawable = require( 'SCENERY/display/drawables/RectangleSVGDrawable' );
  var RectangleWebGLDrawable = require( 'SCENERY/display/drawables/RectangleWebGLDrawable' );
  var RECTANGLE_OPTION_KEYS = [
    'rectBounds', // Sets x/y/width/height based on bounds. See setRectBounds() for more documentation.
    'rectSize', // Sets width/height based on dimension. See setRectSize() for more documentation.
    'rectX', // Sets x. See setRectX() for more documentation.
    'rectY', // Sets y. See setRectY() for more documentation.
    'rectWidth', // Sets width. See setRectWidth() for more documentation.
    'rectHeight', // Sets height. See setRectHeight() for more documentation.
    'cornerRadius', // Sets corner radii. See setCornerRadius() for more documentation.
    'cornerXRadius', // Sets horizontal corner radius. See setCornerXRadius() for more documentation.
    'cornerYRadius' // Sets vertical corner radius. See setCornerYRadius() for more documentation.
  ];
  function Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, options ) {
    this._rectX = 0;
    this._rectY = 0;
    this._rectWidth = 0;
    this._rectHeight = 0;
    this._cornerXRadius = 0;
    this._cornerYRadius = 0;
    if ( typeof x === 'object' ) {
      if ( x instanceof Bounds2 ) {
        if ( typeof y !== 'number' ) {
          assert && assert( arguments.length === 1 || arguments.length === 2,
            'new Rectangle( bounds, { ... } ) should only take one or two arguments' );
          assert && assert( y === undefined || typeof y === 'object',
            'new Rectangle( bounds, { ... } ) second parameter should only ever be an options object' );
          assert && assert( y === undefined || Object.getPrototypeOf( y ) === Object.prototype,
            'Extra prototype on Node options object is a code smell' );
          options = extendDefined( {
            rectBounds: x
          }, y ); // Our options object would be at y
        }
        else {
          assert && assert( arguments.length === 3 || arguments.length === 4,
            'new Rectangle( bounds, cornerXRadius, cornerYRadius, { ... } ) should only take three or four arguments' );
          assert && assert( height === undefined || typeof height === 'object',
            'new Rectangle( bounds, cornerXRadius, cornerYRadius, { ... } ) fourth parameter should only ever be an options object' );
          assert && assert( height === undefined || Object.getPrototypeOf( height ) === Object.prototype,
            'Extra prototype on Node options object is a code smell' );
          options = extendDefined( {
            rectBounds: x,
            cornerXRadius: y, // ignore Intellij warning, our cornerXRadius is the second parameter
            cornerYRadius: width // ignore Intellij warning, our cornerYRadius is the third parameter
          }, height ); // Our options object would be at height
        }
      }
      else {
        options = x;
      }
    }
    else if ( cornerYRadius === undefined ) {
      assert && assert( arguments.length === 4 || arguments.length === 5,
        'new Rectangle( x, y, width, height, { ... } ) should only take four or five arguments' );
      assert && assert( cornerXRadius === undefined || typeof cornerXRadius === 'object',
        'new Rectangle( x, y, width, height, { ... } ) fifth parameter should only ever be an options object' );
      assert && assert( cornerXRadius === undefined || Object.getPrototypeOf( cornerXRadius ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      options = extendDefined( {
        rectX: x,
        rectY: y,
        rectWidth: width,
        rectHeight: height
      }, cornerXRadius );
    }
    else {
      assert && assert( arguments.length === 6 || arguments.length === 7,
        'new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius{ ... } ) should only take six or seven arguments' );
      assert && assert( options === undefined || typeof options === 'object',
        'new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius{ ... } ) seventh parameter should only ever be an options object' );
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      options = extendDefined( {
        rectX: x,
        rectY: y,
        rectWidth: width,
        rectHeight: height,
        cornerXRadius: cornerXRadius,
        cornerYRadius: cornerYRadius
      }, options );
    }
    Path.call( this, null, options );
  }
  scenery.register( 'Rectangle', Rectangle );
  inherit( Path, Rectangle, {
    _mutatorKeys: RECTANGLE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'x', 'y', 'width', 'height', 'cornerXRadius', 'cornerYRadius' ] ).filter( function( flag ) {
      return flag !== 'shape';
    } ),
    getMaximumArcSize: function() {
      return Math.min( this._rectWidth / 2, this._rectHeight / 2 );
    },
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && !this.hasLineDash() ) {
        if ( this.getLineJoin() === 'miter' || ( this.getLineJoin() === 'round' && Features.borderRadius ) ) {
          bitmask |= Renderer.bitmaskDOM;
        }
      }
      if ( !this.hasStroke() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }
      return bitmask;
    },
    getPathRendererBitmask: function() {
      var bitmask = Renderer.bitmaskCanvas | Renderer.bitmaskSVG;
      var maximumArcSize = this.getMaximumArcSize();
      if ( ( !this.hasStroke() || ( this.getLineWidth() <= this._rectHeight && this.getLineWidth() <= this._rectWidth ) ) &&
           ( !this.isRounded() || ( Features.borderRadius && this._cornerXRadius === this._cornerYRadius ) ) &&
           this._cornerYRadius <= maximumArcSize && this._cornerXRadius <= maximumArcSize ) {
        bitmask |= Renderer.bitmaskDOM;
      }
      if ( !this.hasStroke() && !this.isRounded() ) {
        bitmask |= Renderer.bitmaskWebGL;
      }
      return bitmask;
    },
    setRect: function( x, y, width, height, cornerXRadius, cornerYRadius ) {
      var hasXRadius = cornerXRadius !== undefined;
      var hasYRadius = cornerYRadius !== undefined;
      assert && assert( typeof x === 'number' && isFinite( x ) &&
                        typeof y === 'number' && isFinite( y ) &&
                        typeof width === 'number' && isFinite( width ) &&
                        typeof height === 'number' && isFinite( height ), 'x/y/width/height should be finite numbers' );
      assert && assert( !hasXRadius || ( typeof cornerXRadius === 'number' && isFinite( cornerXRadius ) ) &&
                        !hasYRadius || ( typeof cornerYRadius === 'number' && isFinite( cornerYRadius ) ),
                        'Corner radii (if provided) should be finite numbers' );
      if ( this._rectX === x &&
           this._rectY === y &&
           this._rectWidth === width &&
           this._rectHeight === height &&
           ( !hasXRadius || this._cornerXRadius === cornerXRadius ) &&
           ( !hasYRadius || this._cornerYRadius === cornerYRadius ) ) {
        return;
      }
      this._rectX = x;
      this._rectY = y;
      this._rectWidth = width;
      this._rectHeight = height;
      this._cornerXRadius = hasXRadius ? cornerXRadius : this._cornerXRadius;
      this._cornerYRadius = hasYRadius ? cornerYRadius : this._cornerYRadius;
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyRectangle();
      }
      this.invalidateRectangle();
      return this;
    },
    setRectX: function( x ) {
      assert && assert( typeof x === 'number' && isFinite( x ), 'rectX should be a finite number' );
      if ( this._rectX !== x ) {
        this._rectX = x;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set rectX( value ) { this.setRectX( value ); },
    getRectX: function() {
      return this._rectX;
    },
    get rectX() { return this.getRectX(); },
    setRectY: function( y ) {
      assert && assert( typeof y === 'number' && isFinite( y ), 'rectY should be a finite number' );
      if ( this._rectY !== y ) {
        this._rectY = y;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set rectY( value ) { this.setRectY( value ); },
    getRectY: function() {
      return this._rectY;
    },
    get rectY() { return this.getRectY(); },
    setRectWidth: function( width ) {
      assert && assert( typeof width === 'number' && isFinite( width ), 'rectWidth should be a finite number' );
      if ( this._rectWidth !== width ) {
        this._rectWidth = width;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyWidth();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set rectWidth( value ) { this.setRectWidth( value ); },
    getRectWidth: function() {
      return this._rectWidth;
    },
    get rectWidth() { return this.getRectWidth(); },
    setRectHeight: function( height ) {
      assert && assert( typeof height === 'number' && isFinite( height ), 'rectHeight should be a finite number' );
      if ( this._rectHeight !== height ) {
        this._rectHeight = height;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyHeight();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set rectHeight( value ) { this.setRectHeight( value ); },
    getRectHeight: function() {
      return this._rectHeight;
    },
    get rectHeight() { return this.getRectHeight(); },
    setCornerXRadius: function( radius ) {
      assert && assert( typeof radius === 'number' && isFinite( radius ), 'cornerXRadius should be a finite number' );
      if ( this._cornerXRadius !== radius ) {
        this._cornerXRadius = radius;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyCornerXRadius();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set cornerXRadius( value ) { this.setCornerXRadius( value ); },
    getCornerXRadius: function() {
      return this._cornerXRadius;
    },
    get cornerXRadius() { return this.getCornerXRadius(); },
    setCornerYRadius: function( radius ) {
      assert && assert( typeof radius === 'number' && isFinite( radius ), 'cornerYRadius should be a finite number' );
      if ( this._cornerYRadius !== radius ) {
        this._cornerYRadius = radius;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyCornerYRadius();
        }
        this.invalidateRectangle();
      }
      return this;
    },
    set cornerYRadius( value ) { this.setCornerYRadius( value ); },
    getCornerYRadius: function() {
      return this._cornerYRadius;
    },
    get cornerYRadius() { return this.getCornerYRadius(); },
    setRectBounds: function( bounds ) {
      assert && assert( bounds instanceof Bounds2 );
      this.setRect( bounds.x, bounds.y, bounds.width, bounds.height );
      return this;
    },
    set rectBounds( value ) { this.setRectBounds( value ); },
    getRectBounds: function() {
      return Bounds2.rect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );
    },
    get rectBounds() { return this.getRectBounds(); },
    setRectSize: function( size ) {
      assert && assert( size instanceof Dimension2 );
      this.setRectWidth( size.width );
      this.setRectHeight( size.height );
      return this;
    },
    set rectSize( value ) { this.setRectSize( value ); },
    getRectSize: function() {
      return new Dimension2( this._rectWidth, this._rectHeight );
    },
    get rectSize() { return this.getRectSize(); },
    setRectWidthFromRight: function( width ) {
      assert && assert( typeof width === 'number' );
      if ( this._rectWidth !== width ) {
        var right = this._rectX + this._rectWidth;
        this.setRectWidth( width );
        this.setRectX( right - width );
      }
      return this;
    },
    set rectWidthFromRight( value ) { this.setRectWidthFromRight( value ); },
    get rectWidthFromRight() { return this.getRectWidth(); }, // because JSHint complains
    setRectHeightFromBottom: function( height ) {
      assert && assert( typeof height === 'number' );
      if ( this._rectHeight !== height ) {
        var bottom = this._rectY + this._rectHeight;
        this.setRectHeight( height );
        this.setRectY( bottom - height );
      }
      return this;
    },
    set rectHeightFromBottom( value ) { this.setRectHeightFromBottom( value ); },
    get rectHeightFromBottom() { return this.getRectHeight(); }, // because JSHint complains
    isRounded: function() {
      return this._cornerXRadius !== 0 && this._cornerYRadius !== 0;
    },
    computeShapeBounds: function() {
      var bounds = new Bounds2( this._rectX, this._rectY, this._rectX + this._rectWidth, this._rectY + this._rectHeight );
      if ( this._stroke ) {
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },
    getTransformedSelfBounds: function( matrix ) {
      return this.selfBounds.transformed( matrix );
    },
    createRectangleShape: function() {
      if ( this.isRounded() ) {
        var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );
        return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,
          Math.min( maximumArcSize, this._cornerXRadius ), Math.min( maximumArcSize, this._cornerYRadius ) ).makeImmutable();
      }
      else {
        return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight ).makeImmutable();
      }
    },
    invalidateRectangle: function() {
      assert && assert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );
      assert && assert( isFinite( this._rectY ), 'A rectangle needs to have a finite y (' + this._rectY + ')' );
      assert && assert( this._rectWidth >= 0 && isFinite( this._rectWidth ),
        'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );
      assert && assert( this._rectHeight >= 0 && isFinite( this._rectHeight ),
        'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );
      assert && assert( this._cornerXRadius >= 0 && isFinite( this._cornerXRadius ),
        'A rectangle needs to have a non-negative finite arcWidth (' + this._cornerXRadius + ')' );
      assert && assert( this._cornerYRadius >= 0 && isFinite( this._cornerYRadius ),
        'A rectangle needs to have a non-negative finite arcHeight (' + this._cornerYRadius + ')' );
      this._shape = null;
      this.invalidatePath();
      this.invalidateSupportedRenderers();
    },
    containsPointSelf: function( point ) {
      var x = this._rectX;
      var y = this._rectY;
      var width = this._rectWidth;
      var height = this._rectHeight;
      var arcWidth = this._cornerXRadius;
      var arcHeight = this._cornerYRadius;
      var halfLine = this.getLineWidth() / 2;
      var result = true;
      if ( this._strokePickable ) {
        var rounded = this.isRounded();
        if ( !rounded && this.getLineJoin() === 'bevel' ) {
          return Path.prototype.containsPointSelf.call( this, point );
        }
        var miter = this.getLineJoin() === 'miter' && !rounded;
        result = result && Rectangle.intersects( x - halfLine, y - halfLine,
            width + 2 * halfLine, height + 2 * halfLine,
            miter ? 0 : ( arcWidth + halfLine ), miter ? 0 : ( arcHeight + halfLine ),
            point );
      }
      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          return result;
        }
        else {
          return Rectangle.intersects( x, y, width, height, arcWidth, arcHeight, point );
        }
      }
      else if ( this._strokePickable ) {
        return result && !Rectangle.intersects( x + halfLine, y + halfLine,
            width - 2 * halfLine, height - 2 * halfLine,
            arcWidth - halfLine, arcHeight - halfLine,
            point );
      }
      else {
        return false; // either fill nor stroke is pickable
      }
    },
    intersectsBoundsSelf: function( bounds ) {
      return !this.computeShapeBounds().intersection( bounds ).isEmpty();
    },
    canvasPaintSelf: function( wrapper ) {
      RectangleCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    createDOMDrawable: function( renderer, instance ) {
      return RectangleDOMDrawable.createFromPool( renderer, instance );
    },
    createSVGDrawable: function( renderer, instance ) {
      return RectangleSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return RectangleCanvasDrawable.createFromPool( renderer, instance );
    },
    createWebGLDrawable: function( renderer, instance ) {
      return RectangleWebGLDrawable.createFromPool( renderer, instance );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Rectangle( ' +
             this._rectX + ', ' + this._rectY + ', ' +
             this._rectWidth + ', ' + this._rectHeight + ', ' +
             this._cornerXRadius + ', ' + this._cornerYRadius +
             ', {' + propLines + '} )';
    },
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Rectangle to something non-null' );
      }
      else {
        this.invalidatePath();
      }
    },
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createRectangleShape();
      }
      return this._shape;
    },
    hasShape: function() {
      return true;
    },
    setCornerRadius: function( cornerRadius ) {
      this.setCornerXRadius( cornerRadius );
      this.setCornerYRadius( cornerRadius );
      return this;
    },
    set cornerRadius( value ) { this.setCornerRadius( value ); },
    getCornerRadius: function() {
      assert && assert( this._cornerXRadius === this._cornerYRadius,
        'getCornerRadius() invalid if x/y radii are different' );
      return this._cornerXRadius;
    },
    get cornerRadius() { return this.getCornerRadius(); }
  } );
  Rectangle.intersects = function( x, y, width, height, arcWidth, arcHeight, point ) {
    var result = point.x >= x &&
                 point.x <= x + width &&
                 point.y >= y &&
                 point.y <= y + height;
    if ( !result || arcWidth <= 0 || arcHeight <= 0 ) {
      return result;
    }
    var maximumArcSize = Math.min( width / 2, height / 2 );
    arcWidth = Math.min( maximumArcSize, arcWidth );
    arcHeight = Math.min( maximumArcSize, arcHeight );
    var closestCornerX;
    var closestCornerY;
    var guaranteedInside = false;
    if ( point.x < x + width / 2 ) {
      closestCornerX = x + arcWidth;
      guaranteedInside = guaranteedInside || point.x >= closestCornerX;
    }
    else {
      closestCornerX = x + width - arcWidth;
      guaranteedInside = guaranteedInside || point.x <= closestCornerX;
    }
    if ( guaranteedInside ) { return true; }
    if ( point.y < y + height / 2 ) {
      closestCornerY = y + arcHeight;
      guaranteedInside = guaranteedInside || point.y >= closestCornerY;
    }
    else {
      closestCornerY = y + height - arcHeight;
      guaranteedInside = guaranteedInside || point.y <= closestCornerY;
    }
    if ( guaranteedInside ) { return true; }
    var offsetX = point.x - closestCornerX;
    var offsetY = point.y - closestCornerY;
    offsetX /= arcWidth;
    offsetY /= arcHeight;
    offsetX *= offsetX;
    offsetY *= offsetY;
    return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse
  };
  Rectangle.rect = function( x, y, width, height, options ) {
    return new Rectangle( x, y, width, height, 0, 0, options );
  };
  Rectangle.roundedRect = function( x, y, width, height, cornerXRadius, cornerYRadius, options ) {
    return new Rectangle( x, y, width, height, cornerXRadius, cornerYRadius, options );
  };
  Rectangle.bounds = function( bounds, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, options );
  };
  Rectangle.roundedBounds = function( bounds, cornerXRadius, cornerYRadius, options ) {
    return new Rectangle( bounds.minX, bounds.minY, bounds.width, bounds.height, cornerXRadius, cornerYRadius, options );
  };
  Rectangle.dimension = function( dimension, options ) {
    return new Rectangle( 0, 0, dimension.width, dimension.height, 0, 0, options );
  };
  return Rectangle;
} );
define( 'PHET_CORE/escapeHTML',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function escapeHTML( str ) {
    return str
      .replace( /&/g, '&amp;' )
      .replace( /</g, '&lt;' )
      .replace( />/g, '&gt;' )
      .replace( /\"/g, '&quot;' )
      .replace( /\'/g, '&#x27;' )
      .replace( /\//g, '&#x2F;' );
  }
  phetCore.register( 'escapeHTML', escapeHTML );
  return escapeHTML;
} );
define( 'SCENERY/util/Font',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var VALID_STYLES = [ 'normal', 'italic', 'oblique' ];
  var VALID_VARIANTS = [ 'normal', 'small-caps' ];
  var VALID_WEIGHTS = [ 'normal', 'bold', 'bolder', 'lighter',
                        '100', '200', '300', '400', '500', '600', '700', '800', '900' ];
  var VALID_STRETCHES = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed',
                          'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];
  function Font( options ) {
    this._style = 'normal';
    this._variant = 'normal';
    this._weight = 'normal';
    this._stretch = 'normal';
    this._size = '10px';
    this._lineHeight = 'normal';
    this._family = 'sans-serif';
    var type = typeof options;
    assert && assert( options === undefined || type === 'string' || ( type === 'object' && Object.getPrototypeOf( options ) === Object.prototype ),
      'options should be a string or a raw object');
    if ( type === 'string' ) {
      var tokens = _.filter( options.split( /[\x09\x0A\x0C\x0D\x20]/ ), function( token ) { return token.length > 0; } ); // eslint-disable-line no-control-regex
      for ( var i = 0; i < tokens.length; i++ ) {
        var token = tokens[ i ];
        if ( token === 'normal' ) {
        }
        else if ( _.includes( VALID_STYLES, token ) ) {
          assert && assert( this._style === 'normal', 'Style cannot be applied twice. Already set to "' + this._style + '", attempt to replace with "' + token + '"' );
          this._style = token;
        }
        else if ( _.includes( VALID_VARIANTS, token ) ) {
          assert && assert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to "' + this._variant + '", attempt to replace with "' + token + '"' );
          this._variant = token;
        }
        else if ( _.includes( VALID_WEIGHTS, token ) ) {
          assert && assert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to "' + this._weight + '", attempt to replace with "' + token + '"' );
          this._weight = token;
        }
        else if ( _.includes( VALID_STRETCHES, token ) ) {
          assert && assert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to "' + this._stretch + '", attempt to replace with "' + token + '"' );
          this._stretch = token;
        }
        else {
          var subtokens = token.split( /\// ); // extract font size from any line-height
          this._size = subtokens[ 0 ];
          if ( subtokens[ 1 ] ) {
            this._lineHeight = subtokens[ 1 ];
          }
          this._family = tokens.slice( i + 1 ).join( ' ' );
          break;
        }
      }
    }
    else if ( type === 'object' ) {
      if ( options.style !== undefined ) {
        this._style = options.style;
      }
      if ( options.variant !== undefined ) {
        this._variant = options.variant;
      }
      if ( options.weight !== undefined ) {
        this._weight = '' + options.weight; // cast it to a string explicitly
      }
      if ( options.stretch !== undefined ) {
        this._stretch = options.stretch;
      }
      if ( options.size !== undefined ) {
        this._size = Font.castSize( options.size );
      }
      if ( options.lineHeight !== undefined ) {
        this._lineHeight = options.lineHeight;
      }
      if ( options.family !== undefined ) {
        this._family = options.family;
      }
    }
    assert && assert( typeof this._style === 'string' && _.includes( VALID_STYLES, this._style ),
      'Font style must be one of "normal", "italic", or "oblique"' );
    assert && assert( typeof this._variant === 'string' && _.includes( VALID_VARIANTS, this._variant ),
      'Font variant must be "normal" or "small-caps"' );
    assert && assert( typeof this._weight === 'string' && _.includes( VALID_WEIGHTS, this._weight ),
      'Font weight must be one of "normal", "bold", "bolder", "lighter", "100", "200", "300", "400", "500", "600", "700", "800", or "900"' );
    assert && assert( typeof this._stretch === 'string' && _.includes( VALID_STRETCHES, this._stretch ),
      'Font stretch must be one of "normal", "ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "semi-expanded", "expanded", "extra-expanded", or "ultra-expanded"' );
    assert && assert( typeof this._size === 'string' && !_.includes( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[ this._size.length - 1 ] ),
      'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );
    assert && assert( typeof this._lineHeight === 'string' );
    assert && assert( typeof this._family === 'string' );
    this._font = this.computeShorthand();
    phetAllocation && phetAllocation( 'Font' );
  }
  scenery.register( 'Font', Font );
  inherit( Object, Font, {
    getFont: function() {
      return this._font;
    },
    get font() { return this.getFont(); },
    getStyle: function() {
      return this._style;
    },
    get style() { return this.getStyle(); },
    getVariant: function() {
      return this._variant;
    },
    get variant() { return this.getVariant(); },
    getWeight: function() {
      return this._weight;
    },
    get weight() { return this.getWeight(); },
    getStretch: function() {
      return this._stretch;
    },
    get stretch() { return this.getStretch(); },
    getSize: function() {
      return this._size;
    },
    get size() { return this.getSize(); },
    getLineHeight: function() {
      return this._lineHeight;
    },
    get lineHeight() { return this.getLineHeight(); },
    getFamily: function() {
      return this._family;
    },
    get family() { return this.getFamily(); },
    copy: function( options ) {
      return new Font( _.extend( {
        style: this._style,
        variant: this._variant,
        weight: this._weight,
        stretch: this._stretch,
        size: this._size,
        lineHeight: this._lineHeight,
        family: this._family
      }, options ) );
    },
    computeShorthand: function() {
      var ret = '';
      if ( this._style !== 'normal' ) { ret += this._style + ' '; }
      if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }
      if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }
      if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }
      ret += this._size;
      if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }
      ret += ' ' + this._family;
      return ret;
    },
    toCSS: function() {
      return this.getFont();
    }
  }, {
    castSize: function( size ) {
      if ( typeof size === 'number' ) {
        return size + 'px'; // add the pixels suffix by default for numbers
      }
      else {
        return size; // assume that it's a valid to-spec string
      }
    }
  } );
  Font.DEFAULT = new Font();
  return Font;
} );
define( 'SCENERY/display/drawables/TextCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function TextCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'TextCanvasDrawable', TextCanvasDrawable );
  inherit( CanvasSelfDrawable, TextCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },
    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;
      if ( node.hasFill() || node.hasStroke() ) {
        wrapper.setFont( node._font.getFont() );
        wrapper.setDirection( 'ltr' );
      }
      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fillText( node.renderedText, 0, 0 );
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.strokeText( node.renderedText, 0, 0 );
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },
    markDirtyText: function() { this.markPaintDirty(); },
    markDirtyFont: function() { this.markPaintDirty(); },
    markDirtyBounds: function() { this.markPaintDirty(); },
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  PaintableStatelessDrawable.mixin( TextCanvasDrawable );
  SelfDrawable.Poolable.mixin( TextCanvasDrawable );
  return TextCanvasDrawable;
} );
define( 'SCENERY/display/drawables/TextStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  var TextStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyText = true;
        this.dirtyFont = true;
        this.dirtyBounds = true;
        this.initializePaintableState( renderer, instance );
        return this; // allow for chaining
      };
      proto.disposeState = function() {
        this.disposePaintableState();
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyText = function() {
        this.dirtyText = true;
        this.markPaintDirty();
      };
      proto.markDirtyFont = function() {
        this.dirtyFont = true;
        this.markPaintDirty();
      };
      proto.markDirtyBounds = function() {
        this.dirtyBounds = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyText = false;
        this.dirtyFont = false;
        this.dirtyBounds = false;
      };
      PaintableStatefulDrawable.mixin( drawableType );
    }
  };
  scenery.register( 'TextStatefulDrawable', TextStatefulDrawable );
  return TextStatefulDrawable;
} );
define( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2','SCENERY/util/Features'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Features = require( 'SCENERY/util/Features' );
  function p( x, y ) {
    return new Vector2( x, y );
  }
  var debugChromeBoundsScanning = false;
  var transformProperty = Features.transform;
  var transformOriginProperty = Features.transformOrigin || 'transformOrigin'; // fallback, so we don't try to set an empty string property later
  var Util = {
    prepareForTransform: function( element, forceAcceleration ) {
      element.style[ transformOriginProperty ] = 'top left';
      if ( forceAcceleration ) {
        scenery.Util.setTransformAcceleration( element );
      }
      else {
        scenery.Util.unsetTransformAcceleration( element );
      }
    },
    setTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = 'hidden';
    },
    unsetTransformAcceleration: function( element ) {
      element.style.webkitBackfaceVisibility = '';
    },
    applyPreparedTransform: function( matrix, element, forceAcceleration ) {
      element.style[ transformProperty ] = matrix.getCSSTransform();
    },
    setTransform: function( transformString, element, forceAcceleration ) {
      assert && assert( typeof transformString === 'string' );
      element.style[ transformProperty ] = transformString;
    },
    unsetTransform: function( element ) {
      element.style[ transformProperty ] = '';
    },
    polyfillRequestAnimationFrame: function() {
      if ( !window.requestAnimationFrame || !window.cancelAnimationFrame ) {
        if ( !Features.requestAnimationFrame || !Features.cancelAnimationFrame ) {
          window.requestAnimationFrame = function( callback ) {
            var timeAtStart = Date.now();
            return window.setTimeout( function() {
              callback( Date.now() - timeAtStart );
            }, 16 );
          };
          window.cancelAnimationFrame = clearTimeout;
        }
        else {
          window.requestAnimationFrame = window[ Features.requestAnimationFrame ];
          window.cancelAnimationFrame = window[ Features.cancelAnimationFrame ];
        }
      }
    },
    backingStorePixelRatio: function( context ) {
      return context.webkitBackingStorePixelRatio ||
             context.mozBackingStorePixelRatio ||
             context.msBackingStorePixelRatio ||
             context.oBackingStorePixelRatio ||
             context.backingStorePixelRatio || 1;
    },
    backingScale: function( context ) {
      if ( 'devicePixelRatio' in window ) {
        var backingStoreRatio = Util.backingStorePixelRatio( context );
        return window.devicePixelRatio / backingStoreRatio;
      }
      return 1;
    },
    scanBounds: function( imageData, resolution, transform ) {
      var dirtyX = _.map( _.range( resolution ), function() { return false; } );
      var dirtyY = _.map( _.range( resolution ), function() { return false; } );
      for ( var x = 0; x < resolution; x++ ) {
        for ( var y = 0; y < resolution; y++ ) {
          var offset = 4 * ( y * resolution + x );
          if ( imageData.data[ offset ] !== 0 || imageData.data[ offset + 1 ] !== 0 || imageData.data[ offset + 2 ] !== 0 || imageData.data[ offset + 3 ] !== 0 ) {
            dirtyX[ x ] = true;
            dirtyY[ y ] = true;
          }
        }
      }
      var minX = _.indexOf( dirtyX, true );
      var maxX = _.lastIndexOf( dirtyX, true );
      var minY = _.indexOf( dirtyY, true );
      var maxY = _.lastIndexOf( dirtyY, true );
      var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!
      return {
        minBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y
        ),
        maxBounds: new Bounds2(
          ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,
          ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,
          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,
          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y
        )
      };
    },
    canvasAccurateBounds: function( renderToContext, options ) {
      var precision = ( options && options.precision ) ? options.precision : 0.001;
      var resolution = ( options && options.resolution ) ? options.resolution : 128;
      var initialScale = ( options && options.initialScale ) ? options.initialScale : ( 1 / 16 );
      var minBounds = Bounds2.NOTHING;
      var maxBounds = Bounds2.EVERYTHING;
      var canvas = document.createElement( 'canvas' );
      canvas.width = resolution;
      canvas.height = resolution;
      var context = canvas.getContext( '2d' );
      if ( debugChromeBoundsScanning ) {
        $( window ).ready( function() {
          var header = document.createElement( 'h2' );
          $( header ).text( 'Bounds Scan' );
          $( '#display' ).append( header );
        } );
      }
      function scan( transform ) {
        context.save();
        transform.matrix.canvasSetTransform( context );
        renderToContext( context );
        context.restore();
        var data = context.getImageData( 0, 0, resolution, resolution );
        var minMaxBounds = Util.scanBounds( data, resolution, transform );
        function snapshotToCanvas( snapshot ) {
          var canvas = document.createElement( 'canvas' );
          canvas.width = resolution;
          canvas.height = resolution;
          var context = canvas.getContext( '2d' );
          context.putImageData( snapshot, 0, 0 );
          $( canvas ).css( 'border', '1px solid black' );
          $( window ).ready( function() {
            $( '#display' ).append( canvas );
          } );
        }
        if ( debugChromeBoundsScanning ) {
          snapshotToCanvas( data );
        }
        context.clearRect( 0, 0, resolution, resolution );
        return minMaxBounds;
      }
      function idealTransform( bounds ) {
        var borderSize = 2;
        var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );
        var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );
        var translationX = -scaleX * bounds.minX + borderSize;
        var translationY = -scaleY * bounds.minY + borderSize;
        return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );
      }
      var initialTransform = new Transform3();
      initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );
      initialTransform.append( Matrix3.scaling( initialScale ) );
      var coarseBounds = scan( initialTransform );
      minBounds = minBounds.union( coarseBounds.minBounds );
      maxBounds = maxBounds.intersection( coarseBounds.maxBounds );
      var tempMin;
      var tempMax;
      var refinedBounds;
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {
        refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );
        if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
            console.log( 'transformed "min" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );
            console.log( 'transformed "max" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );
          }
          break;
        }
        minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );
        maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }
      tempMin = maxBounds.minY;
      tempMax = maxBounds.maxY;
      while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {
        refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );
        if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );
        maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );
      }
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );
        if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );
        maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }
      tempMin = maxBounds.minX;
      tempMax = maxBounds.maxX;
      while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {
        refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );
        if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {
          if ( debugChromeBoundsScanning ) {
            console.log( 'warning, exiting infinite loop!' );
          }
          break;
        }
        minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );
        maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );
        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );
        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );
      }
      if ( debugChromeBoundsScanning ) {
        console.log( 'minBounds: ' + minBounds );
        console.log( 'maxBounds: ' + maxBounds );
      }
      var result = new Bounds2(
        ( minBounds.minX + maxBounds.minX ) / 2,
        ( minBounds.minY + maxBounds.minY ) / 2,
        ( minBounds.maxX + maxBounds.maxX ) / 2,
        ( minBounds.maxY + maxBounds.maxY ) / 2
      );
      result.minBounds = minBounds;
      result.maxBounds = maxBounds;
      result.isConsistent = maxBounds.containsBounds( minBounds );
      result.precision = Math.max(
        Math.abs( minBounds.minX - maxBounds.minX ),
        Math.abs( minBounds.minY - maxBounds.minY ),
        Math.abs( minBounds.maxX - maxBounds.maxX ),
        Math.abs( minBounds.maxY - maxBounds.maxY )
      );
      return result;
    },
    toPowerOf2: function( n ) {
      var result = 1;
      while ( result < n ) {
        result *= 2;
      }
      return result;
    },
    createShader: function( gl, source, type ) {
      var shader = gl.createShader( type );
      gl.shaderSource( shader, source );
      gl.compileShader( shader );
      if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
        console.log( 'GLSL compile error:' );
        console.log( gl.getShaderInfoLog( shader ) );
        console.log( source );
      }
      return shader;
    },
    applyWebGLContextDefaults: function( gl ) {
      gl.clearColor( 0, 0, 0, 0 );
      gl.enable( gl.BLEND );
      gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
      gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
    },
    checkWebGLSupport: function( extensions ) {
      var canvas = document.createElement( 'canvas' );
      var args = { failIfMajorPerformanceCaveat: true };
      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl', args ) || canvas.getContext( 'experimental-webgl', args ) );
        if ( !gl ) {
          return false;
        }
        if ( extensions ) {
          for ( var i = 0; i < extensions.length; i++ ) {
            if ( gl.getExtension( extensions[ i ] ) === null ) {
              return false;
            }
          }
        }
        return true;
      }
      catch( e ) {
        return false;
      }
    },
    checkIE11StencilSupport: function() {
      var canvas = document.createElement( 'canvas' );
      try {
        var gl = !!window.WebGLRenderingContext &&
                 ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) );
        if ( !gl ) {
          return false;
        }
        gl.clearStencil( 0 );
        return gl.getError() === 0;
      }
      catch( e ) {
        return false;
      }
    },
    get isWebGLSupported() {
      if ( this._extensionlessWebGLSupport === undefined ) {
        this._extensionlessWebGLSupport = scenery.Util.checkWebGLSupport();
      }
      return this._extensionlessWebGLSupport;
    }
  };
  scenery.register( 'Util', Util );
  return Util;
} );
define( 'SCENERY/display/drawables/TextDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/display/DOMSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/TextStatefulDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var TextStatefulDrawable = require( 'SCENERY/display/drawables/TextStatefulDrawable' );
  require( 'SCENERY/util/Util' );
  var keepDOMTextElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  var scratchMatrix = Matrix3.dirtyFromPool();
  function TextDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'TextDOMDrawable', TextDOMDrawable );
  inherit( DOMSelfDrawable, TextDOMDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );
      if ( !this.domElement ) {
        this.domElement = document.createElement( 'div' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
        this.domElement.setAttribute( 'dir', 'ltr' );
      }
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );
      return this; // allow for chaining
    },
    updateDOM: function() {
      var node = this.node;
      var div = this.domElement;
      if ( this.paintDirty ) {
        if ( this.dirtyFont ) {
          div.style.font = node.getFont();
        }
        if ( this.dirtyStroke ) {
          div.style.color = node.getCSSFill();
        }
        if ( this.dirtyBounds ) { // TODO: this condition is set on invalidateText, so it's almost always true?
          div.style.width = node.getSelfBounds().width + 'px';
          div.style.height = node.getSelfBounds().height + 'px';
        }
        if ( this.dirtyText ) {
          div.textContent = node.renderedText;
        }
      }
      if ( this.transformDirty || this.dirtyText || this.dirtyFont || this.dirtyBounds ) {
        var yOffset = node.getSelfBounds().minY;
        scratchMatrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( 0, yOffset );
        scratchMatrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( scratchMatrix, div, this.forceAcceleration );
      }
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },
    dispose: function() {
      this.disposeState();
      if ( !keepDOMTextElements ) {
        this.domElement = null;
      }
      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  TextStatefulDrawable.mixin( TextDOMDrawable );
  SelfDrawable.Poolable.mixin( TextDOMDrawable );
  return TextDOMDrawable;
} );
define( 'SCENERY/display/drawables/TextSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','PHET_CORE/platform','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/TextStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var platform = require( 'PHET_CORE/platform' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var TextStatefulDrawable = require( 'SCENERY/display/drawables/TextStatefulDrawable' );
  var keepSVGTextElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  var useSVGTextLengthAdjustments = !platform.ie && !platform.edge;
  var useTransparentSVGTextWorkaround = platform.safari;
  function TextSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'TextSVGDrawable', TextSVGDrawable );
  inherit( SVGSelfDrawable, TextSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGTextElements ); // usesPaint: true
      if ( !this.svgElement ) {
        var text = document.createElementNS( scenery.svgns, 'text' );
        text.appendChild( document.createTextNode( '' ) );
        this.text = text;
        this.direction = 'ltr';
        if ( useTransparentSVGTextWorkaround ) {
          var group = document.createElementNS( scenery.svgns, 'g' );
          group.appendChild( text );
          this.svgElement = group;
          this.workaroundRect = document.createElementNS( scenery.svgns, 'rect' );
          this.workaroundRect.setAttribute( 'fill', 'transparent' );
          group.appendChild( this.workaroundRect );
        }
        else {
          this.svgElement = text;
        }
        text.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
        text.setAttribute( 'text-rendering', 'geometricPrecision' );
        if ( useSVGTextLengthAdjustments ) {
          text.setAttribute( 'lengthAdjust', 'spacingAndGlyphs' );
        }
        text.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
        text.setAttribute( 'direction', 'ltr' );
      }
      return this;
    },
    updateSVGSelf: function() {
      var text = this.text;
      if ( this.dirtyFont ) {
        text.setAttribute( 'font-family', this.node._font.getFamily() );
        text.setAttribute( 'font-size', this.node._font.getSize() );
        text.setAttribute( 'font-style', this.node._font.getStyle() );
        text.setAttribute( 'font-weight', this.node._font.getWeight() );
        text.setAttribute( 'font-stretch', this.node._font.getStretch() );
      }
      if ( this.dirtyText ) {
        var string = this.node.renderedText;
        if ( platform.firefox ) {
          string = '\u200b' + string;
        }
        text.lastChild.nodeValue = string;
      }
      if ( this.dirtyBounds && useSVGTextLengthAdjustments && isFinite( this.node.selfBounds.width ) ) {
        text.setAttribute( 'textLength', this.node.selfBounds.width );
        if ( useTransparentSVGTextWorkaround ) {
          var paddingRatio = 0.2;
          var horizontalPadding = this.node.selfBounds.width * paddingRatio;
          var verticalPadding = this.node.selfBounds.height * paddingRatio;
          this.workaroundRect.setAttribute( 'x', this.node.selfBounds.minX - horizontalPadding );
          this.workaroundRect.setAttribute( 'y', this.node.selfBounds.minY - verticalPadding );
          this.workaroundRect.setAttribute( 'width', this.node.selfBounds.width + 2 * horizontalPadding );
          this.workaroundRect.setAttribute( 'height', this.node.selfBounds.height + 2 * verticalPadding );
        }
      }
      this.updateFillStrokeStyle( text );
    }
  } );
  TextStatefulDrawable.mixin( TextSVGDrawable );
  SelfDrawable.Poolable.mixin( TextSVGDrawable );
  return TextSVGDrawable;
} );
define( 'SCENERY/display/drawables/TextWebGLDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SelfDrawable','SCENERY/display/WebGLSelfDrawable','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  function TextWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'TextWebGLDrawable', TextWebGLDrawable );
  inherit( WebGLSelfDrawable, TextWebGLDrawable, {
    initialize: function( renderer, instance ) {
      return this.initializeWebGLSelfDrawable( renderer, instance );
    },
    onAddToBlock: function( webglBlock ) {
      var self = this;
      this.node.toImageNodeAsynchronous( function( imageNodeContainer ) {
        var imageNode = imageNodeContainer.children[ 0 ];
        self.textHandle = webglBlock.webGLRenderer.textureRenderer.createFromImageNode( imageNode, 0.4 );
        webglBlock.webGLRenderer.textureRenderer.bindVertexBuffer();
        webglBlock.webGLRenderer.textureRenderer.bindDirtyTextures();
        self.updateText();
      } );
    },
    onRemoveFromBlock: function( webglBlock ) {
    },
    updateText: function() {
      if ( this.textHandle ) {
        this.textHandle.update();
      }
    },
    render: function( shaderProgram ) {
    },
    dispose: function() {
      this.disposeWebGLBuffers();
      WebGLSelfDrawable.prototype.dispose.call( this );
    },
    disposeWebGLBuffers: function() {
      this.webglBlock.webGLRenderer.colorTriangleRenderer.colorTriangleBufferData.dispose( this.rectangleHandle );
    },
    markDirtyText: function() {
      this.markDirty();
    },
    markDirtyBounds: function() {
      this.markDirty();
    },
    markPaintDirty: function() {
      this.markDirty();
    },
    update: function() {
      this.updateText();
      this.dirty = false;
    }
  } );
  PaintableStatefulDrawable.mixin( TextWebGLDrawable );
  SelfDrawable.Poolable.mixin( TextWebGLDrawable );
  return TextWebGLDrawable;
} );
define( 'SCENERY/util/TextBounds',['require','SCENERY/scenery','SCENERY/util/Font','DOT/Bounds2','SCENERY/util/Util','SCENERY/util/CanvasContextWrapper'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var Font = require( 'SCENERY/util/Font' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Util = require( 'SCENERY/util/Util' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var TEXT_SIZE_CONTAINER_ID = 'sceneryTextSizeContainer';
  var TEXT_SIZE_ELEMENT_ID = 'sceneryTextSizeElement';
  var svgTextSizeContainer;
  var svgTextSizeElement;
  var hybridFontVerticalCache = {};
  var TextBounds = {
    approximateSVGBounds: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );
      if ( !svgTextSizeContainer.parentNode ) {
        if ( document.body ) {
          document.body.appendChild( svgTextSizeContainer );
        }
        else {
          throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );
        }
      }
      TextBounds.setSVGTextAttributes( svgTextSizeElement, font, renderedText );
      var rect = svgTextSizeElement.getBBox();
      return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );
    },
    accurateCanvasBounds: function( text ) {
      var svgBounds = TextBounds.approximateSVGBounds( text._font, text.renderedText ); // this seems to be slower than expected, mostly due to Font getters
      if ( !text.renderedText.length || svgBounds.width === 0 ) {
        return svgBounds;
      }
      return Util.canvasAccurateBounds( function( context ) {
        context.font = text._font.toCSS();
        context.direction = 'ltr';
        context.fillText( text.renderedText, 0, 0 );
        if ( text.hasStroke() ) {
          var fakeWrapper = new CanvasContextWrapper( null, context );
          text.beforeCanvasStroke( fakeWrapper );
          context.strokeText( text.renderedText, 0, 0 );
          text.afterCanvasStroke( fakeWrapper );
        }
      }, {
        precision: 0.5,
        resolution: 128,
        initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )
      } );
    },
    getVerticalBounds: function( font ) {
      assert && assert( font instanceof Font, 'Font required' );
      var css = font.toCSS();
      var verticalBounds = hybridFontVerticalCache[ css ];
      if ( !verticalBounds ) {
        verticalBounds = hybridFontVerticalCache[ css ] = TextBounds.approximateSVGBounds( font, 'm' );
      }
      return verticalBounds;
    },
    approximateCanvasWidth: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );
      var context = scenery.scratchContext;
      context.font = font.toCSS();
      context.direction = 'ltr';
      return context.measureText( renderedText ).width;
    },
    approximateHybridBounds: function( font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );
      var verticalBounds = TextBounds.getVerticalBounds( font );
      var canvasWidth = TextBounds.approximateCanvasWidth( font, renderedText );
      return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );
    },
    approximateDOMBounds: function( font, element ) {
      assert && assert( font instanceof Font, 'Font required' );
      var maxHeight = 1024; // technically this will fail if the font is taller than this!
      var div = document.createElement( 'div' );
      $( div ).css( {
        position: 'absolute',
        left: 0,
        top: 0,
        padding: '0 !important',
        margin: '0 !important',
        display: 'hidden'
      } );
      var span = document.createElement( 'span' );
      $( span ).css( 'font', font.toCSS() );
      span.appendChild( element );
      span.setAttribute( 'direction', 'ltr' );
      var fakeImage = document.createElement( 'div' );
      $( fakeImage ).css( {
        'vertical-align': 'baseline',
        display: 'inline-block',
        width: 0,
        height: maxHeight + 'px',
        margin: '0 !important',
        padding: '0 !important'
      } );
      div.appendChild( span );
      div.appendChild( fakeImage );
      document.body.appendChild( div );
      var rect = span.getBoundingClientRect();
      var divRect = div.getBoundingClientRect();
      var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );
      document.body.removeChild( div );
      return result;
    },
    approximateImprovedDOMBounds: function( font, element ) {
      assert && assert( font instanceof Font, 'Font required' );
      var div = document.createElement( 'div' );
      div.style.display = 'inline-block';
      div.style.font = font.toCSS();
      div.style.color = 'transparent';
      div.style.padding = '0 !important';
      div.style.margin = '0 !important';
      div.style.position = 'absolute';
      div.style.left = '0';
      div.style.top = '0';
      div.setAttribute( 'direction', 'ltr' );
      div.appendChild( element );
      document.body.appendChild( div );
      var bounds = new Bounds2( div.offsetLeft, div.offsetTop, div.offsetLeft + div.offsetWidth + 1, div.offsetTop + div.offsetHeight + 1 );
      document.body.removeChild( div );
      var verticalBounds = TextBounds.getVerticalBounds( font );
      return bounds.shiftedY( verticalBounds.minY );
    },
    setSVGTextAttributes: function( textElement, font, renderedText ) {
      assert && assert( font instanceof Font, 'Font required' );
      assert && assert( typeof renderedText === 'string', 'renderedText required' );
      textElement.setAttribute( 'direction', 'ltr' );
      textElement.setAttribute( 'font-family', font.getFamily() );
      textElement.setAttribute( 'font-size', font.getSize() );
      textElement.setAttribute( 'font-style', font.getStyle() );
      textElement.setAttribute( 'font-weight', font.getWeight() );
      textElement.setAttribute( 'font-stretch', font.getStretch() );
      textElement.lastChild.nodeValue = renderedText;
    },
    initializeTextBounds: function() {
      svgTextSizeContainer = document.getElementById( TEXT_SIZE_CONTAINER_ID );
      if ( !svgTextSizeContainer ) {
        svgTextSizeContainer = document.createElementNS( scenery.svgns, 'svg' );
        svgTextSizeContainer.setAttribute( 'width', '2' );
        svgTextSizeContainer.setAttribute( 'height', '2' );
        svgTextSizeContainer.setAttribute( 'id', TEXT_SIZE_CONTAINER_ID );
        svgTextSizeContainer.setAttribute( 'style', 'visibility: hidden; pointer-events: none; position: absolute; left: -65535px; right: -65535px;' ); // so we don't flash it in a visible way to the user
      }
      svgTextSizeElement = document.getElementById( TEXT_SIZE_ELEMENT_ID );
      if ( !svgTextSizeElement ) {
        svgTextSizeElement = document.createElementNS( scenery.svgns, 'text' );
        svgTextSizeElement.appendChild( document.createTextNode( '' ) );
        svgTextSizeElement.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now
        svgTextSizeElement.setAttribute( 'text-rendering', 'geometricPrecision' );
        svgTextSizeElement.setAttributeNS( 'http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve' );
        svgTextSizeElement.setAttribute( 'id', TEXT_SIZE_ELEMENT_ID );
        svgTextSizeContainer.appendChild( svgTextSizeElement );
      }
    }
  };
  scenery.register( 'TextBounds', TextBounds );
  return TextBounds;
} );
define( 'SCENERY/util/TFont',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  function TFont( font, phetioID ) {
    TObject.call( this, font, phetioID );
    assertInstanceOf( font, phet.scenery.Font );
  }
  phetioInherit( TObject, 'TFont', TFont, {}, {
    documentation: 'Font handling for text drawing. Options: <br>' +
                   'style: normal      // normal | italic | oblique <br>' +
                   'variant: normal    // normal | small-caps <br>' +
                   'weight: normal     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 <br>' +
                   'stretch: normal    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded <br>' +
                   'size: 10px         // absolute-size | relative-size | length | percentage -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax. <br>' +
                   'lineHeight: normal // normal | number | length | percentage -- NOTE: Canvas spec forces line-height to normal <br>' +
                   'family: sans-serif // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes',
    fromStateObject: function( stateObject ) {
      return new phet.scenery.Font( stateObject );
    },
    toStateObject: function( font ) {
      return {
        style: font.getStyle(),
        variant: font.getVariant(),
        weight: font.getWeight(),
        stretch: font.getStretch(),
        size: font.getSize(),
        lineHeight: font.getLineHeight(),
        family: font.getFamily()
      };
    }
  } );
  scenery.register( 'TFont', TFont );
  return TFont;
} );
define("PHET_IO/phetioEvents", function(){return function(){ return function(){}; };});
define("PHET_IO/types/TString", function(){return function(){ return function(){}; };});
define( 'SCENERY/nodes/TText',['require','SCENERY/scenery','SCENERY/util/TFont','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var TFont = require( 'SCENERY/util/TFont' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  function TText( text, phetioID ) {
    TNode.call( this, text, phetioID );
    assertInstanceOf( text, phet.scenery.Text );
    text.on( 'text', function( oldText, newText ) {
      phetioEvents.trigger( 'model', phetioID, TText, 'textChanged', {
        oldText: oldText,
        newText: newText
      } );
    } );
  }
  phetioInherit( TNode, 'TText', TText, {
    addTextChangedListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TString ] ) ],
      implementation: function( listener ) {
        this.instance.on( 'text', function( oldText, newText ) {
          listener( newText );
        } );
      },
      documentation: 'Add a listener for when the text has changed.'
    },
    setText: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( text ) {
        this.instance.text = text;
      },
      documentation: 'Set the text content'
    },
    getText: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return this.instance.text;
      },
      documentation: 'Get the text content'
    },
    setFontOptions: {
      returnType: TVoid,
      parameterTypes: [ TFont ],
      implementation: function( font ) {
        this.instance.setFont( font );
      },
      documentation: 'Set font options for this TText instance, e.g. {size: 16, weight: bold}'
    },
    getFontOptions: {
      returnType: TFont,
      parameterTypes: [],
      implementation: function() {
        return this.instance.getFont();
      },
      documentation: 'Get font options for this TText instance as an object'
    },
    setMaxWidth: {
      returnType: TVoid,
      parameterTypes: [ TNumber() ],
      implementation: function( maxWidth ) {
        this.instance.setMaxWidth( maxWidth );
      },
      documentation: 'Set maximum width of text box in px. ' +
                     'If text is wider than maxWidth at its default font size, it is scaled down to fit.'
    },
    getMaxWidth: {
      returnType: TNumber(),
      parameterTypes: [],
      implementation: function() {
        return this.instance.maxWidth;
      },
      documentation: 'Get maximum width of text box in px'
    }
  }, {
    documentation: 'The tandem wrapper type for the scenery Text node',
    events: [ 'textChanged' ]
  } );
  scenery.register( 'TText', TText );
  return TText;
} );
define( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','PHET_CORE/escapeHTML','PHET_CORE/platform','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/nodes/Paintable','SCENERY/util/Font','TANDEM/Tandem','SCENERY/display/drawables/TextCanvasDrawable','SCENERY/display/drawables/TextDOMDrawable','SCENERY/display/drawables/TextSVGDrawable','SCENERY/display/drawables/TextWebGLDrawable','SCENERY/util/TextBounds','SCENERY/nodes/TText'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var escapeHTML = require( 'PHET_CORE/escapeHTML' );
  var platform = require( 'PHET_CORE/platform' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Paintable = require( 'SCENERY/nodes/Paintable' );
  var Font = require( 'SCENERY/util/Font' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TextCanvasDrawable = require( 'SCENERY/display/drawables/TextCanvasDrawable' );
  var TextDOMDrawable = require( 'SCENERY/display/drawables/TextDOMDrawable' );
  var TextSVGDrawable = require( 'SCENERY/display/drawables/TextSVGDrawable' );
  var TextWebGLDrawable = require( 'SCENERY/display/drawables/TextWebGLDrawable' );
  var TextBounds = require( 'SCENERY/util/TextBounds' );
  var TText = require( 'SCENERY/nodes/TText' );
  var TEXT_OPTION_KEYS = [
    'boundsMethod', // Sets how bounds are determined for text, see setBoundsMethod() for more documentation
    'text', // Sets the text to be displayed, see setText() for more documentation
    'font', // Sets the font used for the text, see setFont() for more documentation
    'fontWeight', // Sets the weight of the current font, see setFont() for more documentation
    'fontFamily', // Sets the family of the current font, see setFont() for more documentation
    'fontStretch', // Sets the stretch of the current font, see setFont() for more documentation
    'fontStyle', // Sets the style of the current font, see setFont() for more documentation
    'fontSize' // Sets the size of the current font, see setFont() for more documentation
  ];
  var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&
                           window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;
  function Text( text, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    this._text = '';
    this._font = Font.DEFAULT;
    this._boundsMethod = 'hybrid';
    this._isHTML = this._isHTML === undefined ? false : this._isHTML;
    this._cachedRenderedText = null;
    this.initializePaintable();
    options = extendDefined( {
      fill: '#000000', // Default to black filled text
      text: text,
      tandem: Tandem.tandemOptional(),
      phetioType: TText
    }, options );
    Node.call( this, options );
    this.invalidateSupportedRenderers(); // takes care of setting up supported renderers
  }
  scenery.register( 'Text', Text );
  inherit( Node, Text, {
    _mutatorKeys: TEXT_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'text', 'font', 'bounds' ] ),
    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
      assert && assert( typeof text === 'number' || typeof text === 'string', 'text should be a string or number' );
      text = '' + text;
      if ( text !== this._text ) {
        var oldText = this._text;
        this._text = text;
        this._cachedRenderedText = null;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyText();
        }
        this.invalidateText();
        this.trigger2( 'text', oldText, text );
      }
      return this;
    },
    set text( value ) { this.setText( value ); },
    getText: function() {
      return this._text;
    },
    get text() { return this.getText(); },
    getRenderedText: function() {
      if ( this._cachedRenderedText === null ) {
        this._cachedRenderedText = this._text.replace( ' ', '\xA0' );
        if ( platform.edge ) {
          this._cachedRenderedText = Text.simplifyEmbeddingMarks( this._cachedRenderedText );
        }
      }
      return this._cachedRenderedText;
    },
    get renderedText() { return this.getRenderedText(); },
    setBoundsMethod: function( method ) {
      assert && assert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );
      if ( method !== this._boundsMethod ) {
        this._boundsMethod = method;
        this.invalidateSupportedRenderers();
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyBounds();
        }
        this.invalidateText();
        this.trigger0( 'boundsMethod' );
        this.trigger0( 'selfBoundsValid' ); // whether our self bounds are valid may have changed
      }
      return this;
    },
    set boundsMethod( value ) { this.setBoundsMethod( value ); },
    getBoundsMethod: function() {
      return this._boundsMethod;
    },
    get boundsMethod() { return this.getBoundsMethod(); },
    getTextRendererBitmask: function() {
      var bitmask = 0;
      if ( this._boundsMethod !== 'fast' && !this._isHTML ) {
        bitmask |= Renderer.bitmaskCanvas;
      }
      if ( !this._isHTML ) {
        bitmask |= Renderer.bitmaskSVG;
      }
      bitmask |= Renderer.bitmaskDOM;
      return bitmask;
    },
    invalidateSupportedRenderers: function() {
      this.setRendererBitmask( this.getFillRendererBitmask() & this.getStrokeRendererBitmask() & this.getTextRendererBitmask() );
    },
    invalidateText: function() {
      this.invalidateSelf();
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyBounds();
      }
      this.invalidateSupportedRenderers();
    },
    updateSelfBounds: function() {
      var selfBounds;
      if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {
        selfBounds = TextBounds.approximateDOMBounds( this._font, this.getDOMTextNode() );
      }
      else if ( this._boundsMethod === 'hybrid' ) {
        selfBounds = TextBounds.approximateHybridBounds( this._font, this.renderedText );
      }
      else if ( this._boundsMethod === 'accurate' ) {
        selfBounds = TextBounds.accurateCanvasBounds( this );
      }
      else {
        assert && assert( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' );
        selfBounds = TextBounds.approximateSVGBounds( this._font, this.renderedText );
      }
      if ( this.hasStroke() ) {
        selfBounds.dilate( this.getLineWidth() / 2 );
      }
      var changed = !selfBounds.equals( this._selfBounds );
      if ( changed ) {
        this._selfBounds.set( selfBounds );
      }
      return changed;
    },
    invalidateStroke: function() {
      this.invalidateText();
    },
    invalidateFill: function() {
      this.invalidateText();
    },
    canvasPaintSelf: function( wrapper ) {
      TextCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    createDOMDrawable: function( renderer, instance ) {
      return TextDOMDrawable.createFromPool( renderer, instance );
    },
    createSVGDrawable: function( renderer, instance ) {
      return TextSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return TextCanvasDrawable.createFromPool( renderer, instance );
    },
    createWebGLDrawable: function( renderer, instance ) {
      return TextWebGLDrawable.createFromPool( renderer, instance );
    },
    getDOMTextNode: function() {
      if ( this._isHTML ) {
        var span = document.createElement( 'span' );
        span.innerHTML = this._text;
        return span;
      }
      else {
        return document.createTextNode( this.renderedText );
      }
    },
    getSafeSelfBounds: function() {
      var expansionFactor = 1; // we use a new bounding box with a new size of size * ( 1 + 2 * expansionFactor )
      var selfBounds = this.getSelfBounds();
      return selfBounds.dilatedXY( expansionFactor * selfBounds.width, expansionFactor * selfBounds.height );
    },
    setFont: function( font ) {
      assert && assert( font instanceof Font || typeof font === 'string',
        'Fonts provided to setFont should be a Font object or a string in the CSS3 font shortcut format' );
      var changed = font !== ( ( typeof font === 'string' ) ? this._font.toCSS() : this._font );
      if ( changed ) {
        this._font = ( typeof font === 'string' ) ? new Font( font ) : font;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyFont();
        }
        this.invalidateText();
      }
      return this;
    },
    set font( value ) { this.setFont( value ); },
    getFont: function() {
      return this._font.getFont();
    },
    get font() { return this.getFont(); },
    setFontWeight: function( weight ) {
      return this.setFont( this._font.copy( {
        weight: weight
      } ) );
    },
    set fontWeight( value ) { this.setFontWeight( value ); },
    getFontWeight: function() {
      return this._font.getWeight();
    },
    get fontWeight() { return this.getFontWeight(); },
    setFontFamily: function( family ) {
      return this.setFont( this._font.copy( {
        family: family
      } ) );
    },
    set fontFamily( value ) { this.setFontFamily( value ); },
    getFontFamily: function() {
      return this._font.getFamily();
    },
    get fontFamily() { return this.getFontFamily(); },
    setFontStretch: function( stretch ) {
      return this.setFont( this._font.copy( {
        stretch: stretch
      } ) );
    },
    set fontStretch( value ) { this.setFontStretch( value ); },
    getFontStretch: function() {
      return this._font.getStretch();
    },
    get fontStretch() { return this.getFontStretch(); },
    setFontStyle: function( style ) {
      return this.setFont( this._font.copy( {
        style: style
      } ) );
    },
    set fontStyle( value ) { this.setFontStyle( value ); },
    getFontStyle: function() {
      return this._font.getStyle();
    },
    get fontStyle() { return this.getFontStyle(); },
    setFontSize: function( size ) {
      return this.setFont( this._font.copy( {
        size: size
      } ) );
    },
    set fontSize( value ) { this.setFontSize( value ); },
    getFontSize: function() {
      return this._font.getSize();
    },
    get fontSize() { return this.getFontSize(); },
    isPainted: function() {
      return true;
    },
    areSelfBoundsValid: function() {
      return this._boundsMethod === 'accurate';
    },
    getDebugHTMLExtras: function() {
      return ' "' + escapeHTML( this.renderedText ) + '"' + ( this._isHTML ? ' (html)' : '' );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Text( \'' + escapeHTML( this._text.replace( /'/g, '\\\'' ) ) + '\', {' + propLines + '} )';
    },
    getPropString: function( spaces, includeChildren ) {
      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );
      result = this.appendFillablePropString( spaces, result );
      result = this.appendStrokablePropString( spaces, result );
      function addProp( key, value, nowrap ) {
        if ( result ) {
          result += ',\n';
        }
        if ( !nowrap && typeof value === 'string' ) {
          result += spaces + key + ': \'' + value + '\'';
        }
        else {
          result += spaces + key + ': ' + value;
        }
      }
      if ( this.font !== new scenery.Font().getFont() ) {
        addProp( 'font', this.font.replace( /'/g, '\\\'' ) );
      }
      return result;
    }
  } );
  Paintable.mixin( Text );
  var LTR = '\u202a';
  var RTL = '\u202b';
  var POP = '\u202c';
  Text.embeddedDebugString = function( string ) {
    return string.replace( /\u202a/g, '[LTR]' ).replace( /\u202b/g, '[RTL]' ).replace( /\u202c/g, '[POP]' );
  };
  Text.simplifyEmbeddingMarks = function( string ) {
    var root = {
      dir: null,
      children: [],
      parent: null
    };
    var current = root;
    for ( var i = 0; i < string.length; i++ ) {
      var chr = string.charAt( i );
      if ( chr === LTR || chr === RTL ) {
        var node = {
          dir: chr,
          children: [],
          parent: current
        };
        current.children.push( node );
        current = node;
      }
      else if ( chr === POP ) {
        assert && assert( current.parent, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );
        current = current.parent;
      }
      else {
        current.children.push( chr );
      }
    }
    assert && assert( current === root, 'Bad nesting of embedding marks: ' + Text.embeddedDebugString( string ) );
    function collapseNesting( node ) {
      for ( var i = node.children.length - 1; i >= 0; i-- ) {
        var child = node.children[ i ];
        if ( node.dir === child.dir ) {
          Array.prototype.splice.apply( node.children, [ i, 1 ].concat( child.children ) );
        }
      }
    }
    function collapseUnnecessary( node ) {
      if ( node.children.length === 1 && node.children[ 0 ].dir ) {
        node.dir = node.children[ 0 ].dir;
        node.children = node.children[ 0 ].children;
      }
    }
    function collapseAdjacent( node ) {
      for ( var i = node.children.length - 1; i >= 1; i-- ) {
        var previousChild = node.children[ i - 1 ];
        var child = node.children[ i ];
        if ( child.dir && previousChild.dir === child.dir ) {
          previousChild.children = previousChild.children.concat( child.children );
          node.children.splice( i, 1 );
          collapseAdjacent( previousChild );
        }
      }
    }
    function simplify( node ) {
      if ( typeof node === 'string' ) {
        return;
      }
      for ( var i = 0; i < node.children.length; i++ ) {
        simplify( node.children[ i ] );
      }
      collapseUnnecessary( node );
      collapseNesting( node );
      collapseAdjacent( node );
      return node;
    }
    function stringify( node ) {
      if ( typeof node === 'string' ) {
        return node;
      }
      var childString = node.children.map( stringify ).join( '' );
      if ( node.dir ) {
        return node.dir + childString + '\u202c';
      }
      else {
        return childString;
      }
    }
    return stringify( simplify( root ) );
  };
  TextBounds.initializeTextBounds();
  return Text;
} );
define( 'SUN/TAccordionBox',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TAccordionBox( accordionBox, phetioID ) {
    assertInstanceOf( accordionBox, phet.sun.AccordionBox );
    TNode.call( this, accordionBox, phetioID );
    toEventOnEmit(
      accordionBox.startedCallbacksForCollapsedTitleBarDownEmitter,
      accordionBox.endedCallbacksForCollapsedTitleBarDownEmitter,
      'user',
      phetioID,
      this.constructor,
      'collapsed'
    );
    toEventOnEmit(
      accordionBox.startedCallbacksForExpandedTitleBarDownEmitter,
      accordionBox.endedCallbacksForExpandedTitleBarDownEmitter,
      'user',
      phetioID,
      this.constructor,
      'expanded'
    );
  }
  phetioInherit( TNode, 'TAccordionBox', TAccordionBox, {}, {
    documentation: 'A traditional accordionBox',
    events: [ 'expanded', 'collapsed' ]
  } );
  sun.register( 'TAccordionBox', TAccordionBox );
  return TAccordionBox;
} );
define( 'SUN/AccordionBox',['require','AXON/Emitter','SUN/ExpandCollapseButton','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','AXON/Property','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','TANDEM/Tandem','SCENERY/nodes/Text','ifphetio!PHET_IO/types/TBoolean','SUN/TAccordionBox'],function( require ) {
  'use strict';
  var Emitter = require( 'AXON/Emitter' );
  var ExpandCollapseButton = require( 'SUN/ExpandCollapseButton' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TAccordionBox = require( 'SUN/TAccordionBox' );
  function AccordionBox( contentNode, options ) {
    var self = this;
    options.tandem = options.tandem || Tandem.tandemRequired();
    options = _.extend( {
      cursor: 'pointer', // {string} default cursor
      lineWidth: 1,
      cornerRadius: 3,
      stroke: 'black',
      fill: 'rgb( 238, 238, 238 )',
      minWidth: 0,
      titleNode: new Text( '', { tandem: options.tandem.createTandem( 'titleNode' ) } ), // a {Node} with well-defined bounds
      titleAlignX: 'center', // {string} horizontal alignment of the title, 'left'|'center'|'right'
      titleAlignY: 'center', // {string} vertical alignment of the title, relative to expand/collapse button 'top'|'center'
      titleXMargin: 10, // horizontal space between title and left|right edge of box
      titleYMargin: 2, // vertical space between title and top of box
      titleXSpacing: 5, // horizontal space between title and expand/collapse button
      showTitleWhenExpanded: true, // true = title is visible when expanded, false = title is hidden when expanded
      titleBarFill: null, // {Color|string} title bar fill
      titleBarStroke: null, // {Color|string} title bar stroke, used only for the expanded title bar
      titleBarExpandCollapse: true, // {boolean} clicking on the title bar expands/collapses the accordion box
      buttonLength: 16, // button is a square, this is the length of one side
      buttonAlign: 'left',  // {string} button alignment, 'left'|'right'
      buttonXMargin: 4, // horizontal space between button and left|right edge of box
      buttonYMargin: 2, // vertical space between button and top edge of box
      expandedProperty: new Property( true, {
        tandem: options.tandem.createTandem( 'expandedProperty' ),
        phetioValueType: TBoolean
      } ),
      buttonTouchAreaXDilation: 0,
      buttonTouchAreaYDilation: 0,
      buttonMouseAreaXDilation: 0,
      buttonMouseAreaYDilation: 0,
      contentAlign: 'center', // {string} horizontal alignment of the content, 'left'|'center'|'right'
      contentXMargin: 15, // horizontal space between content and left/right edges of box
      contentYMargin: 8,  // horizontal space between content and bottom edge of box
      contentXSpacing: 5, // horizontal space between content and button, ignored if showTitleWhenExpanded is true
      contentYSpacing: 8, // vertical space between content and title+button, ignored if showTitleWhenExpanded is false
      phetioType: TAccordionBox,
      tagName: 'div',
      accessibleAccordionTitle: 'No Title Given',
    }, options );
    assert && assert( options.buttonAlign === 'left' || options.buttonAlign === 'right' );
    assert && assert( options.contentAlign === 'left' || options.contentAlign === 'right' || options.contentAlign === 'center' );
    assert && assert( options.titleAlignX === 'left' || options.titleAlignX === 'right' || options.titleAlignX === 'center' );
    assert && assert( options.titleAlignY === 'top' || options.titleAlignY === 'center' );
    this.startedCallbacksForExpandedTitleBarDownEmitter = new Emitter();
    this.endedCallbacksForExpandedTitleBarDownEmitter = new Emitter();
    this.startedCallbacksForCollapsedTitleBarDownEmitter = new Emitter();
    this.endedCallbacksForCollapsedTitleBarDownEmitter = new Emitter();
    Node.call( this );
    this.expandCollapseButton = new ExpandCollapseButton( options.expandedProperty, {
      sideLength: options.buttonLength,
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'expandCollapseButton' )
    } );
    this.expandCollapseButton.touchArea = this.expandCollapseButton.localBounds.dilatedXY(
      options.buttonTouchAreaXDilation,
      options.buttonTouchAreaYDilation
    );
    this.expandCollapseButton.mouseArea = this.expandCollapseButton.localBounds.dilatedXY(
      options.buttonMouseAreaXDilation,
      options.buttonMouseAreaYDilation
    );
    var collapsedBoxHeight = Math.max( this.expandCollapseButton.height + ( 2 * options.buttonYMargin ), options.titleNode.height + ( 2 * options.titleYMargin ) );
    assert && assert( options.cornerRadius < collapsedBoxHeight / 2 );
    var boxWidth = Math.max( options.minWidth, this.expandCollapseButton.width + options.titleNode.width + options.buttonXMargin + options.titleXMargin + options.titleXSpacing );
    var expandedBoxHeight;
    if ( options.showTitleWhenExpanded ) {
      boxWidth = Math.max( boxWidth, contentNode.width + ( 2 * options.contentXMargin ) );
      expandedBoxHeight = collapsedBoxHeight + contentNode.height + options.contentYMargin + options.contentYSpacing;
    }
    else {
      boxWidth = Math.max( boxWidth, this.expandCollapseButton.width + contentNode.width + options.buttonXMargin + options.contentXMargin + options.contentXSpacing );
      expandedBoxHeight = Math.max( this.expandCollapseButton.height + ( 2 * options.buttonYMargin ), contentNode.height + ( 2 * options.contentYMargin ) );
    }
    var boxOptions = { fill: options.fill };
    var expandedBox = new Rectangle(
      0,
      0,
      boxWidth,
      expandedBoxHeight,
      options.cornerRadius,
      options.cornerRadius,
      _.extend( {
        tandem: options.tandem.createTandem( 'expandedBox' ),
        tagName: 'div'
      }, boxOptions )
    );
    this.addChild( expandedBox );
    var collapsedBox = new Rectangle(
      0,
      0,
      boxWidth,
      collapsedBoxHeight,
      options.cornerRadius,
      options.cornerRadius,
      _.extend( { tandem: options.tandem.createTandem( 'collapsedBox' ) }, boxOptions )
    );
    this.addChild( collapsedBox );
    var expandedTitleBarShape = Shape.roundedRectangleWithRadii( 0, 0, boxWidth, collapsedBoxHeight, {
      topLeft: options.cornerRadius,
      topRight: options.cornerRadius
    } );
    var expandedTitleBar = new Path( expandedTitleBarShape, {
      fill: options.titleBarFill,
      stroke: options.titleBarStroke,
      lineWidth: options.lineWidth, // use same lineWidth as box, for consistent look
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'expandedTitleBar' ),
      tagName: 'button',
      accessibleLabel: options.accessibleAccordionTitle,
      labelTagName: 'p'
    } );
    expandedBox.addChild( expandedTitleBar );
    var collapsedTitleBar = new Rectangle( 0, 0, boxWidth, collapsedBoxHeight, options.cornerRadius, options.cornerRadius, {
      fill: options.titleBarFill,
      cursor: options.cursor,
      tandem: options.tandem.createTandem( 'collapsedTitleBar' ),
      tagName: 'button',
      accessibleLabel: options.accessibleAccordionTitle,
      labelTagName: 'p'
    } );
    collapsedBox.addChild( collapsedTitleBar );
    if ( options.titleBarExpandCollapse ) {
      collapsedTitleBar.addInputListener( {
        down: function() {
          self.startedCallbacksForExpandedTitleBarDownEmitter.emit();
          options.expandedProperty.value = true;
          self.endedCallbacksForExpandedTitleBarDownEmitter.emit();
        }
      } );
    }
    collapsedTitleBar.addAccessibleInputListener( {
      click: function() {
        self.startedCallbacksForExpandedTitleBarDownEmitter.emit();
        options.expandedProperty.value = true;
        self.endedCallbacksForExpandedTitleBarDownEmitter.emit();
        expandedTitleBar.focus();
      }
    } );
    if ( options.showTitleWhenExpanded ) {
      if ( options.titleBarExpandCollapse ) {
        expandedTitleBar.addInputListener( {
          down: function() {
            self.startedCallbacksForCollapsedTitleBarDownEmitter.emit();
            options.expandedProperty.value = false;
            self.endedCallbacksForCollapsedTitleBarDownEmitter.emit();
          }
        } );
      }
      expandedTitleBar.addAccessibleInputListener( {
        click: function() {
          self.startedCallbacksForCollapsedTitleBarDownEmitter.emit();
          options.expandedProperty.value = false;
          self.endedCallbacksForCollapsedTitleBarDownEmitter.emit();
          collapsedTitleBar.focus();
        }
      } );
    }
    this.addChild( options.titleNode );
    this.addChild( this.expandCollapseButton );
    var expandedBoxOutline;
    var collapsedBoxOutline;
    if ( options.stroke ) {
      var outlineOptions = { stroke: options.stroke, lineWidth: options.lineWidth };
      expandedBoxOutline = new Rectangle(
        0,
        0,
        boxWidth,
        expandedBoxHeight,
        options.cornerRadius,
        options.cornerRadius,
        _.extend( { tandem: options.tandem.createTandem( 'expandedBoxOutline' ) }, outlineOptions )
      );
      collapsedBoxOutline = new Rectangle(
        0,
        0,
        boxWidth,
        collapsedBoxHeight,
        options.cornerRadius,
        options.cornerRadius,
        _.extend( { tandem: options.tandem.createTandem( 'collapsedBoxOutline' ) }, outlineOptions )
      );
      expandedBox.addChild( expandedBoxOutline );
      collapsedBox.addChild( collapsedBoxOutline );
    }
    contentNode.bottom = expandedBox.bottom - options.contentYMargin;
    var contentSpanLeft = expandedBox.left + options.contentXMargin;
    var contentSpanRight = expandedBox.right - options.contentXMargin;
    if ( !options.showTitleWhenExpanded ) {
      if ( options.buttonAlign === 'left' ) {
        contentSpanLeft += this.expandCollapseButton.width + options.contentXSpacing;
      }
      else { // right on right
        contentSpanRight -= this.expandCollapseButton.width + options.contentXSpacing;
      }
    }
    if ( options.contentAlign === 'left' ) {
      contentNode.left = contentSpanLeft;
    }
    else if ( options.contentAlign === 'right' ) {
      contentNode.right = contentSpanRight;
    }
    else { // center
      contentNode.centerX = ( contentSpanLeft + contentSpanRight ) / 2;
    }
    expandedBox.addChild( contentNode ); // do this after layout computations, see sun#280
    var titleLeftSpan = expandedBox.left + options.titleXMargin;
    var titleRightSpan = expandedBox.right - options.titleXMargin;
    if ( options.buttonAlign === 'left' ) {
      this.expandCollapseButton.left = expandedBox.left + options.buttonXMargin;
      titleLeftSpan = this.expandCollapseButton.right + options.titleXSpacing;
    }
    else {
      this.expandCollapseButton.right = expandedBox.right - options.buttonXMargin;
      titleRightSpan = this.expandCollapseButton.left - options.titleXSpacing;
    }
    if ( options.titleAlignX === 'left' ) {
      options.titleNode.left = titleLeftSpan;
    }
    else if ( options.titleAlignX === 'right' ) {
      options.titleNode.right = titleRightSpan;
    }
    else { // center
      options.titleNode.centerX = expandedBox.centerX;
    }
    if ( options.titleAlignY === 'top' ) {
      this.expandCollapseButton.top = collapsedBox.top + Math.max( options.buttonYMargin, options.titleYMargin );
      options.titleNode.top = this.expandCollapseButton.top;
    }
    else { // center
      this.expandCollapseButton.centerY = collapsedBox.centerY;
      options.titleNode.centerY = this.expandCollapseButton.centerY;
    }
    this.expandedPropertyObserver = function( expanded ) {
      expandedBox.visible = expanded;
      collapsedBox.visible = !expanded;
      expandedTitleBar.accessibleHidden = !expanded;
      collapsedTitleBar.accessibleHidden = expanded;
      options.titleNode.visible = ( expanded && options.showTitleWhenExpanded ) || !expanded;
    };
    this.expandedProperty = options.expandedProperty; // @private
    this.expandedProperty.link( this.expandedPropertyObserver ); // must be unlinked in dispose
    this.mutate( _.omit( options, 'cursor' ) );
  }
  sun.register( 'AccordionBox', AccordionBox );
  return inherit( Node, AccordionBox, {
    dispose: function() {
      this.expandCollapseButton.dispose();
      this.expandCollapseButton = null;
      this.expandedProperty.unlink( this.expandedPropertyObserver );
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'SCENERY/display/drawables/CircleStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  var CircleStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyRadius = true;
        this.initializePaintableState( renderer, instance );
        return this; // allow for chaining
      };
      proto.disposeState = function() {
        this.disposePaintableState();
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyRadius = function() {
        this.dirtyRadius = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyRadius = false;
      };
      PaintableStatefulDrawable.mixin( drawableType );
    }
  };
  scenery.register( 'CircleStatefulDrawable', CircleStatefulDrawable );
  return CircleStatefulDrawable;
} );
define( 'SCENERY/display/drawables/CircleDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Matrix3','SCENERY/util/Features','SCENERY/display/DOMSelfDrawable','SCENERY/display/drawables/CircleStatefulDrawable','SCENERY/display/SelfDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Features = require( 'SCENERY/util/Features' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var CircleStatefulDrawable = require( 'SCENERY/display/drawables/CircleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  require( 'SCENERY/util/Util' );
  var keepDOMCircleElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  function CircleDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'CircleDOMDrawable', CircleDOMDrawable );
  inherit( DOMSelfDrawable, CircleDOMDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );
      this.matrix = this.matrix || Matrix3.dirtyFromPool();
      if ( !this.fillElement || !this.strokeElement ) {
        var fillElement = this.fillElement = document.createElement( 'div' );
        var strokeElement = this.strokeElement = document.createElement( 'div' );
        fillElement.style.display = 'block';
        fillElement.style.position = 'absolute';
        fillElement.style.left = '0';
        fillElement.style.top = '0';
        fillElement.style.pointerEvents = 'none';
        strokeElement.style.display = 'block';
        strokeElement.style.position = 'absolute';
        strokeElement.style.left = '0';
        strokeElement.style.top = '0';
        strokeElement.style.pointerEvents = 'none';
        fillElement.appendChild( strokeElement );
      }
      this.domElement = this.fillElement;
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );
      return this; // allow for chaining
    },
    updateDOM: function() {
      var node = this.node;
      var fillElement = this.fillElement;
      var strokeElement = this.strokeElement;
      if ( this.paintDirty ) {
        if ( this.dirtyRadius ) {
          fillElement.style.width = ( 2 * node._radius ) + 'px';
          fillElement.style.height = ( 2 * node._radius ) + 'px';
          fillElement.style[ Features.borderRadius ] = node._radius + 'px';
        }
        if ( this.dirtyFill ) {
          fillElement.style.backgroundColor = node.getCSSFill();
        }
        if ( this.dirtyStroke ) {
          if ( node.hasStroke() ) {
            strokeElement.style.borderStyle = 'solid';
          }
          else {
            strokeElement.style.borderStyle = 'none';
          }
        }
        if ( node.hasStroke() ) {
          var hadNoStrokeBefore = !this.hadStroke;
          if ( hadNoStrokeBefore || this.dirtyLineWidth || this.dirtyRadius ) {
            strokeElement.style.width = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style.height = ( 2 * node._radius - node.getLineWidth() ) + 'px';
            strokeElement.style[ Features.borderRadius ] = ( node._radius + node.getLineWidth() / 2 ) + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyLineWidth ) {
            strokeElement.style.left = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.top = ( -node.getLineWidth() / 2 ) + 'px';
            strokeElement.style.borderWidth = node.getLineWidth() + 'px';
          }
          if ( hadNoStrokeBefore || this.dirtyStroke ) {
            strokeElement.style.borderColor = node.getSimpleCSSStroke();
          }
        }
      }
      if ( this.transformDirty || this.dirtyRadius ) {
        this.matrix.set( this.getTransformMatrix() );
        var translation = Matrix3.translation( -node._radius, -node._radius );
        this.matrix.multiplyMatrix( translation );
        translation.freeToPool();
        scenery.Util.applyPreparedTransform( this.matrix, this.fillElement, this.forceAcceleration );
      }
      this.setToCleanState();
      this.cleanPaintableState();
      this.transformDirty = false;
    },
    dispose: function() {
      this.disposeState();
      if ( !keepDOMCircleElements ) {
        this.fillElement = null;
        this.strokeElement = null;
        this.domElement = null;
      }
      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  CircleStatefulDrawable.mixin( CircleDOMDrawable );
  SelfDrawable.Poolable.mixin( CircleDOMDrawable );
  return CircleDOMDrawable;
} );
define( 'SCENERY/display/drawables/CircleSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/drawables/CircleStatefulDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var CircleStatefulDrawable = require( 'SCENERY/display/drawables/CircleStatefulDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var keepSVGCircleElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  function CircleSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'CircleSVGDrawable', CircleSVGDrawable );
  inherit( SVGSelfDrawable, CircleSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGCircleElements ); // usesPaint: true
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'circle' );
      return this;
    },
    updateSVGSelf: function() {
      var circle = this.svgElement;
      if ( this.dirtyRadius ) {
        circle.setAttribute( 'r', this.node._radius );
      }
      this.updateFillStrokeStyle( circle );
    }
  } );
  CircleStatefulDrawable.mixin( CircleSVGDrawable );
  SelfDrawable.Poolable.mixin( CircleSVGDrawable );
  return CircleSVGDrawable;
} );
define( 'SCENERY/display/drawables/CircleCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function CircleCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'CircleCanvasDrawable', CircleCanvasDrawable );
  inherit( CanvasSelfDrawable, CircleCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },
    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;
      context.beginPath();
      context.arc( 0, 0, node._radius, 0, Math.PI * 2, false );
      context.closePath();
      if ( node.hasFill() ) {
        node.beforeCanvasFill( wrapper ); // defined in Paintable
        context.fill();
        node.afterCanvasFill( wrapper ); // defined in Paintable
      }
      if ( node.hasStroke() ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },
    markDirtyRadius: function() {
      this.markPaintDirty();
    },
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  PaintableStatelessDrawable.mixin( CircleCanvasDrawable );
  SelfDrawable.Poolable.mixin( CircleCanvasDrawable );
  return CircleCanvasDrawable;
} );
define( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','DOT/Bounds2','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/Features','SCENERY/display/Renderer','SCENERY/display/drawables/CircleDOMDrawable','SCENERY/display/drawables/CircleSVGDrawable','SCENERY/display/drawables/CircleCanvasDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Features = require( 'SCENERY/util/Features' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CircleDOMDrawable = require( 'SCENERY/display/drawables/CircleDOMDrawable' );
  var CircleSVGDrawable = require( 'SCENERY/display/drawables/CircleSVGDrawable' );
  var CircleCanvasDrawable = require( 'SCENERY/display/drawables/CircleCanvasDrawable' );
  var CIRCLE_OPTION_KEYS = [
    'radius' // see setRadius() for more documentation
  ];
  function Circle( radius, options ) {
    this._radius = 0;
    if ( typeof radius === 'object' ) {
      options = radius;
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
    }
    else {
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      options = extendDefined( {
        radius: radius
      }, options );
    }
    Path.call( this, null, options );
  }
  scenery.register( 'Circle', Circle );
  inherit( Path, Circle, {
    _mutatorKeys: CIRCLE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'radius' ] ).filter( function( flag ) {
      return flag !== 'shape';
    } ),
    getStrokeRendererBitmask: function() {
      var bitmask = Path.prototype.getStrokeRendererBitmask.call( this );
      if ( this.hasStroke() && !this.getStroke().isGradient && !this.getStroke().isPattern && this.getLineWidth() <= this.getRadius() ) {
        bitmask |= Renderer.bitmaskDOM;
      }
      return bitmask;
    },
    getPathRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | ( Features.borderRadius ? Renderer.bitmaskDOM : 0 );
    },
    invalidateCircle: function() {
      assert && assert( this._radius >= 0, 'A circle needs a non-negative radius' );
      this._shape = null;
      this.invalidatePath();
    },
    createCircleShape: function() {
      return Shape.circle( 0, 0, this._radius ).makeImmutable();
    },
    intersectsBoundsSelf: function( bounds ) {
      var x = Math.abs( bounds.centerX );
      var y = Math.abs( bounds.centerY );
      var halfWidth = bounds.maxX - x;
      var halfHeight = bounds.maxY - y;
      if ( x > halfWidth + this._radius || y > halfHeight + this._radius ) {
        return false;
      }
      if ( x <= halfWidth || y <= halfHeight ) {
        return true;
      }
      x -= halfWidth;
      y -= halfHeight;
      return x * x + y * y <= this._radius * this._radius;
    },
    canvasPaintSelf: function( wrapper ) {
      CircleCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    createDOMDrawable: function( renderer, instance ) {
      return CircleDOMDrawable.createFromPool( renderer, instance );
    },
    createSVGDrawable: function( renderer, instance ) {
      return CircleSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return CircleCanvasDrawable.createFromPool( renderer, instance );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Circle( ' + this._radius + ', {' + propLines + '} )';
    },
    setRadius: function( radius ) {
      assert && assert( typeof radius === 'number', 'Circle.radius must be a number' );
      assert && assert( radius >= 0, 'A circle needs a non-negative radius' );
      assert && assert( isFinite( radius ), 'A circle needs a finite radius' );
      if ( this._radius !== radius ) {
        this._radius = radius;
        this.invalidateCircle();
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyRadius();
        }
      }
      return this;
    },
    set radius( value ) { return this.setRadius( value ); },
    getRadius: function() {
      return this._radius;
    },
    get radius() { return this.getRadius(); },
    computeShapeBounds: function() {
      var bounds = new Bounds2( -this._radius, -this._radius, this._radius, this._radius );
      if ( this._stroke ) {
        bounds = bounds.dilated( this.getLineWidth() / 2 );
      }
      return bounds;
    },
    containsPointSelf: function( point ) {
      var magSq = point.x * point.x + point.y * point.y;
      var result = true;
      var iRadius;
      if ( this._strokePickable ) {
        iRadius = this.getLineWidth() / 2;
        var outerRadius = this._radius + iRadius;
        result = result && magSq <= outerRadius * outerRadius;
      }
      if ( this._fillPickable ) {
        if ( this._strokePickable ) {
          return result;
        }
        else {
          return magSq <= this._radius * this._radius;
        }
      }
      else if ( this._strokePickable ) {
        var innerRadius = this._radius - iRadius;
        return result && magSq >= innerRadius * innerRadius;
      }
      else {
        return false; // neither stroke nor fill is pickable
      }
    },
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Circle to something non-null' );
      }
      else {
        this.invalidatePath();
      }
    },
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createCircleShape();
      }
      return this._shape;
    },
    hasShape: function() {
      return true;
    }
  } );
  return Circle;
} );
define( 'SUN/TRadioButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/events/toEventOnEmit','TANDEM/Tandem'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var Tandem = require( 'TANDEM/Tandem' );
  function TRadioButton( phetioValueType ) {
    var TRadioButtonImpl = function TRadioButtonImpl( radioButton, phetioID ) {
      if ( Tandem.validationEnabled() ) {
        assert && assert( !!phetioValueType, 'phetioValueType must be defined' );
      }
      assertInstanceOf( radioButton, phet.sun.RadioButton );
      TNode.call( this, radioButton, phetioID );
      var emitter = radioButton.radioButtonGroupMemberModel || radioButton; // Handle RadioButtonGroupMemberModel or AquaRadioButton
      toEventOnEmit(
        emitter.startedCallbacksForFiredEmitter,
        emitter.endedCallbacksForFiredEmitter,
        'user',
        phetioID,
        this.constructor,
        'fired',
        function( value ) {
          return { value: phetioValueType.toStateObject( value ) };
        } );
    };
    return phetioInherit( TNode, 'TRadioButton', TRadioButtonImpl, {}, {
      documentation: 'A traditional radio button',
      events: [ 'fired' ]
    } );
  }
  sun.register( 'TRadioButton', TRadioButton );
  return TRadioButton;
} );
define( 'SUN/RadioButton',['require','SCENERY/input/ButtonListener','AXON/Emitter','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','TANDEM/Tandem','SUN/TRadioButton'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TRadioButton = require( 'SUN/TRadioButton' );
  function RadioButton( property, value, selectedNode, deselectedNode, options ) {
    options = _.extend( {
      cursor: 'pointer',
      tandem: Tandem.tandemRequired(),
      enabled: true,
      tagName: 'input',
      inputType: 'radio',
      parentContainerTagName: 'li',
      labelTagName: 'label',
      prependLabels: true
    }, options );
    assert && assert( !options.phetioValueType, 'phetioValueType should be specified in the property, not RadioButton options' );
    var self = this;
    Node.call( this );
    this._enabled = options.enabled; // @private
    this.startedCallbacksForFiredEmitter = new Emitter();
    this.endedCallbacksForFiredEmitter = new Emitter();
    var background = new Rectangle( selectedNode.bounds.union( deselectedNode.bounds ) );
    selectedNode.pickable = deselectedNode.pickable = false; // the background rectangle suffices
    this.addChild( background );
    this.addChild( selectedNode );
    this.addChild( deselectedNode );
    var syncWithModel = function( newValue ) {
      selectedNode.visible = ( newValue === value );
      deselectedNode.visible = !selectedNode.visible;
    };
    property.link( syncWithModel );
    var fire = function() {
      self.startedCallbacksForFiredEmitter.emit1( value );
      property.set( value );
      self.endedCallbacksForFiredEmitter.emit();
    };
    var buttonListener = new ButtonListener( {
      fire: fire
    } );
    this.addInputListener( buttonListener );
    var changeListener = this.addAccessibleInputListener( {
      change: function( ) {
        fire();
      }
    } );
    this.mutate( options );
    if ( property.value === value ) {
      this.setAccessibleAttribute( 'checked', 'checked' );
    }
    var accessibleCheckedListener = function( newValue ) {
      self.accessibleChecked = newValue === value;
    };
    property.link( accessibleCheckedListener );
    this.disposeRadioButton = function() {
      options.tandem.removeInstance( self );
      self.removeInputListener( buttonListener );
      self.removeAccessibleInputListener( changeListener );
      property.unlink( accessibleCheckedListener );
      property.unlink( syncWithModel );
    };
    options.tandem.addInstance( this, TRadioButton( property.phetioValueType ) );
  }
  sun.register( 'RadioButton', RadioButton );
  return inherit( Node, RadioButton, {
    dispose: function() {
      this.disposeRadioButton();
      Node.prototype.dispose.call( this );
    },
    setEnabled: function( enabled ) {
      this._enabled = enabled;
      this.opacity = enabled ? 1 : 0.3;
      this.pickable = enabled; // NOTE: This is a side-effect. If you set pickable independently, it will be changed when you set enabled.
    },
    set enabled( value ) { this.setEnabled( value ); },
    getEnabled: function() {
      return this._enabled;
    },
    get enabled() { return this.getEnabled(); }
  } );
} );
define( 'SUN/TAquaRadioButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TBoolean','SUN/sun','SUN/TRadioButton','TANDEM/Tandem'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var sun = require( 'SUN/sun' );
  var TRadioButton = require( 'SUN/TRadioButton' );
  var Tandem = require( 'TANDEM/Tandem' );
  function TAquaRadioButton( phetioValueType ) {
    var TAquaRadioButtonImpl = function TAquaRadioButtonImpl( radioButton, phetioID ) {
      if ( Tandem.validationEnabled() ) {
        assert && assert( !!phetioValueType, 'phetioValueType must be defined' );
      }
      assertInstanceOf( radioButton, phet.sun.AquaRadioButton );
      TRadioButton( phetioValueType ).call( this, radioButton, phetioID );
    };
    return phetioInherit( TRadioButton( phetioValueType ), 'TAquaRadioButton', TAquaRadioButtonImpl, {
      setCircleButtonVisible: {
        returnType: TVoid,
        parameterTypes: [ TBoolean ],
        implementation: function( visible ) {
          this.instance.setCircleButtonVisible( visible );
        },
        documentation: 'Sets whether the circular part of the radio button will be displayed.'
      }
    }, {
      documentation: 'A radio button which looks like the Mac "Aqua" radio buttons',
      events: TRadioButton( phetioValueType ).events
    } );
  }
  sun.register( 'TAquaRadioButton', TAquaRadioButton );
  return TAquaRadioButton;
} );
define( 'SUN/AquaRadioButton',['require','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/nodes/Node','SUN/RadioButton','SUN/sun','TANDEM/Tandem','SUN/TAquaRadioButton'],function( require ) {
  'use strict';
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var RadioButton = require( 'SUN/RadioButton' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TAquaRadioButton = require( 'SUN/TAquaRadioButton' );
  function AquaRadioButton( property, value, node, options ) {
    options = _.extend( {
      cursor: 'pointer',
      selectedColor: 'rgb( 143, 197, 250 )', // color used to fill the button when it's selected
      deselectedColor: 'white', // color used to fill the button when it's deselected
      centerColor: 'black', // color used to fill the center of teh button when it's selected
      radius: 16, // radius of the button
      xSpacing: 8, // horizontal space between the button and the node
      stroke: 'black', // color used to stroke the outer edge of the button
      tandem: Tandem.tandemRequired()
    }, options );
    var selectedNode = new Node();
    var innerCircle = new Circle( options.radius / 3, { fill: options.centerColor } );
    var outerCircleSelected = new Circle( options.radius, { fill: options.selectedColor, stroke: options.stroke } );
    this.selectedCircleButton = new Node( {
      children: [ outerCircleSelected, innerCircle ]
    } );
    selectedNode.addChild( this.selectedCircleButton );
    selectedNode.addChild( node );
    node.left = outerCircleSelected.right + options.xSpacing;
    node.centerY = outerCircleSelected.centerY;
    var deselectedNode = new Node();
    this.deselectedCircleButton = new Circle( options.radius, {
      fill: options.deselectedColor,
      stroke: options.stroke
    } );
    deselectedNode.addChild( this.deselectedCircleButton );
    deselectedNode.addChild( node );
    node.left = this.deselectedCircleButton.right + options.xSpacing;
    node.centerY = this.deselectedCircleButton.centerY;
    RadioButton.call( this, property, value, selectedNode, deselectedNode, _.extend( {}, options, {
      tandem: options.tandem.createSupertypeTandem()
    } ) );
    options.tandem.addInstance( this, TAquaRadioButton( property.phetioValueType ) );
  }
  sun.register( 'AquaRadioButton', AquaRadioButton );
  return inherit( RadioButton, AquaRadioButton, {
    setCircleButtonVisible: function( circleButtonVisible ) {
      this.deselectedCircleButton.visible = circleButtonVisible;
      this.selectedCircleButton.visible = circleButtonVisible;
    }
  } );
} );
define( 'SCENERY/display/SVGGradientStop',['require','SCENERY/util/Color','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Property','SCENERY/scenery'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Property = require( 'AXON/Property' );
  var scenery = require( 'SCENERY/scenery' );
  var scratchColor = new Color( 'transparent' );
  function SVGGradientStop( svgGradient, ratio, color ) {
    this.initialize( svgGradient, ratio, color );
  }
  scenery.register( 'SVGGradientStop', SVGGradientStop );
  inherit( Object, SVGGradientStop, {
    initialize: function( svgGradient, ratio, color ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] initialize: ' + svgGradient.gradient.id + ' : ' + ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      this.svgGradient = svgGradient;
      this.color = color;
      this.ratio = ratio;
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'stop' );
      this.svgElement.setAttribute( 'offset', ratio );
      this.dirty = true; // true here so our update() actually properly initializes
      this.update();
      this.propertyListener = this.propertyListener || this.onPropertyChange.bind( this );
      this.colorListener = this.colorListener || this.markDirty.bind( this );
      if ( color instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Property listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.lazyLink( this.propertyListener );
        if ( color.value instanceof Color ) {
          sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
          color.value.addChangeListener( this.colorListener );
        }
      }
      else if ( color instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.addChangeListener( this.colorListener );
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      return this;
    },
    onPropertyChange: function( newValue, oldValue ) {
      if ( oldValue instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        oldValue.removeChangeListener( this.colorListener );
      }
      if ( newValue instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] adding Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        newValue.addChangeListener( this.colorListener );
      }
      this.markDirty();
    },
    markDirty: function() {
      this.dirty = true;
      this.svgGradient.markDirty();
    },
    update: function() {
      if ( !this.dirty ) {
        return;
      }
      this.dirty = false;
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] update: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      var color = this.color;
      if ( color instanceof Property ) {
        color = color.value;
      }
      if ( color === null ) {
        color = 'transparent';
      }
      if ( typeof color === 'string' ) {
        scratchColor.setCSS( color );
      }
      else {
        scratchColor.set( color );
      }
      var stopOpacityRule = 'stop-opacity: ' + scratchColor.a.toFixed( 20 ) + ';';
      scratchColor.alpha = 1;
      var stopColorRule = 'stop-color: ' + scratchColor.toCSS() + ';';
      this.svgElement.setAttribute( 'style', stopColorRule + ' ' + stopOpacityRule );
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    dispose: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] dispose: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      var color = this.color;
      if ( color instanceof Property ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Property listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.unlink( this.propertyListener );
        if ( color.value instanceof Color ) {
          sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
          color.value.removeChangeListener( this.colorListener );
        }
      }
      else if ( color instanceof Color ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradientStop] removing Color listener: ' + this.svgGradient.gradient.id + ' : ' + this.ratio );
        color.removeChangeListener( this.colorListener );
      }
      this.color = null; // clear the reference
      this.svgGradient = null; // clear the reference
      this.freeToPool();
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );
  Poolable.mixin( SVGGradientStop, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgGradient, ratio, color ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgGradient, ratio, color );
        }
        else {
          return new SVGGradientStop( svgGradient, ratio, color );
        }
      };
    }
  } );
  return SVGGradientStop;
} );
define( 'SCENERY/display/SVGGradient',['require','PHET_CORE/cleanArray','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGGradientStop'],function( require ) {
  'use strict';
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradientStop = require( 'SCENERY/display/SVGGradientStop' );
  function SVGGradient( svgBlock, gradient ) {
    this.initialize( svgBlock, gradient );
  }
  scenery.register( 'SVGGradient', SVGGradient );
  inherit( Object, SVGGradient, {
    initialize: function( svgBlock, gradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] initialize ' + gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      this.svgBlock = svgBlock;
      this.gradient = gradient;
      var hasPreviousDefinition = this.definition !== undefined;
      this.definition = this.definition || this.createDefinition();
      if ( !hasPreviousDefinition ) {
        this.definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' );
      }
      if ( gradient.transformMatrix ) {
        this.definition.setAttribute( 'gradientTransform', gradient.transformMatrix.getSVGTransform() );
      }
      else {
        this.definition.removeAttribute( 'gradientTransform' );
      }
      var gradientStops = gradient.getSVGStops();
      this.stops = cleanArray( this.stops );
      for ( var i = 0; i < gradientStops.length; i++ ) {
        var stop = new SVGGradientStop( this, gradientStops[ i ].ratio, gradientStops[ i ].color );
        this.stops.push( stop );
        this.definition.appendChild( stop.svgElement );
      }
      this.dirty = false;
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    createDefinition: function() {
      throw new Error( 'abstract method' );
    },
    markDirty: function() {
      if ( !this.dirty ) {
        sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] switched to dirty: ' + this.gradient.id );
        sceneryLog && sceneryLog.Paints && sceneryLog.push();
        this.dirty = true;
        this.svgBlock.markDirtyGradient( this );
        sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      }
    },
    update: function() {
      if ( !this.dirty ) {
        return;
      }
      this.dirty = false;
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] update: ' + this.gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      for ( var i = 0; i < this.stops.length; i++ ) {
        this.stops[ i ].update();
      }
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    },
    dispose: function() {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGGradient] dispose ' + this.gradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      for ( var i = 0; i < this.stops.length; i++ ) {
        var stop = this.stops[ i ]; // SVGGradientStop
        this.definition.removeChild( stop.svgElement );
        stop.dispose();
      }
      cleanArray( this.stops );
      this.svgBlock = null;
      this.gradient = null;
      this.freeToPool();
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
    }
  } );
  return SVGGradient;
} );
define( 'SCENERY/display/SVGRadialGradient',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/SVGGradient'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradient = require( 'SCENERY/display/SVGGradient' );
  function SVGRadialGradient( svgBlock, radialGradient ) {
    this.initialize( svgBlock, radialGradient );
  }
  scenery.register( 'SVGRadialGradient', SVGRadialGradient );
  inherit( SVGGradient, SVGRadialGradient, {
    initialize: function( svgBlock, radialGradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGRadialGradient] initialize ' + radialGradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      SVGGradient.prototype.initialize.call( this, svgBlock, radialGradient );
      this.definition.setAttribute( 'cx', radialGradient.largePoint.x );
      this.definition.setAttribute( 'cy', radialGradient.largePoint.y );
      this.definition.setAttribute( 'r', radialGradient.maxRadius );
      this.definition.setAttribute( 'fx', radialGradient.focalPoint.x );
      this.definition.setAttribute( 'fy', radialGradient.focalPoint.y );
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      return this;
    },
    createDefinition: function() {
      return document.createElementNS( scenery.svgns, 'radialGradient' );
    }
  } );
  Poolable.mixin( SVGRadialGradient, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgBlock, radialGradient ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgBlock, radialGradient );
        }
        else {
          return new SVGRadialGradient( svgBlock, radialGradient );
        }
      };
    }
  } );
  return SVGRadialGradient;
} );
define( 'SCENERY/util/RadialGradient',['require','SCENERY/util/Gradient','PHET_CORE/inherit','PHET_CORE/platform','SCENERY/scenery','SCENERY/display/SVGRadialGradient','DOT/Vector2'],function( require ) {
  'use strict';
  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGRadialGradient = require( 'SCENERY/display/SVGRadialGradient' );
  var Vector2 = require( 'DOT/Vector2' );
  function RadialGradient( x0, y0, r0, x1, y1, r1 ) {
    this.start = new Vector2( x0, y0 );
    this.end = new Vector2( x1, y1 );
    if ( platform.safari ) {
      var x = ( x0 + x1 ) / 2;
      var y = ( y0 + y1 ) / 2;
      this.start.x = x;
      this.start.y = y;
      this.end.x = x;
      this.end.y = y;
    }
    this.startRadius = r0;
    this.endRadius = r1;
    this.focalPoint = this.start.plus( this.end.minus( this.start ).times( this.startRadius / ( this.startRadius - this.endRadius ) ) );
    this.startIsLarger = this.startRadius > this.endRadius;
    this.largePoint = this.startIsLarger ? this.start : this.end;
    this.maxRadius = Math.max( this.startRadius, this.endRadius );
    this.minRadius = Math.min( this.startRadius, this.endRadius );
    if ( this.startRadius >= this.endRadius ) {
      assert && assert( this.focalPoint.minus( this.start ).magnitude() <= this.startRadius );
    }
    else {
      assert && assert( this.focalPoint.minus( this.end ).magnitude() <= this.endRadius );
    }
    Gradient.call( this );
  }
  scenery.register( 'RadialGradient', RadialGradient );
  inherit( Gradient, RadialGradient, {
    isRadialGradient: true,
    createCanvasGradient: function() {
      return scenery.scratchContext.createRadialGradient( this.start.x, this.start.y, this.startRadius, this.end.x, this.end.y, this.endRadius );
    },
    createSVGPaint: function( svgBlock ) {
      return SVGRadialGradient.createFromPool( svgBlock, this );
    },
    getSVGStops: function() {
      var startIsLarger = this.startIsLarger;
      var maxRadius = this.maxRadius;
      var minRadius = this.minRadius;
      function linearMap( a0, b0, a1, b1, x ) {
        return a1 + ( x - a0 ) * ( b1 - a1 ) / ( b0 - a0 );
      }
      function mapStop( stop ) {
        var ratio = startIsLarger ? 1 - stop.ratio : stop.ratio;
        if ( minRadius > 0 ) {
          ratio = linearMap( 0, 1, minRadius / maxRadius, 1, ratio );
        }
        return {
          ratio: ratio,
          color: stop.color
        };
      }
      var stops = this.stops.map( mapStop );
      if ( startIsLarger ) {
        stops.reverse();
      }
      return stops;
    },
    toString: function() {
      var result = 'new scenery.RadialGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.startRadius + ', ' + this.end.x + ', ' + this.end.y + ', ' + this.endRadius + ' )';
      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + stop.color.toString() + '\' )';
      } );
      return result;
    }
  } );
  return RadialGradient;
} );
define( 'SCENERY_PHET/sceneryPhet',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'sceneryPhet' );
} );
define( 'SCENERY_PHET/PhetFont',['require','SCENERY/util/Font','PHET_CORE/inherit','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY/util/TFont'],function( require ) {
  'use strict';
  var Font = require( 'SCENERY/util/Font' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TFont = require( 'SCENERY/util/TFont' ); // TODO: we should have TPhetFont
  function PhetFont( options ) {
    if ( typeof options === 'number' || typeof options === 'string' ) {
      options = { size: options };
    }
    assert && assert( arguments.length === 0 || arguments.length === 1, 'Too many arguments' );
    options = _.extend( {
      family: 'Arial',
      tandem: Tandem.tandemOptional()
    }, options );
    assert && assert( options.family );
    options.family = options.family + ', sans-serif';
    Font.call( this, options );
    options.tandem.addInstance( this, TFont );
  }
  sceneryPhet.register( 'PhetFont', PhetFont );
  return inherit( Font, PhetFont );
} );
define( 'SCENERY_PHET/PhetColorScheme',['require','SCENERY/util/Color','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var DARK_GREEN = new Color( 0, 200, 0 );
  var RED_COLORBLIND = new Color( 255, 85, 0 ); // looks good in colorblind tests, typically used in place of 'red'
  var GREEN_COLORBLIND = new Color( 0, 135, 0 ); // looks good in colorblind tests when used alongside RED_COLORBLIND
  var TAN_ORANGE = new Color( 236, 153, 55 );
  var PHET_LOGO_BLUE = new Color( 106, 206, 245 ); // the color of the blue in the PhET logo
  var PHET_LOGO_YELLOW = new Color( 254, 225, 5 ); // the color of the yellow in the PhET logo
  var PhetColorScheme = {
    ACCELERATION: Color.GREEN,
    APPLIED_FORCE: TAN_ORANGE,
    ELASTIC_ENERGY: new Color( 153, 51, 102 ),
    FRICTION_FORCE: RED_COLORBLIND,
    GRAVITATIONAL_FORCE: new Color( 50, 130, 215 ),
    HEAT_THERMAL_ENERGY: RED_COLORBLIND,
    IMAGINARY_PART: new Color( 153, 51, 102 ),
    KINETIC_ENERGY: Color.GREEN,
    NET_WORK: DARK_GREEN,
    NORMAL_FORCE: new Color( 255, 235, 0 ),
    PHET_LOGO_BLUE: PHET_LOGO_BLUE,
    PHET_LOGO_YELLOW: PHET_LOGO_YELLOW,
    POSITION: Color.BLUE,
    POTENTIAL_ENERGY: Color.BLUE,
    REAL_PART: new Color( 255, 153, 0 ),
    RED_COLORBLIND: RED_COLORBLIND,
    RESET_ALL_BUTTON_BASE_COLOR: new Color( 247, 151, 34 ),
    GREEN_COLORBLIND: GREEN_COLORBLIND,
    TOTAL_ENERGY: TAN_ORANGE,
    TOTAL_FORCE: DARK_GREEN,
    VELOCITY: RED_COLORBLIND,
    WALL_FORCE: new Color( 153, 51, 0 )
  };
  sceneryPhet.register( 'PhetColorScheme', PhetColorScheme );
  return PhetColorScheme;
} );
define( 'SHRED/ShredConstants',['require','DOT/Bounds2','SHRED/shred','SCENERY_PHET/PhetFont','SCENERY_PHET/PhetColorScheme'],function( require ) {
  'use strict';
  var Bounds2 = require( 'DOT/Bounds2' );
  var shred = require( 'SHRED/shred' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var ShredConstants = {
    LAYOUT_BOUNDS: new Bounds2( 0, 0, 768, 464 ),
    NUCLEON_RADIUS: 10, // In screen coordinates, which are roughly pixels.
    ELECTRON_RADIUS: 8, // In screen coordinates, which are roughly pixels.
    MAX_ELECTRONS: 10,
    DISPLAY_PANEL_BACKGROUND_COLOR: 'rgb( 254, 255, 153 )',
    ACCORDION_BOX_TITLE_FONT: new PhetFont( 16 ),
    ACCORDION_BOX_TITLE_MAX_WIDTH: 225, // empirically determined
    MAX_PROBLEM_ATTEMPTS: 2,
    CHARGE_TEXT_COLOR: function( charge ) {
      return charge > 0 ? PhetColorScheme.RED_COLORBLIND : charge < 0 ? 'blue' : 'black';
    },
    LEVEL_NAMES: [ 'periodic-table-game', 'mass-and-charge-game', 'symbol-game', 'advanced-symbol-game' ],
    MAP_LEVEL_NAME_TO_NUMBER: function( levelName ) { return this.LEVEL_NAMES.indexOf( levelName ); }
  };
  shred.register( 'ShredConstants', ShredConstants);
  return ShredConstants;
} );
define( 'SCENERY/input/SimpleDragHandler',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  function SimpleDragHandler( options ) {
    var self = this;
    options = _.extend( {
      allowTouchSnag: false,
      mouseButton: 0,
      dragCursor: 'pointer'
    }, options );
    this.options = options; // @private
    this.dragging = false;            // whether a node is being dragged with this handler
    this.pointer = null;              // the pointer doing the current dragging
    this.trail = null;                // stores the path to the node that is being dragged
    this.transform = null;            // transform of the trail to our node (but not including our node, so we can prepend the deltas)
    this.node = null;                 // the node that we are handling the drag for
    this.lastDragPoint = null;        // the location of the drag at the previous event (so we can calculate a delta)
    this.startTransformMatrix = null; // the node's transform at the start of the drag, so we can reset on a touch cancel
    this.mouseButton = undefined;     // tracks which mouse button was pressed, so we can handle that specifically
    this.interrupted = false;         // whether the last input was interrupted (available during endDrag)
    this.transformListener = {
      transform: function( args ) {
        if ( !self.trail.isExtensionOf( args.trail, true ) ) {
          return;
        }
        var newMatrix = args.trail.getMatrix();
        var oldMatrix = self.transform.getMatrix();
        self.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );
        self.transform.setMatrix( newMatrix );
      }
    };
    this.dragListener = {
      up: function( event ) {
        if ( !self.dragging ) { return; }
        assert && assert( event.pointer === self.pointer, 'Wrong pointer in up' );
        if ( !event.pointer.isMouse || event.domEvent.button === self.mouseButton ) {
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          self.endDrag( event );
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      },
      cancel: function( event ) {
        if ( !self.dragging ) { return; }
        assert && assert( event.pointer === self.pointer, 'Wrong pointer in cancel' );
        var saveCurrentTarget = event.currentTarget;
        event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
        self.endDrag( event );
        event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        if ( !self.transform ) {
          self.node.setMatrix( self.startTransformMatrix );
        }
      },
      move: function( event ) {
        if ( !self.dragging ) { return; }
        assert && assert( event.pointer === self.pointer, 'Wrong pointer in move' );
        var globalDelta = self.pointer.point.minus( self.lastDragPoint );
        if ( globalDelta.magnitudeSquared() === 0 ) {
          return;
        }
        var delta = self.transform.inverseDelta2( globalDelta );
        if ( self.options.translate ) {
          var translation = self.node.getMatrix().getTranslation();
          self.options.translate.call( null, {
            delta: delta,
            oldPosition: translation,
            position: translation.plus( delta )
          } );
        }
        self.lastDragPoint = self.pointer.point;
        if ( self.options.drag ) {
          var saveCurrentTarget = event.currentTarget;
          event.currentTarget = self.node; // #66: currentTarget on a pointer is null, so set it to the node we're dragging
          self.options.drag.call( null, event, self.trail ); // new position (old position?) delta
          event.currentTarget = saveCurrentTarget; // be polite to other listeners, restore currentTarget
        }
      },
      interrupt: () => {
        self.interrupt();
      }
    };
  }
  scenery.register( 'SimpleDragHandler', SimpleDragHandler );
  return inherit( Object, SimpleDragHandler, {
    startDrag: function( event ) {
      if ( this.dragging ) { return; }
      event.pointer.dragging = true;
      event.pointer.cursor = this.options.dragCursor;
      event.pointer.addInputListener( this.dragListener );
      this.dragging = true;
      this.pointer = event.pointer;
      this.trail = event.trail.subtrailTo( event.currentTarget, true );
      this.transform = this.trail.getTransform();
      this.node = event.currentTarget;
      this.lastDragPoint = event.pointer.point;
      this.startTransformMatrix = event.currentTarget.getMatrix().copy();
      this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;
      if ( this.options.start ) {
        this.options.start.call( null, event, this.trail );
      }
    },
    endDrag: function( event ) {
      if ( !this.dragging ) { return; }
      this.pointer.dragging = false;
      this.pointer.cursor = null;
      this.pointer.removeInputListener( this.dragListener );
      this.dragging = false;
      if ( this.options.end ) {
        this.options.end.call( null, event, this.trail );
      }
      this.pointer = null;
    },
    interrupt: function() {
      if ( this.dragging ) {
        this.interrupted = true;
        this.endDrag( {
          pointer: this.pointer,
          currentTarget: this.node
        } );
        this.interrupted = false;
      }
    },
    tryToSnag: function( event ) {
      if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {
        return;
      }
      if ( !this.dragging && !event.pointer.dragging ) {
        this.startDrag( event );
      }
    },
    tryTouchToSnag: function( event ) {
      if ( this.options.allowTouchSnag && ( this.options.allowTouchSnag === true || this.options.allowTouchSnag( event ) ) ) {
        this.tryToSnag( event );
      }
    },
    down: function( event ) {
      this.tryToSnag( event );
    },
    touchenter: function( event ) {
      this.tryTouchToSnag( event );
    },
    touchmove: function( event ) {
      this.tryTouchToSnag( event );
    },
    dispose: function() {
      if ( this.dragging ) {
        this.pointer.dragging = false;
        this.pointer.cursor = null;
        this.pointer.removeInputListener( this.dragListener );
      }
    }
  }, {
    createForwardingListener: function( inputListener, options ) {
      options = _.extend( {
        allowTouchSnag: false
      }, options );
      return {
        down: function( event ) {
          if ( !event.pointer.dragging && event.canStartPress() ) {
            inputListener.down( event );
          }
        },
        touchenter: function( event ) {
          options.allowTouchSnag && this.down( event );
        },
        touchmove: function( event ) {
          options.allowTouchSnag && this.down( event );
        }
      };
    }
  } );
} );
define( 'TANDEM/scenery/input/TTandemSimpleDragHandler',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','TANDEM/tandemNamespace','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TTandemSimpleDragHandler( tandemSimpleDragHandler, phetioID ) {
    TObject.call( this, tandemSimpleDragHandler, phetioID );
    assertInstanceOf( tandemSimpleDragHandler, phet.tandem.TandemSimpleDragHandler );
    var toXY = function( x, y ) { return { x: x, y: y }; };
    toEventOnEmit( tandemSimpleDragHandler.startedCallbacksForDragStartedEmitter, tandemSimpleDragHandler.endedCallbacksForDragStartedEmitter, 'user', phetioID, this.constructor, 'dragStarted', toXY );
    toEventOnEmit( tandemSimpleDragHandler.startedCallbacksForDraggedEmitter, tandemSimpleDragHandler.endedCallbacksForDraggedEmitter, 'user', phetioID, this.constructor, 'dragged', toXY );
    toEventOnEmit( tandemSimpleDragHandler.startedCallbacksForDragEndedEmitter, tandemSimpleDragHandler.endedCallbacksForDragEndedEmitter, 'user', phetioID, this.constructor, 'dragEnded' );
  }
  phetioInherit( TObject, 'TTandemSimpleDragHandler', TTandemSimpleDragHandler, {}, {
    documentation: 'Drag listener for objects that can be dragged by the user.',
    events: [ 'dragStarted', 'dragged', 'dragEnded' ]
  } );
  tandemNamespace.register( 'TTandemSimpleDragHandler', TTandemSimpleDragHandler );
  return TTandemSimpleDragHandler;
} );
define( 'TANDEM/scenery/input/TandemSimpleDragHandler',['require','AXON/Emitter','PHET_CORE/inherit','SCENERY/input/SimpleDragHandler','TANDEM/tandemNamespace','TANDEM/Tandem','TANDEM/scenery/input/TTandemSimpleDragHandler'],function( require ) {
  'use strict';
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TTandemSimpleDragHandler = require( 'TANDEM/scenery/input/TTandemSimpleDragHandler' );
  function TandemSimpleDragHandler( options ) {
    var self = this;
    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    this.startedCallbacksForDragStartedEmitter = new Emitter(); // @public (phet-io)
    this.endedCallbacksForDragStartedEmitter = new Emitter(); // @public (phet-io)
    this.startedCallbacksForDraggedEmitter = new Emitter(); // @public (phet-io)
    this.endedCallbacksForDraggedEmitter = new Emitter(); // @public (phet-io)
    this.startedCallbacksForDragEndedEmitter = new Emitter(); // @public (phet-io)
    this.endedCallbacksForDragEndedEmitter = new Emitter(); // @public (phet-io)
    var optionsCopy = _.clone( options );
    if ( window.phet && phet.phetio ) {
      optionsCopy.start = function( event, trail ) {
        self.startedCallbacksForDragStartedEmitter.emit2( event.pointer.point.x, event.pointer.point.y );
        options.start && options.start( event, trail );
        self.endedCallbacksForDragStartedEmitter.emit();
      };
      optionsCopy.drag = function( event, trail ) {
        self.startedCallbacksForDraggedEmitter.emit2( event.pointer.point.x, event.pointer.point.y );
        options.drag && options.drag( event, trail );
        self.endedCallbacksForDraggedEmitter.emit();
      };
      optionsCopy.end = function( event, trail ) {
        self.startedCallbacksForDragEndedEmitter.emit();
        options.end && options.end( event, trail );
        self.endedCallbacksForDragEndedEmitter.emit();
      };
    }
    SimpleDragHandler.call( this, optionsCopy );
    options.tandem && options.tandem.addInstance( this, TTandemSimpleDragHandler );
    this.disposeTandemSimpleDragHandler = function() {
      if ( window.phet && phet.phetio ) {
        options.tandem && options.tandem.removeInstance( self );
      }
    };
  }
  tandemNamespace.register( 'TandemSimpleDragHandler', TandemSimpleDragHandler );
  return inherit( SimpleDragHandler, TandemSimpleDragHandler, {
    dispose: function() {
      this.disposeTandemSimpleDragHandler();
      SimpleDragHandler.prototype.dispose.call( this );
    }
  } );
} );
define( 'SHRED/view/ElectronCloudView',['require','PHET_CORE/inherit','SCENERY/util/RadialGradient','SHRED/ShredConstants','SHRED/shred','TANDEM/Tandem','SCENERY/nodes/Circle','TANDEM/scenery/input/TandemSimpleDragHandler'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var TandemSimpleDragHandler = require( 'TANDEM/scenery/input/TandemSimpleDragHandler' );
  function ElectronCloudView( atom, modelViewTransform, options ) {
    var self = this;
    options = _.extend( { tandem: Tandem.tandemRequired() }, options );
    Circle.call( this, {
        cursor: 'pointer',
        fill: 'pink',
        translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } )
      }
    );
    var update = function( numElectrons ) {
      if ( numElectrons === 0 ) {
        self.radius = 1E-5; // Arbitrary non-zero value.
        self.fill = 'transparent';
      }
      else {
        var minRadius = modelViewTransform.modelToViewDeltaX( atom.innerElectronShellRadius ) * 0.5;
        var maxRadius = modelViewTransform.modelToViewDeltaX( atom.outerElectronShellRadius );
        var radius = minRadius + ( ( maxRadius - minRadius ) / ShredConstants.MAX_ELECTRONS ) * numElectrons;
        self.radius = radius;
        self.fill = new RadialGradient( 0, 0, 0, 0, 0, radius )
          .addColorStop( 0, 'rgba( 0, 0, 255, 200 )' )
          .addColorStop( 0.9, 'rgba( 0, 0, 255, 0 )' );
      }
    };
    update( atom.electrons.length );
    atom.electrons.lengthProperty.link( update );
    this.extractedElectron = null; // @private
    this.addInputListener( new TandemSimpleDragHandler( {
      activeParticle: null,
      start: function( event, trail ) {
        var positionInModelSpace = modelViewTransform.viewToModelPosition(
          self.getParents()[ 0 ].globalToLocalPoint( event.pointer.point )
        );
        var electron = atom.extractParticle( 'electron' );
        if ( electron !== null ) {
          electron.userControlledProperty.set( true );
          electron.setPositionAndDestination( positionInModelSpace );
          self.extractedElectron = electron;
        }
      },
      translate: function( translationParams ) {
        if ( self.extractedElectron !== null ) {
          self.extractedElectron.setPositionAndDestination(
            self.extractedElectron.positionProperty.get().plus(
              modelViewTransform.viewToModelDelta( translationParams.delta ) ) );
        }
      },
      end: function( event ) {
        if ( self.extractedElectron !== null ) {
          self.extractedElectron.userControlledProperty.set( false );
        }
      },
      tandem: options.tandem.createTandem( 'dragHandler' )
    } ) );
    this.disposeElectronCloudView = function() {
      atom.electrons.lengthProperty.unlink( update );
      options.tandem && options.tandem.removeInstance( self );
    };
    this.mutate( options );
  }
  shred.register( 'ElectronCloudView', ElectronCloudView );
  return inherit( Circle, ElectronCloudView, {
    dispose: function() {
      this.disposeElectronCloudView();
      Circle.prototype.dispose.call( this );
    }
  } );
} );
define( 'SHRED/view/ElectronShellView',['require','PHET_CORE/inherit','SHRED/shred','TANDEM/Tandem','SCENERY/nodes/Circle','SCENERY/nodes/Node','AXON/Property','SCENERY/input/Input'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var Input = require( 'SCENERY/input/Input' );
  var LINE_DASH = [ 4, 5 ];
  function ElectronShellView( atom, modelViewTransform, options ) {
    var self = this;
    options = _.extend( {
        tandem: Tandem.tandemRequired()
      },
      options
    );
    Node.call( this, {
      pickable: false,
      tandem: options.tandem,
      tagName: 'div',
      ariaRole: 'listbox',
      focusable: true
    } );
    var outerRing = new Circle( modelViewTransform.modelToViewDeltaX( atom.outerElectronShellRadius ), {
      stroke: 'blue',
      lineWidth: 1.5,
      lineDash: LINE_DASH,
      translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } ),
      pickable: false,
      tandem: options.tandem.createTandem( 'outerRing' ),
      tagName: 'div',
      ariaRole: 'option',
      accessibleLabel: 'Outer Electron Ring'
    } );
    var innerRing = new Circle( modelViewTransform.modelToViewDeltaX( atom.innerElectronShellRadius ), {
      stroke: 'blue',
      lineWidth: 1.5,
      lineDash: LINE_DASH,
      translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } ),
      pickable: false,
      tandem: options.tandem.createTandem( 'innerRing' ),
      tagName: 'div',
      ariaRole: 'option',
      accessibleLabel: 'Inner Electron Ring'
    } );
    var centerOption = new Node( {
      tagName: 'div',
      ariaRole: 'option',
      accessibleLabel: 'Nucleus'
    } );
    var nucleusFocusHighlight = new Circle( atom.nucleusRadius, {
      lineWidth: 2,
      stroke: 'red',
      translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } )
    } );
    var electronOuterFocusHighlight = new Circle( atom.outerElectronShellRadius, {
      lineWidth: 2,
      stroke: 'red',
      translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } )
    } );
    var electronInnerFocusHighlight = new Circle( atom.innerElectronShellRadius, {
      lineWidth: 2,
      stroke: 'red',
      translation: modelViewTransform.modelToViewPosition( { x: 0, y: 0 } )
    } );
    var selectValueProperty = new Property( 'none' );
    selectValueProperty.lazyLink( function( newValue ) {
      switch( newValue ) {
        case ( centerOption.accessibleId ):
          self.setFocusHighlight( electronOuterFocusHighlight );
          break;
        case ( innerRing.accessibleId ):
          self.setFocusHighlight( electronInnerFocusHighlight );
          break;
        case ( outerRing.accessibleId ):
          self.setFocusHighlight( nucleusFocusHighlight );
          break;
        default:
          throw new Error( 'You tried to set the selectValueProperty to an unsupported value.' );
      }
    } );
    var optionNodes = [ centerOption, innerRing, outerRing ];
    var currentIndex = 0;
    this.addAccessibleInputListener( {
      keydown: function( event ) {
        if ( event.keyCode === Input.KEY_DOWN_ARROW || event.keyCode === Input.KEY_RIGHT_ARROW ) {
          currentIndex = ( currentIndex + 1 ) % optionNodes.length;
        }
        else if ( event.keyCode === Input.KEY_UP_ARROW || event.keyCode === Input.KEY_LEFT_ARROW ) {
          currentIndex = currentIndex - 1;
          if ( currentIndex < 0 ) { currentIndex = optionNodes.length - 1; }
        }
        var nextElementId = optionNodes[ currentIndex ].accessibleId;
        self.setAccessibleAttribute( 'aria-activedescendant', nextElementId );
        selectValueProperty.set( nextElementId );
      }
    } );
    optionNodes.forEach( function( node ) { self.addChild( node ); } );
    Property.multilink( [ atom.protonCountProperty, atom.neutronCountProperty ], function( protonCount, neutronCount ) {
      atom.reconfigureNucleus();
      var radiusOffset = atom.nucleusRadius === 0 ? 0 : 4;
      nucleusFocusHighlight.radius = atom.nucleusRadius + radiusOffset;
    } );
  }
  shred.register( 'ElectronShellView', ElectronShellView );
  return inherit( Node, ElectronShellView );
} );
define("string!SHRED/minusSignIon",function(){return window.phet.chipper.strings.get("SHRED/minusSignIon");});
define("string!SHRED/neutralAtom",function(){return window.phet.chipper.strings.get("SHRED/neutralAtom");});
define("string!SHRED/positiveSignIon",function(){return window.phet.chipper.strings.get("SHRED/positiveSignIon");});
define("string!SHRED/stable",function(){return window.phet.chipper.strings.get("SHRED/stable");});
define("string!SHRED/unstable",function(){return window.phet.chipper.strings.get("SHRED/unstable");});
define( 'SHRED/view/AtomNode',['require','SHRED/AtomIdentifier','SHRED/view/ElectronCloudView','SHRED/view/ElectronShellView','PHET_CORE/inherit','SCENERY_PHET/PhetColorScheme','SCENERY_PHET/PhetFont','AXON/Property','KITE/Shape','SHRED/shred','TANDEM/Tandem','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Text','DOT/Vector2','string!SHRED/minusSignIon','string!SHRED/neutralAtom','string!SHRED/positiveSignIon','string!SHRED/stable','string!SHRED/unstable'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var ElectronCloudView = require( 'SHRED/view/ElectronCloudView' );
  var ElectronShellView = require( 'SHRED/view/ElectronShellView' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var minusSignIonString = require( 'string!SHRED/minusSignIon' );
  var neutralAtomString = require( 'string!SHRED/neutralAtom' );
  var positiveSignIonString = require( 'string!SHRED/positiveSignIon' );
  var stableString = require( 'string!SHRED/stable' );
  var unstableString = require( 'string!SHRED/unstable' );
  var ELEMENT_NAME_FONT_SIZE = 22;
  function AtomNode( particleAtom, modelViewTransform, options ) {
    options = _.extend( {
        showCenterX: true,
        showElementNameProperty: new Property( true ),
        showNeutralOrIonProperty: new Property( true ),
        showStableOrUnstableProperty: new Property( true ),
        electronShellDepictionProperty: new Property( 'orbits' ),
        tandem: Tandem.tandemRequired()
      },
      options
    );
    Node.call( this ); // Call super constructor.
    var self = this;
    this.atom = particleAtom;
    this.modelViewTransform = modelViewTransform;
    if ( options.showCenterX ) {
      var sizeInPixels = modelViewTransform.modelToViewDeltaX( 20 );
      var center = modelViewTransform.modelToViewPosition( particleAtom.positionProperty.get() );
      var centerMarker = new Shape();
      centerMarker.moveTo( center.x - sizeInPixels / 2, center.y - sizeInPixels / 2 );
      centerMarker.lineTo( center.x + sizeInPixels / 2, center.y + sizeInPixels / 2 );
      centerMarker.moveTo( center.x - sizeInPixels / 2, center.y + sizeInPixels / 2 );
      centerMarker.lineTo( center.x + sizeInPixels / 2, center.y - sizeInPixels / 2 );
      var atomCenterMarker = new Path( centerMarker, {
        stroke: 'orange',
        lineWidth: 5,
        pickable: false,
        tandem: options.tandem.createTandem( 'atomCenterMarker' )
      } );
      this.addChild( atomCenterMarker );
      var listener = function() { atomCenterMarker.visible = particleAtom.getWeight() === 0; };
      particleAtom.electronCountProperty.link( listener );
      particleAtom.neutronCountProperty.link( listener );
      particleAtom.protonCountProperty.link( listener );
    }
    var electronShell = new ElectronShellView( particleAtom, modelViewTransform, {
      tandem: options.tandem.createTandem( 'electronShell' )
    } );
    this.addChild( electronShell );
    var electronCloud = new ElectronCloudView( particleAtom, modelViewTransform, {
      tandem: options.tandem.createTandem( 'electronCloud' )
    } );
    this.addChild( electronCloud );
    var updateElectronShellDepictionVisibility = function( depiction ) {
      electronShell.visible = depiction === 'orbits';
      electronCloud.visible = depiction === 'cloud';
    };
    options.electronShellDepictionProperty.link( updateElectronShellDepictionVisibility );
    var elementNameCenterPos = modelViewTransform.modelToViewPosition(
      particleAtom.positionProperty.get().plus( new Vector2( 0, particleAtom.innerElectronShellRadius * 0.60 ) )
    );
    this.elementName = new Text( '', {
      font: new PhetFont( ELEMENT_NAME_FONT_SIZE ),
      fill: PhetColorScheme.RED_COLORBLIND,
      center: elementNameCenterPos,
      pickable: false,
      tandem: options.tandem.createTandem( 'elementName' )
    } );
    this.addChild( this.elementName );
    var updateElementName = function() {
      var name = AtomIdentifier.getName( self.atom.protonCountProperty.get() );
      if ( name.length === 0 ) {
        name = '';
      }
      self.elementName.text = name;
      self.elementName.setScaleMagnitude( 1 );
      var maxLabelWidth = modelViewTransform.modelToViewDeltaX( particleAtom.innerElectronShellRadius * 1.4 );
      self.elementName.setScaleMagnitude( Math.min( maxLabelWidth / self.elementName.width, 1 ) );
      self.elementName.center = elementNameCenterPos;
    };
    updateElementName(); 
    particleAtom.protonCountProperty.link( updateElementName );
    var updateElementNameVisibility = function( visible ) {
      self.elementName.visible = visible;
    };
    options.showElementNameProperty.link( updateElementNameVisibility );
    var ionIndicatorTranslation = modelViewTransform.modelToViewPosition( particleAtom.positionProperty.get().plus(
      new Vector2( particleAtom.outerElectronShellRadius * 1.05, 0 ).rotated( Math.PI * 0.3 ) ) );
    this.ionIndicator = new Text( '', {
      font: new PhetFont( 20 ),
      fill: 'black',
      translation: ionIndicatorTranslation,
      pickable: false,
      maxWidth: 150,
      tandem: options.tandem.createTandem( 'ionIndicator' )
    } );
    this.addChild( this.ionIndicator );
    var updateIonIndicator = function() {
      if ( self.atom.protonCountProperty.get() > 0 ) {
        var charge = self.atom.getCharge();
        if ( charge < 0 ) {
          self.ionIndicator.text = minusSignIonString;
          self.ionIndicator.fill = 'blue';
        }
        else if ( charge > 0 ) {
          self.ionIndicator.text = positiveSignIonString;
          self.ionIndicator.fill = PhetColorScheme.RED_COLORBLIND;
        }
        else {
          self.ionIndicator.text = neutralAtomString;
          self.ionIndicator.fill = 'black';
        }
      }
      else {
        self.ionIndicator.text = '';
        self.ionIndicator.fill = 'black';
      }
    };
    updateIonIndicator(); // Do the initial update.
    particleAtom.protonCountProperty.link( updateIonIndicator );
    particleAtom.electronCountProperty.link( updateIonIndicator );
    var updateIonIndicatorVisibility = function( visible ) {
      self.ionIndicator.visible = visible;
    };
    options.showNeutralOrIonProperty.link( updateIonIndicatorVisibility );
    var stabilityIndicatorCenterPos = modelViewTransform.modelToViewPosition( particleAtom.positionProperty.get().plus(
      new Vector2( 0, -particleAtom.innerElectronShellRadius * 0.60 ) ) );
    this.stabilityIndicator = new Text( '', {
      font: new PhetFont( 20 ),
      fill: 'black',
      center: stabilityIndicatorCenterPos,
      pickable: false,
      maxWidth: modelViewTransform.modelToViewDeltaX( particleAtom.innerElectronShellRadius * 1.4 ),
      tandem: options.tandem.createTandem( 'stabilityIndicator' )
    } );
    this.addChild( this.stabilityIndicator );
    var updateStabilityIndicator = function() {
      if ( self.atom.protonCountProperty.get() > 0 ) {
        if ( AtomIdentifier.isStable( self.atom.protonCountProperty.get(), self.atom.neutronCountProperty.get() ) ) {
          self.stabilityIndicator.text = stableString;
        }
        else {
          self.stabilityIndicator.text = unstableString;
        }
      }
      else {
        self.stabilityIndicator.text = '';
      }
      self.stabilityIndicator.center = stabilityIndicatorCenterPos;
    };
    updateStabilityIndicator(); 
    particleAtom.protonCountProperty.link( updateStabilityIndicator );
    particleAtom.neutronCountProperty.link( updateStabilityIndicator );
    var updateStabilityIndicatorVisibility = function( visible ) {
      self.stabilityIndicator.visible = visible;
    };
    options.showStableOrUnstableProperty.link( updateStabilityIndicatorVisibility );
    this.disposeAtomNode = function() {
      electronCloud.dispose();
      if ( options.showCenterX ) {
        particleAtom.electronCountProperty.unlink( listener );
        particleAtom.neutronCountProperty.unlink( listener );
        particleAtom.protonCountProperty.unlink( listener );
      }
      options.electronShellDepictionProperty.unlink( updateElectronShellDepictionVisibility );
      particleAtom.protonCountProperty.unlink( updateElementName );
      options.showElementNameProperty.unlink( updateElementNameVisibility );
      particleAtom.protonCountProperty.unlink( updateIonIndicator );
      particleAtom.electronCountProperty.unlink( updateIonIndicator );
      options.showNeutralOrIonProperty.unlink( updateIonIndicatorVisibility );
      particleAtom.protonCountProperty.unlink( updateStabilityIndicator );
      particleAtom.neutronCountProperty.unlink( updateStabilityIndicator );
      options.showStableOrUnstableProperty.unlink( updateStabilityIndicatorVisibility );
    };
    this.mutate( options );
  }
  shred.register( 'AtomNode', AtomNode );
  return inherit( Node, AtomNode, {
    dispose: function() {
      this.disposeAtomNode();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/common/BAAQueryParameters',['require','BUILD_AN_ATOM/buildAnAtom'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAQueryParameters = QueryStringMachine.getAll( {
    reward: { type: 'flag' },
    highContrastParticles: { type: 'flag' }
  } );
  buildAnAtom.register('BAAQueryParameters', BAAQueryParameters);
  return BAAQueryParameters;
} );
define( 'BUILD_AN_ATOM/common/BAAGlobalOptions',['require','BUILD_AN_ATOM/common/BAAQueryParameters','AXON/BooleanProperty','BUILD_AN_ATOM/buildAnAtom'],function( require ) {
  'use strict';
  var BAAQueryParameters = require( 'BUILD_AN_ATOM/common/BAAQueryParameters' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGlobalOptions = {
    highContrastParticlesProperty: new BooleanProperty( BAAQueryParameters.highContrastParticles )
  };
  buildAnAtom.register( 'BAAGlobalOptions', BAAGlobalOptions );
  return BAAGlobalOptions;
} );
define( 'BUILD_AN_ATOM/common/BAASharedConstants',['require','BUILD_AN_ATOM/buildAnAtom'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAASharedConstants = {
    RESET_BUTTON_RADIUS: 20,
    MINUS_SIGN: '\u2212'
  };
  buildAnAtom.register( 'BAASharedConstants', BAASharedConstants );
  return BAASharedConstants;
} );
define( 'SHRED/view/BucketDragHandler',['require','PHET_CORE/inherit','SHRED/shred','TANDEM/scenery/input/TandemSimpleDragHandler','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var shred = require( 'SHRED/shred' );
  var TandemSimpleDragHandler = require( 'TANDEM/scenery/input/TandemSimpleDragHandler' );
  var Tandem = require( 'TANDEM/Tandem' );
  function BucketDragHandler( bucket, bucketView, modelViewTransform, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    var activeParticle = null;
    var inputListenerOptions = {
      tandem: options.tandem,
      start: function( event, trail ) {
        var positionInModelSpace = modelViewTransform.viewToModelPosition(
          bucketView.getParents()[ 0 ].globalToLocalPoint( event.pointer.point )
        );
        activeParticle = bucket.extractClosestParticle( positionInModelSpace );
        if ( activeParticle !== null ) {
          activeParticle.setPositionAndDestination( positionInModelSpace );
        }
      },
      translate: function( translationParams ) {
        if ( activeParticle !== null ) {
          activeParticle.setPositionAndDestination( activeParticle.positionProperty.get().plus(
            modelViewTransform.viewToModelDelta( translationParams.delta ) ) );
        }
      },
      end: function( event ) {
        if ( activeParticle !== null ) {
          activeParticle.userControlledProperty.set( false );
        }
      }
    };
    TandemSimpleDragHandler.call( this, inputListenerOptions ); // Call super constructor.
  }
  shred.register( 'BucketDragHandler', BucketDragHandler );
  return inherit( TandemSimpleDragHandler, BucketDragHandler );
} );
define( 'SCENERY/display/SVGLinearGradient',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/SVGGradient'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGGradient = require( 'SCENERY/display/SVGGradient' );
  function SVGLinearGradient( svgBlock, linearGradient ) {
    this.initialize( svgBlock, linearGradient );
  }
  scenery.register( 'SVGLinearGradient', SVGLinearGradient );
  inherit( SVGGradient, SVGLinearGradient, {
    initialize: function( svgBlock, linearGradient ) {
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( '[SVGLinearGradient] initialize ' + linearGradient.id );
      sceneryLog && sceneryLog.Paints && sceneryLog.push();
      SVGGradient.prototype.initialize.call( this, svgBlock, linearGradient );
      this.definition.setAttribute( 'x1', linearGradient.start.x );
      this.definition.setAttribute( 'y1', linearGradient.start.y );
      this.definition.setAttribute( 'x2', linearGradient.end.x );
      this.definition.setAttribute( 'y2', linearGradient.end.y );
      sceneryLog && sceneryLog.Paints && sceneryLog.pop();
      return this;
    },
    createDefinition: function() {
      return document.createElementNS( scenery.svgns, 'linearGradient' );
    }
  } );
  Poolable.mixin( SVGLinearGradient, {
    constructorDuplicateFactory: function( pool ) {
      return function( svgBlock, linearGradient ) {
        if ( pool.length ) {
          return pool.pop().initialize( svgBlock, linearGradient );
        }
        else {
          return new SVGLinearGradient( svgBlock, linearGradient );
        }
      };
    }
  } );
  return SVGLinearGradient;
} );
define( 'SCENERY/util/LinearGradient',['require','SCENERY/util/Gradient','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGLinearGradient','DOT/Vector2'],function( require ) {
  'use strict';
  var Gradient = require( 'SCENERY/util/Gradient' );
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGLinearGradient = require( 'SCENERY/display/SVGLinearGradient' );
  var Vector2 = require( 'DOT/Vector2' );
  function LinearGradient( x0, y0, x1, y1 ) {
    assert && assert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );
    var usesVectors = y1 === undefined;
    if ( usesVectors ) {
      assert && assert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );
    }
    this.start = usesVectors ? x0 : new Vector2( x0, y0 );
    this.end = usesVectors ? y0 : new Vector2( x1, y1 );
    Gradient.call( this );
  }
  scenery.register( 'LinearGradient', LinearGradient );
  inherit( Gradient, LinearGradient, {
    isLinearGradient: true,
    createCanvasGradient: function() {
      return scenery.scratchContext.createLinearGradient( this.start.x, this.start.y, this.end.x, this.end.y );
    },
    createSVGPaint: function( svgBlock ) {
      return SVGLinearGradient.createFromPool( svgBlock, this );
    },
    toString: function() {
      var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';
      _.each( this.stops, function( stop ) {
        result += '.addColorStop( ' + stop.ratio + ', \'' + ( stop.color.toCSS ? stop.color.toCSS() : stop.color.toString() ) + '\' )';
      } );
      return result;
    }
  } );
  return LinearGradient;
} );
define( 'SCENERY_PHET/bucket/BucketFront',['require','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/util/LinearGradient','DOT/Matrix3','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY_PHET/PhetFont','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY/nodes/Text'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Text = require( 'SCENERY/nodes/Text' );
  function BucketFront( bucket, modelViewTransform, options ) {
    Node.call( this, { cursor: 'pointer' } );
    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    if ( !options.labelNode ) {
      options.labelNode = new Text( bucket.captionText, {
        font: new PhetFont( 20 ),
        fill: bucket.captionColor,
        tandem: options.tandem.createTandem( 'label' )
      } );
    }
    this.bucket = bucket;
    var scaleMatrix = Matrix3.scaling( modelViewTransform.getMatrix().m00(), modelViewTransform.getMatrix().m11() );
    var transformedShape = bucket.containerShape.transformed( scaleMatrix );
    var baseColor = new Color( bucket.baseColor );
    var frontGradient = new LinearGradient( transformedShape.bounds.getMinX(),
      0,
      transformedShape.bounds.getMaxX(),
      0 );
    frontGradient.addColorStop( 0, baseColor.colorUtilsBrighter( 0.5 ).toCSS() );
    frontGradient.addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ).toCSS() );
    this.addChild( new Path( transformedShape, {
      fill: frontGradient
    } ) );
    this.labelNode = options.labelNode;
    this.setLabel( this.labelNode );
    this.translation = modelViewTransform.modelToViewPosition( bucket.position );
    this.mutate( options );
  }
  sceneryPhet.register( 'BucketFront', BucketFront );
  return inherit( Node, BucketFront, {
    setLabel: function( labelNode ) {
      if ( this.hasChild( this.labelNode ) ) {
        this.removeChild( this.labelNode );
      }
      if ( labelNode ) {
        this.labelNode = labelNode;
        this.labelNode.maxWidth = this.width * 0.8;
        this.labelNode.maxHeight = this.height;
        this.labelNode.center = this.localBounds.center;
        this.addChild( this.labelNode );
      }
    }
  } );
} );
define( 'SCENERY_PHET/bucket/BucketHole',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/util/LinearGradient','DOT/Matrix3','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  function BucketHole( bucket, modelViewTransform ) {
    Node.call( this );
    var scaleMatrix = Matrix3.scaling( modelViewTransform.getMatrix().m00(), modelViewTransform.getMatrix().m11() );
    var transformedShape = bucket.holeShape.transformed( scaleMatrix );
    var gradientPaint = new LinearGradient( transformedShape.bounds.getMinX(), 0, transformedShape.bounds.getMaxX(), 0 );
    gradientPaint.addColorStop( 0, 'black' );
    gradientPaint.addColorStop( 1, '#c0c0c0' );
    this.addChild( new Path( transformedShape, {
      fill: gradientPaint,
      stroke: '#777',
      lineWidth: 1
    } ) );
    this.translation = modelViewTransform.modelToViewPosition( bucket.position );
  }
  sceneryPhet.register( 'BucketHole', BucketHole );
  return inherit( Node, BucketHole );
} );
define( 'PHETCOMMON/phetcommon',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'phetcommon' );
} );
define( 'PHETCOMMON/view/ModelViewTransform2',['require','PHET_CORE/inherit','DOT/Vector2','DOT/Matrix3','DOT/Transform3','PHETCOMMON/phetcommon'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Transform3 = require( 'DOT/Transform3' );
  var phetcommon = require( 'PHETCOMMON/phetcommon' );
  function ModelViewTransform2( matrix ) {
    Transform3.call( this, matrix );
  }
  phetcommon.register( 'ModelViewTransform2', ModelViewTransform2 );
  inherit( Transform3, ModelViewTransform2, {
    modelToViewPosition: function( point ) { return this.transformPosition2( point ); },
    modelToViewXY: function( x, y ) { return new Vector2( this.modelToViewX( x ), this.modelToViewY( y ) ); },
    modelToViewX: function( x ) { return this.matrix.m00() * x + this.matrix.m02();},
    modelToViewY: function( y ) { return this.matrix.m11() * y + this.matrix.m12();},
    modelToViewDelta: function( vector ) { return this.transformDelta2( vector ); },
    modelToViewNormal: function( normal ) { return this.transformNormal2( normal ); },
    modelToViewDeltaX: function( x ) { return this.transformDeltaX( x ); },
    modelToViewDeltaY: function( y ) { return this.transformDeltaY( y ); },
    modelToViewBounds: function( bounds ) { return this.transformBounds2( bounds ); },
    modelToViewShape: function( shape ) { return this.transformShape( shape ); },
    modelToViewRay: function( ray ) { return this.transformRay2( ray ); },
    viewToModelPosition: function( point ) { return this.inversePosition2( point ); },
    viewToModelXY: function( x, y ) { return new Vector2( this.viewToModelX( x ), this.viewToModelY( y ) ); },
    viewToModelX: function( x ) {
      var inverse = this.getInverse();
      return inverse.m00() * x + inverse.m02();
    },
    viewToModelY: function( y ) {
      var inverse = this.getInverse();
      return inverse.m11() * y + inverse.m12();
    },
    viewToModelDelta: function( vector ) { return this.inverseDelta2( vector ); },
    viewToModelDeltaXY: function( x, y ) { return new Vector2( this.viewToModelDeltaX( x ), this.viewToModelDeltaY( y ) ); },
    viewToModelNormal: function( normal ) { return this.inverseNormal2( normal ); },
    viewToModelDeltaX: function( x ) { return this.inverseDeltaX( x ); },
    viewToModelDeltaY: function( y ) { return this.inverseDeltaY( y ); },
    viewToModelBounds: function( bounds ) { return this.inverseBounds2( bounds ); },
    viewToModelShape: function( shape ) { return this.inverseShape( shape ); },
    viewToModelRay: function( ray ) { return this.inverseRay2( ray ); },
    invalidate: function() {
      assert && assert( this.matrix.isAligned(),
        'Our current ModelViewTransform2 implementation will not work with arbitrary rotations.' );
      Transform3.prototype.invalidate.call( this );
    }
  } );
  ModelViewTransform2.createIdentity = function() {
    return new ModelViewTransform2( Matrix3.IDENTITY );
  };
  ModelViewTransform2.createOffsetScaleMapping = function( offset, scale ) {
    return new ModelViewTransform2( Matrix3.affine( scale, 0, 0, scale, offset.x, offset.y ) );
  };
  ModelViewTransform2.createOffsetXYScaleMapping = function( offset, xScale, yScale ) {
    return new ModelViewTransform2( Matrix3.affine( xScale, 0, 0, yScale, offset.x, offset.y ) );
  };
  ModelViewTransform2.createSinglePointXYScaleMapping = function( modelPoint, viewPoint, xScale, yScale ) {
    var offsetX = viewPoint.x - modelPoint.x * xScale;
    var offsetY = viewPoint.y - modelPoint.y * yScale;
    return this.createOffsetXYScaleMapping( new Vector2( offsetX, offsetY ), xScale, yScale );
  };
  ModelViewTransform2.createSinglePointScaleMapping = function( modelPoint, viewPoint, scale ) {
    return this.createSinglePointXYScaleMapping( modelPoint, viewPoint, scale, scale );
  };
  ModelViewTransform2.createSinglePointScaleInvertedYMapping = function( modelPoint, viewPoint, scale ) {
    return this.createSinglePointXYScaleMapping( modelPoint, viewPoint, scale, -scale );
  };
  ModelViewTransform2.createRectangleMapping = function( modelBounds, viewBounds ) {
    var m00 = viewBounds.width / modelBounds.width;
    var m02 = viewBounds.x - m00 * modelBounds.x;
    var m11 = viewBounds.height / modelBounds.height;
    var m12 = viewBounds.y - m11 * modelBounds.y;
    return new ModelViewTransform2( Matrix3.affine( m00, 0, 0, m11, m02, m12 ) );
  };
  ModelViewTransform2.createRectangleInvertedYMapping = function( modelBounds, viewBounds ) {
    var m00 = viewBounds.width / modelBounds.width;
    var m02 = viewBounds.x - m00 * modelBounds.x;
    var m11 = -viewBounds.height / modelBounds.height;
    var m12 = viewBounds.y - m11 * modelBounds.getMaxY();
    return new ModelViewTransform2( Matrix3.affine( m00, 0, 0, m11, m02, m12 ) );
  };
  return ModelViewTransform2;
} );
define( 'SUN/TPanel',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SCENERY/nodes/TNode'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  function TPanel( panel, phetioID ) {
    TNode.call( this, panel, phetioID );
    assertInstanceOf( panel, phet.sun.Panel );
  }
  phetioInherit( TNode, 'TPanel', TPanel, {}, {
    documentation: 'A container for other TNodes'
  } );
  sun.register( 'TPanel', TPanel );
  return TPanel;
} );
define( 'SUN/Panel',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','TANDEM/Tandem','SUN/TPanel'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPanel = require( 'SUN/TPanel' );
  var ALIGN_VALUES = [ 'left', 'center', 'right' ];
  var DEFAULT_OPTIONS = {
    fill: 'white',
    stroke: 'black',
    lineWidth: 1, // width of the background border
    xMargin: 5,
    yMargin: 5,
    cornerRadius: 10, // radius of the rounded corners on the background
    resize: true, // dynamically resize when content bounds change
    backgroundPickable: false,
    align: 'left',
    minWidth: 0, // minimum width of the panel
    tandem: Tandem.tandemRequired(),
    phetioType: TPanel
  };
  assert && Object.freeze( DEFAULT_OPTIONS );
  function Panel( content, options ) {
    options = _.extend( {}, DEFAULT_OPTIONS, options );
    assert && assert( _.includes( ALIGN_VALUES, options.align ), 'invalid align: ' + options.align );
    Node.call( this );
    var background = new Rectangle( 0, 0, 1, 1, {
      lineWidth: options.lineWidth,
      pickable: options.backgroundPickable,
      lineDash: options.lineDash,
      cornerRadius: options.cornerRadius
    } );
    this.background = background; // @private
    this.setStroke( options.stroke );
    this.setFill( options.fill );
    this.addChild( background );
    this.addChild( content );
    var backgroundUpdateInProgress = false;
    var updateBackground = function() {
      if ( backgroundUpdateInProgress ) {
        return;
      }
      background.visible = content.bounds.isValid();
      if ( !background.visible ) {
        return;
      }
      backgroundUpdateInProgress = true;
      var backgroundWidth = Math.max( options.minWidth, content.width + ( 2 * options.xMargin ) );
      background.setRect( 0, 0, backgroundWidth, content.height + ( 2 * options.yMargin ) );
      if ( options.align === 'center' ) {
        content.center = background.center;
      }
      else if ( options.align === 'left' ) {
        content.left = background.centerX - backgroundWidth / 2 + options.xMargin;
        content.centerY = background.centerY;
      }
      else { 
        content.right = background.centerX + backgroundWidth / 2 - options.xMargin;
        content.centerY = background.centerY;
      }
      backgroundUpdateInProgress = false;
    };
    if ( options.resize ) {
      content.on( 'bounds', updateBackground );
    }
    updateBackground();
    this.disposePanel = function() {
      if ( options.resize ) {
        content.off( 'bounds', updateBackground );
      }
    };
    this.mutate( options );
  }
  sun.register( 'Panel', Panel );
  inherit( Node, Panel, {
    dispose: function() {
      this.disposePanel();
      Node.prototype.dispose.call( this );
    },
    setStroke: function( stroke ) {
      this.background.stroke = stroke;
    },
    getStroke: function() {
      return this.background.stroke;
    },
    set stroke( value ) { this.setStroke( value ); },
    get stroke() { return this.getStroke(); },
    setFill: function( fill ) {
      this.background.fill = fill;
    },
    getFill: function() {
      return this.background.fill;
    },
    set fill( value ) { this.setFill( value ); },
    get fill() { return this.getFill(); }
  }, {
    DEFAULT_OPTIONS: DEFAULT_OPTIONS
  } );
  return Panel;
} );
define( 'SHRED/view/ParticleNode',['require','SCENERY/nodes/Circle','SCENERY/util/Color','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetColorScheme','SCENERY/util/RadialGradient','SHRED/shred','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var DEFAULT_LINE_WIDTH = 0.5;
  function ParticleNode( particleType, radius, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this, options ); // Call super constructor.
    var colors = {
      proton: PhetColorScheme.RED_COLORBLIND,
      neutron: Color.gray,
      electron: Color.blue
    };
    var baseColor = colors[ particleType ];
    if ( baseColor === undefined ) {
      assert && assert( false, 'Unrecognized particle type: ' + particleType );
      baseColor = 'black';
    }
    var gradientFill = new RadialGradient( -radius * 0.4, -radius * 0.4, 0, -radius * 0.4, -radius * 0.4, radius * 1.6 )
      .addColorStop( 0, 'white' )
      .addColorStop( 1, baseColor );
    var nonHighContrastStroke = baseColor.colorUtilsDarker( 0.33 );
    var circle = new Circle( radius, {
      fill: gradientFill,
      stroke: nonHighContrastStroke,
      lineWidth: DEFAULT_LINE_WIDTH,
      cursor: 'pointer'
    } );
    this.addChild( circle );
    var highContrastListener = null;
    if ( options.highContrastProperty ) {
      highContrastListener = function( highContrast ) {
        circle.fill = highContrast ? baseColor : gradientFill;
        circle.stroke = highContrast ? baseColor.colorUtilsDarker( 0.5 ) : nonHighContrastStroke;
        circle.lineWidth = highContrast ? 2 : DEFAULT_LINE_WIDTH;
      };
      options.highContrastProperty.link( highContrastListener );
    }
    this.disposeParticleNode = function(){
      if ( highContrastListener ) {
        options.highContrastProperty.unlink( highContrastListener );
      }
    };
  }
  shred.register( 'ParticleNode', ParticleNode );
  return inherit( Node, ParticleNode );
} );
define("string!SHRED/protonsColon",function(){return window.phet.chipper.strings.get("SHRED/protonsColon");});
define("string!SHRED/neutronsColon",function(){return window.phet.chipper.strings.get("SHRED/neutronsColon");});
define("string!SHRED/electronsColon",function(){return window.phet.chipper.strings.get("SHRED/electronsColon");});
define( 'SHRED/view/ParticleCountDisplay',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SUN/Panel','SHRED/view/ParticleNode','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','SHRED/ShredConstants','SHRED/shred','SCENERY/nodes/Text','TANDEM/Tandem','string!SHRED/protonsColon','string!SHRED/neutronsColon','string!SHRED/electronsColon'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Panel = require( 'SUN/Panel' );
  var ParticleNode = require( 'SHRED/view/ParticleNode' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var shred = require( 'SHRED/shred' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var protonsColonString = require( 'string!SHRED/protonsColon' );
  var neutronsColonString = require( 'string!SHRED/neutronsColon' );
  var electronsColonString = require( 'string!SHRED/electronsColon' );
  var TITLE_MAX_WIDTH_PROPORTION = 1 / 3;
  var MIN_VERTICAL_SPACING = 16; // Empirically Determined
  var LABEL_FONT = new PhetFont( 12 );
  function ParticleCountDisplay( numberAtom, maxParticles, maxWidth, options ) {
    options = _.extend( {
      fill: ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR,
      cornerRadius: 5,
      pickable: false,
      tandem: Tandem.tandemRequired()
    }, options );
    var panelContents = new Node();
    var protonTitle = new Text( protonsColonString, {
      font: LABEL_FONT,
      tandem: options.tandem.createTandem( 'protonTitle' )
    } );
    panelContents.addChild( protonTitle );
    var neutronTitle = new Text( neutronsColonString, {
      font: LABEL_FONT,
      tandem: options.tandem.createTandem( 'neutronTitle' )
    } );
    panelContents.addChild( neutronTitle );
    var electronTitle = new Text( electronsColonString, {
      font: LABEL_FONT,
      tandem: options.tandem.createTandem( 'electronTitle' )
    } );
    panelContents.addChild( electronTitle );
    var maxAllowableLabelWidth = maxWidth * TITLE_MAX_WIDTH_PROPORTION;
    protonTitle.maxWidth = maxAllowableLabelWidth;
    electronTitle.maxWidth = maxAllowableLabelWidth;
    neutronTitle.maxWidth = maxAllowableLabelWidth;
    var maxLabelWidth = Math.max( Math.max( protonTitle.width, neutronTitle.width ), electronTitle.width );
    protonTitle.right = maxLabelWidth;
    protonTitle.top = 0;
    neutronTitle.right = maxLabelWidth;
    neutronTitle.bottom = protonTitle.bottom + Math.max( neutronTitle.height, MIN_VERTICAL_SPACING );
    electronTitle.right = maxLabelWidth;
    electronTitle.bottom = neutronTitle.bottom + Math.max( electronTitle.height, MIN_VERTICAL_SPACING );
    var totalParticleSpace = maxWidth - protonTitle.right - 10;
    var nucleonRadius = totalParticleSpace / ( (maxParticles * 2) + ( maxParticles - 1) + 2);
    var electronRadius = nucleonRadius * 0.6; // Arbitrarily chosen.
    var interParticleSpacing = nucleonRadius * 3;
    var spacer = new Rectangle( maxLabelWidth, 0, interParticleSpacing * 3, 1 );
    var particleLayer = new Node( { children: [ spacer ] } );
    panelContents.addChild( particleLayer );
    var protons = [];
    var neutrons = [];
    var electrons = [];
    var protonDisplayCount = 0;
    var neutronDisplayCount = 0;
    var electronDisplayCount = 0;
    function incrementParticleCount( array, currentQuantity, particleType, radius, startX, startY, groupTandem ) {
      var newIndex = currentQuantity;
      if ( newIndex === array.length ) {
        array.push( new ParticleNode( particleType, radius, {
          x: startX + newIndex * interParticleSpacing,
          y: startY,
          tandem: groupTandem.createNextTandem()
        } ) );
      }
      particleLayer.addChild( array[ newIndex ] );
      currentQuantity += 1;
      return currentQuantity;
    }
    function decrementParticleCount( array, currentQuantity ) {
      currentQuantity -= 1;
      particleLayer.removeChild( array[ currentQuantity ] );
      array.splice( currentQuantity, 1 );
      return currentQuantity;
    }
    var protonNodeGroupTandem = options.tandem.createGroupTandem( 'protons' );
    var neutronNodeGroupTandem = options.tandem.createGroupTandem( 'neutron' );
    var electronNodeGroupTandem = options.tandem.createGroupTandem( 'electron' );
    var updateParticles = function( atom ) {
      while ( atom.protonCountProperty.get() > protonDisplayCount ) {
        protonDisplayCount = incrementParticleCount(
          protons,
          protonDisplayCount,
          'proton',
          nucleonRadius,
          protonTitle.right + interParticleSpacing,
          protonTitle.center.y,
          protonNodeGroupTandem
        );
      }
      while ( atom.protonCountProperty.get() < protonDisplayCount ) {
        protonDisplayCount = decrementParticleCount( protons, protonDisplayCount );
      }
      while ( atom.neutronCountProperty.get() > neutronDisplayCount ) {
        neutronDisplayCount = incrementParticleCount(
          neutrons,
          neutronDisplayCount,
          'neutron',
          nucleonRadius,
          neutronTitle.right + interParticleSpacing, neutronTitle.center.y,
          neutronNodeGroupTandem
        );
      }
      while ( atom.neutronCountProperty.get() < neutronDisplayCount ) {
        neutronDisplayCount = decrementParticleCount( neutrons, neutronDisplayCount );
      }
      while ( atom.electronCountProperty.get() > electronDisplayCount ) {
        electronDisplayCount = incrementParticleCount(
          electrons,
          electronDisplayCount,
          'electron',
          electronRadius,
          electronTitle.right + interParticleSpacing, electronTitle.center.y,
          electronNodeGroupTandem
        );
      }
      while ( atom.electronCountProperty.get() < electronDisplayCount ) {
        electronDisplayCount = decrementParticleCount( electrons, electronDisplayCount );
      }
    };
    numberAtom.particleCountProperty.link( function() {
      updateParticles( numberAtom );
    } );
    updateParticles( numberAtom );
    Panel.call( this, panelContents, options );
  }
  shred.register( 'ParticleCountDisplay', ParticleCountDisplay );
  return inherit( Panel, ParticleCountDisplay );
} );
define( 'SCENERY/display/drawables/LineCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/PaintableStatelessDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var PaintableStatelessDrawable = require( 'SCENERY/display/drawables/PaintableStatelessDrawable' );
  function LineCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'LineCanvasDrawable', LineCanvasDrawable );
  inherit( CanvasSelfDrawable, LineCanvasDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeCanvasSelfDrawable( renderer, instance );
      this.initializePaintableStateless( renderer, instance );
      return this;
    },
    paintCanvas: function( wrapper, node ) {
      var context = wrapper.context;
      context.beginPath();
      context.moveTo( node._x1, node._y1 );
      context.lineTo( node._x2, node._y2 );
      if ( node._stroke ) {
        node.beforeCanvasStroke( wrapper ); // defined in Paintable
        context.stroke();
        node.afterCanvasStroke( wrapper ); // defined in Paintable
      }
    },
    markDirtyLine: function() { this.markPaintDirty(); },
    markDirtyP1: function() { this.markPaintDirty(); },
    markDirtyP2: function() { this.markPaintDirty(); },
    markDirtyX1: function() { this.markPaintDirty(); },
    markDirtyY1: function() { this.markPaintDirty(); },
    markDirtyX2: function() { this.markPaintDirty(); },
    markDirtyY2: function() { this.markPaintDirty(); },
    dispose: function() {
      CanvasSelfDrawable.prototype.dispose.call( this );
      this.disposePaintableStateless();
    }
  } );
  PaintableStatelessDrawable.mixin( LineCanvasDrawable );
  SelfDrawable.Poolable.mixin( LineCanvasDrawable );
  return LineCanvasDrawable;
} );
define( 'SCENERY/display/drawables/LineStatefulDrawable',['require','SCENERY/scenery','SCENERY/display/drawables/PaintableStatefulDrawable'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var PaintableStatefulDrawable = require( 'SCENERY/display/drawables/PaintableStatefulDrawable' );
  var LineStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.initializePaintableState( renderer, instance );
        return this; // allow for chaining
      };
      proto.disposeState = function() {
        this.disposePaintableState();
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyLine = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };
      proto.markDirtyP1 = function() {
        this.dirtyX1 = true;
        this.dirtyY1 = true;
        this.markPaintDirty();
      };
      proto.markDirtyP2 = function() {
        this.dirtyX2 = true;
        this.dirtyY2 = true;
        this.markPaintDirty();
      };
      proto.markDirtyX1 = function() {
        this.dirtyX1 = true;
        this.markPaintDirty();
      };
      proto.markDirtyY1 = function() {
        this.dirtyY1 = true;
        this.markPaintDirty();
      };
      proto.markDirtyX2 = function() {
        this.dirtyX2 = true;
        this.markPaintDirty();
      };
      proto.markDirtyY2 = function() {
        this.dirtyY2 = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyX1 = false;
        this.dirtyY1 = false;
        this.dirtyX2 = false;
        this.dirtyY2 = false;
      };
      PaintableStatefulDrawable.mixin( drawableType );
    }
  };
  scenery.register( 'LineStatefulDrawable', LineStatefulDrawable );
  return LineStatefulDrawable;
} );
define( 'SCENERY/display/drawables/LineSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/LineStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var LineStatefulDrawable = require( 'SCENERY/display/drawables/LineStatefulDrawable' );
  var keepSVGLineElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  function LineSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'LineSVGDrawable', LineSVGDrawable );
  inherit( SVGSelfDrawable, LineSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, true, keepSVGLineElements ); // usesPaint: true
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'line' );
      return this;
    },
    updateSVGSelf: function() {
      var line = this.svgElement;
      if ( this.dirtyX1 ) {
        line.setAttribute( 'x1', this.node._x1 );
      }
      if ( this.dirtyY1 ) {
        line.setAttribute( 'y1', this.node._y1 );
      }
      if ( this.dirtyX2 ) {
        line.setAttribute( 'x2', this.node._x2 );
      }
      if ( this.dirtyY2 ) {
        line.setAttribute( 'y2', this.node._y2 );
      }
      this.updateFillStrokeStyle( line );
    }
  } );
  LineStatefulDrawable.mixin( LineSVGDrawable );
  SelfDrawable.Poolable.mixin( LineSVGDrawable );
  return LineSVGDrawable;
} );
define( 'SCENERY/nodes/Line',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','KITE/segments/Line','SCENERY/nodes/Path','KITE/Shape','DOT/Bounds2','DOT/Vector2','SCENERY/display/Renderer','SCENERY/display/drawables/LineCanvasDrawable','SCENERY/display/drawables/LineSVGDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var KiteLine = require( 'KITE/segments/Line' ); // eslint-disable-line require-statement-match
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var LineCanvasDrawable = require( 'SCENERY/display/drawables/LineCanvasDrawable' );
  var LineSVGDrawable = require( 'SCENERY/display/drawables/LineSVGDrawable' );
  var LINE_OPTION_KEYS = [
    'p1', // {Vector2} - Start position
    'p2', // {Vector2} - End position
    'x1', // {number} - Start x position
    'y1', // {number} - Start y position
    'x2', // {number} - End x position
    'y2' // {number} - End y position
  ];
  function Line( x1, y1, x2, y2, options ) {
    this._x1 = 0;
    this._y1 = 0;
    this._x2 = 0;
    this._y2 = 0;
    if ( typeof x1 === 'object' ) {
      if ( x1 instanceof Vector2 ) {
        assert && assert( y1 instanceof Vector2 );
        assert && assert( x2 === undefined || typeof x2 === 'object' );
        assert && assert( x2 === undefined || Object.getPrototypeOf( x2 ) === Object.prototype,
          'Extra prototype on Node options object is a code smell' );
        options = extendDefined( {
          x1: x1.x,
          y1: x1.y,
          x2: y1.x,
          y2: y1.y
        }, x2 ); // Options object (if available) is under the x2 name
      }
      else {
        assert && assert( y1 === undefined );
        options = x1;
        assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
          'Extra prototype on Node options object is a code smell' );
      }
    }
    else {
      assert && assert( typeof x1 === 'number' &&
                        typeof y1 === 'number' &&
                        typeof x2 === 'number' &&
                        typeof y2 === 'number' );
      assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
        'Extra prototype on Node options object is a code smell' );
      options = extendDefined( {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      }, options );
    }
    Path.call( this, null, options );
  }
  scenery.register( 'Line', Line );
  inherit( Path, Line, {
    _mutatorKeys: LINE_OPTION_KEYS.concat( Path.prototype._mutatorKeys ),
    drawableMarkFlags: Path.prototype.drawableMarkFlags.concat( [ 'line', 'p1', 'p2', 'x1', 'x2', 'y1', 'y2' ] ).filter( function( flag ) {
      return flag !== 'shape';
    } ),
    setLine: function( x1, y1, x2, y2 ) {
      assert && assert( x1 !== undefined &&
                        y1 !== undefined &&
                        x2 !== undefined &&
                        y2 !== undefined, 'parameters need to be defined' );
      this._x1 = x1;
      this._y1 = y1;
      this._x2 = x2;
      this._y2 = y2;
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyLine();
      }
      this.invalidateLine();
      return this;
    },
    setPoint1: function( x1, y1 ) {
      if ( typeof x1 === 'number' ) {
        assert && assert( x1 !== undefined && y1 !== undefined, 'parameters need to be defined' );
        this._x1 = x1;
        this._y1 = y1;
      }
      else {
        assert && assert( x1.x !== undefined && x1.y !== undefined, 'parameters need to be defined' );
        this._x1 = x1.x;
        this._y1 = x1.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP1();
      }
      this.invalidateLine();
      return this;
    },
    set p1( point ) { this.setPoint1( point ); },
    get p1() { return new Vector2( this._x1, this._y1 ); },
    setPoint2: function( x2, y2 ) {
      if ( typeof x2 === 'number' ) {
        assert && assert( x2 !== undefined && y2 !== undefined, 'parameters need to be defined' );
        this._x2 = x2;
        this._y2 = y2;
      }
      else {
        assert && assert( x2.x !== undefined && x2.y !== undefined, 'parameters need to be defined' );
        this._x2 = x2.x;
        this._y2 = x2.y;
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        var state = this._drawables[ i ];
        state.markDirtyP2();
      }
      this.invalidateLine();
      return this;
    },
    set p2( point ) { this.setPoint2( point ); },
    get p2() { return new Vector2( this._x2, this._y2 ); },
    setX1: function( x1 ) {
      if ( this._x1 !== x1 ) {
        this._x1 = x1;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX1();
        }
        this.invalidateLine();
      }
      return this;
    },
    set x1( value ) { this.setX1( value ); },
    getX1: function() {
      return this._x1;
    },
    get x1() { return this.getX1(); },
    setY1: function( y1 ) {
      if ( this._y1 !== y1 ) {
        this._y1 = y1;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY1();
        }
        this.invalidateLine();
      }
      return this;
    },
    set y1( value ) { this.setY1( value ); },
    getY1: function() {
      return this._y1;
    },
    get y1() { return this.getY1(); },
    setX2: function( x2 ) {
      if ( this._x2 !== x2 ) {
        this._x2 = x2;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyX2();
        }
        this.invalidateLine();
      }
      return this;
    },
    set x2( value ) { this.setX2( value ); },
    getX2: function() {
      return this._x2;
    },
    get x2() { return this.getX2(); },
    setY2: function( y2 ) {
      if ( this._y2 !== y2 ) {
        this._y2 = y2;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyY2();
        }
        this.invalidateLine();
      }
      return this;
    },
    set y2( value ) { this.setY2( value ); },
    getY2: function() {
      return this._y2;
    },
    get y2() { return this.getY2(); },
    createLineShape: function() {
      return Shape.lineSegment( this._x1, this._y1, this._x2, this._y2 ).makeImmutable();
    },
    invalidateLine: function() {
      assert && assert( isFinite( this._x1 ), 'A rectangle needs to have a finite x1 (' + this._x1 + ')' );
      assert && assert( isFinite( this._y1 ), 'A rectangle needs to have a finite y1 (' + this._y1 + ')' );
      assert && assert( isFinite( this._x2 ), 'A rectangle needs to have a finite x2 (' + this._x2 + ')' );
      assert && assert( isFinite( this._y2 ), 'A rectangle needs to have a finite y2 (' + this._y2 + ')' );
      this._shape = null;
      this.invalidatePath();
    },
    containsPointSelf: function( point ) {
      if ( this._strokePickable ) {
        return Path.prototype.containsPointSelf.call( this, point );
      }
      else {
        return false; // nothing is in a line! (although maybe we should handle edge points properly?)
      }
    },
    intersectsBoundsSelf: function( bounds ) {
      return new KiteLine( this.p1, this.p2 ).intersectsBounds( bounds );
    },
    canvasPaintSelf: function( wrapper ) {
      LineCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    computeShapeBounds: function() {
      if ( this._stroke ) {
        var lineCap = this.getLineCap();
        var halfLineWidth = this.getLineWidth() / 2;
        if ( lineCap === 'round' ) {
          return new Bounds2(
            Math.min( this._x1, this._x2 ) - halfLineWidth, Math.min( this._y1, this._y2 ) - halfLineWidth,
            Math.max( this._x1, this._x2 ) + halfLineWidth, Math.max( this._y1, this._y2 ) + halfLineWidth );
        }
        else {
          var dx = this._x2 - this._x1;
          var dy = this._y2 - this._y1;
          var magnitude = Math.sqrt( dx * dx + dy * dy );
          if ( magnitude === 0 ) {
            return new Bounds2( this._x1 - halfLineWidth, this._y1 - halfLineWidth, this._x2 + halfLineWidth, this._y2 + halfLineWidth );
          }
          var sx = halfLineWidth * dx / magnitude;
          var sy = halfLineWidth * dy / magnitude;
          var bounds = Bounds2.NOTHING.copy();
          if ( lineCap === 'butt' ) {
            bounds.addCoordinates( this._x1 - sy, this._y1 + sx );
            bounds.addCoordinates( this._x1 + sy, this._y1 - sx );
            bounds.addCoordinates( this._x2 - sy, this._y2 + sx );
            bounds.addCoordinates( this._x2 + sy, this._y2 - sx );
          }
          else {
            assert && assert( lineCap === 'square' );
            bounds.addCoordinates( this._x1 - sx - sy, this._y1 - sy + sx );
            bounds.addCoordinates( this._x1 - sx + sy, this._y1 - sy - sx );
            bounds.addCoordinates( this._x2 + sx - sy, this._y2 + sy + sx );
            bounds.addCoordinates( this._x2 + sx + sy, this._y2 + sy - sx );
          }
          return bounds;
        }
      }
      else {
        var fillBounds = Bounds2.NOTHING.copy();
        fillBounds.addCoordinates( this._x1, this._y1 );
        fillBounds.addCoordinates( this._x2, this._y2 );
        return fillBounds;
      }
    },
    createSVGDrawable: function( renderer, instance ) {
      return LineSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return LineCanvasDrawable.createFromPool( renderer, instance );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Line( ' + this._x1 + ', ' + this._y1 + ', ' + this._x1 + ', ' + this._y1 + ', {' + propLines + '} )';
    },
    setShape: function( shape ) {
      if ( shape !== null ) {
        throw new Error( 'Cannot set the shape of a scenery.Line to something non-null' );
      }
      else {
        this.invalidatePath();
      }
    },
    getShape: function() {
      if ( !this._shape ) {
        this._shape = this.createLineShape();
      }
      return this._shape;
    },
    hasShape: function() {
      return true;
    },
    getFillRendererBitmask: function() {
      return Renderer.bitmaskCanvas | Renderer.bitmaskSVG | Renderer.bitmaskDOM | Renderer.bitmaskWebGL;
    }
  } );
  return Line;
} );
define( 'SCENERY_PHET/RichText',['require','SCENERY/input/ButtonListener','SCENERY/util/Color','PHET_CORE/extendDefined','SCENERY/util/Font','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY_PHET/sceneryPhet','SCENERY/nodes/Text'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Color = require( 'SCENERY/util/Color' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var Font = require( 'SCENERY/util/Font' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Text = require( 'SCENERY/nodes/Text' );
  var RICH_TEXT_OPTION_KEYS = [
    'font',
    'fill',
    'stroke',
    'subScale',
    'subXSpacing',
    'subYOffset',
    'supScale',
    'supXSpacing',
    'supYOffset',
    'capHeightScale',
    'underlineLineWidth',
    'underlineHeightScale',
    'strikethroughLineWidth',
    'strikethroughHeightScale',
    'linkFill',
    'linkEventsHandled',
    'links',
    'text'
  ];
  var DEFAULT_FONT = new PhetFont( 20 );
  var ACCESSIBLE_TAGS = [
    'b', 'strong', 'i', 'em', 'sub', 'sup', 'u', 's'
  ];
  function RichText( text, options ) {
    this._text = '';
    this._font = DEFAULT_FONT;
    this._fill = '#000000';
    this._stroke = null;
    this._subScale = 0.75;
    this._subXSpacing = 0;
    this._subYOffset = 0;
    this._supScale = 0.75;
    this._supXSpacing = 0;
    this._supYOffset = 0;
    this._capHeightScale = 0.75;
    this._underlineLineWidth = 1;
    this._underlineHeightScale = 0.15;
    this._strikethroughLineWidth = 1;
    this._strikethroughHeightScale = 0.3;
    this._linkFill = 'rgb(27,0,241)';
    this._linkEventsHandled = false;
    this._links = {};
    Node.call( this );
    this.richTextContainer = new Node();
    this.addChild( this.richTextContainer );
    options = extendDefined( {
      fill: '#000000',
      text: text
    }, options );
    this.mutate( options );
  }
  sceneryPhet.register( 'RichText', RichText );
  return inherit( Node, RichText, {
    _mutatorKeys: RICH_TEXT_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    rebuildRichText: function() {
      this.richTextContainer.removeAllChildren();
      var mappedText = this._text.replace( /\u202a/g, '<span dir="ltr">' )
                                 .replace( /\u202b/g, '<span dir="rtl">' )
                                 .replace( /\u202c/g, '</span>' );
      var rootElements = himalaya.parse( mappedText );
      for ( var i = 0; i < rootElements.length; i++ ) {
        this.appendElement( this.richTextContainer, rootElements[ i ], this._font, this._fill, true );
      }
    },
    appendElement: function( containerNode, element, font, fill, isLTR ) {
      var self = this;
      var nextSideName = isLTR ? 'left' : 'right';
      var previousSideName = isLTR ? 'right' : 'left';
      var x = isFinite( containerNode.localBounds[ previousSideName ] ) ? containerNode.localBounds[ previousSideName ] : 0;
      var node;
      if ( element.type === 'Text' ) {
        node = new Text( RichText.contentToString( element.content, isLTR ), {
          font: font,
          fill: fill,
          stroke: this._stroke
        } );
      }
      else if ( element.type === 'Element' ) {
        node = new Node();
        if ( element.tagName === 'a' ) {
          var href = element.attributes.href;
          if ( this._links !== true ) {
            if ( href.indexOf( '{{' ) === 0 && href.indexOf( '}}' ) === href.length - 2 ) {
              href = this._links[ href.slice( 2, -2 ) ];
            }
            else {
              href = null;
            }
          }
          if ( href ) {
            if ( this._linkFill !== null ) {
              fill = this._linkFill; // Link color
            }
            node.cursor = 'pointer';
            node.addInputListener( new ButtonListener( {
              fire: function( event ) {
                self._linkEventsHandled && event.handle();
                var newWindow = window.open( href, '_blank' ); // open in a new window/tab
                newWindow.focus();
              }
            } ) );
            node.tagName = 'a';
            node.accessibleLabel = RichText.himalayaElementToAccessibleString( element, isLTR );
            node.setAccessibleAttribute( 'href', href );
            node.setAccessibleAttribute( 'target', '_blank' );
          }
        }
        else if ( element.tagName === 'b' || element.tagName === 'strong' ) {
          font = font.copy( {
            weight: 'bold'
          } );
        }
        else if ( element.tagName === 'i' || element.tagName === 'em' ) {
          font = font.copy( {
            style: 'italic'
          } );
        }
        else if ( element.tagName === 'sub' ) {
          node.scale( this._subScale );
          node.x += ( isLTR ? 1 : -1 ) * this._subXSpacing;
          node.y += this._subYOffset;
        }
        else if ( element.tagName === 'sup' ) {
          node.scale( this._supScale );
          node.x += ( isLTR ? 1 : -1 ) * this._supXSpacing;
          node.y += this._supYOffset;
        }
        else if ( element.tagName === 'font' ) {
          if ( element.attributes.color ) {
            fill = new Color( element.attributes.color );
          }
          if ( element.attributes.face ) {
            font = font.copy( {
              family: element.attributes.face
            } );
          }
          if ( element.attributes.size ) {
            font = font.copy( {
              size: element.attributes.size
            } );
          }
        }
        else if ( element.tagName === 'span' ) {
          if ( element.attributes.dir ) {
            assert && assert( element.attributes.dir === 'ltr' || element.attributes.dir === 'rtl',
              'Span dir attributes should be ltr or rtl.' );
            isLTR = element.attributes.dir === 'ltr';
          }
        }
        for ( var i = 0; i < element.children.length; i++ ) {
          this.appendElement( node, element.children[ i ], font, fill, isLTR );
        }
        if ( element.tagName === 'sub' ) {
          if ( isFinite( node.height ) ) {
            node.centerY = 0;
          }
        }
        else if ( element.tagName === 'sup' ) {
          if ( isFinite( node.height ) ) {
            node.centerY = new Text( 'X', { font: font } ).top * this._capHeightScale;
          }
        }
        else if ( element.tagName === 'u' ) {
          var underlineY = -node.top * this._underlineHeightScale;
          if ( isFinite( node.top ) ) {
            node.addChild( new Line( node.localBounds.left, underlineY, node.localBounds.right, underlineY, {
              stroke: fill,
              lineWidth: this._underlineLineWidth
            } ) );
          }
        }
        else if ( element.tagName === 's' ) {
          var strikethroughY = node.top * this._strikethroughHeightScale;
          if ( isFinite( node.top ) ) {
            node.addChild( new Line( node.localBounds.left, strikethroughY, node.localBounds.right, strikethroughY, {
              stroke: fill,
              lineWidth: this._strikethroughLineWidth
            } ) );
          }
        }
      }
      if ( isFinite( node.width ) ) {
        node[ nextSideName ] = x;
        containerNode.addChild( node );
      }
    },
    setText: function( text ) {
      assert && assert( text !== null && text !== undefined, 'Text should be defined and non-null. Use the empty string if needed.' );
      assert && assert( typeof text === 'number' || typeof text === 'string', 'text should be a string or number' );
      text = '' + text;
      if ( text !== this._text ) {
        this._text = text;
        this.rebuildRichText();
      }
      return this;
    },
    set text( value ) { this.setText( value ); },
    getText: function() {
      return this._text;
    },
    get text() { return this.getText(); },
    setFont: function( font ) {
      assert && assert( font instanceof Font || typeof font === 'string',
        'Fonts provided to setFont should be a Font object or a string in the CSS3 font shortcut format' );
      if ( this._font !== font ) {
        this._font = font;
        this.rebuildRichText();
      }
      return this;
    },
    set font( value ) { this.setFont( value ); },
    getFont: function() {
      return this._font;
    },
    get font() { return this.getFont(); },
    setFill: function( fill ) {
      if ( this._fill !== fill ) {
        this._fill = fill;
        this.rebuildRichText();
      }
      return this;
    },
    set fill( value ) { this.setFill( value ); },
    getFill: function() {
      return this._fill;
    },
    get fill() { return this.getFill(); },
    setStroke: function( stroke ) {
      if ( this._stroke !== stroke ) {
        this._stroke = stroke;
        this.rebuildRichText();
      }
      return this;
    },
    set stroke( value ) { this.setStroke( value ); },
    getStroke: function() {
      return this._stroke;
    },
    get stroke() { return this.getStroke(); },
    setSubScale: function( subScale ) {
      if ( this._subScale !== subScale ) {
        this._subScale = subScale;
        this.rebuildRichText();
      }
      return this;
    },
    set subScale( value ) { this.setSubScale( value ); },
    getSubScale: function() {
      return this._subScale;
    },
    get subScale() { return this.getSubScale(); },
    setSubXSpacing: function( subXSpacing ) {
      if ( this._subXSpacing !== subXSpacing ) {
        this._subXSpacing = subXSpacing;
        this.rebuildRichText();
      }
      return this;
    },
    set subXSpacing( value ) { this.setSubXSpacing( value ); },
    getSubXSpacing: function() {
      return this._subXSpacing;
    },
    get subXSpacing() { return this.getSubXSpacing(); },
    setSubYOffset: function( subYOffset ) {
      if ( this._subYOffset !== subYOffset ) {
        this._subYOffset = subYOffset;
        this.rebuildRichText();
      }
      return this;
    },
    set subYOffset( value ) { this.setSubYOffset( value ); },
    getSubYOffset: function() {
      return this._subYOffset;
    },
    get subYOffset() { return this.getSubYOffset(); },
    setSupScale: function( supScale ) {
      if ( this._supScale !== supScale ) {
        this._supScale = supScale;
        this.rebuildRichText();
      }
      return this;
    },
    set supScale( value ) { this.setSupScale( value ); },
    getSupScale: function() {
      return this._supScale;
    },
    get supScale() { return this.getSupScale(); },
    setSupXSpacing: function( supXSpacing ) {
      if ( this._supXSpacing !== supXSpacing ) {
        this._supXSpacing = supXSpacing;
        this.rebuildRichText();
      }
      return this;
    },
    set supXSpacing( value ) { this.setSupXSpacing( value ); },
    getSupXSpacing: function() {
      return this._supXSpacing;
    },
    get supXSpacing() { return this.getSupXSpacing(); },
    setSupYOffset: function( supYOffset ) {
      if ( this._supYOffset !== supYOffset ) {
        this._supYOffset = supYOffset;
        this.rebuildRichText();
      }
      return this;
    },
    set supYOffset( value ) { this.setSupYOffset( value ); },
    getSupYOffset: function() {
      return this._supYOffset;
    },
    get supYOffset() { return this.getSupYOffset(); },
    setCapHeightScale: function( capHeightScale ) {
      if ( this._capHeightScale !== capHeightScale ) {
        this._capHeightScale = capHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set capHeightScale( value ) { this.setCapHeightScale( value ); },
    getCapHeightScale: function() {
      return this._capHeightScale;
    },
    get capHeightScale() { return this.getCapHeightScale(); },
    setUnderlineLineWidth: function( underlineLineWidth ) {
      if ( this._underlineLineWidth !== underlineLineWidth ) {
        this._underlineLineWidth = underlineLineWidth;
        this.rebuildRichText();
      }
      return this;
    },
    set underlineLineWidth( value ) { this.setUnderlineLineWidth( value ); },
    getUnderlineLineWidth: function() {
      return this._underlineLineWidth;
    },
    get underlineLineWidth() { return this.getUnderlineLineWidth(); },
    setUnderlineHeightScale: function( underlineHeightScale ) {
      if ( this._underlineHeightScale !== underlineHeightScale ) {
        this._underlineHeightScale = underlineHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set underlineHeightScale( value ) { this.setUnderlineHeightScale( value ); },
    getUnderlineHeightScale: function() {
      return this._underlineHeightScale;
    },
    get underlineHeightScale() { return this.getUnderlineHeightScale(); },
    setStrikethroughLineWidth: function( strikethroughLineWidth ) {
      if ( this._strikethroughLineWidth !== strikethroughLineWidth ) {
        this._strikethroughLineWidth = strikethroughLineWidth;
        this.rebuildRichText();
      }
      return this;
    },
    set strikethroughLineWidth( value ) { this.setStrikethroughLineWidth( value ); },
    getStrikethroughLineWidth: function() {
      return this._strikethroughLineWidth;
    },
    get strikethroughLineWidth() { return this.getStrikethroughLineWidth(); },
    setStrikethroughHeightScale: function( strikethroughHeightScale ) {
      if ( this._strikethroughHeightScale !== strikethroughHeightScale ) {
        this._strikethroughHeightScale = strikethroughHeightScale;
        this.rebuildRichText();
      }
      return this;
    },
    set strikethroughHeightScale( value ) { this.setStrikethroughHeightScale( value ); },
    getStrikethroughHeightScale: function() {
      return this._strikethroughHeightScale;
    },
    get strikethroughHeightScale() { return this.getStrikethroughHeightScale(); },
    setLinkFill: function( linkFill ) {
      if ( this._linkFill !== linkFill ) {
        this._linkFill = linkFill;
        this.rebuildRichText();
      }
      return this;
    },
    set linkFill( value ) { this.setLinkFill( value ); },
    getLinkFill: function() {
      return this._linkFill;
    },
    get linkFill() { return this.getLinkFill(); },
    setLinkEventsHandled: function( linkEventsHandled ) {
      if ( this._linkEventsHandled !== linkEventsHandled ) {
        this._linkEventsHandled = linkEventsHandled;
        this.rebuildRichText();
      }
      return this;
    },
    set linkEventsHandled( value ) { this.setLinkEventsHandled( value ); },
    getLinkEventsHandled: function() {
      return this._linkEventsHandled;
    },
    get linkEventsHandled() { return this.getLinkEventsHandled(); },
    setLinks: function( links ) {
      if ( this._links !== links ) {
        this._links = links;
        this.rebuildRichText();
      }
      return this;
    },
    set links( value ) { this.setLinks( value ); },
    getLinks: function() {
      return this._links;
    },
    get links() { return this.getLinks(); }
  }, {
    himalayaElementToString: function( element, isLTR ) {
      if ( element.type === 'Text' ) {
        return RichText.contentToString( element.content, isLTR );
      }
      else if ( element.type === 'Element' ) {
        if ( element.tagName === 'span' && element.attributes.dir ) {
          isLTR = element.attributes.dir === 'ltr';
        }
        return element.children.map( function( child ) {
          return RichText.himalayaElementToString( child, isLTR );
        } ).join( '' );
      }
      else {
        return '';
      }
    },
    himalayaElementToAccessibleString: function( element, isLTR ) {
      if ( element.type === 'Text' ) {
        return RichText.contentToString( element.content, isLTR );
      }
      else if ( element.type === 'Element' ) {
        if ( element.tagName === 'span' && element.attributes.dir ) {
          isLTR = element.attributes.dir === 'ltr';
        }
        var content = element.children.map( function( child ) {
          return RichText.himalayaElementToAccessibleString( child, isLTR );
        } ).join( '' );
        if ( _.includes( ACCESSIBLE_TAGS, element.tagName ) ) {
          return '<' + element.tagName + '>' + content + '</' + element.tagName + '>';
        }
        else {
          return content;
        }
      }
      else {
        return '';
      }
    },
    contentToString: function( content, isLTR ) {
      var unescapedContent = _.unescape( content );
      return isLTR ? ( '\u202a' + unescapedContent + '\u202c' ) : ( '\u202b' + unescapedContent + '\u202c' );
    }
  } );
} );
define( 'SHRED/view/IsotopeNode',['require','SHRED/AtomIdentifier','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/util/RadialGradient','SHRED/shred','SCENERY_PHET/RichText'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var shred = require( 'SHRED/shred' );
  var RichText = require( 'SCENERY_PHET/RichText' );
  function IsotopeNode( isotope, radius, options ) {
    options = _.extend( {
      showLabel: true
    }, options );
    Node.call( this, options ); // Call super constructor.
    var baseColor = isotope.color;
    if ( baseColor === undefined ) {
      assert && assert( false, 'Unrecognized Isotope' );
      baseColor = 'black';
    }
    var isotopeSphere = new Circle( radius, {
      fill: baseColor,
      cursor: 'pointer'
    } );
    this.addChild( isotopeSphere );
    if ( options.showLabel ) {
      var symbol = AtomIdentifier.getSymbol( isotope.protonCount );
      var label = new RichText( ' <sup>' + isotope.massNumber + '</sup>' + symbol, {
        font: new PhetFont( 10 ),
        maxWidth: 2 * radius - 2
      } );
      label.centerX = isotopeSphere.centerX - 1; // empirically determined -1 to make it appear centered
      label.centerY = isotopeSphere.centerY;
      isotopeSphere.addChild( label );
      isotopeSphere.fill = new RadialGradient(
        -radius * 0.4,
        -radius * 0.4,
        0,
        -radius * 0.4,
        -radius * 0.4,
        radius * 1.6
      )
        .addColorStop( 0, 'white' )
        .addColorStop( 1, baseColor );
    }
    else{
      isotopeSphere.stroke = 'black';
    }
  }
  shred.register( 'IsotopeNode', IsotopeNode );
  return inherit( Node, IsotopeNode );
} );
define( 'SCENERY_PHET/input/MovableDragHandler',['require','DOT/Bounds2','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','TANDEM/scenery/input/TandemSimpleDragHandler','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var TandemSimpleDragHandler = require( 'TANDEM/scenery/input/TandemSimpleDragHandler' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  function MovableDragHandler( locationProperty, options ) {
    var self = this;
    options = _.extend( {
      dragBounds: Bounds2.EVERYTHING, // {Bounds2} dragging will be constrained to these bounds, in model coordinate frame
      modelViewTransform: ModelViewTransform2.createIdentity(), // {ModelViewTransform2} defaults to identity
      startDrag: function( event ) {},  // use this to do something at the start of dragging, like moving a node to the foreground
      onDrag: function( event ) {}, // use this to do something every time drag is called, such as notify that a user has modified the position
      endDrag: function( event ) {},  // use this to do something at the end of dragging, like 'snapping'
      allowTouchSnag: true, // Override this with false to prevent touch snagging.
      targetNode: null,
      tandem: Tandem.tandemRequired()
    }, options );
    this.locationProperty = locationProperty; // @private
    this._dragBounds = options.dragBounds.copy(); // @private
    this._modelViewTransform = options.modelViewTransform; // @private
    var startOffset; // where the drag started relative to locationProperty, in parent view coordinates
    this.movableDragHandlerStart = function( event, trail ) {
      options.startDrag( event );
      var location = self._modelViewTransform.modelToViewPosition( locationProperty.get() );
      if ( options.targetNode ) {
        startOffset = options.targetNode.globalToParentPoint( event.pointer.point );
      }
      else {
        startOffset = trail.globalToLocalPoint( event.pointer.point );
      }
      startOffset = startOffset.minus( location );
    };
    this.movableDragHandlerDrag = function( event, trail ) {
      var parentPoint;
      if ( options.targetNode ) {
        parentPoint = options.targetNode.globalToParentPoint( event.pointer.point );
      }
      else {
        parentPoint = trail.globalToLocalPoint( event.pointer.point );
      }
      parentPoint = parentPoint.minus( startOffset );
      var location = self._modelViewTransform.viewToModelPosition( parentPoint );
      location = self._dragBounds.closestPointTo( location );
      locationProperty.set( location );
      options.onDrag( event );
    };
    this.movableDragHandlerEnd = function( event, trail ) {
      options.endDrag( event );
    };
    TandemSimpleDragHandler.call( this, {
      tandem: options.tandem,
      allowTouchSnag: options.allowTouchSnag,
      start: this.movableDragHandlerStart,
      drag: this.movableDragHandlerDrag,
      end: this.movableDragHandlerEnd
    } );
  }
  sceneryPhet.register( 'MovableDragHandler', MovableDragHandler );
  return inherit( TandemSimpleDragHandler, MovableDragHandler, {
    setDragBounds: function( dragBounds ) {
      this._dragBounds = dragBounds.copy();
      this.locationProperty.set( this._dragBounds.closestPointTo( this.locationProperty.get() ) );
    },
    set dragBounds( value ) { this.setDragBounds( value ); },
    getDragBounds: function() {
      return this._dragBounds;
    },
    get dragBounds() { return this.getDragBounds(); },
    setModelViewTransform: function( modelViewTransform ) {
      this._modelViewTransform = modelViewTransform;
    },
    set modelViewTransform( modelViewTransform ) { this.setModelViewTransform( modelViewTransform ); },
    getModelViewTransform: function() {
      return this._modelViewTransform;
    },
    get modelViewTransform() { return this.getModelViewTransform(); },
    handleForwardedStartEvent: function( event, trail ) {
      this.movableDragHandlerStart( event, trail );
    },
    handleForwardedDragEvent: function( event, trail ) {
      this.movableDragHandlerDrag( event, trail );
    },
    handleForwardedEndEvent: function( event, trail ) {
      this.movableDragHandlerEnd( event, trail );
    }
  } );
} );
define( 'SHRED/view/ParticleView',['require','DOT/Bounds2','PHET_CORE/inherit','SHRED/view/IsotopeNode','SCENERY_PHET/input/MovableDragHandler','SCENERY/nodes/Node','SHRED/view/ParticleNode','SHRED/shred','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Bounds2 = require( 'DOT/Bounds2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var IsotopeNode = require( 'SHRED/view/IsotopeNode' );
  var MovableDragHandler = require( 'SCENERY_PHET/input/MovableDragHandler' );
  var Node = require( 'SCENERY/nodes/Node' );
  var ParticleNode = require( 'SHRED/view/ParticleNode' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  function createParticleNode( particle, modelViewTransform, highContrastProperty, tandem ) {
    var particleNode;
    if ( particle.type === 'Isotope' ) {
      particleNode = new IsotopeNode(
        particle,
        modelViewTransform.modelToViewDeltaX( particle.radiusProperty.get() ),
        { showLabel: particle.showLabel, tandem: tandem }
      );
    }
    else {
      particleNode = new ParticleNode(
        particle.type,
        modelViewTransform.modelToViewDeltaX( particle.radiusProperty.get() ),
        {
          highContrastProperty: highContrastProperty,
          tandem: tandem
        }
      );
    }
    return particleNode;
  }
  function ParticleView( particle, modelViewTransform, options ) {
    options = _.extend( {
      dragBounds: Bounds2.EVERYTHING,
      highContrastProperty: null,
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this ); // Call super constructor.
    var self = this;
    this.particle = particle; // @public
    this.modelViewTransform = modelViewTransform; // @private
    this.addChild( createParticleNode(
      particle,
      modelViewTransform,
      options.highContrastProperty,
      options.tandem.createTandem( 'particleRepresentation' )
    ) );
    var updateParticlePosition = function( position ) {
      self.translation = self.modelViewTransform.modelToViewPosition( position );
    };
    particle.positionProperty.link( updateParticlePosition );
    this.addInputListener( new MovableDragHandler( particle.destinationProperty, {
      tandem: options.tandem ? options.tandem.createTandem( 'inputListener' ) : null,
      startDrag: function( event, trail ) {
        self.particle.userControlledProperty.set( true );
        if ( !particle.positionProperty.get().equals( particle.destinationProperty.get() ) ) {
          particle.destinationProperty.set( particle.positionProperty.get() );
        }
      },
      onDrag: function( event, trail ) {
        self.particle.moveImmediatelyToDestination();
      },
      endDrag: function( event, trail ) {
        self.particle.userControlledProperty.set( false );
      },
      modelViewTransform: modelViewTransform,
      dragBounds: options.dragBounds
    } ) );
    this.mutate( options );
    this.disposeParticleView = function() {
      particle.positionProperty.unlink( updateParticlePosition );
    };
  }
  shred.register( 'ParticleView', ParticleView );
  return inherit( Node, ParticleView, {
    dispose: function() {
      this.disposeParticleView();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'SHRED/view/TPeriodicTableCell',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit','SHRED/shred'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var shred = require( 'SHRED/shred' );
  function TPeriodicTableCell( periodicTableCell, phetioID ) {
    assertInstanceOf( periodicTableCell, phet.shred.PeriodicTableCell );
    TObject.call( this, periodicTableCell, phetioID );
    toEventOnEmit(
      periodicTableCell.startedCallbacksForPressedEmitter,
      periodicTableCell.endedCallbacksForPressedEmitter,
      'user',
      phetioID,
      TPeriodicTableCell,
      'fired'
    );
  }
  phetioInherit( TObject, 'TPeriodicTableCell', TPeriodicTableCell, {}, {
    documentation: 'The type that wraps a periodic table cell.',
    events: [ 'fired' ],
    fromStateObject: function( stateObject ) {
      return new phet.dot.Vector2( stateObject.x, stateObject.y );
    },
    toStateObject: function( instance ) {
      return { x: instance.x, y: instance.y };
    }
  } );
  shred.register( 'TPeriodicTableCell', TPeriodicTableCell );
  return TPeriodicTableCell;
} );
define( 'SHRED/view/PeriodicTableCell',['require','SHRED/AtomIdentifier','SCENERY/input/ButtonListener','AXON/Emitter','PHET_CORE/inherit','SCENERY_PHET/PhetColorScheme','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','SHRED/shred','SCENERY/nodes/Text','TANDEM/Tandem','SHRED/view/TPeriodicTableCell'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var shred = require( 'SHRED/shred' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPeriodicTableCell = require( 'SHRED/view/TPeriodicTableCell' );
  var NOMINAL_CELL_DIMENSION = 25;
  var NOMINAL_FONT_SIZE = 14;
  function PeriodicTableCell( atomicNumber, numberAtom, cellColor, options ) {
    options = _.extend( {
      length: 25, //Width and height of cell (cells are square).
      interactive: false, // Boolean flag that determines whether cell is interactive.
      showLabels: true,
      tandem: Tandem.tandemRequired()
    }, options );
    var self = this;
    this.options = options;
    this.startedCallbacksForPressedEmitter = new Emitter();
    this.endedCallbacksForPressedEmitter = new Emitter();
    this.normalFill = options.interactive ? cellColor.enabled : cellColor.disabled;
    this.highlightedFill = cellColor.selected;
    Rectangle.call( this, 0, 0, options.length, options.length, 0, 0, {
      stroke: 'black',
      lineWidth: 1,
      fill: this.normalFill,
      cursor: options.interactive ? 'pointer' : null
    } ); // Call super constructor.
    if ( options.showLabels ) {
      this.label = new Text( AtomIdentifier.getSymbol( atomicNumber ), {
        font: new PhetFont( NOMINAL_FONT_SIZE * ( options.length / NOMINAL_CELL_DIMENSION ) ),
        center: this.center,
        maxWidth: options.length - 5,
        tandem: options.tandem.createTandem( 'label' )
      } );
      this.addChild( this.label );
    }
    if ( options.interactive ) {
      this.addInputListener(
        new ButtonListener( {
          tandem: options.tandem.createTandem( 'buttonListener' ),
          fire: function( evt ) {
            self.startedCallbacksForPressedEmitter.emit();
            numberAtom.setSubAtomicParticleCount(
              atomicNumber,
              AtomIdentifier.getNumNeutronsInMostCommonIsotope( atomicNumber ),
              atomicNumber
            );
            self.endedCallbacksForPressedEmitter.emit();
          }
        } )
      );
    }
    options.tandem.addInstance( this, TPeriodicTableCell );
  }
  shred.register( 'PeriodicTableCell', PeriodicTableCell );
  return inherit( Rectangle, PeriodicTableCell, {
    setHighlighted: function( highLighted ) {
      this.fill = highLighted ? this.highlightedFill : this.normalFill;
      this.stroke = highLighted ? PhetColorScheme.RED_COLORBLIND : 'black';
      this.lineWidth = highLighted ? 2 : 1;
      if ( this.options.showLabels ) {
        this.label.fontWeight = highLighted ? 'bold' : 'normal';
      }
    }
  } );
} );
define( 'SHRED/view/PeriodicTableNode',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SHRED/view/PeriodicTableCell','SHRED/ShredConstants','SHRED/shred','DOT/Vector2','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PeriodicTableCell = require( 'SHRED/view/PeriodicTableCell' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var shred = require( 'SHRED/shred' );
  var Vector2 = require( 'DOT/Vector2' );
  var Tandem = require( 'TANDEM/Tandem' );
  var POPULATED_CELLS = [
    [ 0, 17 ],
    [ 0, 1, 12, 13, 14, 15, 16, 17 ],
    [ 0, 1, 12, 13, 14, 15, 16, 17 ],
    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ],
    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ],
    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ],
    [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 ]
  ];
  var ENABLED_CELL_COLOR = ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR;
  var DISABLED_CELL_COLOR = '#EEEEEE';
  var SELECTED_CELL_COLOR = '#FA8072'; //salmon
  function PeriodicTableNode( numberAtom, options ) {
    options = _.extend( {
      interactiveMax: 0, //Atomic number of the heaviest element that should be interactive
      cellDimension: 25,
      showLabels: true,
      enabledCellColor: ENABLED_CELL_COLOR,
      disabledCellColor: DISABLED_CELL_COLOR,
      selectedCellColor: SELECTED_CELL_COLOR,
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this ); // Call super constructor.
    var self = this;
    this.cells = []; // @private
    var elementIndex = 1;
    var rowGroupTandem = options.tandem && options.tandem.createGroupTandem( 'row' );
    for ( var i = 0; i < POPULATED_CELLS.length; i++ ) {
      var populatedCellsInRow = POPULATED_CELLS[ i ];
      var rowTandem = rowGroupTandem && rowGroupTandem.createNextTandem();
      var columnGroupTandem = rowTandem && rowTandem.createGroupTandem( 'column' );
      var cellColor = {
        'enabled': options.enabledCellColor,
        'disabled': options.disabledCellColor,
        'selected': options.selectedCellColor
      };
      for ( var j = 0; j < populatedCellsInRow.length; j++ ) {
        var cell = new PeriodicTableCell( elementIndex, numberAtom, cellColor, {
          interactive: elementIndex <= options.interactiveMax,
          showLabels: options.showLabels,
          length: options.cellDimension,
          tandem: columnGroupTandem && columnGroupTandem.createNextTandem()
        } );
        cell.translation = new Vector2( populatedCellsInRow[ j ] * options.cellDimension, i * options.cellDimension );
        this.addChild( cell );
        this.cells.push( cell );
        elementIndex++;
        if ( elementIndex === 58 ) {
          elementIndex = 72;
        }
        if ( elementIndex === 90 ) {
          elementIndex = 104;
        }
      }
    }
    var updateHighlightedCell = function( protonCount ) {
      if ( highlightedCell !== null ) {
        highlightedCell.setHighlighted( false );
      }
      if ( protonCount > 0 && protonCount <= 118 ) {
        var elementIndex = protonCount;
        if ( protonCount >= 72 ) {
          elementIndex = elementIndex - 14;
        }
        if ( protonCount >= 104 && protonCount <= 118 ) {
          elementIndex = elementIndex - 14;
        }
        highlightedCell = self.cells[ elementIndex - 1 ];
        highlightedCell.moveToFront();
        highlightedCell.setHighlighted( true );
      }
    };
    var highlightedCell = null;
    numberAtom.protonCountProperty.link( updateHighlightedCell );
    this.disposePeriodicTableNode = function() {
      numberAtom.protonCountProperty.unlink( updateHighlightedCell );
    };
  }
  shred.register( 'PeriodicTableNode', PeriodicTableNode );
  return inherit( Node, PeriodicTableNode, {
    dispose: function(){
      this.disposePeriodicTableNode();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/buildanatom/view/PeriodicTableAndSymbol',['require','SHRED/AtomIdentifier','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY/nodes/Node','SHRED/view/PeriodicTableNode','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','DOT/Vector2'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PeriodicTableNode = require( 'SHRED/view/PeriodicTableNode' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var SYMBOL_WIDTH_PROPORTION = 0.2;
  var SYMBOL_ASPECT_RATIO = 1.0; // Width/height.
  function PeriodicTableAndSymbol( numberAtom, tandem, options ) {
    Node.call( this ); // Call super constructor.
    var periodicTable = new PeriodicTableNode( numberAtom, {
      interactiveMax: 0,
      disabledCellColor: 'white',
      tandem: tandem.createTandem( 'periodicTable' )
    } );
    this.addChild( periodicTable );
    var symbolRectangle = new Rectangle(
      0,
      0,
      periodicTable.width * SYMBOL_WIDTH_PROPORTION,
      periodicTable.width * SYMBOL_WIDTH_PROPORTION / SYMBOL_ASPECT_RATIO,
      {
        fill: 'white',
        stroke: 'black',
        lineWidth: 2,
        tandem: tandem.createTandem( 'symbolRectangle' )
      }
    );
    this.addChild( symbolRectangle );
    numberAtom.protonCountProperty.link( function( protonCount ) {
      symbolRectangle.removeAllChildren();
      var symbolText = new Text( AtomIdentifier.getSymbol( protonCount ), {
        font: new PhetFont( { size: 48, weight: 'bold' } )
      } );
      symbolText.scale( Math.min( Math.min( symbolRectangle.width * 0.8 / symbolText.width, symbolRectangle.height * 0.8 / symbolText.height ), 1 ) );
      symbolText.center = new Vector2( symbolRectangle.width / 2, symbolRectangle.height / 2 );
      symbolRectangle.addChild( symbolText );
    } );
    symbolRectangle.centerX = (7.5 / 18 ) * periodicTable.width;
    symbolRectangle.top = 0;
    periodicTable.top = symbolRectangle.bottom - ( periodicTable.height / 7 * 2.5);
    periodicTable.left = 0;
    options.tandem = tandem;
    this.mutate( options );
  }
  buildAnAtom.register( 'PeriodicTableAndSymbol', PeriodicTableAndSymbol );
  return inherit( Node, PeriodicTableAndSymbol );
} );
define( 'SCENERY_PHET/ResetShape',['require','PHET_CORE/inherit','KITE/Shape','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  function ResetShape( radius ) {
    Shape.call( this );
    var INNER_RADIUS = radius * 0.4;
    var OUTER_RADIUS = radius * 0.625;
    var HEAD_WIDTH = 2.25 * ( OUTER_RADIUS - INNER_RADIUS );
    var START_ANGLE = -Math.PI * 0.35;
    var END_TO_NECK_ANGULAR_SPAN = -2 * Math.PI * 0.85;
    var ARROW_HEAD_ANGULAR_SPAN = -Math.PI * 0.18;
    this.moveTo( INNER_RADIUS * Math.cos( START_ANGLE ), INNER_RADIUS * Math.sin( START_ANGLE ) );
    this.lineTo( OUTER_RADIUS * Math.cos( START_ANGLE ), OUTER_RADIUS * Math.sin( START_ANGLE ) );
    var neckAngle = START_ANGLE + END_TO_NECK_ANGULAR_SPAN;
    this.arc( 0, 0, OUTER_RADIUS, START_ANGLE, neckAngle, true );
    var HEAD_WIDTHExtrusion = ( HEAD_WIDTH - ( OUTER_RADIUS - INNER_RADIUS ) ) / 2;
    this.lineTo(
      ( OUTER_RADIUS + HEAD_WIDTHExtrusion ) * Math.cos( neckAngle ),
      ( OUTER_RADIUS + HEAD_WIDTHExtrusion ) * Math.sin( neckAngle ) );
    var pointRadius = ( OUTER_RADIUS + INNER_RADIUS ) * 0.55; // Tweaked a little from center for better look.
    this.lineTo(
      pointRadius * Math.cos( neckAngle + ARROW_HEAD_ANGULAR_SPAN ),
      pointRadius * Math.sin( neckAngle + ARROW_HEAD_ANGULAR_SPAN ) );
    this.lineTo(
      ( INNER_RADIUS - HEAD_WIDTHExtrusion ) * Math.cos( neckAngle ),
      ( INNER_RADIUS - HEAD_WIDTHExtrusion ) * Math.sin( neckAngle ) );
    this.lineTo(
      INNER_RADIUS * Math.cos( neckAngle ),
      INNER_RADIUS * Math.sin( neckAngle ) );
    this.arc( 0, 0, INNER_RADIUS, neckAngle, START_ANGLE );
    this.close();
  }
  sceneryPhet.register( 'ResetShape', ResetShape );
  return inherit( Shape, ResetShape );
} );
define( 'AXON/TDerivedProperty',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TVoid','AXON/TProperty'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TProperty = require( 'AXON/TProperty' );
  function TDerivedProperty( phetioValueType ) {
    var TPropertyImpl = new TProperty( phetioValueType );
    var TDerivedPropertyImpl = function TDerivedPropertyImpl( property, phetioID ) {
      assert && assert( !!phetioValueType, 'TDerivedProperty needs phetioValueType' );
      TPropertyImpl.call( this, property, phetioID );
      assertInstanceOf( property, phet.axon.DerivedProperty );
    };
    return phetioInherit( TPropertyImpl, 'TDerivedProperty', TDerivedPropertyImpl, {
      setValue: {
        returnType: TVoid,
        parameterTypes: [ phetioValueType ],
        implementation: function( value ) {
          return this.instance.set( value );
        },
        documentation: 'Errors out when you try to set a derived property.'
      }
    }, {
      documentation: 'Like TProperty, but not settable.  Instead it is derived from other TDerivedProperty or TProperty ' +
                     'instances',
      valueType: phetioValueType,
      events: [ 'changed' ],
      fromStateObject: function( stateObject ) {
        return phetioValueType.fromStateObject( stateObject );
      },
      toStateObject: function( instance ) {
        return phetioValueType.toStateObject( instance.value );
      }
    } );
  }
  axon.register( 'TDerivedProperty', TDerivedProperty );
  return TDerivedProperty;
} );
define( 'AXON/DerivedProperty',['require','AXON/Property','AXON/axon','PHET_CORE/inherit','AXON/TDerivedProperty','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var TDerivedProperty = require( 'AXON/TDerivedProperty' );
  var Tandem = require( 'TANDEM/Tandem' );
  function equalsFunction( a, b ) {
    return a === b;
  }
  function conjunctionWithProperty( value, property ) {
    return value && property.value;
  }
  function disjunctionWithProperty( value, property ) {
    return value || property.value;
  }
  function DerivedProperty( dependencies, derivation, options ) {
    options = _.extend( {
      tandem: Tandem.tandemOptional()
    }, options );
    this.dependencies = dependencies; // @private
    this.dependencyValues = dependencies.map( function( property ) {return property.get();} );
    var initialValue = derivation.apply( null, this.dependencyValues );
    Property.call( this, initialValue, _.extend( {}, options, {
      tandem: options.tandem && options.tandem.createSupertypeTandem()
    } ) );
    var self = this;
    this.dependencyListeners = [];
    for ( var i = 0; i < dependencies.length; i++ ) {
      var dependency = dependencies[ i ];
      (function( dependency, i ) {
        var listener = function( newValue ) {
          self.dependencyValues[ i ] = newValue;
          Property.prototype.set.call( self, derivation.apply( null, self.dependencyValues ) );
        };
        self.dependencyListeners.push( listener );
        dependency.lazyLink( listener );
      })( dependency, i );
    }
    options.tandem.supplied && options.tandem.addInstance( this, TDerivedProperty( options.phetioValueType ) );
    this.disposeDerivedProperty = function() {
      options.tandem && options.tandem.removeInstance( self );
    };
  }
  axon.register( 'DerivedProperty', DerivedProperty );
  return inherit( Property, DerivedProperty, {
    dispose: function() {
      Property.prototype.dispose.call( this );
      this.disposeDerivedProperty();
      for ( var i = 0; i < this.dependencies.length; i++ ) {
        var dependency = this.dependencies[ i ];
        dependency.unlink( this.dependencyListeners[ i ] );
      }
      this.dependencies = null;
      this.dependencyListeners = null;
      this.dependencyValues = null;
    },
    set: function( value ) { throw new Error( 'Cannot set values directly to a derived property, tried to set: ' + value ); },
    set value( newValue ) { throw new Error( 'Cannot es5-set values directly to a derived property, tried to set: ' + newValue ); },
    get value() {return Property.prototype.get.call( this );},
    reset: function() { throw new Error( 'Cannot reset a derived property directly' ); }
  }, {
    valueEquals: function( firstProperty, secondProperty, options ) {
      return new DerivedProperty( [ firstProperty, secondProperty ], equalsFunction, options );
    },
    and: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, conjunctionWithProperty, true ), options ); // TODO: fix
    },
    or: function( properties, options ) {
      return new DerivedProperty( properties, _.reduce.bind( null, properties, disjunctionWithProperty, false ), options );
    }
  } );
} );
define( 'SUN/buttons/PushButtonInteractionStateProperty',['require','PHET_CORE/inherit','AXON/DerivedProperty','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var sun = require( 'SUN/sun' );
  function PushButtonInteractionStateProperty( buttonModel, options ) {
    DerivedProperty.call(
      this,
      [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty ],
      function( over, down, enabled ) {
        return !enabled ? 'disabled' :
               over && !down ? 'over' :
               over && down ? 'pressed' :
               'idle';
      }, options );
  }
  sun.register( 'PushButtonInteractionStateProperty', PushButtonInteractionStateProperty );
  return inherit( DerivedProperty, PushButtonInteractionStateProperty );
} );
define( 'SUN/buttons/ButtonModel',['require','PHET_CORE/inherit','AXON/Property','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var sun = require( 'SUN/sun' );
  function ButtonModel( options ) {
    options = _.extend( {
      startCallback: function() {},
      endCallback: function( over ) {},
      enabled: true
    }, options );
    var self = this;
    this.overProperty = new Property( false ); // @public - Is the pointer over the button?
    this.downProperty = new Property( false ); // @public - Is the pointer down?
    this.enabledProperty = new Property( options.enabled ); // @public - Is the button enabled?
    this.downProperty.lazyLink( function( down ) {
      if ( down ) {
        options.startCallback();
      }
      else {
        options.endCallback( self.overProperty.get() );
      }
    } );
  }
  sun.register( 'ButtonModel', ButtonModel );
  return inherit( Object, ButtonModel, {
    dispose: function() {
    }
  } );
} );
define( 'PHET_CORE/Timer',['require','PHET_CORE/cleanArray','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var phetCore = require( 'PHET_CORE/phetCore' );
  var listeners = [];
  var listenersDefensiveCopy = []; // separated out to prevent garbage collection issues
  var Timer = {
    step: function( dt ) {
      var length = listeners.length;
      var i;
      for ( i = 0; i < length; i++ ) {
        listenersDefensiveCopy[ i ] = listeners[ i ];
      }
      for ( i = 0; i < length; i++ ) {
        listenersDefensiveCopy[ i ]( dt );
      }
      cleanArray( listenersDefensiveCopy );
    },
    setTimeout: function( listener, timeout ) {
      var elapsed = 0;
      var self = this;
      var callback = function( dt ) {
        elapsed += dt;
        if ( elapsed * 1000 >= timeout ) {
          listener();
          self.removeStepListener( callback );
        }
      };
      this.addStepListener( callback );
      return callback;
    },
    clearTimeout: function( timeoutID ) {
      if ( this.hasStepListener( timeoutID ) ) {
        this.removeStepListener( timeoutID );
      }
    },
    setInterval: function( listener, interval ) {
      var elapsed = 0;
      var callback = function( dt ) {
        elapsed += dt;
        while ( elapsed * 1000 >= interval && listeners.indexOf( callback ) !== -1 ) {
          listener();
          elapsed = elapsed - interval / 1000.0; //Save the leftover time so it won't accumulate
        }
      };
      this.addStepListener( callback );
      return callback;
    },
    clearInterval: function( intervalID ) {
      if ( this.hasStepListener( intervalID ) ) {
        this.removeStepListener( intervalID );
      }
    },
    addStepListener: function( listener ) {
      listeners.push( listener );
    },
    removeStepListener: function( listener ) {
      var index = listeners.indexOf( listener );
      assert && assert( index !== -1, 'An attempt was made to remove a non-existent step listener' );
      if ( index !== -1 ) {
        listeners.splice( index, 1 );
      }
    },
    hasStepListener: function( listener ) {
      return listeners.indexOf( listener ) >= 0;
    }
  };
  phetCore.register( 'Timer', Timer );
  return Timer;
} );
define( 'SUN/CallbackTimer',['require','PHET_CORE/inherit','PHET_CORE/Timer','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Timer = require( 'PHET_CORE/Timer' );
  var sun = require( 'SUN/sun' );
  function CallbackTimer( options ) {
    options = _.extend( {
      callback: null, // {function} convenience for adding 1 callback
      delay: 400, // {number} start to fire continuously after pressing for this long (milliseconds)
      interval: 100 // {number} fire continuously at this interval (milliseconds)
    }, options );
    assert && assert( options.delay >= 0, 'bad value for delay: ' + options.delay );
    assert && assert( options.interval > 0, 'bad value for interval: ' + options.interval );
    this.delay = options.delay; // @private
    this.interval = options.interval; // @private
    this.callbacks = []; // @private
    if ( options.callback ) { this.callbacks.push( options.callback ); }
    this.delayID = null; // @private identifier for timer associated with the initial delay
    this.intervalID = null; // @private identifier for timer associates with the continuous interval
    this.fired = false;  // @private has the timer fired since it was started?
  }
  sun.register( 'CallbackTimer', CallbackTimer );
  return inherit( Object, CallbackTimer, {
    isRunning: function() {
      return ( this.delayID !== null || this.intervalID !== null );
    },
    start: function() {
      var self = this;
      if ( !self.isRunning() ) {
        self.fired = false;
        self.delayID = Timer.setTimeout( function() {
          self.delayID = null;
          self.intervalID = Timer.setInterval( function() {
            self.fire();
          }, self.interval );
          self.fire();
        }, self.delay );
      }
    },
    stop: function( fire ) {
      if ( this.isRunning() ) {
        if ( this.delayID ) {
          Timer.clearTimeout( this.delayID );
          this.delayID = null;
        }
        if ( this.intervalID ) {
          Timer.clearInterval( this.intervalID );
          this.intervalID = null;
        }
        if ( fire && !this.fired ) {
          this.fire();
        }
      }
    },
    addCallback: function( callback ) {
      if ( this.callbacks.indexOf( callback ) === -1 ) {
        this.callbacks.push( callback );
      }
    },
    removeCallback: function( callback ) {
      var index = this.callbacks.indexOf( callback );
      if ( index !== -1 ) {
        this.callbacks.splice( index, 1 );
      }
    },
    fire: function() {
      var callbacksCopy = this.callbacks.slice( 0 );
      for ( var i = 0; i < callbacksCopy.length; i++ ) {
        callbacksCopy[ i ]();
      }
      this.fired = true;
    },
    dispose: function() {
      this.stop();
      this.callbacks.length = 0;
    }
  } );
} );
define( 'TANDEM/axon/TTandemEmitter',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','TANDEM/tandemNamespace','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  function TTandemEmitter( phetioArgumentTypes ) {
    var TTandemEmitterImpl = function TTandemEmitterImpl( tandemEmitter, phetioID ) {
      assert && assert( phetioArgumentTypes, 'phetioArgumentTypes should be defined' );
      TObject.call( this, tandemEmitter, phetioID );
      assertInstanceOf( tandemEmitter, phet.tandem.TandemEmitter );
      var messageIndex = null;
      if ( tandemEmitter.phetioEmitData ) {
        tandemEmitter.callbacksStartedEmitter.addListener( function() {
          assert && assert( arguments.length === phetioArgumentTypes.length, 'Wrong number of arguments, expected ' + phetioArgumentTypes.length + ', received ' + arguments.length );
          var p = [];
          for ( var i = 0; i < arguments.length; i++ ) {
            var a = arguments[ i ];
            p.push( a );
          }
          var parameters = { arguments: p };
          messageIndex = phetioEvents.start( 'model', phetioID, TTandemEmitter( phetioArgumentTypes ), 'emitted', parameters );
        } );
        tandemEmitter.callbacksEndedEmitter.addListener( function() {
          assert && assert( arguments.length === 0, 'Wrong number of arguments, expected ' + phetioArgumentTypes.length + ', received ' + arguments.length );
          messageIndex && phetioEvents.end( messageIndex );
        } );
      }
    };
    return phetioInherit( TObject, 'TTandemEmitter', TTandemEmitterImpl, {
      addListener: {
        returnType: TVoid,
        parameterTypes: [ TFunctionWrapper( TVoid, phetioArgumentTypes ) ],
        implementation: function( listener ) {
          this.instance.addListener( listener );
        },
        documentation: 'Add a listener which will be called when the emitter emits.'
      }
    }, {
      documentation: 'Emitters indicate when events have occurred, with optional arguments describing the event',
      events: [ 'emitted' ]
    } );
  }
  tandemNamespace.register( 'TTandemEmitter', TTandemEmitter );
  return TTandemEmitter;
} );
define( 'TANDEM/axon/TandemEmitter',['require','PHET_CORE/inherit','AXON/Emitter','TANDEM/tandemNamespace','TANDEM/Tandem','TANDEM/axon/TTandemEmitter'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var tandemNamespace = require( 'TANDEM/tandemNamespace' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TTandemEmitter = require( 'TANDEM/axon/TTandemEmitter' );
  function TandemEmitter( options ) {
    options = _.extend( {
      phetioArgumentTypes: null,
      tandem: Tandem.tandemRequired(),
      phetioEmitData: true // Can be overriden to suppress data from the phet-io data stream
    }, options );
    var self = this;
    this.phetioEmitData = options.phetioEmitData;
    Emitter.call( this );
    this.callbacksStartedEmitter = new Emitter();
    this.callbacksEndedEmitter = new Emitter();
    options.tandem.addInstance( this, TTandemEmitter( options.phetioArgumentTypes ) );
    this.disposeTandemEmitter = function() {
      this.listeners.length = 0;
      options.tandem.removeInstance( self );
    };
  }
  tandemNamespace.register( 'TandemEmitter', TandemEmitter );
  return inherit( Emitter, TandemEmitter, {
    emit: function() {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit();
      Emitter.prototype.emit.call( this );
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },
    emit1: function( arg ) {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit1( arg );
      Emitter.prototype.emit1.call( this, arg );
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },
    emit2: function( arg1, arg2 ) {
      this.callbacksStartedEmitter && this.callbacksStartedEmitter.emit2( arg1, arg2 );
      Emitter.prototype.emit2.call( this, arg1, arg2 );
      this.callbacksEndedEmitter && this.callbacksEndedEmitter.emit();
    },
    dispose: function() {
      this.disposeTandemEmitter();
      Emitter.prototype.dispose.call( this );
    }
  } );
} );
define( 'SUN/buttons/PushButtonModel',['require','SUN/buttons/ButtonModel','SUN/CallbackTimer','PHET_CORE/inherit','SUN/sun','AXON/Emitter','TANDEM/axon/TandemEmitter','TANDEM/Tandem'],function( require ) {
  'use strict';
  var ButtonModel = require( 'SUN/buttons/ButtonModel' );
  var CallbackTimer = require( 'SUN/CallbackTimer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  var Emitter = require( 'AXON/Emitter' );
  var TandemEmitter = require( 'TANDEM/axon/TandemEmitter' );
  var Tandem = require( 'TANDEM/Tandem' );
  function PushButtonModel( options ) {
    options = _.extend( {
      fireOnDown: false, // true: fire on pointer down; false: fire on pointer up if pointer is over button
      listener: null, // {function} convenience for adding 1 listener, no args
      fireOnHold: false, // is the fire-on-hold feature enabled?
      fireOnHoldDelay: 400, // start to fire continuously after pressing for this long (milliseconds)
      fireOnHoldInterval: 100, // fire continuously at this interval (milliseconds),
      tandem: Tandem.tandemOptional()
    }, options );
    var self = this;
    ButtonModel.call( this, options );
    if ( options.tandem.supplied ) {
      this.startedCallbacksForFiredEmitter = new TandemEmitter( {
        tandem: options.tandem.createTandem( 'startedFiredEmitter' ),
        phetioArgumentTypes: [],
        phetioEmitData: false
      } );
      this.endedCallbacksForFiredEmitter = new TandemEmitter( {
        tandem: options.tandem.createTandem( 'endedFiredEmitter' ),
        phetioArgumentTypes: [],
        phetioEmitData: false
      } );
    }
    else {
      this.startedCallbacksForFiredEmitter = new Emitter();
      this.endedCallbacksForFiredEmitter = new Emitter();
    }
    this.listeners = []; // @private
    if ( options.listener !== null ) {
      this.listeners.push( options.listener );
    }
    if ( options.fireOnHold ) {
      this.timer = new CallbackTimer( {
        callback: this.fire.bind( this ),
        delay: options.fireOnHoldDelay,
        interval: options.fireOnHoldInterval
      } );
    }
    this.downProperty.link( function( down ) {
      if ( down ) {
        if ( self.enabledProperty.get() ) {
          if ( options.fireOnDown ) {
            self.fire();
          }
          if ( self.timer ) {
            self.timer.start();
          }
        }
      }
      else {
        var fire = ( !options.fireOnDown && self.overProperty.get() && self.enabledProperty.get() ); // should the button fire?
        if ( self.timer ) {
          self.timer.stop( fire );
        }
        else if ( fire ) {
          self.fire();
        }
      }
    } );
    this.enabledProperty.link( function( enabled ) {
      if ( !enabled && self.timer ) {
        self.timer.stop( false ); // Stop the timer, don't fire if we haven't already
      }
    } );
    this.disposePushButtonModel = function() {
      this.listeners.length = 0;
      if ( this.timer ) {
        this.timer.dispose();
        this.timer = null;
      }
      this.startedCallbacksForFiredEmitter.dispose();
      this.endedCallbacksForFiredEmitter.dispose();
    };
  }
  sun.register( 'PushButtonModel', PushButtonModel );
  return inherit( ButtonModel, PushButtonModel, {
    dispose: function() {
      this.disposePushButtonModel();
      ButtonModel.prototype.dispose.call( this );
    },
    addListener: function( listener ) {
      if ( this.listeners.indexOf( listener ) === -1 ) {
        this.listeners.push( listener );
      }
    },
    removeListener: function( listener ) {
      var i = this.listeners.indexOf( listener );
      if ( i !== -1 ) {
        this.listeners.splice( i, 1 );
      }
    },
    fire: function() {
      this.startedCallbacksForFiredEmitter.emit();
      var copy = this.listeners.slice( 0 );
      copy.forEach( function( listener ) {
        listener();
      } );
      this.endedCallbacksForFiredEmitter.emit();
    }
  } );
} );
define( 'SUN/buttons/ButtonListener',['require','SCENERY/input/DownUpListener','SCENERY/input/Input','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';
  var DownUpListener = require( 'SCENERY/input/DownUpListener' );
  var Input = require( 'SCENERY/input/Input' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  function ButtonListener( buttonModel ) {
    this.buttonModel = buttonModel; // @private
    var self = this;
    this.overPointer = null; // @private
    this.downPointer = null; // @private
    DownUpListener.call( this, {
      down: function( event, trail ) {
        if ( self.downPointer === null ) {
          self.downPointer = event.pointer;
        }
        if ( event.pointer === self.downPointer ) {
          buttonModel.downProperty.set( true );
        }
      },
      up: function( event, trail ) {
        if ( event.pointer === self.downPointer ) {
          self.downPointer = null;
          buttonModel.downProperty.set( false );
        }
      }
    } );
  }
  sun.register( 'ButtonListener', ButtonListener );
  return inherit( DownUpListener, ButtonListener, {
    keydown: function( event, trail ) {
      if ( event.domEvent.keyCode === Input.KEY_ENTER || event.domEvent.keyCode === Input.KEY_SPACE ) {
        this.enter( event, trail );
        this.buttonModel.downProperty.set( true );
      }
    },
    keyup: function( event, trail ) {
      if ( event.domEvent.keyCode === Input.KEY_ENTER || event.domEvent.keyCode === Input.KEY_SPACE ) {
        this.buttonModel.downProperty.set( false );
        this.exit( event, trail );
      }
    },
    enter: function( event, trail ) {
      if ( this.overPointer === null ) {
        this.overPointer = event.pointer;
        this.buttonModel.overProperty.set( true );
      }
    },
    exit: function( event, trail ) {
      if ( event.pointer === this.overPointer ) {
        this.overPointer = null;
        this.buttonModel.overProperty.set( false );
      }
    }
  } );
} );
define( 'SUN/ColorConstants',['require','SCENERY/util/Color','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  function ColorConstants() {
  }
  sun.register( 'ColorConstants', ColorConstants );
  return inherit( Object, ColorConstants, {}, {
    LIGHT_BLUE: new Color( 153, 206, 255 ),
    LIGHT_GRAY: new Color( 220, 220, 220 )
  } );
} );
define( 'SUN/buttons/RoundButtonView',['require','SUN/buttons/ButtonListener','SCENERY/nodes/Circle','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/Property','SCENERY/util/RadialGradient','KITE/Shape','SUN/sun','DOT/Vector2'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var RadialGradient = require( 'SCENERY/util/RadialGradient' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var Vector2 = require( 'DOT/Vector2' );
  var HIGHLIGHT_GRADIENT_LENGTH = 5; // In screen coords, which are roughly pixels.
  var DEFAULT_COLOR = ColorConstants.LIGHT_BLUE;
  function RoundButtonView( buttonModel, interactionStateProperty, options ) {
    this.buttonModel = buttonModel; // @protected
    options = _.extend( {
      radius: ( options && options.content ) ? undefined : 30,
      content: null,
      cursor: 'pointer',
      baseColor: DEFAULT_COLOR,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,
      minXMargin: 5, // Minimum margin in x direction, i.e. on left and right
      minYMargin: 5, // Minimum margin in y direction, i.e. on top and bottom
      fireOnDown: false,
      touchAreaDilation: 0, // radius dilation for touch area
      mouseAreaDilation: 0, // radius dilation for mouse area
      stroke: undefined, // undefined by default, which will cause a stroke to be derived from the base color
      lineWidth: 0.5, // Only meaningful if stroke is non-null
      xContentOffset: 0,
      yContentOffset: 0,
      buttonAppearanceStrategy: RoundButtonView.ThreeDAppearanceStrategy,
      contentAppearanceStrategy: RoundButtonView.FadeContentWhenDisabled
    }, options );
    Node.call( this );
    var content = options.content; // convenience variable
    var upCenter = new Vector2( options.xContentOffset, options.yContentOffset );
    if ( content ) {
      content.pickable = false;
    }
    this.baseColorProperty = new Property( Color.toColor( options.baseColor ) ); // @private
    this.addInputListener( new ButtonListener( buttonModel ) );
    var buttonRadius = options.radius || Math.max( content.width + options.minXMargin * 2, content.height + options.minYMargin * 2 ) / 2;
    var button = new Circle( buttonRadius, { fill: options.baseColor, lineWidth: options.lineWidth } );
    this.addChild( button );
    var buttonAppearanceStrategy = new options.buttonAppearanceStrategy(
      button,
      interactionStateProperty,
      this.baseColorProperty,
      options
    );
    if ( content ) {
      content.center = upCenter;
      this.addChild( content );
    }
    var contentAppearanceStrategy = new options.contentAppearanceStrategy( content, interactionStateProperty );
    var self = this;
    function handleInteractionStateChanged( state ) {
      self.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
    }
    interactionStateProperty.link( handleInteractionStateChanged );
    this.touchArea = Shape.circle( 0, 0, buttonRadius + options.touchAreaDilation );
    this.mouseArea = Shape.circle( 0, 0, buttonRadius + options.mouseAreaDilation );
    this.pickable = null;
    this.focusHighlight = new Shape.circle( 0, 0, buttonRadius + 5 );
    this.mutate( options );
    this.disposeRoundButtonView = function() {
      buttonAppearanceStrategy.dispose();
      contentAppearanceStrategy.dispose();
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  }
  sun.register( 'RoundButtonView', RoundButtonView );
  RoundButtonView.ThreeDAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {
    var buttonRadius = button.width / 2;
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var transparentDisabledBaseColor = new Color(
      disabledBaseColor.getRed(),
      disabledBaseColor.getGreen(),
      disabledBaseColor.getBlue(),
      0
    );
    var disabledStroke = options.stroke ? disabledBaseColor.colorUtilsDarker( 0.4 ) : null;
    var innerGradientRadius = buttonRadius - HIGHLIGHT_GRADIENT_LENGTH / 2;
    var outerGradientRadius = buttonRadius + HIGHLIGHT_GRADIENT_LENGTH / 2;
    var gradientOffset = HIGHLIGHT_GRADIENT_LENGTH / 2;
    var overlayForShadowGradient = new Circle( buttonRadius, { lineWidth: options.lineWidth, pickable: false } );
    button.addChild( overlayForShadowGradient );
    var upFillHighlight;
    var upFillShadow;
    var overFillHighlight;
    var overFillShadow;
    var pressedFill;
    var disabledFillHighlight;
    var disabledFillShadow;
    var disabledPressedFillHighlight;
    var enabledStroke = null;
    function createPressedFill( color ) {
      return new RadialGradient( -gradientOffset, -gradientOffset, 0, 0, 0, outerGradientRadius )
        .addColorStop( 0, color.colorUtilsDarker( 0.1 ) )
        .addColorStop( 0.6, color.colorUtilsDarker( 0.2 ) )
        .addColorStop( 0.8, color )
        .addColorStop( 1, color.colorUtilsBrighter( 0.8 ) );
    }
    function updateAppearance( interactionState ) {
      switch( interactionState ) {
        case 'idle':
          button.fill = upFillHighlight;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = upFillShadow;
          break;
        case 'over':
          button.fill = overFillHighlight;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = overFillShadow;
          break;
        case 'pressed':
          button.fill = pressedFill;
          overlayForShadowGradient.stroke = enabledStroke;
          overlayForShadowGradient.fill = overFillShadow;
          break;
        case 'disabled':
          button.fill = disabledFillHighlight;
          overlayForShadowGradient.stroke = disabledStroke;
          overlayForShadowGradient.fill = disabledFillShadow;
          break;
        case 'disabled-pressed':
          button.fill = disabledPressedFillHighlight;
          overlayForShadowGradient.stroke = disabledStroke;
          overlayForShadowGradient.fill = disabledFillShadow;
          break;
        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }
    function updateFillsAndStrokes( baseColor ) {
      var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );
      upFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, baseColor )
        .addColorStop( 1, baseColor.colorUtilsBrighter( 0.7 ) );
      upFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      overFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.3 ) )
        .addColorStop( 1, baseColor.colorUtilsBrighter( 0.8 ) );
      overFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      pressedFill = createPressedFill( baseColor );
      disabledFillHighlight = new RadialGradient( gradientOffset, gradientOffset, innerGradientRadius, gradientOffset, gradientOffset, outerGradientRadius )
        .addColorStop( 0, disabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsBrighter( 0.5 ) );
      disabledFillShadow = new RadialGradient( -gradientOffset, -gradientOffset, innerGradientRadius, -gradientOffset, -gradientOffset, outerGradientRadius )
        .addColorStop( 0, transparentDisabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
      disabledPressedFillHighlight = createPressedFill( disabledBaseColor );
      if ( options.stroke === null ) {
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      button.cachedPaints = [
        upFillHighlight, overFillHighlight, pressedFill, disabledFillHighlight, disabledPressedFillHighlight
      ];
      overlayForShadowGradient.cachedPaints = [
        upFillShadow, overFillShadow, disabledFillShadow,
        enabledStroke, disabledStroke
      ];
      updateAppearance( interactionStateProperty.value );
    }
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );
    baseColorProperty.lazyLink( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };
  RoundButtonView.FlatAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var upFill;
    var overFill;
    var downFill;
    var disabledFill;
    var disabledPressedFillVertical;
    var enabledStroke = null;
    var disabledStroke = null;
    function updateAppearance( interactionState ) {
      switch( interactionState ) {
        case 'idle':
          button.fill = upFill;
          button.stroke = enabledStroke;
          break;
        case 'over':
          button.fill = overFill;
          button.stroke = enabledStroke;
          break;
        case 'pressed':
          button.fill = downFill;
          button.stroke = enabledStroke;
          break;
        case 'disabled':
          button.fill = disabledFill;
          button.stroke = disabledStroke;
          break;
        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          break;
        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }
    function updateFillsAndStrokes( baseColor ) {
      upFill = baseColor;
      overFill = baseColor.colorUtilsBrighter( 0.4 );
      downFill = baseColor.colorUtilsDarker( 0.4 );
      disabledFill = disabledBaseColor;
      disabledPressedFillVertical = disabledFill;
      if ( options.stroke === null ) {
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      button.cachedPaints = [
        upFill, overFill, downFill, disabledFill, disabledPressedFillVertical,
        enabledStroke, disabledStroke
      ];
      updateAppearance( interactionStateProperty.value );
    }
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );
    baseColorProperty.lazyLink( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };
  RoundButtonView.FadeContentWhenDisabled = function( content, interactionStateProperty ) {
    function updateOpacity( state ) {
      if ( content ) {
        content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
      }
    }
    interactionStateProperty.link( updateOpacity );
    this.dispose = function() {
      interactionStateProperty.unlink( updateOpacity );
    };
  };
  return inherit( Node, RoundButtonView, {
    setEnabled: function( value ) {
      assert && assert( typeof value === 'boolean', 'RoundButtonView.enabled must be a boolean value' );
      this.buttonModel.enabledProperty.set( value );
    },
    set enabled( value ) { this.setEnabled( value ); },
    getEnabled: function() {return this.buttonModel.enabledProperty.get(); },
    get enabled() { return this.getEnabled(); },
    setBaseColor: function( baseColor ) { this.baseColorProperty.value = Color.toColor( baseColor ); },
    set baseColor( baseColor ) { this.setBaseColor( baseColor ); },
    getBaseColor: function() { return this.baseColorProperty.value; },
    get baseColor() { return this.getBaseColor(); },
    dispose: function() {
      this.disposeRoundButtonView();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define("PHET_IO/assertions/assertInstanceOfTypes", function(){return function(){ return function(){}; };});
define( 'SUN/buttons/TPushButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOfTypes','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/events/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';
  var assertInstanceOfTypes = require( 'ifphetio!PHET_IO/assertions/assertInstanceOfTypes' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  function TPushButton( button, phetioID ) {
    TNode.call( this, button, phetioID );
    assertInstanceOfTypes( button, [
      phet.sun.RoundPushButton,
      phet.sun.RectangularPushButton
    ] );
    assert && assert( button.buttonModel.startedCallbacksForFiredEmitter, 'button models should use emitters' );
    toEventOnEmit(
      button.buttonModel.startedCallbacksForFiredEmitter,
      button.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }
  phetioInherit( TNode, 'TPushButton', TPushButton, {
    addListener: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [] ) ],
      implementation: function( listener ) {
        this.instance.addListener( listener );
      },
      documentation: 'Adds a listener that is called back when the button is pressed.'
    },
    fire: {
      returnType: TVoid,
      parameterTypes: [],
      implementation: function() {
        this.instance.buttonModel.fire();
      },
      documentation: 'Performs the action associated with the button'
    }
  }, {
    documentation: 'A pressable button in the simulation',
    events: [ 'fired' ]
  } );
  sun.register( 'TPushButton', TPushButton );
  return TPushButton;
} );
define( 'SUN/buttons/RoundPushButton',['require','PHET_CORE/inherit','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','SUN/buttons/RoundButtonView','SUN/sun','TANDEM/Tandem','SUN/buttons/TPushButton'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var RoundButtonView = require( 'SUN/buttons/RoundButtonView' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );
  function RoundPushButton( options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      tagName: 'input',
      inputType: 'button'
    }, options );
    var self = this;
    var tandem = options.tandem;
    options.tandem = tandem.createSupertypeTandem();
    var listener = options.listener;
    options = _.omit( options, [ 'listener' ] );
    this.buttonModel = new PushButtonModel( options ); // @public, listen only
    RoundButtonView.call( this, this.buttonModel, new PushButtonInteractionStateProperty( this.buttonModel ), options );
    listener && this.addListener( listener );
    var accessibleClickListener = this.addAccessibleInputListener( {
      click: function() {
        self.buttonModel.fire();
      }
    } );
    this.disposeRoundPushButton = function() {
      tandem.removeInstance( self );
      self.removeAccessibleInputListener( accessibleClickListener );
      self.buttonModel.dispose();
    };
    tandem.addInstance( this, TPushButton );
  }
  sun.register( 'RoundPushButton', RoundPushButton );
  return inherit( RoundButtonView, RoundPushButton, {
    dispose: function() {
      this.disposeRoundPushButton();
      RoundButtonView.prototype.dispose.call( this );
    },
    addListener: function( listener ) {
      this.buttonModel.addListener( listener );
    },
    removeListener: function( listener ) {
      this.buttonModel.removeListener( listener );
    }
  } );
} );
define( 'SCENERY_PHET/buttons/ResetButton',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/nodes/Path','SCENERY_PHET/ResetShape','SUN/buttons/RoundPushButton','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Path = require( 'SCENERY/nodes/Path' );
  var ResetShape = require( 'SCENERY_PHET/ResetShape' );
  var RoundPushButton = require( 'SUN/buttons/RoundPushButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  function ResetButton( options ) {
    var BUTTON_RADIUS = ( options && options.radius ) ? options.radius : 24;
    options = _.extend( {
      radius: BUTTON_RADIUS,
      minXMargin: BUTTON_RADIUS * 0.2,
      baseColor: 'white',
      arrowColor: 'black',
      xContentOffset: -0.03 * BUTTON_RADIUS,
      yContentOffset: -0.0125 * BUTTON_RADIUS,
      tandem: Tandem.tandemRequired()
    }, options );
    var resetIcon = new Path( new ResetShape( options.radius ), { fill: options.arrowColor } );
    var reflectedIcon = new Path( resetIcon.shape.transformed( Matrix3.scaling( -1, -1 ) ) );
    resetIcon.localBounds = resetIcon.localBounds.union( reflectedIcon.localBounds );
    assert && assert( !options.content, 'content is not customizable' );
    options.content = resetIcon;
    options.tandem = options.tandem.createSupertypeTandem();
    RoundPushButton.call( this, options );
  }
  sceneryPhet.register( 'ResetButton', ResetButton );
  return inherit( RoundPushButton, ResetButton );
} );
define( 'SCENERY_PHET/accessibility/AriaHerald',['require','SCENERY_PHET/sceneryPhet','AXON/Property','TANDEM/Tandem','PHET_CORE/Timer','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Property = require( 'AXON/Property' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Timer = require( 'PHET_CORE/Timer' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var tandem = Tandem.createStaticTandem( 'ariaHerald' );
  var ASSERTIVE_ELEMENT_ID = 'assertive';
  var POLITE_ELEMENT_ID = 'polite';
  var ASSERTIVE_ALERT_ELEMENT_ID = 'assertive-alert';
  var POLITE_STATUS_ELEMENT_ID = 'polite-status';
  var ALERT_CONTAINER_ELEMENT_ID = 'aria-live-elements';
  var DEFAULT_WITH_CLEAR = true;
  var assertiveElement = document.getElementById( ASSERTIVE_ELEMENT_ID );
  var politeElement = document.getElementById( POLITE_ELEMENT_ID );
  var assertiveAlertElement = document.getElementById( ASSERTIVE_ALERT_ELEMENT_ID );
  var politeStatusElement = document.getElementById( POLITE_STATUS_ELEMENT_ID );
  var alertContainer = document.getElementById( ALERT_CONTAINER_ELEMENT_ID );
  assert && assert( assertiveElement, 'No assertive element found in document' );
  assert && assert( politeElement, 'No polite element found in document' );
  assert && assert( assertiveAlertElement, 'No assertive alert element found in document' );
  assert && assert( politeStatusElement, 'No polite status element found in document' );
  assert && assert( alertContainer, 'No alert container element found in document' );
  var assertiveElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'assertiveElementProperty' ),
    phetioValueType: TString
  } );
  assertiveElementProperty.link( function( text ) {
    assertiveElement.textContent = text;
  } );
  var politeElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'politeElementProperty' ),
    phetioValueType: TString
  } );
  politeElementProperty.link( function( text ) {
    politeElement.textContent = text;
  } );
  var assertiveAlertElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'assertiveAlertElementProperty' ),
    phetioValueType: TString
  } );
  assertiveAlertElementProperty.link( function( text ) {
    assertiveAlertElement.textContent = text;
  } );
  var politeStatusElementProperty = new Property( '', {
    tandem: tandem.createTandem( 'politeStatusElementProperty' ),
    phetioValueType: TString
  } );
  politeStatusElementProperty.link( function( text ) {
    politeStatusElement.textContent = text;
  } );
  var alertsVisibleProperty = new Property( true, {
    tandem: tandem.createTandem( 'alertsVisibleProperty' ),
    phetioValueType: TBoolean
  } );
  var alertsEnabledProperty = new Property( true, {
    tandem: tandem.createTandem( 'alertsEnabledProperty' ),
    phetioValueType: TBoolean
  } );
  alertsVisibleProperty.link( function( visible ) {
    alertContainer.hidden = !visible;
  } );
  function updateLiveElement( elementContentProperty, textContent, withClear ) {
    withClear = ( withClear === undefined ) ? DEFAULT_WITH_CLEAR : withClear;
    assert && assert( typeof withClear === 'boolean', 'withClear must be of type boolean' );
    if ( alertsEnabledProperty.get() ) {
      if ( withClear ) { elementContentProperty.reset(); }
      Timer.setTimeout( function() { elementContentProperty.set( textContent ); }, 200 ); 
    }
  }
  var AriaHerald = {
    announceAssertive: function( textContent, withClear ) {
      updateLiveElement( assertiveElementProperty, textContent, withClear );
    },
    announcePolite: function( textContent, withClear ) {
      updateLiveElement( politeElementProperty, textContent, withClear );
    },
    announceAssertiveWithAlert: function( textContent, withClear ) {
      updateLiveElement( assertiveAlertElementProperty, textContent, withClear );
    },
    announcePoliteWithStatus: function( textContent, withClear ) {
      updateLiveElement( politeStatusElementProperty, textContent, withClear );
    },
    clearAll: function() {
      assertiveElementProperty.reset();
      politeElementProperty.reset();
      assertiveAlertElementProperty.reset();
      politeStatusElementProperty.reset();
    },
    clearAssertive: function() {
      assertiveElementProperty.reset();
    },
    clearPolite: function() {
      politeElementProperty.reset();
    },
    clearAssertiveWithAlert: function() {
      assertiveAlertElementProperty.reset();
    },
    clearPoliteWithStatus: function() {
      politeStatusElementProperty.reset();
    },
    setVisible: function( visible ) {
      alertsVisibleProperty.set( visible );
    },
    set visible( visible ) { AriaHerald.setVisible( visible ); },
    getVisible: function() {
      return alertsVisibleProperty.get();
    },
    get visible() { return alertsVisibleProperty.get(); },
    setEnabled: function( enabled ) {
      alertsEnabledProperty.set( enabled );
    },
    set enabled( enabled ) { AriaHerald.setEnabled( enabled ); },
    getEnabled: function() {
      return alertsEnabledProperty.get();
    },
    get enabled() { return AriaHerald.getEnabled(); },
    callWithDisabledAlerts: function( callback ) {
      alertsEnabledProperty.set( false );
      callback();
      alertsEnabledProperty.set( true );
    },
    ASSERTIVE_ELEMENT_ID: ASSERTIVE_ELEMENT_ID,
    POLITE_ELEMENT_ID: POLITE_ELEMENT_ID,
    ASSERTIVE_ALERT_ELEMENT_ID: ASSERTIVE_ALERT_ELEMENT_ID,
    POLITE_STATUS_ELEMENT_ID: POLITE_STATUS_ELEMENT_ID,
    ALERT_CONTAINER_ELEMENT_ID: ALERT_CONTAINER_ELEMENT_ID
  };
  sceneryPhet.register( 'AriaHerald', AriaHerald );
  return AriaHerald;
} );
define( 'SCENERY_PHET/SceneryPhetA11yStrings',['require','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var SceneryPhetA11yStrings = {
    soundToggleLabelString: 'Mute Sound',
    simSoundOnString: 'Sim sound on',
    simSoundOffString: 'Sim sound off',
    resetAllAlertString: 'Sim screen restarted. Everything reset.'
  };
  if ( phet.chipper.queryParameters.stringTest === 'xss' ) {
    for ( var key in SceneryPhetA11yStrings ) {
      SceneryPhetA11yStrings[ key ] += '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />';
    }
  }
  if ( assert ) { Object.freeze( SceneryPhetA11yStrings ); }
  sceneryPhet.register( 'SceneryPhetA11yStrings', SceneryPhetA11yStrings );
  return SceneryPhetA11yStrings;
} );
define( 'SUN/buttons/TResetAllButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SUN/buttons/TPushButton'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );
  function TResetAllButton( resetAllButton, phetioID ) {
    assertInstanceOf( resetAllButton, phet.sceneryPhet.ResetAllButton );
    TPushButton.call( this, resetAllButton, phetioID );
  }
  phetioInherit( TPushButton, 'TResetAllButton', TResetAllButton, {}, {
    documentation: 'The round (typically orange) button that restores the simulation screen to its initial state',
    events: [ 'reset', 'fired' ] // This is a manual override of TPushButton's 'fired' event. See https://github.com/phetsims/phet-io/issues/1069
  } );
  sun.register( 'TResetAllButton', TResetAllButton );
  return TResetAllButton;
} );
define("string!SCENERY_PHET/ResetAllButton.name",function(){return window.phet.chipper.strings.get("SCENERY_PHET/ResetAllButton.name");});
define( 'SCENERY_PHET/buttons/ResetAllButton',['require','PHET_CORE/inherit','SCENERY_PHET/PhetColorScheme','SCENERY_PHET/buttons/ResetButton','KITE/Shape','SCENERY_PHET/sceneryPhet','TANDEM/Tandem','SCENERY_PHET/accessibility/AriaHerald','SCENERY_PHET/SceneryPhetA11yStrings','SUN/buttons/TResetAllButton','string!SCENERY_PHET/ResetAllButton.name'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var ResetButton = require( 'SCENERY_PHET/buttons/ResetButton' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  var AriaHerald = require( 'SCENERY_PHET/accessibility/AriaHerald' );
  var SceneryPhetA11yStrings = require( 'SCENERY_PHET/SceneryPhetA11yStrings' );
  var TResetAllButton = require( 'SUN/buttons/TResetAllButton' );
  var RESET_ALL_BUTTON_RADIUS = 24; // derived from the image files that were originally used for this button
  var resetAllButtonNameString = require( 'string!SCENERY_PHET/ResetAllButton.name' );
  var resetAllAlertString = SceneryPhetA11yStrings.resetAllAlertString;
  function ResetAllButton( options ) {
    options = _.extend( {
      radius: RESET_ALL_BUTTON_RADIUS,
      baseColor: PhetColorScheme.RESET_ALL_BUTTON_BASE_COLOR,
      arrowColor: 'white',
      tandem: Tandem.tandemRequired(),
      tagName: 'input',
      inputType: 'button',
      accessibleLabel: resetAllButtonNameString,
      useAriaLabel: true
    }, options );
    var tandem = options.tandem;
    options.tandem = tandem.createSupertypeTandem();
    ResetButton.call( this, options );
    this.focusHighlight = new Shape().circle( 0, 0, options.radius + 5 );
    var disableAlertsListener = function() {
      AriaHerald.enabled = false;
    };
    this.buttonModel.startedCallbacksForFiredEmitter.addListener( disableAlertsListener );
    var enableAlertsListener = function() {
      AriaHerald.enabled = true;
      AriaHerald.announcePolite( resetAllAlertString );
    };
    this.buttonModel.endedCallbacksForFiredEmitter.addListener( enableAlertsListener );
    this.disposeResetAllButton = function() {
      self.buttonModel.startedCallbacksForFiredEmitter.removeListener( disableAlertsListener );
      self.buttonModel.endedCallbacksForFiredEmitter.removeListener( enableAlertsListener );
    };
    tandem.addInstance( this, TResetAllButton );
  }
  sceneryPhet.register( 'ResetAllButton', ResetAllButton );
  return inherit( ResetButton, ResetAllButton, {
    dispose: function() {
      this.disposeResetAllButton();
      ResetButton.prototype.dispose && ResetButton.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/joist',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'joist' );
} );
define( 'JOIST/ScreenView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','DOT/Bounds2','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );
  var DEFAULT_LAYOUT_BOUNDS = new Bounds2( 0, 0, 1024, 618 );
  function ScreenView( options ) {
    options = _.extend( {
      layoutBounds: DEFAULT_LAYOUT_BOUNDS.copy()
    }, options );
    this.layoutBounds = options.layoutBounds;
    Node.call( this, _.extend( {
      layerSplit: true, // so we're not in the same layer as the navbar, etc.
      excludeInvisible: true, // so we don't keep invisible screens in the SVG tree
      parentContainerTagName: 'article',
      tagName: 'div',
      labelTagName: 'h1',
      prependLabels: true
    }, options ) );
    this.visibleBoundsProperty = new Property( options.layoutBounds );
    this.accessibleHiddenListener = this.updateAccessibleHidden.bind( this );
    this.on( 'visibility', this.accessibleHiddenListener );
    this.updateAccessibleHidden();
  }
  joist.register( 'ScreenView', ScreenView );
  return inherit( Node, ScreenView, {
      getLayoutScale: function( width, height ) {
        return Math.min( width / this.layoutBounds.width, height / this.layoutBounds.height );
      },
      layout: function( width, height ) {
        this.resetTransform();
        var scale = this.getLayoutScale( width, height );
        this.setScaleMagnitude( scale );
        var dx = 0;
        var dy = 0;
        if ( scale === width / this.layoutBounds.width ) {
          dy = (height / scale - this.layoutBounds.height ) / 2;
        }
        else if ( scale === height / this.layoutBounds.height ) {
          dx = (width / scale - this.layoutBounds.width ) / 2;
        }
        this.translate( dx, dy );
        this.visibleBoundsProperty.set( new Bounds2( -dx, -dy, width / scale - dx, height / scale - dy ) );
      },
      updateAccessibleHidden: function() {
        this.accessibleHidden = !this.visible;
      },
      dispose: function() {
        Node.prototype.dispose.call( this );
        this.disposeScreenView();
      }
    },
    {
      DEFAULT_LAYOUT_BOUNDS: DEFAULT_LAYOUT_BOUNDS
    }
  );
} );
define( 'SUN/FontAwesomeNode',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var ICONS = {
    camera: 'M960 864q119 0 203.5 -84.5t84.5 -203.5t-84.5 -203.5t-203.5 -84.5t-203.5 84.5t-84.5 203.5t84.5 203.5t203.5 84.5zM1664 1280q106 0 181 -75t75 -181v-896q0 -106 -75 -181t-181 -75h-1408q-106 0 -181 75t-75 181v896q0 106 75 181t181 75h224l51 136 q19 49 69.5 84.5t103.5 35.5h512q53 0 103.5 -35.5t69.5 -84.5l51 -136h224zM960 128q185 0 316.5 131.5t131.5 316.5t-131.5 316.5t-316.5 131.5t-316.5 -131.5t-131.5 -316.5t131.5 -316.5t316.5 -131.5z',
    check: 'M1671 970q0 -40 -28 -68l-724 -724l-136 -136q-28 -28 -68 -28t-68 28l-136 136l-362 362q-28 28 -28 68t28 68l136 136q28 28 68 28t68 -28l294 -295l656 657q28 28 68 28t68 -28l136 -136q28 -28 28 -68z',
    check_empty: 'M1120 1280h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v832q0 66 -47 113t-113 47zM1408 1120v-832q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q119 0 203.5 -84.5t84.5 -203.5z',
    check_square_o: 'M1408 606v-318q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-10 -10 -23 -10q-3 0 -9 2q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832 q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v254q0 13 9 22l64 64q10 10 23 10q6 0 12 -3q20 -8 20 -29zM1639 1095l-814 -814q-24 -24 -57 -24t-57 24l-430 430q-24 24 -24 57t24 57l110 110q24 24 57 24t57 -24l263 -263l647 647q24 24 57 24t57 -24l110 -110 q24 -24 24 -57t-24 -57z',
    cut: 'M960 640q26 0 45 -19t19 -45t-19 -45t-45 -19t-45 19t-19 45t19 45t45 19zM1260 576l507 -398q28 -20 25 -56q-5 -35 -35 -51l-128 -64q-13 -7 -29 -7q-17 0 -31 8l-690 387l-110 -66q-8 -4 -12 -5q14 -49 10 -97q-7 -77 -56 -147.5t-132 -123.5q-132 -84 -277 -84 q-136 0 -222 78q-90 84 -79 207q7 76 56 147t131 124q132 84 278 84q83 0 151 -31q9 13 22 22l122 73l-122 73q-13 9 -22 22q-68 -31 -151 -31q-146 0 -278 84q-82 53 -131 124t-56 147q-5 59 15.5 113t63.5 93q85 79 222 79q145 0 277 -84q83 -52 132 -123t56 -148 q4 -48 -10 -97q4 -1 12 -5l110 -66l690 387q14 8 31 8q16 0 29 -7l128 -64q30 -16 35 -51q3 -36 -25 -56zM579 836q46 42 21 108t-106 117q-92 59 -192 59q-74 0 -113 -36q-46 -42 -21 -108t106 -117q92 -59 192 -59q74 0 113 36zM494 91q81 51 106 117t-21 108 q-39 36 -113 36q-100 0 -192 -59q-81 -51 -106 -117t21 -108q39 -36 113 -36q100 0 192 59zM672 704l96 -58v11q0 36 33 56l14 8l-79 47l-26 -26q-3 -3 -10 -11t-12 -12q-2 -2 -4 -3.5t-3 -2.5zM896 480l96 -32l736 576l-128 64l-768 -431v-113l-160 -96l9 -8q2 -2 7 -6 q4 -4 11 -12t11 -12l26 -26zM1600 64l128 64l-520 408l-177 -138q-2 -3 -13 -7z',
    eye_close: 'M555 201l78 141q-87 63 -136 159t-49 203q0 121 61 225q-229 -117 -381 -353q167 -258 427 -375zM944 960q0 20 -14 34t-34 14q-125 0 -214.5 -89.5t-89.5 -214.5q0 -20 14 -34t34 -14t34 14t14 34q0 86 61 147t147 61q20 0 34 14t14 34zM1307 1151q0 -7 -1 -9 q-105 -188 -315 -566t-316 -567l-49 -89q-10 -16 -28 -16q-12 0 -134 70q-16 10 -16 28q0 12 44 87q-143 65 -263.5 173t-208.5 245q-20 31 -20 69t20 69q153 235 380 371t496 136q89 0 180 -17l54 97q10 16 28 16q5 0 18 -6t31 -15.5t33 -18.5t31.5 -18.5t19.5 -11.5 q16 -10 16 -27zM1344 704q0 -139 -79 -253.5t-209 -164.5l280 502q8 -45 8 -84zM1792 576q0 -35 -20 -69q-39 -64 -109 -145q-150 -172 -347.5 -267t-419.5 -95l74 132q212 18 392.5 137t301.5 307q-115 179 -282 294l63 112q95 -64 182.5 -153t144.5 -184q20 -34 20 -69z',
    eye_open: 'M1664 576q-152 236 -381 353q61 -104 61 -225q0 -185 -131.5 -316.5t-316.5 -131.5t-316.5 131.5t-131.5 316.5q0 121 61 225q-229 -117 -381 -353q133 -205 333.5 -326.5t434.5 -121.5t434.5 121.5t333.5 326.5zM944 960q0 20 -14 34t-34 14q-125 0 -214.5 -89.5 t-89.5 -214.5q0 -20 14 -34t34 -14t34 14t14 34q0 86 61 147t147 61q20 0 34 14t14 34zM1792 576q0 -34 -20 -69q-140 -230 -376.5 -368.5t-499.5 -138.5t-499.5 139t-376.5 368q-20 35 -20 69t20 69q140 229 376.5 368t499.5 139t499.5 -139t376.5 -368q20 -35 20 -69z',
    exchange: 'M1792 352v-192q0 -13 -9.5 -22.5t-22.5 -9.5h-1376v-192q0 -13 -9.5 -22.5t-22.5 -9.5q-12 0 -24 10l-319 320q-9 9 -9 22q0 14 9 23l320 320q9 9 23 9q13 0 22.5 -9.5t9.5 -22.5v-192h1376q13 0 22.5 -9.5t9.5 -22.5zM1792 896q0 -14 -9 -23l-320 -320q-9 -9 -23 -9 q-13 0 -22.5 9.5t-9.5 22.5v192h-1376q-13 0 -22.5 9.5t-9.5 22.5v192q0 13 9.5 22.5t22.5 9.5h1376v192q0 14 9 23t23 9q12 0 24 -10l319 -319q9 -9 9 -23z',
    home: 'M1408 544v-480q0 -26 -19 -45t-45 -19h-384v384h-256v-384h-384q-26 0 -45 19t-19 45v480q0 1 0.5 3t0.5 3l575 474l575 -474q1 -2 1 -6zM1631 613l-62 -74q-8 -9 -21 -11h-3q-13 0 -21 7l-692 577l-692 -577q-12 -8 -24 -7q-13 2 -21 11l-62 74q-8 10 -7 23.5t11 21.5 l719 599q32 26 76 26t76 -26l244 -204v195q0 14 9 23t23 9h192q14 0 23 -9t9 -23v-408l219 -182q10 -8 11 -21.5t-7 -23.5z',
    info_circle: 'M1024 160v160q0 14 -9 23t-23 9h-96v512q0 14 -9 23t-23 9h-320q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23t23 -9h96v-320h-96q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23t23 -9h448q14 0 23 9t9 23zM896 1056v160q0 14 -9 23t-23 9h-192q-14 0 -23 -9t-9 -23v-160q0 -14 9 -23 t23 -9h192q14 0 23 9t9 23zM1536 640q0 -209 -103 -385.5t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z',
    level_down: 'M32 1280h704q13 0 22.5 -9.5t9.5 -23.5v-863h192q40 0 58 -37t-9 -69l-320 -384q-18 -22 -49 -22t-49 22l-320 384q-26 31 -9 69q18 37 58 37h192v640h-320q-14 0 -25 11l-160 192q-13 14 -4 34q9 19 29 19z',
    pencil_square_o: 'M888 352l116 116l-152 152l-116 -116v-56h96v-96h56zM1328 1072q-16 16 -33 -1l-350 -350q-17 -17 -1 -33t33 1l350 350q17 17 1 33zM1408 478v-190q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-14 -14 -32 -8q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v126q0 13 9 22l64 64q15 15 35 7t20 -29zM1312 1216l288 -288l-672 -672h-288v288zM1756 1084l-92 -92 l-288 288l92 92q28 28 68 28t68 -28l152 -152q28 -28 28 -68t-28 -68z',
    refresh: 'M1511 480q0 -5 -1 -7q-64 -268 -268 -434.5t-478 -166.5q-146 0 -282.5 55t-243.5 157l-129 -129q-19 -19 -45 -19t-45 19t-19 45v448q0 26 19 45t45 19h448q26 0 45 -19t19 -45t-19 -45l-137 -137q71 -66 161 -102t187 -36q134 0 250 65t186 179q11 17 53 117 q8 23 30 23h192q13 0 22.5 -9.5t9.5 -22.5zM1536 1280v-448q0 -26 -19 -45t-45 -19h-448q-26 0 -45 19t-19 45t19 45l138 138q-148 137 -349 137q-134 0 -250 -65t-186 -179q-11 -17 -53 -117q-8 -23 -30 -23h-199q-13 0 -22.5 9.5t-9.5 22.5v7q65 268 270 434.5t480 166.5 q146 0 284 -55.5t245 -156.5l130 129q19 19 45 19t45 -19t19 -45z',
    reply: 'M1792 416q0 -166 -127 -451q-3 -7 -10.5 -24t-13.5 -30t-13 -22q-12 -17 -28 -17q-15 0 -23.5 10t-8.5 25q0 9 2.5 26.5t2.5 23.5q5 68 5 123q0 101 -17.5 181t-48.5 138.5t-80 101t-105.5 69.5t-133 42.5t-154 21.5t-175.5 6h-224v-256q0 -26 -19 -45t-45 -19t-45 19 l-512 512q-19 19 -19 45t19 45l512 512q19 19 45 19t45 -19t19 -45v-256h224q713 0 875 -403q53 -134 53 -333z',
    times: 'M1298 214q0 -40 -28 -68l-136 -136q-28 -28 -68 -28t-68 28l-294 294l-294 -294q-28 -28 -68 -28t-68 28l-136 136q-28 28 -28 68t28 68l294 294l-294 294q-28 28 -28 68t28 68l136 136q28 28 68 28t68 -28l294 -294l294 294q28 28 68 28t68 -28l136 -136q28 -28 28 -68 t-28 -68l-294 -294l294 -294q28 -28 28 -68z',
    times_circle: 'M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46zM1536 640q0 -209 -103 -385.5t-279.5 -279.5t-385.5 -103t-385.5 103t-279.5 279.5t-103 385.5t103 385.5t279.5 279.5t385.5 103t385.5 -103t279.5 -279.5t103 -385.5z',
    trash: 'M512 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM768 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1024 800v-576q0 -14 -9 -23t-23 -9h-64q-14 0 -23 9t-9 23v576 q0 14 9 23t23 9h64q14 0 23 -9t9 -23zM1152 76v948h-896v-948q0 -22 7 -40.5t14.5 -27t10.5 -8.5h832q3 0 10.5 8.5t14.5 27t7 40.5zM480 1152h448l-48 117q-7 9 -17 11h-317q-10 -2 -17 -11zM1408 1120v-64q0 -14 -9 -23t-23 -9h-96v-948q0 -83 -47 -143.5t-113 -60.5h-832 q-66 0 -113 58.5t-47 141.5v952h-96q-14 0 -23 9t-9 23v64q0 14 9 23t23 9h309l70 167q15 37 54 63t79 26h320q40 0 79 -26t54 -63l70 -167h309q14 0 23 -9t9 -23z',
    undo: 'M1536 640q0 -156 -61 -298t-164 -245t-245 -164t-298 -61q-179 0 -336.5 76t-266 213t-147.5 312q-3 14 7 27q9 12 25 12h199q23 0 30 -23q50 -162 185 -261.5t304 -99.5q104 0 198.5 40.5t163.5 109.5t109.5 163.5t40.5 198.5t-40.5 198.5t-109.5 163.5t-163.5 109.5 t-198.5 40.5q-98 0 -188 -35.5t-160 -101.5l137 -138q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l130 -129q107 101 244.5 156.5t284.5 55.5q156 0 298 -61t245 -164t164 -245t61 -298z',
    volume_off: 'M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45z',
    volume_up: 'M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45zM1152 640q0 -76 -42.5 -141.5t-112.5 -93.5q-10 -5 -25 -5q-26 0 -45 18.5t-19 45.5q0 21 12 35.5t29 25t34 23t29 35.5 t12 57t-12 57t-29 35.5t-34 23t-29 25t-12 35.5q0 27 19 45.5t45 18.5q15 0 25 -5q70 -27 112.5 -93t42.5 -142zM1408 640q0 -153 -85 -282.5t-225 -188.5q-13 -5 -25 -5q-27 0 -46 19t-19 45q0 39 39 59q56 29 76 44q74 54 115.5 135.5t41.5 173.5t-41.5 173.5 t-115.5 135.5q-20 15 -76 44q-39 20 -39 59q0 26 19 45t45 19q13 0 26 -5q140 -59 225 -188.5t85 -282.5zM1664 640q0 -230 -127 -422.5t-338 -283.5q-13 -5 -26 -5q-26 0 -45 19t-19 45q0 36 39 59q7 4 22.5 10.5t22.5 10.5q46 25 82 51q123 91 192 227t69 289t-69 289 t-192 227q-36 26 -82 51q-7 4 -22.5 10.5t-22.5 10.5q-39 23 -39 59q0 26 19 45t45 19q13 0 26 -5q211 -91 338 -283.5t127 -422.5z',
    warning_sign: 'M1024 161v190q0 14 -9.5 23.5t-22.5 9.5h-192q-13 0 -22.5 -9.5t-9.5 -23.5v-190q0 -14 9.5 -23.5t22.5 -9.5h192q13 0 22.5 9.5t9.5 23.5zM1022 535l18 459q0 12 -10 19q-13 11 -24 11h-220q-11 0 -24 -11q-10 -7 -10 -21l17 -457q0 -10 10 -16.5t24 -6.5h185 q14 0 23.5 6.5t10.5 16.5zM1008 1469l768 -1408q35 -63 -2 -126q-17 -29 -46.5 -46t-63.5 -17h-1536q-34 0 -63.5 17t-46.5 46q-37 63 -2 126l768 1408q17 31 47 49t65 18t65 -18t47 -49z'
  };
  var SHAPE_MATRIX = Matrix3.createFromPool( 0.025, 0, 0, 0, -0.025, 0, 0, 0, 1 ); // to create a unity-scale icon
  var shapeCache = {};
  function FontAwesomeNode( iconName, options ) {
    options = _.extend( {
      fill: '#000',
      pickable: false,
      enableCache: true
    }, options );
    var shape;
    if ( options.enableCache ) {
      if ( !shapeCache[ iconName ] ) {
        shapeCache[ iconName ] = FontAwesomeNode.createShape( iconName );
      }
      shape = shapeCache[ iconName ];
    }
    else {
      shape = FontAwesomeNode.createShape( iconName );
    }
    Path.call( this, shape, options );
  }
  sun.register( 'FontAwesomeNode', FontAwesomeNode );
  return inherit( Path, FontAwesomeNode, {}, {
    createShape: function( iconName ) {
      assert && assert( ICONS[ iconName ], 'unsupported iconName: ' + iconName );
      return new Shape( ICONS[ iconName ] ).transformed( SHAPE_MATRIX ).makeImmutable();
    }
  } );
} );
define( 'SUN/TCheckBox',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/events/toEventOnEmit','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  function TCheckBox( checkBox, phetioID ) {
    assertInstanceOf( checkBox, phet.sun.CheckBox );
    TNode.call( this, checkBox, phetioID );
    toEventOnEmit(
      checkBox.startedCallbacksForToggledEmitter,
      checkBox.endedCallbacksForToggledEmitter,
      'user',
      phetioID,
      this.constructor,
      'toggled',
      function( oldValue, newValue ) {
        return {
          oldValue: oldValue,
          newValue: newValue
        };
      } );
  }
  phetioInherit( TNode, 'TCheckBox', TCheckBox, {
    link: {
      returnType: TVoid,
      parameterTypes: [ TFunctionWrapper( TVoid, [ TBoolean ] ) ],
      implementation: function( listener ) {
        this.instance.checkBoxValueProperty.link( listener );
      },
      documentation: 'Link a listener to the underlying checked TProperty.  The listener receives an immediate callback ' +
                     'with the current value (true/false)'
    },
    setChecked: {
      returnType: TVoid,
      parameterTypes: [ TBoolean ],
      implementation: function( checked ) {
        this.instance.checkBoxValueProperty.set( checked );
      },
      documentation: 'Sets whether the checkbox is checked or not'
    },
    isChecked: {
      returnType: TBoolean,
      parameterTypes: [],
      implementation: function() {
        return this.instance.checkBoxValueProperty.get();
      },
      documentation: 'Returns true if the checkbox is checked, false otherwise'
    }
  }, {
    documentation: 'A traditional checkbox',
    events: [ 'toggled' ]
  } );
  sun.register( 'TCheckBox', TCheckBox );
  return TCheckBox;
} );
define( 'SUN/CheckBox',['require','SCENERY/input/ButtonListener','SUN/FontAwesomeNode','AXON/Emitter','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SUN/sun','SCENERY/nodes/Text','TANDEM/Tandem','SUN/TCheckBox'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var sun = require( 'SUN/sun' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TCheckBox = require( 'SUN/TCheckBox' );
  var DISABLED_OPACITY = 0.3;
  function CheckBox( content, property, options ) {
    this.checkBoxValueProperty = property;
    options = _.extend( {
      spacing: 5,
      boxWidth: 21,
      cursor: 'pointer',
      checkBoxColor: 'black',
      checkBoxColorBackground: 'white',
      tandem: Tandem.tandemRequired(),
      phetioType: TCheckBox,
      tagName: 'input',
      inputType: 'checkbox',
      checkBoxAppearanceStrategy: CheckBox.fadeCheckBoxWhenDisabled,
      contentAppearanceStrategy: CheckBox.fadeContentWhenDisabled
    }, options );
    var self = this;
    Node.call( this );
    this.content = content; // @private
    this.checkBoxAppearanceStrategy = options.checkBoxAppearanceStrategy; // @private
    this.contentAppearanceStrategy = options.contentAppearanceStrategy; // @private
    this._enabled = true; // @private
    this.startedCallbacksForToggledEmitter = new Emitter();
    this.endedCallbacksForToggledEmitter = new Emitter();
    this.backgroundNode = new Rectangle( 0, -options.boxWidth, options.boxWidth * 0.95, options.boxWidth * 0.95,
      options.boxWidth * 0.2, options.boxWidth * 0.2, {
        fill: options.checkBoxColorBackground
      } );
    this.uncheckedNode = new FontAwesomeNode( 'check_empty', {
      fill: options.checkBoxColor
    } );
    var iconScale = options.boxWidth / this.uncheckedNode.width;
    this.uncheckedNode.scale( iconScale );
    this.checkedNode = new FontAwesomeNode( 'check_square_o', {
      scale: iconScale,
      fill: options.checkBoxColor
    } );
    this.checkBoxNode = new Node( { children: [ this.backgroundNode, this.checkedNode, this.uncheckedNode ] } );
    this.addChild( this.checkBoxNode );
    this.addChild( content );
    content.left = this.checkedNode.right + options.spacing;
    content.centerY = this.checkedNode.centerY;
    this.addChild( new Rectangle( this.left, this.top, this.width, this.height ) );
    content.pickable = false; // since there's a pickable rectangle on top of content
    this.fire = function() {
      if ( self._enabled ) {
        var oldValue = property.value;
        var newValue = !property.value;
        self.startedCallbacksForToggledEmitter.emit2( oldValue, newValue );
        property.value = newValue;
        self.endedCallbacksForToggledEmitter.emit();
      }
    };
    this.checkBoxButtonListener = new ButtonListener( {
      fire: this.fire
    } );
    this.addInputListener( this.checkBoxButtonListener );
    this.changeListener = this.addAccessibleInputListener( {
      change: this.fire
    } );
    this.checkBoxCheckedListener = function( checked ) {
      self.checkedNode.visible = checked;
      self.uncheckedNode.visible = !checked;
    };
    property.link( this.checkBoxCheckedListener );
    this.mutate( options );
  }
  sun.register( 'CheckBox', CheckBox );
  inherit( Node, CheckBox, {
    dispose: function() {
      this.checkBoxValueProperty.unlink( this.checkBoxCheckedListener );
      this.removeInputListener( this.checkBoxButtonListener );
      this.removeAccessibleInputListener( this.changeListener );
      Node.prototype.dispose.call( this );
    },
    setCheckBoxColorBackground: function( value ) { this.backgroundNode.fill = value; },
    set checkBoxColorBackground( value ) { this.setCheckBoxColorBackground( value ); },
    getCheckboxColorBackground: function() { return this.backgroundNode.fill; },
    get checkBoxColorBackground() { return this.getCheckboxColorBackground(); },
    setCheckBoxColor: function( value ) { this.checkedNode.fill = this.uncheckedNode.fill = value; },
    set checkBoxColor( value ) { this.setCheckBoxColor( value ); },
    getCheckboxColor: function() { return this.checkedNode.fill; },
    get checkBoxColor() { return this.getCheckboxColor(); },
    setEnabled: function( value ) {
      this._enabled = this.pickable = value;
      this.checkBoxAppearanceStrategy( this.checkBoxNode, value );
      this.contentAppearanceStrategy( this.content, value );
    },
    set enabled( value ) { this.setEnabled( value ); },
    getEnabled: function() { return this._enabled; },
    get enabled() { return this.getEnabled(); }
  }, {
    fadeCheckBoxWhenDisabled: function( checkBoxNode, enabled ) {
      checkBoxNode.opacity = enabled ? 1 : DISABLED_OPACITY;
    },
    fadeContentWhenDisabled: function( content, enabled ) {
      content.opacity = enabled ? 1 : DISABLED_OPACITY;
    },
    createTextCheckBox: function( text, textOptions, property, checkBoxOptions ) {
      textOptions = textOptions || {};
      checkBoxOptions = _.extend( {
        icon: null,  // an optional node, added to the right of the text
        iconSpacing: 15
      }, checkBoxOptions );
      var content = new Node();
      var textNode = new Text( text, textOptions );
      content.addChild( textNode );
      if ( checkBoxOptions.icon ) {
        content.addChild( checkBoxOptions.icon );
        checkBoxOptions.icon.left = textNode.right + checkBoxOptions.iconSpacing;
        checkBoxOptions.icon.centerY = textNode.centerY;
      }
      return new CheckBox( content, property, checkBoxOptions );
    }
  } );
  return CheckBox;
} );
define( 'SCENERY/nodes/LayoutBox',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node','DOT/Bounds2'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var DEFAULT_SPACING = 0;
  var LAYOUT_BOX_OPTION_KEYS = [
    'orientation', // 'horizontal' or 'vertical', see setOrientation for documentation
    'spacing', // Spacing between each Node, see setSpacing for documentation
    'align', // How to line up items, see setAlign for documentation
    'resize' // Whether we should update the layout when children change, see setResize for documentation
  ];
  var LAYOUT_POSITION = {
    vertical: 'top',
    horizontal: 'left'
  };
  var LAYOUT_DIMENSION = {
    vertical: 'height',
    horizontal: 'width'
  };
  var LAYOUT_ALIGNMENT = {
    vertical: {
      left: 'left',
      center: 'centerX',
      right: 'right'
    },
    horizontal: {
      top: 'top',
      center: 'centerY',
      bottom: 'bottom'
    }
  };
  function LayoutBox( options ) {
    this._orientation = 'vertical';
    this._spacing = DEFAULT_SPACING;
    this._align = 'center';
    this._resize = true;
    Node.call( this );
    this._boundsListener = this.updateLayoutAutomatically.bind( this );
    this._updateLayoutLocked = false;
    this.onStatic( 'childInserted', this.onLayoutBoxChildInserted.bind( this ) );
    this.onStatic( 'childRemoved', this.onLayoutBoxChildRemoved.bind( this ) );
    this._layoutMutating = true;
    this.mutate( options );
    this._layoutMutating = false;
  }
  scenery.register( 'LayoutBox', LayoutBox );
  return inherit( Node, LayoutBox, {
    _mutatorKeys: LAYOUT_BOX_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    getAlignmentBounds: function() {
      var maxWidth = Number.NEGATIVE_INFINITY;
      var maxHeight = Number.NEGATIVE_INFINITY;
      for ( var i = 0; i < this._children.length; i++ ) {
        var child = this._children[ i ];
        maxWidth = Math.max( maxWidth, child.width );
        maxHeight = Math.max( maxHeight, child.height );
      }
      return new Bounds2( 0, 0, maxWidth, maxHeight );
    },
    layout: function() {
      var children = this._children;
      var layoutPosition = LAYOUT_POSITION[ this._orientation ];
      var layoutDimension = LAYOUT_DIMENSION[ this._orientation ];
      var layoutAlignment = LAYOUT_ALIGNMENT[ this._orientation ][ this._align ];
      var alignmentBounds = this.getAlignmentBounds();
      var position = 0;
      for ( var i = 0; i < children.length; i++ ) {
        var child = children[ i ];
        if ( !child.bounds.isValid() ) {
          continue; // Skip children without bounds
        }
        child[ layoutPosition ] = position;
        child[ layoutAlignment ] = alignmentBounds[ layoutAlignment ];
        position += child[ layoutDimension ] + this._spacing; // Move forward by the node's size, including spacing
      }
    },
    updateLayout: function() {
      if ( !this._updateLayoutLocked ) {
        this._updateLayoutLocked = true;
        this.layout();
        this._updateLayoutLocked = false;
      }
    },
    updateLayoutAutomatically: function() {
      if ( this._layoutMutating || this._resize ) {
        this.updateLayout();
      }
    },
    onLayoutBoxChildInserted: function( node ) {
      if ( this._resize ) {
        node.onStatic( 'bounds', this._boundsListener );
        this.updateLayoutAutomatically();
      }
    },
    onLayoutBoxChildRemoved: function( node ) {
      if ( this._resize ) {
        node.offStatic( 'bounds', this._boundsListener );
        this.updateLayoutAutomatically();
      }
    },
    setChildren: function( children ) {
      if ( this._updateLayoutLocked ) {
        return Node.prototype.setChildren.call( this, children );
      }
      var oldChildren = this.getChildren(); // defensive copy
      this._updateLayoutLocked = true;
      Node.prototype.setChildren.call( this, children );
      this._updateLayoutLocked = false;
      if ( !_.isEqual( oldChildren, children ) ) {
        this.updateLayoutAutomatically();
      }
      return this;
    },
    setOrientation: function( orientation ) {
      assert && assert( this._orientation === 'vertical' || this._orientation === 'horizontal' );
      if ( this._orientation !== orientation ) {
        this._orientation = orientation;
        this.updateLayout();
      }
      return this;
    },
    set orientation( value ) { this.setOrientation( value ); },
    getOrientation: function() {
      return this._orientation;
    },
    get orientation() { return this.getOrientation(); },
    setSpacing: function( spacing ) {
      assert && assert( typeof spacing === 'number' && isFinite( spacing ),
        'spacing must be a finite number' );
      if ( this._spacing !== spacing ) {
        this._spacing = spacing;
        this.updateLayout();
      }
      return this;
    },
    set spacing( value ) { this.setSpacing( value ); },
    getSpacing: function() {
      return this._spacing;
    },
    get spacing() { return this.getSpacing(); },
    setAlign: function( align ) {
      if ( assert ) {
        if ( this._orientation === 'vertical' ) {
          assert( this._align === 'left' || this._align === 'center' || this._align === 'right',
            'Illegal vertical LayoutBox alignment: ' + align );
        }
        else {
          assert( this._align === 'top' || this._align === 'center' || this._align === 'bottom',
            'Illegal horizontal LayoutBox alignment: ' + align );
        }
      }
      if ( this._align !== align ) {
        this._align = align;
        this.updateLayout();
      }
      return this;
    },
    set align( value ) { this.setAlign( value ); },
    getAlign: function() {
      return this._align;
    },
    get align() { return this.getAlign(); },
    setResize: function( resize ) {
      assert && assert( typeof resize === 'boolean', 'resize should be a boolean' );
      if ( this._resize !== resize ) {
        this._resize = resize;
        for ( var i = 0; i < this._children.length; i++ ) {
          var child = this._children[ i ];
          if ( resize ) {
            child.onStatic( 'bounds', this._boundsListener );
          }
          else {
            child.offStatic( 'bounds', this._boundsListener );
          }
        }
        this.updateLayoutAutomatically();
      }
      return this;
    },
    set resize( value ) { this.setResize( value ); },
    isResize: function() {
      return this._resize;
    },
    get resize() { return this.isResize(); }
  } );
} );
define( 'SCENERY/nodes/HBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );
  function HBox( options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    LayoutBox.call( this, _.extend( {}, options, { orientation: 'horizontal' } ) );
  }
  scenery.register( 'HBox', HBox );
  return inherit( LayoutBox, HBox );
} );
define( 'SCENERY/nodes/VBox',['require','PHET_CORE/inherit','SCENERY/nodes/LayoutBox','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var LayoutBox = require( 'SCENERY/nodes/LayoutBox' );
  var scenery = require( 'SCENERY/scenery' );
  function VBox( options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    LayoutBox.call( this, _.extend( {}, options, { orientation: 'vertical' } ) );
  }
  scenery.register( 'VBox', VBox );
  return inherit( LayoutBox, VBox );
} );
define( 'SUN/TVerticalCheckBoxGroup',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','SUN/sun','ifphetio!PHET_IO/phetioInherit','SCENERY/nodes/TNode'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var sun = require( 'SUN/sun' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  function TVerticalCheckBoxGroup( verticalCheckBoxGroup, phetioID ) {
    TNode.call( this, verticalCheckBoxGroup, phetioID );
    assertInstanceOf( verticalCheckBoxGroup, phet.sun.VerticalCheckBoxGroup );
  }
  phetioInherit( TNode, 'TVerticalCheckBoxGroup', TVerticalCheckBoxGroup, {}, {
    documentation: 'A vertical group of checkboxes'
  } );
  sun.register( 'TVerticalCheckBoxGroup', TVerticalCheckBoxGroup );
  return TVerticalCheckBoxGroup;
} );
define( 'SUN/VerticalCheckBoxGroup',['require','SUN/CheckBox','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','SUN/sun','SCENERY/nodes/VBox','TANDEM/Tandem','SUN/TVerticalCheckBoxGroup'],function( require ) {
  'use strict';
  var CheckBox = require( 'SUN/CheckBox' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TVerticalCheckBoxGroup = require( 'SUN/TVerticalCheckBoxGroup' );
  function VerticalCheckBoxGroup( items, options ) {
    options = _.extend( {
      spacing: 10, // vertical spacing
      padding: 8, //TODO what is this? It looks like it's added to the right of the check box. Shouldn't this be an x-margin, added to left and right?
      checkBoxColor: 'black',
      align: 'left',
      boxWidth: 21,
      tandem: Tandem.tandemRequired(),
      phetioType: TVerticalCheckBoxGroup
    }, options );
    var maxWidth = 0;
    for ( var i = 0; i < items.length; i++ ) {
      maxWidth = Math.max( maxWidth, items[ i ].content.width );
    }
    var children = [];
    for ( i = 0; i < items.length; i++ ) {
      (function( i ) {
        var offset = items[ i ].indent || 0;
        var content = new Path( Shape.rect( 0, 0, maxWidth + options.padding - offset, 0 ), { children: [ items[ i ].content ] } );
        if ( Tandem.validationEnabled() ) {
          assert && assert( items[ i ].tandemName, 'Tandem name must be supplied for phet-io' );
        }
        var checkBox = new CheckBox( content, items[ i ].property, {
          textDescription: items[ i ].label + ': Checkbox (' + 'unchecked' + ')',
          checkBoxColor: options.checkBoxColor,
          boxWidth: options.boxWidth,
          tandem: options.tandem.createTandem( items[ i ].tandemName || 'checkBox' )
        } );
        checkBox.mouseArea = checkBox.touchArea = Shape.bounds( checkBox.bounds.dilatedXY( 5, options.spacing / 2 ) );
        if ( items[ i ].indent ) {
          var hBox = new HBox( {
            children: [ new Rectangle( 0, 0, items[ i ].indent, 1 ), checkBox ]
          } );
          children.push( hBox );
        }
        else {
          var simpleBox = new HBox( { children: [ checkBox ] } );
          children.push( simpleBox );
        }
      })( i );
    }
    options.children = children; //TODO bad form, if options.children was already set, then this will blow it away
    VBox.call( this, options );
  }
  sun.register( 'VerticalCheckBoxGroup', VerticalCheckBoxGroup );
  return inherit( VBox, VerticalCheckBoxGroup );
} );
define("string!BUILD_AN_ATOM/element",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/element");});
define("string!BUILD_AN_ATOM/neutralSlashIon",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/neutralSlashIon");});
define("string!BUILD_AN_ATOM/stableSlashUnstable",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/stableSlashUnstable");});
define("string!BUILD_AN_ATOM/show",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/show");});
define("string!BUILD_AN_ATOM/orbits",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/orbits");});
define("string!BUILD_AN_ATOM/cloud",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/cloud");});
define("string!BUILD_AN_ATOM/model",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/model");});
define( 'BUILD_AN_ATOM/common/view/AtomView',['require','SUN/AccordionBox','SUN/AquaRadioButton','SHRED/view/AtomNode','BUILD_AN_ATOM/common/BAAGlobalOptions','BUILD_AN_ATOM/common/BAASharedConstants','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','SHRED/view/BucketDragHandler','SCENERY_PHET/bucket/BucketFront','SCENERY_PHET/bucket/BucketHole','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','SCENERY/nodes/Node','SUN/Panel','SHRED/view/ParticleCountDisplay','SHRED/view/ParticleView','SCENERY/nodes/Path','BUILD_AN_ATOM/buildanatom/view/PeriodicTableAndSymbol','SCENERY_PHET/buttons/ResetAllButton','JOIST/ScreenView','KITE/Shape','SHRED/ShredConstants','SCENERY/nodes/Text','DOT/Vector2','SUN/VerticalCheckBoxGroup','AXON/BooleanProperty','string!BUILD_AN_ATOM/element','string!BUILD_AN_ATOM/neutralSlashIon','string!BUILD_AN_ATOM/stableSlashUnstable','string!BUILD_AN_ATOM/show','string!BUILD_AN_ATOM/orbits','string!BUILD_AN_ATOM/cloud','string!BUILD_AN_ATOM/model'],function( require ) {
  'use strict';
  var AccordionBox = require( 'SUN/AccordionBox' );
  var AquaRadioButton = require( 'SUN/AquaRadioButton' );
  var AtomNode = require( 'SHRED/view/AtomNode' );
  var BAAGlobalOptions = require( 'BUILD_AN_ATOM/common/BAAGlobalOptions' );
  var BAASharedConstants = require( 'BUILD_AN_ATOM/common/BAASharedConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var BucketDragHandler = require( 'SHRED/view/BucketDragHandler' );
  var BucketFront = require( 'SCENERY_PHET/bucket/BucketFront' );
  var BucketHole = require( 'SCENERY_PHET/bucket/BucketHole' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Panel = require( 'SUN/Panel' );
  var ParticleCountDisplay = require( 'SHRED/view/ParticleCountDisplay' );
  var ParticleView = require( 'SHRED/view/ParticleView' );
  var Path = require( 'SCENERY/nodes/Path' );
  var PeriodicTableAndSymbol = require( 'BUILD_AN_ATOM/buildanatom/view/PeriodicTableAndSymbol' );
  var ResetAllButton = require( 'SCENERY_PHET/buttons/ResetAllButton' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var Shape = require( 'KITE/Shape' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var VerticalCheckBoxGroup = require( 'SUN/VerticalCheckBoxGroup' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var elementString = require( 'string!BUILD_AN_ATOM/element' );
  var neutralSlashIonString = require( 'string!BUILD_AN_ATOM/neutralSlashIon' );
  var stableSlashUnstableString = require( 'string!BUILD_AN_ATOM/stableSlashUnstable' );
  var showString = require( 'string!BUILD_AN_ATOM/show' );
  var orbitsString = require( 'string!BUILD_AN_ATOM/orbits' );
  var cloudString = require( 'string!BUILD_AN_ATOM/cloud' );
  var modelString = require( 'string!BUILD_AN_ATOM/model' );
  var CONTROLS_INSET = 10;
  var LABEL_CONTROL_FONT = new PhetFont( 12 );
  var LABEL_CONTROL_MAX_WIDTH = 180;
  var LABEL_CONTROL_LINE_WIDTH = 1;
  var ELECTRON_VIEW_CONTROL_FONT = new PhetFont( 12 );
  var ELECTRON_VIEW_CONTROL_MAX_WIDTH = 60;
  var NUM_NUCLEON_LAYERS = 5; // This is based on max number of particles, may need adjustment if that changes.
  function AtomView( model, tandem ) {
    ScreenView.call( this, { layoutBounds: ShredConstants.LAYOUT_BOUNDS } ); // Call super constructor.
    var self = this;
    this.model = model;
    this.resetFunctions = [];
    this.periodicTableAccordionBoxExpandedProperty = new BooleanProperty( true, {
      tandem: tandem.createTandem( 'periodicTableAccordionBoxExpandedProperty' )
    } );
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( self.layoutBounds.width * 0.3, self.layoutBounds.height * 0.45 ),
      1.0 );
    var atomNode = new AtomNode( model.particleAtom, modelViewTransform, {
      showElementNameProperty: model.showElementNameProperty,
      showNeutralOrIonProperty: model.showNeutralOrIonProperty,
      showStableOrUnstableProperty: model.showStableOrUnstableProperty,
      electronShellDepictionProperty: model.electronShellDepictionProperty,
      tandem: tandem.createTandem( 'atomNode' )
    } );
    this.addChild( atomNode );
    _.each( model.buckets, function( bucket ) {
      self.addChild( new BucketHole( bucket, modelViewTransform ).mutate( {
        pickable: false,
        tandem: tandem.createTandem( bucket.sphereBucketTandem.tail + 'Hole' )
      } ) );
    } );
    var nucleonElectronLayer = new Node( { tandem: tandem.createTandem( 'nucleonElectronLayer' ) } );
    var nucleonLayers = [];
    var nucleonLayersTandem = tandem.createGroupTandem( 'nucleonLayers' );
    _.times( NUM_NUCLEON_LAYERS, function() {
      var nucleonLayer = new Node( { tandem: nucleonLayersTandem.createNextTandem() } );
      nucleonLayers.push( nucleonLayer );
      nucleonElectronLayer.addChild( nucleonLayer );
    } );
    nucleonLayers.reverse(); // Set up the nucleon layers so that layer 0 is in front.
    var electronLayer = new Node( { layerSplit: true, tandem: tandem.createTandem( 'electronLayer' ) } );
    nucleonElectronLayer.addChild( electronLayer );
    var nucleonsGroupTandem = tandem.createGroupTandem( 'nucleons' );
    var electronsGroupTandem = tandem.createGroupTandem( 'electrons' );
    var particleDragBounds = modelViewTransform.viewToModelBounds( this.layoutBounds );
    model.nucleons.forEach( function( nucleon ) {
      nucleonLayers[ nucleon.zLayerProperty.get() ].addChild( new ParticleView( nucleon, modelViewTransform, {
        dragBounds: particleDragBounds,
        highContrastProperty: BAAGlobalOptions.highContrastParticlesProperty,
        tandem: nucleonsGroupTandem.createNextTandem()
      } ) );
      nucleon.zLayerProperty.link( function( zLayer ) {
        assert && assert(
          nucleonLayers.length > zLayer,
          'zLayer for nucleon exceeds number of layers, max number may need increasing.'
        );
        var onCorrectLayer = false;
        nucleonLayers[ zLayer ].children.forEach( function( particleView ) {
          if ( particleView.particle === nucleon ) {
            onCorrectLayer = true;
          }
        } );
        if ( !onCorrectLayer ) {
          var particleView = null;
          for ( var layerIndex = 0; layerIndex < nucleonLayers.length && particleView === null; layerIndex++ ) {
            for ( var childIndex = 0; childIndex < nucleonLayers[ layerIndex ].children.length; childIndex++ ) {
              if ( nucleonLayers[ layerIndex ].children[ childIndex ].particle === nucleon ) {
                particleView = nucleonLayers[ layerIndex ].children[ childIndex ];
                nucleonLayers[ layerIndex ].removeChildAt( childIndex );
                break;
              }
            }
          }
          assert && assert( particleView !== null, 'Particle view not found during relayering' );
          nucleonLayers[ zLayer ].addChild( particleView );
        }
      } );
    } );
    model.electrons.forEach( function( electron ) {
      electronLayer.addChild( new ParticleView( electron, modelViewTransform, {
        dragBounds: particleDragBounds,
        highContrastProperty: BAAGlobalOptions.highContrastParticlesProperty,
        tandem: electronsGroupTandem.createNextTandem()
      } ) );
    } );
    var updateElectronVisibility = function() {
      electronLayer.getChildren().forEach( function( electronNode ) {
        electronNode.visible = model.electronShellDepictionProperty.get() === 'orbits' || !model.particleAtom.electrons.contains( electronNode.particle );
      } );
    };
    model.particleAtom.electrons.lengthProperty.link( updateElectronVisibility );
    model.electronShellDepictionProperty.link( updateElectronVisibility );
    var bucketFrontLayer = new Node( { tandem: tandem.createTandem( 'bucketFrontLayer' ) } );
    _.each( model.buckets, function( bucket ) {
      var bucketFront = new BucketFront( bucket, modelViewTransform, {
        tandem: tandem.createTandem( bucket.sphereBucketTandem.tail + 'Front' )
      } );
      bucketFrontLayer.addChild( bucketFront );
      bucketFront.addInputListener( new BucketDragHandler( bucket, bucketFront, modelViewTransform, {
        tandem: tandem.createTandem( bucket.sphereBucketTandem.tail + 'DragHandler' )
      } ) );
    } );
    var particleCountDisplay = new ParticleCountDisplay( model.particleAtom, 13, 250, {
      tandem: tandem.createTandem( 'particleCountDisplay' )
    } );  // Width arbitrarily chosen.
    this.addChild( particleCountDisplay );
    var periodicTableAndSymbol = new PeriodicTableAndSymbol(
      model.particleAtom,
      tandem.createTandem( 'periodicTableAndSymbol' ),
      {
        pickable: false,
      }
    );
    periodicTableAndSymbol.scale( 0.55 ); // Scale empirically determined to match layout in design doc.
    var periodicTableAccordionBoxTandem = tandem.createTandem( 'periodicTableAccordionBox' );
    this.periodicTableAccordionBox = new AccordionBox( periodicTableAndSymbol, {
      titleNode: new Text( elementString, {
        font: ShredConstants.ACCORDION_BOX_TITLE_FONT,
        maxWidth: ShredConstants.ACCORDION_BOX_TITLE_MAX_WIDTH,
        tandem: periodicTableAccordionBoxTandem.createTandem( 'title' )
      } ),
      fill: ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR,
      contentAlign: 'left',
      titleAlignX: 'left',
      buttonAlign: 'right',
      expandedProperty: this.periodicTableAccordionBoxExpandedProperty,
      buttonTouchAreaXDilation: 8,
      buttonTouchAreaYDilation: 8,
      tandem: periodicTableAccordionBoxTandem,
      accessibleAccordionTitle: elementString
    } );
    this.addChild( this.periodicTableAccordionBox );
    var labelVisibilityControlPanelTandem = tandem.createTandem( 'labelVisibilityControlPanel' );
    var labelVisibilityControlPanel = new Panel( new VerticalCheckBoxGroup( [ {
      content: new Text( elementString, {
        font: LABEL_CONTROL_FONT,
        maxWidth: LABEL_CONTROL_MAX_WIDTH,
        tandem: labelVisibilityControlPanelTandem.createTandem( 'elementText' )
      } ),
      property: model.showElementNameProperty,
      tandemName: 'showElementNameCheckBox'
    }, {
      content: new Text( neutralSlashIonString, {
        font: LABEL_CONTROL_FONT,
        maxWidth: LABEL_CONTROL_MAX_WIDTH,
        tandem: labelVisibilityControlPanelTandem.createTandem( 'neutralOrIonText' )
      } ),
      property: model.showNeutralOrIonProperty,
      tandemName: 'showNeutralOrIonCheckBox'
    }, {
      content: new Text( stableSlashUnstableString, {
        font: LABEL_CONTROL_FONT,
        maxWidth: LABEL_CONTROL_MAX_WIDTH,
        tandem: labelVisibilityControlPanelTandem.createTandem( 'stableUnstableText' )
      } ),
      property: model.showStableOrUnstableProperty,
      tandemName: 'showStableOrUnstableCheckBox'
    } ], {
      boxWidth: 12,
      spacing: 8,
      tandem: tandem.createTandem( 'labelVisibilityCheckBoxGroup' )
    } ), {
      fill: 'rgb( 245, 245, 245 )',
      lineWidth: LABEL_CONTROL_LINE_WIDTH,
      xMargin: 7.5,
      cornerRadius: 5,
      resize: false,
      tandem: labelVisibilityControlPanelTandem
    } );
    var numDividerLines = 2;
    var dividerLineShape = new Shape().moveTo( 0, 0 ).lineTo( labelVisibilityControlPanel.width - 2 * LABEL_CONTROL_LINE_WIDTH, 0 );
    for ( var dividerLines = 0; dividerLines < numDividerLines; dividerLines++ ) {
      var dividerLine1 = new Path( dividerLineShape, {
        lineWidth: 1,
        stroke: 'gray',
        centerY: labelVisibilityControlPanel.height * ( dividerLines + 1 ) / ( numDividerLines + 1 ),
        x: LABEL_CONTROL_LINE_WIDTH / 2
      } );
      labelVisibilityControlPanel.addChild( dividerLine1 );
    }
    this.addChild( labelVisibilityControlPanel );
    var labelVisibilityControlPanelTitle = new Text( showString, {
      font: new PhetFont( { size: 16, weight: 'bold' } ),
      maxWidth: labelVisibilityControlPanel.width,
      tandem: tandem.createTandem( 'labelVisibilityControlPanelTitle' )
    } );
    this.addChild( labelVisibilityControlPanelTitle );
    var radioButtonRadius = 6;
    var orbitsRadioButtonTandem = tandem.createTandem( 'orbitsRadioButton' );
    var orbitsRadioButton = new AquaRadioButton(
      model.electronShellDepictionProperty,
      'orbits',
      new Text( orbitsString, {
          font: ELECTRON_VIEW_CONTROL_FONT,
          maxWidth: ELECTRON_VIEW_CONTROL_MAX_WIDTH,
          tandem: orbitsRadioButtonTandem.createTandem( 'orbitsText' )
        }
      ),
      { radius: radioButtonRadius, tandem: orbitsRadioButtonTandem }
    );
    var cloudRadioButtonTandem = tandem.createTandem( 'cloudRadioButton' );
    var cloudRadioButton = new AquaRadioButton(
      model.electronShellDepictionProperty,
      'cloud',
      new Text( cloudString, {
        font: ELECTRON_VIEW_CONTROL_FONT,
        maxWidth: ELECTRON_VIEW_CONTROL_MAX_WIDTH,
        tandem: cloudRadioButtonTandem.createTandem( 'cloudText' )
      } ),
      { radius: radioButtonRadius, tandem: cloudRadioButtonTandem }
    );
    var electronViewButtonGroup = new Node( { tandem: tandem.createTandem( 'electronViewButtonGroup' ) } );
    electronViewButtonGroup.addChild( new Text( modelString, {
      font: new PhetFont( {
        size: 14,
        weight: 'bold'
      } ),
      maxWidth: ELECTRON_VIEW_CONTROL_MAX_WIDTH + 20,
      tandem: tandem.createTandem( 'electronViewButtonGroupLabel' )
    } ) );
    orbitsRadioButton.top = electronViewButtonGroup.bottom + 5;
    orbitsRadioButton.left = electronViewButtonGroup.left;
    electronViewButtonGroup.addChild( orbitsRadioButton );
    cloudRadioButton.top = electronViewButtonGroup.bottom + 5;
    cloudRadioButton.left = electronViewButtonGroup.left;
    electronViewButtonGroup.addChild( cloudRadioButton );
    this.addChild( electronViewButtonGroup );
    var resetAllButton = new ResetAllButton( {
      listener: function() {
        self.model.reset();
        self.reset();
      },
      right: this.layoutBounds.maxX - CONTROLS_INSET,
      bottom: this.layoutBounds.maxY - CONTROLS_INSET,
      radius: BAASharedConstants.RESET_BUTTON_RADIUS,
      touchAreaDilation: 8,
      tandem: tandem.createTandem( 'resetAllButton' )
    } );
    this.addChild( resetAllButton );
    particleCountDisplay.top = CONTROLS_INSET;
    particleCountDisplay.left = CONTROLS_INSET;
    this.periodicTableAccordionBox.top = CONTROLS_INSET;
    this.periodicTableAccordionBox.right = this.layoutBounds.maxX - CONTROLS_INSET;
    labelVisibilityControlPanel.left = this.periodicTableAccordionBox.left;
    labelVisibilityControlPanel.bottom = this.layoutBounds.height - CONTROLS_INSET;
    labelVisibilityControlPanelTitle.bottom = labelVisibilityControlPanel.top;
    labelVisibilityControlPanelTitle.centerX = labelVisibilityControlPanel.centerX;
    electronViewButtonGroup.left = atomNode.right + 30;
    electronViewButtonGroup.bottom = atomNode.bottom + 5;
    this.controlPanelLayer = new Node( { tandem: tandem.createTandem( 'controlPanelLayer' ) } );
    this.addChild( this.controlPanelLayer );
    this.addChild( nucleonElectronLayer );
    this.addChild( bucketFrontLayer );
  }
  buildAnAtom.register( 'AtomView', AtomView );
  return inherit( ScreenView, AtomView, {
    reset: function() {
      this.periodicTableAccordionBoxExpandedProperty.reset();
    }
  }, {
    NUM_NUCLEON_LAYERS: NUM_NUCLEON_LAYERS
  } );
} );
define( 'DOT/Range',['require','DOT/dot'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  function Range( min, max ) {
    this.min = min;
    this.max = max;
    assert && assert( min <= max );
  }
  dot.register( 'Range', Range );
  Range.prototype = {
    constructor: Range,
    copy: function() {
      return new Range( this.min, this.max );
    },
    getLength: function() {
      return this.max - this.min;
    },
    getCenter: function() {
      return (this.max + this.min) / 2;
    },
    contains: function( value ) {
      return ( value >= this.min ) && ( value <= this.max );
    },
    containsRange: function( range ) {
      return this.min <= range.min && this.max >= range.max;
    },
    intersects: function( range ) {
      return ( this.max >= range.min ) && ( range.max >= this.min );
    },
    intersectsExclusive: function( range ) {
      return ( this.max > range.min ) && ( range.max > this.min );
    },
    toString: function() {
      return '[Range (min:' + this.min + ' max:' + this.max + ')]';
    },
    constrainValue: function( value ) {
      return Math.min( Math.max( value, this.min ), this.max );
    },
    equals: function( other ) {
      return this.min === other.min && this.max === other.max;
    }
  };
  return Range;
} );
define( 'DOT/TVector2',['require','DOT/dot','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/assertions/assertInstanceOf'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  function TVector2( vector2, phetioID ) {
    assertInstanceOf( vector2, phet.dot.Vector2 );
    TObject.call( this, vector2, phetioID );
  }
  phetioInherit( TObject, 'TVector2', TVector2, {}, {
    documentation: 'A numerical object with x/y scalar values',
    fromStateObject: function( stateObject ) {
      return new phet.dot.Vector2( stateObject.x, stateObject.y );
    },
    toStateObject: function( instance ) {
      return { x: instance.x, y: instance.y };
    }
  } );
  dot.register( 'TVector2', TVector2 );
  return TVector2;
} );
define( 'SHRED/model/TParticle',['require','SHRED/shred','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/assertions/assertInstanceOf'],function( require ) {
  'use strict';
  var shred = require( 'SHRED/shred' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  function TParticle( particle, phetioID ) {
    assertInstanceOf( particle, phet.shred.Particle );
    TObject.call( this, particle, phetioID );
  }
  phetioInherit( TObject, 'TParticle', TParticle, {}, {
    documentation: 'The model for a single particle such as an electron, proton, or neutron.'
  } );
  shred.register( 'TParticle', TParticle );
  return TParticle;
} );
define( 'SHRED/model/Particle',['require','PHET_CORE/inherit','AXON/Property','DOT/Range','SHRED/ShredConstants','SHRED/shred','TANDEM/Tandem','DOT/Vector2','DOT/TVector2','SHRED/model/TParticle','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var Range = require( 'DOT/Range' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Vector2 = require( 'DOT/Vector2' );
  var TVector2 = require( 'DOT/TVector2' );
  var TParticle = require( 'SHRED/model/TParticle' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var DEFAULT_PARTICLE_VELOCITY = 200; // Basically in pixels/sec.
  function Particle( type, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      maxZLayer: Number.POSITIVE_INFINITY // for phet-io, can take on values 0-maxZLayer (inclusive)
    }, options );
    this.particleTandem = options.tandem;
    this.type = type; // @public (read-only)
    this.positionProperty = new Property( Vector2.ZERO, {
      useDeepEquality: true,
      tandem: options.tandem && options.tandem.createTandem( 'positionProperty' ),
      phetioValueType: TVector2
    } );
    this.destinationProperty = new Property( Vector2.ZERO, {
      useDeepEquality: true,
      tandem: options.tandem && options.tandem.createTandem( 'destinationProperty' ),
      phetioValueType: TVector2
    } );
    this.radiusProperty = new Property(
      type === 'electron' ? ShredConstants.ELECTRON_RADIUS : ShredConstants.NUCLEON_RADIUS,
      {
        tandem: options.tandem && options.tandem.createTandem( 'radiusProperty' ),
        phetioValueType: TNumber( { type: 'FloatingPoint' } ),
        phetioInstanceDocumentation: 'changes to radius may not be reflected in view'
      }
    );
    this.animationVelocityProperty = new Property( DEFAULT_PARTICLE_VELOCITY, {
      tandem: options.tandem && options.tandem.createTandem( 'animationVelocityProperty' ),
      phetioValueType: TNumber( {
        type: 'FloatingPoint',
        range: new Range( 0, 10 * DEFAULT_PARTICLE_VELOCITY ), // limited for instance proxies, code can handle any value
        units: 'view-coordinates/second'
      } )
    } );
    this.userControlledProperty = new Property( false, {
      tandem: options.tandem && options.tandem.createTandem( 'userControlledProperty' ),
      phetioValueType: TBoolean
    } );
    this.zLayerProperty = new Property( 0, {
      isValidValue: function( value ) {
        return value >= 0 && value <= options.maxZLayer;
      },
      tandem: options.tandem && options.tandem.createTandem( 'zLayerProperty' ),
      phetioValueType: TNumber( {
        type: 'Integer',
        range: new Range( 0, options.maxZLayer )
      } )
    } ); // Used in view, integer value, higher means further back.
    options.tandem.addInstance( this, TParticle );
  }
  shred.register( 'Particle', Particle );
  return inherit( Object, Particle, {
    step: function( dt ) {
      if ( !this.userControlledProperty.get() ) {
        var position = this.positionProperty.get();
        var destination = this.destinationProperty.get();
        var velocity = this.animationVelocityProperty.get();
        var distanceToDestination = position.distance( destination );
        if ( distanceToDestination > dt * velocity ) {
          var stepMagnitude = velocity * dt;
          var stepAngle = Math.atan2( destination.y - position.y, destination.x - position.x );
          var stepVector = Vector2.createPolar( stepMagnitude, stepAngle );
          this.positionProperty.set( position.plus( stepVector ) );
        }
        else if ( distanceToDestination > 0 ) {
          this.moveImmediatelyToDestination();
        }
      }
    },
    moveImmediatelyToDestination: function() {
      this.positionProperty.set( this.destinationProperty.get() );
    },
    setPositionAndDestination: function( newPosition ) {
      assert && assert( newPosition instanceof Vector2, 'Attempt to set non-vector position.' );
      if ( newPosition instanceof Vector2 ) {
        this.destinationProperty.set( newPosition );
        this.moveImmediatelyToDestination();
      }
    }
  }, {
    MAX_LAYERS: 5
  } );
} );
define( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  require( 'DOT/Util' );
  function LinearFunction( a1, a2, b1, b2, clamp ) {
    clamp = _.isUndefined( clamp ) ? false : clamp;
    var map = function( a1, a2, b1, b2, a3, clamp ) {
      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );
      if ( clamp ) {
        var max = Math.max( b1, b2 );
        var min = Math.min( b1, b2 );
        b3 = dot.Util.clamp( b3, min, max );
      }
      return b3;
    };
    var evaluate = function( a3 ) {
      return map( a1, a2, b1, b2, a3, clamp );
    };
    evaluate.inverse = function( b3 ) {
      return map( b1, b2, a1, a2, b3, clamp );
    };
    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)
  }
  dot.register( 'LinearFunction', LinearFunction );
  return LinearFunction;
} );
define( 'AXON/TObservableArray',['require','AXON/axon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit','ifphetio!PHET_IO/types/TVoid','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TFunctionWrapper'],function( require ) {
  'use strict';
  var axon = require( 'AXON/axon' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  function TObservableArray( elementType ) {
    var TObservableArrayImpl = function TObservableArrayImpl( observableArray, phetioID ) {
      assert && assert( typeof( elementType ) === 'function', 'element type should be defined' );
      TObject.call( this, observableArray, phetioID );
      assertInstanceOf( observableArray, phet.axon.ObservableArray );
      var formatForDataStream = function( item ) {
        var result = { phetioID: item.phetioID };
        if ( elementType.toStateObject ) {
          result.state = elementType.toStateObject( item );
        }
        return result;
      };
      toEventOnEmit( observableArray.startedCallbacksForItemAddedEmitter, observableArray.endedCallbacksForItemAddedEmitter, 'model', phetioID, this.constructor, 'itemAdded', formatForDataStream );
      toEventOnEmit( observableArray.startedCallbacksForItemRemovedEmitter, observableArray.endedCallbacksForItemRemovedEmitter, 'model', phetioID, this.constructor, 'itemRemoved', formatForDataStream );
    };
    return phetioInherit( TObject, 'TObservableArray', TObservableArrayImpl, {
        addItemAddedListener: {
          returnType: TVoid,
          parameterTypes: [ TFunctionWrapper( TVoid, [ elementType ] ) ],
          implementation: function( listener ) {
            this.instance.addItemAddedListener( listener );
          },
          documentation: 'Add a listener that is called when an item is added to the observable array.'
        },
        addItemRemovedListener: {
          returnType: TVoid,
          parameterTypes: [ TFunctionWrapper( TVoid, [ elementType ] ) ],
          implementation: function( listener ) {
            this.instance.addItemRemovedListener( listener );
          },
          documentation: 'Add a listener that is called when an item is removed from the observable array.'
        },
        getLength: {
          returnType: TNumber( { type: 'Integer' } ),
          parameterTypes: [],
          implementation: function() {
            return this.instance.length;
          },
          documentation: 'Get the number of elements in the observable array'
        }
      },
      {
        documentation: 'An array that sends notifications when its values have changed.',
        elementType: elementType,
        events: [ 'itemAdded', 'itemRemoved' ]
      } );
  }
  axon.register( 'TObservableArray', TObservableArray );
  return TObservableArray;
} );
define( 'AXON/ObservableArray',['require','AXON/Property','AXON/axon','PHET_CORE/inherit','AXON/Emitter','AXON/TObservableArray','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Property = require( 'AXON/Property' );
  var axon = require( 'AXON/axon' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var TObservableArray = require( 'AXON/TObservableArray' );
  var Tandem = require( 'TANDEM/Tandem' );
  function ObservableArray( array, options ) {
    var self = this;
    if ( array instanceof Object && !(array instanceof Array) ) {
      options = array;
      array = null;
    }
    options = _.extend( {
      allowDuplicates: false, // are duplicate items allowed in the array?
      tandem: Tandem.tandemOptional(),
      phetioValueType: null
    }, options );
    this.allowDuplicates = options.allowDuplicates; // @private
    this._array = array || []; // @private internal, do not access directly
    this._addedListeners = []; // @private listeners called when an item is added
    this._removedListeners = []; // @private listeners called when an item is removed
    this.lengthProperty = new Property( this._array.length ); // @public (read-only) observe this, but don't set it
    this.initialArray = array ? array.slice() : [];
    this.startedCallbacksForItemAddedEmitter = new Emitter();
    this.endedCallbacksForItemAddedEmitter = new Emitter();
    this.startedCallbacksForItemRemovedEmitter = new Emitter();
    this.endedCallbacksForItemRemovedEmitter = new Emitter();
    options.tandem.supplied && options.tandem.addInstance( this, TObservableArray( options.phetioValueType ) );
    this.disposeObservableArray = function() {
      options.tandem.supplied && options.tandem.removeInstance( self );
    };
  }
  axon.register( 'ObservableArray', ObservableArray );
  return inherit( Object, ObservableArray, {
    dispose: function() {
      this.disposeObservableArray();
    },
    reset: function() {
      for ( var i = 0; i < this._array.length; i++ ) {
        this._fireItemRemoved( this._array[ i ] );
      }
      this._array = this.initialArray.slice();
      for ( i = 0; i < this._array.length; i++ ) {
        this._fireItemAdded( this._array[ i ] );
      }
    },
    get length() { return this._array.length; },
    addItemAddedListener: function( listener ) {
      assert && assert( this._addedListeners.indexOf( listener ) === -1 ); // listener is not already registered
      this._addedListeners.push( listener );
    },
    removeItemAddedListener: function( listener ) {
      var index = this._addedListeners.indexOf( listener );
      assert && assert( index !== -1 ); // listener is registered
      this._addedListeners.splice( index, 1 );
    },
    addItemRemovedListener: function( listener ) {
      assert && assert( this._removedListeners.indexOf( listener ) === -1, 'Listener was already registered' ); // listener is not already registered
      this._removedListeners.push( listener );
    },
    removeItemRemovedListener: function( listener ) {
      var index = this._removedListeners.indexOf( listener );
      assert && assert( index !== -1, 'Listener is still registered after removal' ); // listener is registered
      this._removedListeners.splice( index, 1 );
    },
    _fireItemAdded: function( item ) {
      this.startedCallbacksForItemAddedEmitter.emit1( item );
      var copy = this._addedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }
      this.endedCallbacksForItemAddedEmitter.emit();
    },
    _fireItemRemoved: function( item ) {
      this.startedCallbacksForItemRemovedEmitter.emit1( item );
      var copy = this._removedListeners.slice( 0 ); // operate on a copy, firing could result in the listeners changing
      for ( var i = 0; i < copy.length; i++ ) {
        copy[ i ]( item, this );
      }
      this.endedCallbacksForItemRemovedEmitter.emit();
    },
    add: function( item ) {
      this.push( item );
    },
    addAll: function( items ) {
      for ( var i = 0; i < items.length; i++ ) {
        this.add( items[ i ] );
      }
    },
    remove: function( item ) {
      var index = this._array.indexOf( item );
      if ( index !== -1 ) {
        this._array.splice( index, 1 );
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
    },
    removeAll: function( array ) {
      assert && assert( _.isArray( array ), 'array should be an array' );
      for ( var i = 0; i < array.length; i++ ) {
        this.remove( array[ i ] );
      }
    },
    push: function( item ) {
      if ( !this.allowDuplicates && this.contains( item ) ) {
        throw new Error( 'duplicates are not allowed' );
      }
      this._array.push( item );
      this.lengthProperty.set( this._array.length );
      this._fireItemAdded( item );
    },
    pop: function() {
      var item = this._array.pop();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },
    shift: function() {
      var item = this._array.shift();
      if ( item !== undefined ) {
        this.lengthProperty.set( this._array.length );
        this._fireItemRemoved( item );
      }
      return item;
    },
    contains: function( item ) {
      return this.indexOf( item ) !== -1;
    },
    get: function( index ) {
      return this._array[ index ];
    },
    indexOf: function( item ) {
      return this._array.indexOf( item );
    },
    clear: function() {
      while ( this.length > 0 ) {
        this.pop();
      }
    },
    forEach: function( callback ) {
      this._array.slice().forEach( callback ); // do this on a copy of the array, in case callbacks involve array modification
    },
    map: function( mapFunction ) {
      return new ObservableArray( this._array.map( mapFunction ) );
    },
    filter: function( predicate ) {
      return new ObservableArray( this._array.filter( predicate ) );
    },
    count: function( predicate ) {
      var count = 0;
      for ( var i = 0; i < this._array.length; i++ ) {
        if ( predicate( this._array[ i ] ) ) {
          count++;
        }
      }
      return count;
    },
    anyElementMatchesPredicate: function( predicate ) {
      for ( var i = 0; i < this._array.length; i++ ) {
        if ( predicate( this._array[ i ] ) ) {
          return true;
        }
      }
      return false;
    },
    reduce: function( value, combiner ) {
      for ( var i = 0; i < this._array.length; i++ ) {
        value = combiner( value, this._array[ i ] );
      }
      return value;
    },
    getArray: function() {
      return this._array;
    },
    splice: function( start, deleteCount, item1, item2, etc ) {
      var deleted = this._array.splice.apply( this._array, arguments );
      var args = Array.prototype.slice.call( arguments );
      for ( var i = 0; i < deleted.length; i++ ) {
        this._fireItemRemoved( deleted[ i ] );
      }
      for ( var k = 2; k < args.length; k++ ) {
        this._fireItemAdded( args[ k ] );
      }
      return deleted;
    }
  } );
} );
define( 'SHRED/Utils',['require','SHRED/shred'],function( require ) {
  'use strict';
  var shred = require( 'SHRED/shred' );
  var Utils = {
    roughlyEqual: function( value1, value2, tolerance ) {
      return Math.abs( value1 - value2 ) < tolerance;
    }
  };
  shred.register( 'Utils', Utils);
  return Utils;
} );
define( 'SHRED/model/TParticleAtom',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetio','SHRED/shred','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  var shred = require( 'SHRED/shred' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  function TParticleAtom( instance, phetioID ) {
    TObject.call( this, instance, phetioID );
    assertInstanceOf( instance, phet.shred.ParticleAtom );
  }
  function getParticleTandemID( particle ) {
    return particle.particleTandem.id;
  }
  phetioInherit( TObject, 'TParticleAtom', TParticleAtom, {}, {
    documentation: 'A model of an atom that tracks and arranges the subatomic particles, i.e. protons, neutrons, ' +
                   'and electrons, of which it is comprised.  When particles are added, they are moved into the ' +
                   'appropriate places.  This object also keeps track of things like atomic number, mass number, and ' +
                   'charge.',
    toStateObject: function( instance ) {
      return {
        residentParticleIDs: instance.protons.map( getParticleTandemID ).getArray()
          .concat( instance.neutrons.map( getParticleTandemID ).getArray() )
          .concat( instance.electrons.map( getParticleTandemID ).getArray() ),
        electronShellOccupantIDs: instance.electronShellPositions.map( function( electronShellPosition ) {
          return electronShellPosition.electron ? getParticleTandemID( electronShellPosition.electron ) : null;
        } )
      };
    },
    fromStateObject: function( stateObject ) {
      return {
        residentParticles: stateObject.residentParticleIDs.map( function( tandemID ) {
          return phetio.getInstance( tandemID );
        } ),
        electronShellOccupants: stateObject.electronShellOccupantIDs.map( function( tandemID ) {
          return tandemID ? phetio.getInstance( tandemID ) : null;
        } )
      };
    },
    setValue: function( instance, particleAtomState ) {
      instance.clear();
      particleAtomState.residentParticles.forEach( function( value ) { instance.addParticle( value ); } );
      particleAtomState.electronShellOccupants.forEach( function( electron, index ) {
        instance.electronShellPositions[ index ].electron = electron;
      } );
    }
  } );
  shred.register( 'TParticleAtom', TParticleAtom );
  return TParticleAtom;
} );
define( 'SHRED/model/ParticleAtom',['require','SHRED/AtomIdentifier','AXON/DerivedProperty','PHET_CORE/inherit','DOT/LinearFunction','AXON/ObservableArray','AXON/Property','SHRED/ShredConstants','SHRED/shred','TANDEM/Tandem','SHRED/Utils','DOT/Vector2','DOT/TVector2','SHRED/model/TParticle','SHRED/model/TParticleAtom','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearFunction = require( 'DOT/LinearFunction' );
  var ObservableArray = require( 'AXON/ObservableArray' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Utils = require( 'SHRED/Utils' );
  var Vector2 = require( 'DOT/Vector2' );
  var TVector2 = require( 'DOT/TVector2' );
  var TParticle = require( 'SHRED/model/TParticle' );
  var TParticleAtom = require( 'SHRED/model/TParticleAtom' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var NUM_ELECTRON_POSITIONS = 10; // first two electron shells, i.e. 2 + 8
  function ParticleAtom( options ) {
    var self = this;
    options = _.extend( {
      innerElectronShellRadius: 85,
      outerElectronShellRadius: 130,
      nucleonRadius: ShredConstants.NUCLEON_RADIUS,
      tandem: Tandem.tandemRequired()
    }, options );
    this.nucleonRadius = options.nucleonRadius; // @private
    this.nucleusRadius = 0;
    this.positionProperty = new Property( Vector2.ZERO, {
      useDeepEquality: true,
      tandem: options.tandem.createTandem( 'positionProperty' ),
      phetioValueType: TVector2
    } );
    this.nucleusOffsetProperty = new Property( Vector2.ZERO, {
      useDeepEquality: true,
      tandem: options.tandem.createTandem( 'nucleusOffsetProperty' ),
      phetioValueType: TVector2
    } );
    this.protons = new ObservableArray( {
      tandem: options.tandem.createTandem( 'protons' ),
      phetioValueType: TParticle
    } );
    this.neutrons = new ObservableArray( {
      tandem: options.tandem.createTandem( 'neutrons' ),
      phetioValueType: TParticle
    } );
    this.electrons = new ObservableArray( {
      tandem: options.tandem.createTandem( 'electrons' ),
      phetioValueType: TParticle
    } );
    this.protonCountProperty = new DerivedProperty(
      [ this.protons.lengthProperty ],
      function( length ) {
        return length;
      },
      {
        tandem: options.tandem.createTandem( 'protonCountProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.neutronCountProperty = new DerivedProperty(
      [ this.neutrons.lengthProperty ],
      function( length ) {
        return length;
      },
      {
        tandem: options.tandem.createTandem( 'neutronCountProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.electronCountProperty = new DerivedProperty(
      [ this.electrons.lengthProperty ],
      function( length ) {
        return length;
      },
      {
        tandem: options.tandem.createTandem( 'electronCountProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.chargeProperty = new DerivedProperty(
      [ this.protonCountProperty, this.electronCountProperty ],
      function( protonCount, electronCount ) {
        return protonCount - electronCount;
      },
      {
        tandem: options.tandem.createTandem( 'chargeProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.massNumberProperty = new DerivedProperty(
      [ this.protonCountProperty, this.neutronCountProperty ],
      function( protonCount, neutronCount ) {
        return protonCount + neutronCount;
      },
      {
        tandem: options.tandem.createTandem( 'massNumberProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.particleCountProperty = new DerivedProperty(
      [ this.protonCountProperty, this.neutronCountProperty, this.electronCountProperty ],
      function( protonCount, neutronCount, electronCount ) {
        return protonCount + neutronCount + electronCount;
      },
      {
        tandem: options.tandem.createTandem( 'particleCountProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.innerElectronShellRadius = options.innerElectronShellRadius; // @public
    this.outerElectronShellRadius = options.outerElectronShellRadius; // @public
    this.electronAddMode = 'proximal'; // @private
    this.electronShellPositions = new Array( NUM_ELECTRON_POSITIONS ); // @private
    this.electronShellPositions[ 0 ] = {
      electron: null,
      position: new Vector2( self.innerElectronShellRadius, 0 )
    };
    this.electronShellPositions[ 1 ] = {
      electron: null,
      position: new Vector2( -self.innerElectronShellRadius, 0 )
    };
    var numSlotsInOuterShell = 8;
    var angle = Math.PI / numSlotsInOuterShell * 1.2;
    for ( var i = 0; i < numSlotsInOuterShell; i++ ) {
      this.electronShellPositions[ i + 2 ] = {
        electron: null,
        position: new Vector2(
          Math.cos( angle ) * self.outerElectronShellRadius,
          Math.sin( angle ) * self.outerElectronShellRadius
        )
      };
      angle += 2 * Math.PI / numSlotsInOuterShell;
    }
    this.electrons.addItemRemovedListener( function( electron ) {
      self.electronShellPositions.forEach( function( electronShellPosition ) {
        if ( electronShellPosition.electron === electron ) {
          electronShellPosition.electron = null;
          if ( Math.abs( electronShellPosition.position.magnitude() - self.innerElectronShellRadius ) < 1E-5 ) {
            var occupiedOuterShellPositions = _.filter( self.electronShellPositions, function( electronShellPosition ) {
              return ( electronShellPosition.electron !== null &&
                       Utils.roughlyEqual( electronShellPosition.position.magnitude(),
                         self.outerElectronShellRadius,
                         1E-5
                       )
              );
            } );
            occupiedOuterShellPositions = _.sortBy( occupiedOuterShellPositions, function( occupiedShellPosition ) {
              return occupiedShellPosition.position.distance( electronShellPosition.position );
            } );
            if ( occupiedOuterShellPositions.length > 0 ) {
              electronShellPosition.electron = occupiedOuterShellPositions[ 0 ].electron;
              occupiedOuterShellPositions[ 0 ].electron = null;
              electronShellPosition.electron.destinationProperty.set( electronShellPosition.position );
            }
          }
        }
      } );
    } );
    var translateParticle = function( particle, translation ) {
      if ( particle.positionProperty.get().equals( particle.destinationProperty.get() ) ) {
        particle.setPositionAndDestination( particle.positionProperty.get().plus( translation ) );
      }
      else {
        particle.destinationProperty.set( particle.destinationProperty.get().plus( translation ) );
      }
    };
    this.nucleusOffsetProperty.link( function( newOffset, oldOffset ) {
      var translation = oldOffset === null ? Vector2.ZERO : newOffset.minus( oldOffset );
      self.protons.forEach( function( particle ) {
        translateParticle( particle, translation );
      } );
      self.neutrons.forEach( function( particle ) {
        translateParticle( particle, translation );
      } );
    } );
    this.positionProperty.link( function( newOffset, oldOffset ) {
      var translation = oldOffset === null ? Vector2.ZERO : newOffset.minus( oldOffset );
      self.protons.forEach( function( particle ) {
        translateParticle( particle, translation );
      } );
      self.neutrons.forEach( function( particle ) {
        translateParticle( particle, translation );
      } );
    } );
    options.tandem.addInstance( this, TParticleAtom );
  }
  shred.register( 'ParticleAtom', ParticleAtom );
  return inherit( Object, ParticleAtom, {
    containsParticle: function( particle ) {
      return this.protons.contains( particle ) ||
             this.neutrons.contains( particle ) ||
             this.electrons.contains( particle );
    },
    addParticle: function( particle ) {
      if ( phet.phetio && this.containsParticle( particle ) ) {
        return;
      }
      var self = this;
      if ( particle.type === 'proton' || particle.type === 'neutron' ) {
        var nucleonRemovedListener = function( userControlled ) {
          if ( userControlled && particleArray.contains( particle ) ) {
            particleArray.remove( particle );
            self.reconfigureNucleus();
            particle.zLayerProperty.set( 0 );
            particle.userControlledProperty.unlink( nucleonRemovedListener );
            delete particle.particleAtomRemovalListener;
          }
        };
        particle.userControlledProperty.lazyLink( nucleonRemovedListener );
        particle.particleAtomRemovalListener = nucleonRemovedListener;
        var particleArray = particle.type === 'proton' ? this.protons : this.neutrons;
        particleArray.push( particle );
        this.reconfigureNucleus();
      }
      else if ( particle.type === 'electron' ) {
        this.electrons.push( particle );
        var openPositions = this.electronShellPositions.filter( function( electronPosition ) {
          return ( electronPosition.electron === null );
        } );
        var sortedOpenPositions;
        if ( this.electronAddMode === 'proximal' ) {
          sortedOpenPositions = openPositions.sort( function( p1, p2 ) {
            return ( particle.positionProperty.get().distance( p1.position ) -
                     particle.positionProperty.get().distance( p2.position ) );
          } );
        }
        else {
          sortedOpenPositions = phet.joist.random.shuffle( openPositions );
        }
        sortedOpenPositions = sortedOpenPositions.sort( function( p1, p2 ) {
          return ( self.positionProperty.get().distance( p1.position ) -
                   self.positionProperty.get().distance( p2.position ) );
        } );
        assert && assert( sortedOpenPositions.length > 0, 'No open positions found for electrons' );
        sortedOpenPositions[ 0 ].electron = particle;
        particle.destinationProperty.set( sortedOpenPositions[ 0 ].position );
        var electronRemovedListener = function( userControlled ) {
          if ( userControlled && self.electrons.contains( particle ) ) {
            self.electrons.remove( particle );
            particle.zLayerProperty.set( 0 );
            particle.userControlledProperty.unlink( electronRemovedListener );
            delete particle.particleAtomRemovalListener;
          }
        };
        particle.userControlledProperty.lazyLink( electronRemovedListener );
        particle.particleAtomRemovalListener = electronRemovedListener;
      }
      else {
        throw new Error( 'Unexpected particle type.' );
      }
    },
    removeParticle: function( particle ) {
      if ( this.protons.contains( particle ) ) {
        this.protons.remove( particle );
      }
      else if ( this.neutrons.contains( particle ) ) {
        this.neutrons.remove( particle );
      }
      else if ( this.electrons.contains( particle ) ) {
        this.electrons.remove( particle );
      }
      else {
        throw new Error( 'Attempt to remove particle that is not in this particle atom.' );
      }
      assert && assert( typeof( particle.particleAtomRemovalListener ) === 'function',
        'No particle removal listener attached to particle.' );
      particle.userControlledProperty.unlink( particle.particleAtomRemovalListener );
      delete particle.particleAtomRemovalListener;
    },
    extractParticle: function( particleType ) {
      var particle = null;
      switch( particleType ) {
        case 'proton':
          if ( this.protons.length > 0 ) {
            particle = this.protons.get( this.protons.length - 1 );
          }
          break;
        case 'neutron':
          if ( this.neutrons.length > 0 ) {
            particle = this.neutrons.get( this.neutrons.length - 1 );
          }
          break;
        case 'electron':
          if ( this.electrons.length > 0 ) {
            particle = this.electrons.get( this.electrons.length - 1 );
          }
          break;
        default:
          throw new Error( 'Attempt to remove unknown particle type.' );
      }
      if ( particle !== null ) {
        this.removeParticle( particle );
      }
      return particle;
    },
    clear: function() {
      var self = this;
      this.protons.forEach( function( particle ) { self.removeParticle( particle ); } );
      this.neutrons.forEach( function( particle ) { self.removeParticle( particle ); } );
      this.electrons.forEach( function( particle ) { self.removeParticle( particle ); } );
    },
    moveAllParticlesToDestination: function() {
      this.protons.forEach( function( p ) { p.moveImmediatelyToDestination(); } );
      this.neutrons.forEach( function( p ) { p.moveImmediatelyToDestination(); } );
      this.electrons.forEach( function( p ) { p.moveImmediatelyToDestination(); } );
    },
    getWeight: function() {
      return this.protonCountProperty.get() + this.neutronCountProperty.get();
    },
    getCharge: function() {
      return this.protonCountProperty.get() - this.electronCountProperty.get();
    },
    getIsotopeAtomicMass: function() {
      return AtomIdentifier.getIsotopeAtomicMass( this.protonCountProperty.get(), this.neutronCountProperty.get() );
    },
    reconfigureNucleus: function() {
      var centerX = this.positionProperty.get().x + this.nucleusOffsetProperty.get().x;
      var centerY = this.positionProperty.get().y + this.nucleusOffsetProperty.get().y;
      var nucleonRadius = this.nucleonRadius;
      var angle;
      var distFromCenter;
      var nucleusRadius = nucleonRadius;
      var nucleons = [];
      var protonIndex = 0;
      var neutronIndex = 0;
      var neutronsPerProton = this.neutrons.length / this.protons.length;
      var neutronsToAdd = 0;
      while ( nucleons.length < this.neutrons.length + this.protons.length ) {
        neutronsToAdd += neutronsPerProton;
        while ( neutronsToAdd >= 1 && neutronIndex < this.neutrons.length ) {
          nucleons.push( this.neutrons.get( neutronIndex++ ) );
          neutronsToAdd -= 1;
        }
        if ( protonIndex < this.protons.length ) {
          nucleons.push( this.protons.get( protonIndex++ ) );
        }
      }
      if ( nucleons.length === 1 ) {
        nucleusRadius = this.nucleonRadius;
        nucleons[ 0 ].destinationProperty.set( new Vector2( centerX, centerY ) );
        nucleons[ 0 ].zLayerProperty.set( 0 );
      }
      else if ( nucleons.length === 2 ) {
        nucleusRadius = this.nucleonRadius * 2;
        angle = 0.2 * 2 * Math.PI; // Angle arbitrarily chosen.
        nucleons[ 0 ].destinationProperty.set( new Vector2( centerX + nucleonRadius * Math.cos( angle ),
          centerY + nucleonRadius * Math.sin( angle ) ) );
        nucleons[ 0 ].zLayerProperty.set( 0 );
        nucleons[ 1 ].destinationProperty.set( new Vector2( centerX - nucleonRadius * Math.cos( angle ),
          centerY - nucleonRadius * Math.sin( angle ) ) );
        nucleons[ 1 ].zLayerProperty.set( 0 );
      }
      else if ( nucleons.length === 3 ) {
        angle = 0.7 * 2 * Math.PI; // Angle arbitrarily chosen.
        distFromCenter = nucleonRadius * 1.155;
        nucleons[ 0 ].destinationProperty.set( new Vector2( centerX + distFromCenter * Math.cos( angle ),
          centerY + distFromCenter * Math.sin( angle ) ) );
        nucleons[ 0 ].zLayerProperty.set( 0 );
        nucleons[ 1 ].destinationProperty.set( new Vector2( centerX + distFromCenter * Math.cos( angle + 2 * Math.PI / 3 ),
          centerY + distFromCenter * Math.sin( angle + 2 * Math.PI / 3 ) ) );
        nucleons[ 1 ].zLayerProperty.set( 0 );
        nucleons[ 2 ].destinationProperty.set( new Vector2( centerX + distFromCenter * Math.cos( angle + 4 * Math.PI / 3 ),
          centerY + distFromCenter * Math.sin( angle + 4 * Math.PI / 3 ) ) );
        nucleons[ 2 ].zLayerProperty.set( 0 );
        nucleusRadius = distFromCenter + nucleonRadius;
      }
      else if ( nucleons.length === 4 ) {
        angle = 1.4 * 2 * Math.PI; // Angle arbitrarily chosen.
        nucleons[ 0 ].destinationProperty.set( new Vector2( centerX + nucleonRadius * Math.cos( angle ),
          centerY + nucleonRadius * Math.sin( angle ) ) );
        nucleons[ 0 ].zLayerProperty.set( 0 );
        nucleons[ 2 ].destinationProperty.set( new Vector2( centerX - nucleonRadius * Math.cos( angle ),
          centerY - nucleonRadius * Math.sin( angle ) ) );
        nucleons[ 2 ].zLayerProperty.set( 0 );
        distFromCenter = nucleonRadius * 2 * Math.cos( Math.PI / 3 );
        nucleons[ 1 ].destinationProperty.set( new Vector2( centerX + distFromCenter * Math.cos( angle + Math.PI / 2 ),
          centerY + distFromCenter * Math.sin( angle + Math.PI / 2 ) ) );
        nucleons[ 1 ].zLayerProperty.set( 1 );
        nucleons[ 3 ].destinationProperty.set( new Vector2( centerX - distFromCenter * Math.cos( angle + Math.PI / 2 ),
          centerY - distFromCenter * Math.sin( angle + Math.PI / 2 ) ) );
        nucleons[ 3 ].zLayerProperty.set( 1 );
        nucleusRadius = distFromCenter + nucleonRadius;
      }
      else if ( nucleons.length >= 5 ) {
        var placementRadius = 0;
        var numAtThisRadius = 1;
        var level = 0;
        var placementAngle = 0;
        var placementAngleDelta = 0;
        var radiusA = 3;
        var radiusB = 10;
        var scaleFactorA = 2.4;
        var scaleFactorB = 1.35;
        var scaleFunction = LinearFunction( radiusA, radiusB, scaleFactorA, scaleFactorB, this.nucleonRadius );
        var scaleFactor = scaleFunction( this.nucleonRadius );
        for ( var i = 0; i < nucleons.length; i++ ) {
          nucleons[ i ].destinationProperty.set( new Vector2( centerX + placementRadius * Math.cos( placementAngle ),
            centerY + placementRadius * Math.sin( placementAngle ) ) );
          nucleons[ i ].zLayerProperty.set( level );
          numAtThisRadius--;
          if ( numAtThisRadius > 0 ) {
            placementAngle += placementAngleDelta;
          }
          else {
            level++;
            placementRadius += nucleonRadius * scaleFactor / level;
            placementAngle += 2 * Math.PI * 0.2 + level * Math.PI; // Arbitrary value chosen based on looks.
            numAtThisRadius = Math.floor( placementRadius * Math.PI / nucleonRadius );
            placementAngleDelta = 2 * Math.PI / numAtThisRadius;
          }
        }
        nucleusRadius = placementRadius + this.nucleonRadius;
      }
      this.nucleusRadius = nucleusRadius;
    }
  } );
} );
define( 'PHETCOMMON/model/Bucket',['require','DOT/Vector2','DOT/Dimension2','KITE/Shape','PHETCOMMON/phetcommon'],function( require ) {
  'use strict';
  var Vector2 = require( 'DOT/Vector2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Shape = require( 'KITE/Shape' );
  var phetcommon = require( 'PHETCOMMON/phetcommon' );
  var HOLE_ELLIPSE_HEIGHT_PROPORTION = 0.25;
  function Bucket( options ) {
    options = _.extend( {
      position: Vector2.ZERO,
      size: new Dimension2( 200, 50 ),
      baseColor: '#ff0000',
      captionText: '',
      captionColor: 'white',
      invertY: false
    }, options );
    this.position = options.position;
    this.baseColor = options.baseColor;
    this.captionText = options.captionText;
    this.captionColor = options.captionColor;
    this.size = options.size;
    var size = this.size;
    var holeRadiusX = size.width / 2;
    var holeRadiusY = size.height * HOLE_ELLIPSE_HEIGHT_PROPORTION / 2;
    this.holeShape = Shape.ellipse( 0, 0, holeRadiusX, holeRadiusY );
    var containerHeight = size.height * ( 1 - ( HOLE_ELLIPSE_HEIGHT_PROPORTION / 2 ) );
    var multiplier = options.invertY ? 1 : -1;
    this.containerShape = new Shape().moveTo( -size.width * 0.5, 0 )
      .lineTo( -size.width * 0.4, multiplier * containerHeight * 0.8 )
      .cubicCurveTo( -size.width * 0.3, multiplier * ( containerHeight * 0.8 + size.height * HOLE_ELLIPSE_HEIGHT_PROPORTION * 0.6 ),
        size.width * 0.3, multiplier * ( containerHeight * 0.8 + size.height * HOLE_ELLIPSE_HEIGHT_PROPORTION * 0.6 ),
        size.width * 0.4, multiplier * containerHeight * 0.8 )
      .lineTo( size.width * 0.5, 0 )
      .ellipticalArc( 0, 0, holeRadiusX, holeRadiusY, 0, 0, Math.PI, !options.invertY )
      .close();
  }
  phetcommon.register( 'Bucket', Bucket );
  return Bucket;
} );
define( 'PHETCOMMON/model/TSphereBucket',['require','PHETCOMMON/phetcommon','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetio','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';
  var phetcommon = require( 'PHETCOMMON/phetcommon' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  function TSphereBucket( instance, phetioID ) {
    TObject.call( this, instance, phetioID );
    assertInstanceOf( instance, phet.phetcommon.SphereBucket );
  }
  function getParticleTandemID( particle ) {
    return particle.particleTandem.id;
  }
  phetioInherit( TObject, 'TSphereBucket', TSphereBucket, {}, {
    toStateObject: function( instance ) {
      return instance._particles.map( getParticleTandemID );
    },
    fromStateObject: function( stateArray ) {
      return stateArray.map( function( tandemID ) { return phetio.getInstance( tandemID ); } );
    },
    setValue: function( instance, particleArray ) {
      instance.reset();
      particleArray.forEach( function( particle ) { instance.addParticle( particle ); } );
    },
    documentation: 'A model of a bucket into which spherical objects can be placed.'
  } );
  phetcommon.register( 'TSphereBucket', TSphereBucket );
  return TSphereBucket;
} );
define( 'PHETCOMMON/model/SphereBucket',['require','PHETCOMMON/model/Bucket','PHET_CORE/cleanArray','PHET_CORE/inherit','PHETCOMMON/phetcommon','TANDEM/Tandem','DOT/Vector2','PHETCOMMON/model/TSphereBucket'],function( require ) {
  'use strict';
  var Bucket = require( 'PHETCOMMON/model/Bucket' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var inherit = require( 'PHET_CORE/inherit' );
  var phetcommon = require( 'PHETCOMMON/phetcommon' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Vector2 = require( 'DOT/Vector2' );
  var TSphereBucket = require( 'PHETCOMMON/model/TSphereBucket' );
  function SphereBucket( options ) {
    Bucket.call( this, options );
    options = _.extend( {
      sphereRadius: 10,  // expected radius of the spheres that will be placed in this bucket
      usableWidthProportion: 1.0,  // proportion of the bucket width that the spheres can occupy
      tandem: Tandem.tandemOptional()
    }, options );
    this.sphereBucketTandem = options.tandem;
    this._sphereRadius = options.sphereRadius;
    this._usableWidthProportion = options.usableWidthProportion;
    this._verticalParticleOffset = options.verticalParticleOffset || -this._sphereRadius * 0.4;
    this._particles = [];
    options.tandem.addInstance( this, TSphereBucket );
  }
  phetcommon.register( 'SphereBucket', SphereBucket );
  inherit( Bucket, SphereBucket, {
    addParticleFirstOpen: function( particle, animate ) {
      particle.destinationProperty.set( this.getFirstOpenLocation() );
      this.addParticle( particle, animate );
    },
    addParticleNearestOpen: function( particle, animate ) {
      particle.destinationProperty.set( this.getNearestOpenLocation( particle.destinationProperty.get() ) );
      this.addParticle( particle, animate );
    },
    addParticle: function( particle, animate ) {
      if ( !animate ) {
        particle.positionProperty.set( particle.destinationProperty.get() );
      }
      this._particles.push( particle );
      var self = this;
      var particleRemovedListener = function( userControlled ) {
        self.removeParticle( particle );
        particle.userControlledProperty.unlink( particleRemovedListener );
        delete particle.bucketRemovalListener;
      };
      particle.userControlledProperty.lazyLink( particleRemovedListener );
      particle.bucketRemovalListener = particleRemovedListener; // Attach to the particle to aid unlinking in some cases.
    },
    removeParticle: function( particle, skipLayout ) {
      assert && assert( this.containsParticle( particle ), 'attempt made to remove particle that is not in bucket' );
      this._particles = _.without( this._particles, particle );
      if ( particle.bucketRemovalListener ) {
        particle.userControlledProperty.unlink( particle.bucketRemovalListener );
        delete particle.bucketRemovalListener;
      }
      if ( !skipLayout ) {
        this.relayoutBucketParticles();
      }
    },
    containsParticle: function( particle ) {
      return this._particles.indexOf( particle ) !== -1;
    },
    extractClosestParticle: function( location ) {
      var closestParticle = null;
      this._particles.forEach( function( particle ) {
        if ( closestParticle === null ||
             closestParticle.positionProperty.get().distance( location ) > particle.positionProperty.get().distance( location ) ) {
          closestParticle = particle;
        }
      } );
      if ( closestParticle !== null ) {
        closestParticle.userControlledProperty.set( true );
      }
      return closestParticle;
    },
    getParticleList: function() { return this._particles; },
    reset: function() {
      this._particles.forEach( function( particle ) {
        if ( typeof( particle.bucketRemovalListener ) === 'function' ) {
          particle.userControlledProperty.unlink( particle.bucketRemovalListener );
          delete particle.bucketRemovalListener;
        }
      } );
      cleanArray( this._particles );
    },
    isPositionOpen: function( position ) {
      var positionOpen = true;
      for ( var i = 0; i < this._particles.length; i++ ) {
        var particle = this._particles[ i ];
        if ( particle.destinationProperty.get().equals( position ) ) {
          positionOpen = false;
          break;
        }
      }
      return positionOpen;
    },
    getFirstOpenLocation: function() {
      var openLocation = Vector2.ZERO;
      var usableWidth = this.size.width * this._usableWidthProportion - 2 * this._sphereRadius;
      var offsetFromBucketEdge = ( this.size.width - usableWidth ) / 2 + this._sphereRadius;
      var numParticlesInLayer = Math.floor( usableWidth / ( this._sphereRadius * 2 ) );
      var row = 0;
      var positionInLayer = 0;
      var found = false;
      while ( !found ) {
        var testLocation = new Vector2( this.position.x - this.size.width / 2 + offsetFromBucketEdge + positionInLayer * 2 * this._sphereRadius,
          this.getYPositionForLayer( row ) );
        if ( this.isPositionOpen( testLocation ) ) {
          openLocation = testLocation;
          found = true;
        }
        else {
          positionInLayer++;
          if ( positionInLayer >= numParticlesInLayer ) {
            row++;
            positionInLayer = 0;
            numParticlesInLayer--;
            offsetFromBucketEdge += this._sphereRadius;
            if ( numParticlesInLayer === 0 ) {
              numParticlesInLayer = 1;
              offsetFromBucketEdge -= this._sphereRadius;
            }
          }
        }
      }
      return openLocation;
    },
    getLayerForYPosition: function( yPosition ) {
      return Math.abs( Math.round( ( yPosition - ( this.position.y + this._verticalParticleOffset ) ) / ( this._sphereRadius * 2 * 0.866 ) ) );
    },
    getNearestOpenLocation: function( position ) {
      var highestOccupiedLayer = 0;
      var self = this;
      _.each( this._particles, function( particle ) {
        var layer = self.getLayerForYPosition( particle.destinationProperty.get().y );
        if ( layer > highestOccupiedLayer ) {
          highestOccupiedLayer = layer;
        }
      } );
      var openLocations = [];
      var usableWidth = this.size.width * this._usableWidthProportion - 2 * this._sphereRadius;
      var offsetFromBucketEdge = ( this.size.width - usableWidth ) / 2 + this._sphereRadius;
      var numParticlesInLayer = Math.floor( usableWidth / ( this._sphereRadius * 2 ) );
      for ( var layer = 0; layer <= highestOccupiedLayer + 1; layer++ ) {
        for ( var positionInLayer = 0; positionInLayer < numParticlesInLayer; positionInLayer++ ) {
          var testPosition = new Vector2( this.position.x - this.size.width / 2 + offsetFromBucketEdge + positionInLayer * 2 * this._sphereRadius,
            this.getYPositionForLayer( layer ) );
          if ( this.isPositionOpen( testPosition ) ) {
            if ( layer === 0 || this.countSupportingParticles( testPosition ) === 2 ) {
              openLocations.push( testPosition );
            }
          }
        }
        numParticlesInLayer--;
        offsetFromBucketEdge += this._sphereRadius;
        if ( numParticlesInLayer === 0 ) {
          numParticlesInLayer = 1;
          offsetFromBucketEdge -= this._sphereRadius;
        }
      }
      var closestOpenLocation = openLocations[ 0 ] || Vector2.ZERO;
      _.each( openLocations, function( location ) {
        if ( location.distance( position ) < closestOpenLocation.distance( position ) ) {
          closestOpenLocation = location;
        }
      } );
      return closestOpenLocation;
    },
    getYPositionForLayer: function( layer ) {
      return this.position.y + this._verticalParticleOffset + layer * this._sphereRadius * 2 * 0.866;
    },
    isDangling: function( particle ) {
      var onBottomRow = particle.destinationProperty.get().y === this.position.y + this._verticalParticleOffset;
      return !onBottomRow && this.countSupportingParticles( particle.destinationProperty.get() ) < 2;
    },
    countSupportingParticles: function( position ) {
      var count = 0;
      for ( var i = 0; i < this._particles.length; i++ ) {
        var p = this._particles[ i ];
        if ( p.destinationProperty.get().y < position.y && // Must be in a lower layer
             p.destinationProperty.get().distance( position ) < this._sphereRadius * 3 ) {
          count++;
        }
      }
      return count;
    },
    relayoutBucketParticles: function() {
      var particleMoved;
      do {
        for ( var i = 0; i < this._particles.length; i++ ) {
          particleMoved = false;
          var particle = this._particles[ i ];
          if ( this.isDangling( particle ) ) {
            particle.destinationProperty.set( this.getNearestOpenLocation( particle.destinationProperty.get() ) );
            particleMoved = true;
            break;
          }
        }
      } while ( particleMoved );
    }
  } );
  return SphereBucket;
} );
define("string!BUILD_AN_ATOM/protons",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/protons");});
define("string!BUILD_AN_ATOM/neutrons",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/neutrons");});
define("string!BUILD_AN_ATOM/electrons",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/electrons");});
define( 'BUILD_AN_ATOM/common/model/BuildAnAtomModel',['require','SHRED/AtomIdentifier','BUILD_AN_ATOM/common/view/AtomView','AXON/BooleanProperty','BUILD_AN_ATOM/buildAnAtom','AXON/DerivedProperty','DOT/Dimension2','PHET_CORE/inherit','SHRED/model/Particle','SHRED/model/ParticleAtom','SCENERY_PHET/PhetColorScheme','AXON/Property','SHRED/ShredConstants','PHETCOMMON/model/SphereBucket','DOT/Vector2','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TString','string!BUILD_AN_ATOM/protons','string!BUILD_AN_ATOM/neutrons','string!BUILD_AN_ATOM/electrons'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var AtomView = require( 'BUILD_AN_ATOM/common/view/AtomView' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Particle = require( 'SHRED/model/Particle' );
  var ParticleAtom = require( 'SHRED/model/ParticleAtom' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var SphereBucket = require( 'PHETCOMMON/model/SphereBucket' );
  var Vector2 = require( 'DOT/Vector2' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var protonsString = require( 'string!BUILD_AN_ATOM/protons' );
  var neutronsString = require( 'string!BUILD_AN_ATOM/neutrons' );
  var electronsString = require( 'string!BUILD_AN_ATOM/electrons' );
  var NUM_PROTONS = 10;
  var NUM_NEUTRONS = 13;
  var NUM_ELECTRONS = 10;
  var NUCLEON_CAPTURE_RADIUS = 100;
  var BUCKET_WIDTH = 120;
  var BUCKET_HEIGHT = BUCKET_WIDTH * 0.45;
  var BUCKET_Y_OFFSET = -205;
  var NUCLEUS_JUMP_PERIOD = 0.1; // In seconds
  var MAX_NUCLEUS_JUMP = ShredConstants.NUCLEON_RADIUS * 0.5;
  var JUMP_ANGLES = [ Math.PI * 0.1, Math.PI * 1.6, Math.PI * 0.7, Math.PI * 1.1, Math.PI * 0.3 ];
  var JUMP_DISTANCES = [ MAX_NUCLEUS_JUMP * 0.4, MAX_NUCLEUS_JUMP * 0.8, MAX_NUCLEUS_JUMP * 0.2, MAX_NUCLEUS_JUMP * 0.9 ];
  function BuildAnAtomModel( tandem ) {
    var self = this;
    this.showElementNameProperty = new BooleanProperty( true, {
      tandem: tandem.createTandem( 'showElementNameProperty' )
    } );
    this.showNeutralOrIonProperty = new BooleanProperty( true, {
      tandem: tandem.createTandem( 'showNeutralOrIonProperty' )
    } );
    this.showStableOrUnstableProperty = new BooleanProperty( false, {
      tandem: tandem.createTandem( 'showStableOrUnstableProperty' )
    } );
    this.electronShellDepictionProperty = new Property( 'orbits', {
      tandem: tandem.createTandem( 'electronShellDepictionProperty' ),
      phetioValueType: TString,
      validValues: [ 'orbits', 'cloud' ]
    } );
    this.particleAtom = new ParticleAtom( { tandem: tandem.createTandem( 'particleAtom' ) } );
    this.buckets = {
      protonBucket: new SphereBucket( {
        position: new Vector2( -BUCKET_WIDTH * 1.1, BUCKET_Y_OFFSET ),
        size: new Dimension2( BUCKET_WIDTH, BUCKET_HEIGHT ),
        sphereRadius: ShredConstants.NUCLEON_RADIUS,
        baseColor: PhetColorScheme.RED_COLORBLIND,
        captionText: protonsString,
        captionColor: 'white',
        tandem: tandem.createTandem( 'protonBucket' )
      } ),
      neutronBucket: new SphereBucket( {
        position: new Vector2( 0, BUCKET_Y_OFFSET ),
        size: new Dimension2( BUCKET_WIDTH, BUCKET_HEIGHT ),
        sphereRadius: ShredConstants.NUCLEON_RADIUS,
        baseColor: 'rgb( 100, 100, 100 )',
        captionText: neutronsString,
        captionColor: 'white',
        tandem: tandem.createTandem( 'neutronBucket' )
      } ),
      electronBucket: new SphereBucket( {
        position: new Vector2( BUCKET_WIDTH * 1.1, BUCKET_Y_OFFSET ),
        size: new Dimension2( BUCKET_WIDTH, BUCKET_HEIGHT ),
        sphereRadius: ShredConstants.ELECTRON_RADIUS,
        usableWidthProportion: 0.8,
        baseColor: 'blue',
        captionText: electronsString,
        captionColor: 'white',
        tandem: tandem.createTandem( 'electronBucket' )
      } )
    };
    function placeNucleon( particle, bucket, atom ) {
      if ( particle.positionProperty.get().distance( atom.positionProperty.get() ) < NUCLEON_CAPTURE_RADIUS ) {
        atom.addParticle( particle );
      }
      else {
        bucket.addParticleNearestOpen( particle, true );
      }
    }
    this.nucleons = [];
    this.electrons = [];
    var protonGroupTandem = tandem.createGroupTandem( 'protons' );
    var neutronGroupTandem = tandem.createGroupTandem( 'neutrons' );
    var electronGroupTandem = tandem.createGroupTandem( 'electrons' );
    _.times( NUM_PROTONS, function() {
      var proton = new Particle( 'proton', {
        tandem: protonGroupTandem.createNextTandem(),
        maxZLayer: AtomView.NUM_NUCLEON_LAYERS - 1
      } );
      self.nucleons.push( proton );
      self.buckets.protonBucket.addParticleFirstOpen( proton, false );
      proton.userControlledProperty.link( function( userControlled ) {
        if ( !userControlled && !self.buckets.protonBucket.containsParticle( proton ) ) {
          placeNucleon( proton, self.buckets.protonBucket, self.particleAtom );
        }
      } );
    } );
    _.times( NUM_NEUTRONS, function() {
      var neutron = new Particle( 'neutron', {
        tandem: neutronGroupTandem.createNextTandem(),
        maxZLayer: AtomView.NUM_NUCLEON_LAYERS - 1
      } );
      self.nucleons.push( neutron );
      self.buckets.neutronBucket.addParticleFirstOpen( neutron, false );
      neutron.userControlledProperty.link( function( userControlled ) {
        if ( !userControlled && !self.buckets.neutronBucket.containsParticle( neutron ) ) {
          placeNucleon( neutron, self.buckets.neutronBucket, self.particleAtom );
        }
      } );
    } );
    _.times( NUM_ELECTRONS, function() {
      var electron = new Particle( 'electron', {
        tandem: electronGroupTandem.createNextTandem(),
        maxZLayer: AtomView.NUM_NUCLEON_LAYERS - 1
      } );
      self.electrons.push( electron );
      self.buckets.electronBucket.addParticleFirstOpen( electron, false );
      electron.userControlledProperty.link( function( userControlled ) {
        if ( !userControlled && !self.buckets.electronBucket.containsParticle( electron ) ) {
          if ( electron.positionProperty.get().distance( Vector2.ZERO ) < self.particleAtom.outerElectronShellRadius * 1.1 ) {
            self.particleAtom.addParticle( electron );
          }
          else {
            self.buckets.electronBucket.addParticleNearestOpen( electron, true );
          }
        }
      } );
    } );
    this.nucleusStableProperty = new DerivedProperty(
      [ this.particleAtom.protonCountProperty, this.particleAtom.neutronCountProperty ],
      function( protonCount, neutronCount ) {
        return protonCount + neutronCount > 0 ? AtomIdentifier.isStable( protonCount, neutronCount ) : true;
      },
      {
        tandem: tandem.createTandem( 'nucleusStableProperty' ),
        phetioValueType: TBoolean
      }
    );
    this.nucleusJumpCountdown = NUCLEUS_JUMP_PERIOD;
    this.nucleusOffset = Vector2.ZERO;
    this.nucleusJumpCount = 0;
  }
  BuildAnAtomModel.MAX_CHARGE = Math.max( NUM_PROTONS, NUM_ELECTRONS );
  BuildAnAtomModel.MAX_ELECTRONS = NUM_ELECTRONS;
  buildAnAtom.register( 'BuildAnAtomModel', BuildAnAtomModel );
  return inherit( Object, BuildAnAtomModel, {
    step: function( dt ) {
      this.nucleons.forEach( function( nucleon ) {
        nucleon.step( dt );
      } );
      this.electrons.forEach( function( electron ) {
        electron.step( dt );
      } );
      if ( !this.nucleusStableProperty.get() && this.showStableOrUnstableProperty.get() ) {
        this.nucleusJumpCountdown -= dt;
        if ( this.nucleusJumpCountdown <= 0 ) {
          this.nucleusJumpCountdown = NUCLEUS_JUMP_PERIOD;
          if ( this.particleAtom.nucleusOffsetProperty.set( Vector2.ZERO ) ) {
            this.nucleusJumpCount++;
            var angle = JUMP_ANGLES[ this.nucleusJumpCount % JUMP_ANGLES.length ];
            var distance = JUMP_DISTANCES[ this.nucleusJumpCount % JUMP_DISTANCES.length ];
            this.particleAtom.nucleusOffsetProperty.set(
              new Vector2( Math.cos( angle ) * distance, Math.sin( angle ) * distance )
            );
          }
          else {
            this.particleAtom.nucleusOffsetProperty.set( Vector2.ZERO );
          }
        }
      }
      else if ( this.particleAtom.nucleusOffsetProperty.get() !== Vector2.ZERO ) {
        this.particleAtom.nucleusOffsetProperty.set( Vector2.ZERO );
      }
    },
    _moveParticlesFromAtomToBucket: function( particleCollection, bucket ) {
      var particlesToRemove = [];
      for ( var i = 0; i < particleCollection.length; i++ ) {
        particlesToRemove[ i ] = particleCollection.get( i );
      }
      var self = this;
      particlesToRemove.forEach( function( particle ) {
        self.particleAtom.removeParticle( particle );
          bucket.addParticleFirstOpen( particle );
        }
      );
    },
    reset: function() {
      this.showElementNameProperty.reset();
      this.showNeutralOrIonProperty.reset();
      this.showStableOrUnstableProperty.reset();
      this.electronShellDepictionProperty.reset();
      this.nucleons.forEach( function( nucleon ) {
        if ( !nucleon.positionProperty.get().equals( nucleon.destinationProperty.get() ) ) {
          nucleon.moveImmediatelyToDestination();
        }
      } );
      this.electrons.forEach( function( electron ) {
        if ( !electron.positionProperty.get().equals( electron.destinationProperty.get() ) ) {
          electron.moveImmediatelyToDestination();
        }
      } );
      this.particleAtom.clear();
      this.buckets.protonBucket.reset();
      this.buckets.neutronBucket.reset();
      this.buckets.electronBucket.reset();
      var self = this;
      this.nucleons.forEach( function( nucleon ) {
        if ( nucleon.type === 'proton' ) {
          self.buckets.protonBucket.addParticleFirstOpen( nucleon, false );
        }
        else {
          self.buckets.neutronBucket.addParticleFirstOpen( nucleon, false );
        }
      } );
      this.electrons.forEach( function( electron ) {
        self.buckets.electronBucket.addParticleFirstOpen( electron, false );
      } );
    },
    setAtomConfiguration: function( numberAtom ) {
      var atomCenter = this.particleAtom.positionProperty.get();
      var self = this;
      var moveParticlesToAtom = function( currentCountInAtom, targetCountInAtom, particlesInAtom, bucket ) {
        while ( currentCountInAtom < targetCountInAtom ) {
          var particle = bucket.extractClosestParticle( atomCenter );
          particle.setPositionAndDestination( atomCenter );
          particle.userControlledProperty.set( false ); // Necessary to make it look like user released particle.
          currentCountInAtom++;
        }
        while ( currentCountInAtom > targetCountInAtom ) {
          self._moveParticlesFromAtomToBucket( particlesInAtom, bucket );
          currentCountInAtom--;
        }
      };
      moveParticlesToAtom( this.particleAtom.protons.length,
        numberAtom.protonCountProperty.get(),
        this.particleAtom.protons,
        this.buckets.protonBucket
      );
      moveParticlesToAtom(
        this.particleAtom.neutrons.length,
        numberAtom.neutronCountProperty.get(),
        this.particleAtom.neutrons,
        this.buckets.neutronBucket
      );
      moveParticlesToAtom(
        this.particleAtom.electrons.length,
        numberAtom.electronCountProperty.get(),
        this.particleAtom.electrons,
        this.buckets.electronBucket
      );
      this.particleAtom.moveAllParticlesToDestination();
    }
  } );
} );
define( 'BUILD_AN_ATOM/buildanatom/view/ChargeComparisonDisplay',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/common/model/BuildAnAtomModel','SCENERY/nodes/Node','KITE/Shape','SCENERY/nodes/Rectangle','SCENERY/nodes/Path','SCENERY_PHET/PhetColorScheme','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BuildAnAtomModel = require( 'BUILD_AN_ATOM/common/model/BuildAnAtomModel' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Shape = require( 'KITE/Shape' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Path = require( 'SCENERY/nodes/Path' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var inherit = require( 'PHET_CORE/inherit' );
  var SYMBOL_WIDTH = 12;
  var VERTICAL_INSET = 5;
  var INTER_SYMBOL_DISTANCE = SYMBOL_WIDTH * 0.4;
  var SYMBOL_LINE_WIDTH = SYMBOL_WIDTH * 0.3;
  function ChargeComparisonDisplay( numberAtom, tandem, options ) {
    Node.call( this ); // Call super constructor.
    var MAX_CHARGE = BuildAnAtomModel.MAX_CHARGE;
    var i;
    var symbolLayer = new Node( { tandem: tandem.createTandem( 'symbolLayer' ) } );
    var minusSymbolShape = new Shape();
    minusSymbolShape.moveTo( -SYMBOL_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    minusSymbolShape.lineTo( SYMBOL_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    minusSymbolShape.lineTo( SYMBOL_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    minusSymbolShape.lineTo( -SYMBOL_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    minusSymbolShape.close();
    var minusSymbolPath = new Path( minusSymbolShape, {
      stroke: 'black',
      lineWidth: 1,
      fill: 'rgb( 100, 100, 255 )',
      left: INTER_SYMBOL_DISTANCE / 2,
      centerY: VERTICAL_INSET + SYMBOL_WIDTH * 1.5
    } );
    var minusesGroupTandem = tandem.createGroupTandem( 'minuses' );
    var minuses = [];
    for ( i = 0; i < MAX_CHARGE; i++ ) {
      var minusSymbol = new Node( {
        children: [ minusSymbolPath ],
        x: i * ( SYMBOL_WIDTH + INTER_SYMBOL_DISTANCE ),
        tandem: minusesGroupTandem.createNextTandem()
      } );
      minuses.push( minusSymbol );
      symbolLayer.addChild( minusSymbol );
    }
    var plusSymbolShape = new Shape();
    plusSymbolShape.moveTo( -SYMBOL_LINE_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( -SYMBOL_LINE_WIDTH / 2, -SYMBOL_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_LINE_WIDTH / 2, -SYMBOL_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_LINE_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_LINE_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( SYMBOL_LINE_WIDTH / 2, SYMBOL_WIDTH / 2 );
    plusSymbolShape.lineTo( -SYMBOL_LINE_WIDTH / 2, SYMBOL_WIDTH / 2 );
    plusSymbolShape.lineTo( -SYMBOL_LINE_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( -SYMBOL_WIDTH / 2, SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.lineTo( -SYMBOL_WIDTH / 2, -SYMBOL_LINE_WIDTH / 2 );
    plusSymbolShape.close();
    var plusSymbolPath = new Path( plusSymbolShape, {
      stroke: 'black',
      lineWidth: 1,
      fill: PhetColorScheme.RED_COLORBLIND,
      left: INTER_SYMBOL_DISTANCE / 2,
      centerY: VERTICAL_INSET + SYMBOL_WIDTH / 2
    } );
    var plussesGroupTandem = tandem.createGroupTandem( 'plusses' );
    var plusses = [];
    for ( i = 0; i < MAX_CHARGE; i++ ) {
      var plusSymbol = new Node( {
        children: [ plusSymbolPath ],
        x: i * ( SYMBOL_WIDTH + INTER_SYMBOL_DISTANCE ),
        tandem: plussesGroupTandem.createNextTandem()
      } );
      plusses.push( plusSymbol );
      symbolLayer.addChild( plusSymbol );
    }
    var matchBox = new Rectangle( 0, 0, INTER_SYMBOL_DISTANCE / 2, 2 * SYMBOL_WIDTH + 2 * VERTICAL_INSET, 4, 4, {
      lineWidth: 1,
      stroke: 'black',
      visible: false,
      tandem: tandem.createTandem( 'matchBox' )
    } );
    symbolLayer.addChild( matchBox );
    var update = function( atom ) {
      for ( var numProtons = 0; numProtons < MAX_CHARGE; numProtons++ ) {
        plusses[ numProtons ].visible = numProtons < atom.protonCountProperty.get();
      }
      for ( var numElectrons = 0; numElectrons < MAX_CHARGE; numElectrons++ ) {
        minuses[ numElectrons ].visible = numElectrons < atom.electronCountProperty.get();
      }
      var numMatchedSymbols = Math.min( atom.protonCountProperty.get(), atom.electronCountProperty.get() );
      matchBox.visible = numMatchedSymbols > 0;
      matchBox.rectWidth = INTER_SYMBOL_DISTANCE / 2 + ( numMatchedSymbols * SYMBOL_WIDTH ) + ( ( numMatchedSymbols - 0.5 ) * INTER_SYMBOL_DISTANCE );
    };
    this.addChild( new Rectangle( 0, 0, SYMBOL_WIDTH, 2 * SYMBOL_WIDTH + 2 * VERTICAL_INSET, 0, 0, {
      fill: 'rgba( 0, 0, 0, 0 )'
    } ) );
    numberAtom.particleCountProperty.link( function() {
      update( numberAtom );
    } );
    this.addChild( symbolLayer ); // added at the end so we have faster startup times
    options.tandem = tandem;
    this.mutate( options );
  }
  buildAnAtom.register( 'ChargeComparisonDisplay', ChargeComparisonDisplay );
  return inherit( Node, ChargeComparisonDisplay );
} );
define( 'SCENERY_PHET/ArrowShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  function ArrowShape( tailX, tailY, tipX, tipY, options ) {
    options = _.extend( {
      tailWidth: 5,
      headWidth: 10,
      headHeight: 10,
      doubleHead: false,
      isHeadDynamic: false,
      scaleTailToo: false,
      fractionalHeadHeight: 0.5 // head will be scaled when head size is less than fractionalHeadHeight * arrow length
    }, options );
    Tandem.disallowTandem( options );
    var self = this;
    Shape.call( this );
    if ( tipX !== tailX || tipY !== tailY ) {
      var points = ArrowShape.getArrowShapePoints( tailX, tailY, tipX, tipY, [], options );
      this.moveTo( points[ 0 ].x, points[ 0 ].y );
      var tail = _.tail( points );
      _.each( tail, function( element ) {
        self.lineTo( element.x, element.y );
      } );
      this.close();
    }
  }
  sceneryPhet.register( 'ArrowShape', ArrowShape );
  return inherit( Shape, ArrowShape, {}, {
    getArrowShapePoints: function( tailX, tailY, tipX, tipY, shapePoints, options ) {
      if ( !shapePoints ) {
        shapePoints = [];
      }
      if ( tipX === tailX && tipY === tailY ) {
        shapePoints.length = 0;
      }
      else {
        var vector = new Vector2( tipX - tailX, tipY - tailY );
        var xHatUnit = vector.normalized();
        var yHatUnit = xHatUnit.rotated( Math.PI / 2 );
        var length = vector.magnitude();
        var headWidth = options.headWidth;
        var headHeight = options.headHeight;
        var tailWidth = options.tailWidth;
        if ( options.isHeadDynamic ) {
          if ( length < options.headHeight / options.fractionalHeadHeight ) {
            headHeight = length * options.fractionalHeadHeight;
            if ( options.scaleTailToo ) {
              tailWidth = options.tailWidth * headHeight / options.headHeight;
              headWidth = options.headWidth * headHeight / options.headHeight;
            }
          }
          else {
          }
        }
        else {
          headHeight = Math.min( options.headHeight, options.doubleHead ? 0.35 * length : 0.99 * length );
        }
        var index = 0;
        var addPoint = function( xHat, yHat ) {
          var x = xHatUnit.x * xHat + yHatUnit.x * yHat + tailX;
          var y = xHatUnit.y * xHat + yHatUnit.y * yHat + tailY;
          if ( shapePoints[ index ] ) {
            shapePoints[ index ].x = x;
            shapePoints[ index ].y = y;
          }
          else {
            shapePoints.push( new Vector2( x, y ) );
          }
          index++;
        };
        if ( options.doubleHead ) {
          addPoint( 0, 0 );
          addPoint( headHeight, headWidth / 2 );
          addPoint( headHeight, tailWidth / 2 );
        }
        else {
          addPoint( 0, tailWidth / 2 );
        }
        addPoint( length - headHeight, tailWidth / 2 );
        addPoint( length - headHeight, headWidth / 2 );
        addPoint( length, 0 );
        addPoint( length - headHeight, -headWidth / 2 );
        addPoint( length - headHeight, -tailWidth / 2 );
        if ( options.doubleHead ) {
          addPoint( headHeight, -tailWidth / 2 );
          addPoint( headHeight, -headWidth / 2 );
        }
        else {
          addPoint( 0, -tailWidth / 2 );
        }
        if ( index < shapePoints.length ) {
          shapePoints.length = index;
        }
      }
      return shapePoints;
    }
  } );
} );
define( 'SCENERY_PHET/ArrowNode',['require','SCENERY_PHET/ArrowShape','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY_PHET/sceneryPhet','KITE/Shape','TANDEM/Tandem'],function( require ) {
  'use strict';
  var ArrowShape = require( 'SCENERY_PHET/ArrowShape' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );
  function ArrowNode( tailX, tailY, tipX, tipY, options ) {
    options = _.extend( {
      headHeight: 10,
      headWidth: 10,
      tailWidth: 5,
      isHeadDynamic: false,
      scaleTailToo: false,
      fractionalHeadHeight: 0.5, // head will be scaled when head size is less than fractionalHeadHeight * arrow length
      doubleHead: false, // true puts heads on both ends of the arrow, false puts a head at the tip
      fill: 'black',
      stroke: 'black',
      lineWidth: 1,
      tandem: Tandem.tandemRequired()
    }, options );
    this.options = options; // @private
    Path.call( this, null );
    this.shapePoints = [];
    this.setTailAndTip( tailX, tailY, tipX, tipY );
    assert && assert( options.headWidth > options.tailWidth );
    this.mutate( options );
  }
  sceneryPhet.register( 'ArrowNode', ArrowNode );
  return inherit( Path, ArrowNode, {
    updateShapePoints: function() {
      var numberOfPoints = this.shapePoints.length;
      this.shapePoints = ArrowShape.getArrowShapePoints( this.tailX, this.tailY, this.tipX, this.tipY, this.shapePoints, this.options );
      return this.shapePoints.length !== numberOfPoints;
    },
    updateShape: function() {
      var shape = new Shape();
      if ( this.shapePoints.length > 1 ) {
        shape.moveToPoint( this.shapePoints[ 0 ] );
        for ( var i = 1; i < this.shapePoints.length; i++ ) {
          shape.lineToPoint( this.shapePoints[ i ] );
        }
        shape.close();
      }
      this.shape = shape;
    },
    setTailAndTip: function( tailX, tailY, tipX, tipY ) {
      this.tailX = tailX; // @public {read-only}
      this.tailY = tailY; // @public {read-only}
      this.tipX = tipX; // @public {read-only}
      this.tipY = tipY; // @public {read-only}
      var numberOfPointsChanged = this.updateShapePoints();
      if ( !this.shape || numberOfPointsChanged ) {
        this.updateShape();
      }
      else {
        this.shape.invalidatePoints();
      }
    },
    setTailWidth: function( tailWidth ) {
      this.options.tailWidth = tailWidth;
      this.updateShapePoints();
      this.updateShape();
    },
    setDoubleHead: function( doubleHead ) {
      this.options.doubleHead = doubleHead;
      this.updateShapePoints();
      this.updateShape();
    }
  } );
} );
define( 'BUILD_AN_ATOM/common/view/ChargeMeter',['require','SCENERY_PHET/ArrowNode','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','DOT/Dimension2','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY_PHET/PhetColorScheme','SCENERY/nodes/Rectangle','KITE/Shape','SCENERY/nodes/Text','DOT/Vector2'],function( require ) {
  'use strict';
  var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var WIDTH = 70; // In screen coords, which are roughly pixels.
  var _MAX_CHARGE = 10;
  var CHARGE_SYMBOL_WIDTH = 7; // In screen coords, which are roughly pixels.
  var SYMBOL_LINE_WIDTH = 2; // In screen coords, which are roughly pixels.
  function ChargeMeter( numberAtom, tandem, options ) {
    Node.call( this ); // Call super constructor.
    options = _.extend( { showNumericalReadout: true }, options );
    var backgroundHeight = options.showNumericalReadout ? WIDTH * 0.9 : WIDTH * 0.55; // Multipliers arbitrary to get desired aspect ratios.
    var background = new Rectangle( 0, 0, WIDTH, backgroundHeight, 7, 7, {
      fill: 'rgb( 210, 210, 210 )',
      stroke: 'gray',
      lineWidth: 1.0,
      tandem: tandem.createTandem( 'background' )
    } );
    this.addChild( background );
    var meterWindowShape = new Shape();
    var meterWindowWidth = background.width * 0.8;
    var meterWindowHeight = meterWindowWidth * 0.5; // Empirically chosen, change if needed.
    meterWindowShape.moveTo( 0, meterWindowHeight );
    meterWindowShape.quadraticCurveTo( 0, 0, meterWindowWidth / 2, 0 );
    meterWindowShape.quadraticCurveTo( meterWindowWidth, 0, meterWindowWidth, meterWindowHeight );
    meterWindowShape.close();
    var meterWindow = new Path( meterWindowShape, {
      stroke: 'gray',
      lineWidth: 2,
      fill: new LinearGradient( 0, 0, meterWindowWidth, 0 )
        .addColorStop( 0, 'rgb( 0, 0, 255 )' )
        .addColorStop( 0.5, 'white' )
        .addColorStop( 1, 'rgb( 255, 0, 0 )' ),
      centerX: background.centerX,
      top: 3, // Adjust as needed to work with background graphics.
      tandem: tandem.createTandem( 'meterWindow' )
    } );
    this.addChild( meterWindow );
    var shadowOffset = 0.5; // In pixels.
    var plusShape = new Shape().moveTo( -CHARGE_SYMBOL_WIDTH / 2, 0 ).lineTo( CHARGE_SYMBOL_WIDTH / 2, 0 ).moveTo( 0, -CHARGE_SYMBOL_WIDTH / 2 ).lineTo( 0, CHARGE_SYMBOL_WIDTH / 2 );
    var plusSymbol = new Node( { tandem: tandem.createTandem( 'plusSymbol' ) } );
    plusSymbol.addChild( new Path( plusShape, {
      lineWidth: SYMBOL_LINE_WIDTH,
      stroke: 'black',
      centerX: shadowOffset,
      centerY: shadowOffset,
      tandem: tandem.createTandem( 'plusSymbolShadow' )
    } ) );
    plusSymbol.addChild( new Path( plusShape, {
      lineWidth: SYMBOL_LINE_WIDTH,
      stroke: 'rgb(255, 0, 0 )',
      tandem: tandem.createTandem( 'plusSymbolMainShape' )
    } ) );
    plusSymbol.center = new Vector2( meterWindow.width * 0.7, meterWindow.height * 0.5 );
    meterWindow.addChild( plusSymbol );
    var minusShape = new Shape().moveTo( -CHARGE_SYMBOL_WIDTH / 2, 0 ).lineTo( CHARGE_SYMBOL_WIDTH / 2, 0 );
    var minusSymbol = new Node( { tandem: tandem.createTandem( 'minusSymbol' ) } );
    minusSymbol.addChild( new Path( minusShape, {
      lineWidth: SYMBOL_LINE_WIDTH,
      stroke: 'black',
      centerX: shadowOffset,
      centerY: shadowOffset,
      tandem: tandem.createTandem( 'minusSymbolShadow' )
    } ) );
    minusSymbol.addChild( new Path( minusShape, {
      lineWidth: SYMBOL_LINE_WIDTH,
      stroke: 'rgb(0, 0, 255 )',
      tandem: tandem.createTandem( 'minusSymbolMainShape' )
    } ) );
    minusSymbol.center = new Vector2( meterWindow.width * 0.3, meterWindow.height * 0.5 );
    meterWindow.addChild( minusSymbol );
    var meterNeedleLayer = new Node( {
      x: meterWindow.centerX,
      y: meterWindow.bottom - 3,
      tandem: tandem.createTandem( 'meterNeedleWindow' )
    } );
    meterNeedleLayer.setScaleMagnitude( 1, 0.9 ); // match previous scaling behavior
    var meterNeedle = new ArrowNode(
      0, 0, // tip at origin, so we can rotate around it
      0, 3 - meterWindowHeight, {
        headHeight: 7,
        headWidth: 5,
        tailWidth: 1,
        tandem: tandem.createTandem( 'meterNeedle' )
      } );
    meterNeedleLayer.addChild( meterNeedle );
    this.addChild( meterNeedleLayer );
    var numericalReadout;
    var readoutText;
    var readoutSize = new Dimension2( WIDTH * 0.6, ( background.height - meterWindow.height ) * 0.6 );
    if ( options.showNumericalReadout ) {
      numericalReadout = new Rectangle( 0, 0, readoutSize.width, readoutSize.height, 3, 3, {
        fill: 'white',
        stroke: 'black',
        lineWidth: 1,
        top: meterWindow.bottom + 3,
        centerX: background.centerX,
        tandem: tandem.createTandem( 'numericalReadout' )
      } );
      this.addChild( numericalReadout );
      readoutText = new Text( '', {
        font: new PhetFont( { size: 24, weight: 'bold' } ),
        tandem: tandem.createTandem( 'readoutText' )
      } );
      numericalReadout.addChild( readoutText );
    }
    numberAtom.chargeProperty.link( function( charge ) {
      meterNeedle.rotation = ( charge / _MAX_CHARGE ) * Math.PI * 0.4;
      if ( numericalReadout !== undefined ) {
        var sign = '';
        var textColor;
        if ( charge > 0 ) {
          sign = '+';
          textColor = PhetColorScheme.RED_COLORBLIND;
        }
        else if ( charge < 0 ) {
          textColor = 'blue';
        }
        else {
          textColor = 'black';
        }
        readoutText.fill = textColor;
        var newText = sign + charge;
        if ( newText !== readoutText.text ) {
          readoutText.text = newText;
          readoutText.resetTransform();
          readoutText.scale( Math.min( Math.min( readoutSize.width * 0.8 / readoutText.width, readoutSize.height * 0.8 / readoutText.height ), 1 ) );
          readoutText.center = new Vector2( readoutSize.width / 2, readoutSize.height / 2 );
        }
      }
    } );
    options.tandem = tandem;
    this.mutate( options );
  }
  buildAnAtom.register( 'ChargeMeter', ChargeMeter );
  return inherit( Node, ChargeMeter );
} );
define( 'DOT/BinPacker',['require','DOT/dot','PHET_CORE/inherit','DOT/Bounds2'],function( require ) {
  'use strict';
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  function BinPacker( bounds ) {
    this.rootBin = new dot.BinPacker.Bin( bounds, null );
  }
  dot.register( 'BinPacker', BinPacker );
  inherit( Object, BinPacker, {
    allocate: function( width, height ) {
      var bin = this.rootBin.findAvailableBin( width, height );
      if ( bin ) {
        var sizedBin = bin.split( width, height );
        sizedBin.use();
        return sizedBin;
      }
      else {
        return null;
      }
    },
    deallocate: function( bin ) {
      bin.unuse();
    },
    toString: function() {
      var result = '';
      var padding = '';
      function binTree( bin ) {
        result += padding + bin.toString() + '\n';
        padding = padding + '  ';
        _.each( bin.children, binTree );
        padding = padding.substring( 2 );
      }
      binTree( this.rootBin );
      return result;
    }
  } );
  BinPacker.Bin = function Bin( bounds, parent ) {
    this.bounds = bounds;
    this.parent = parent;
    this.isSplit = false;
    this.isUsed = false;
    this.children = [];
  };
  inherit( Object, BinPacker.Bin, {
    findAvailableBin: function( width, height ) {
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );
      if ( this.isUsed ) {
        return null;
      }
      else if ( this.bounds.width < width || this.bounds.height < height ) {
        return null;
      }
      else if ( this.isSplit ) {
        for ( var i = 0; i < this.children.length; i++ ) {
          var result = this.children[ i ].findAvailableBin( width, height );
          if ( result ) {
            return result;
          }
        }
        return null;
      }
      else {
        return this;
      }
    },
    split: function( width, height ) {
      assert && assert( this.bounds.width >= width && this.bounds.height >= height,
        'Bin does not have space' );
      assert && assert( !this.isSplit, 'Bin should not be re-split' );
      assert && assert( !this.isUsed, 'Bin should not be split when used' );
      assert && assert( width > 0 && height > 0, 'Empty bin requested?' );
      if ( width === this.bounds.width && height === this.bounds.height ) {
        return this;
      }
      this.isSplit = true;
      var splitX = this.bounds.minX + width;
      var splitY = this.bounds.minY + height;
      var mainBounds = new Bounds2( this.bounds.minX, this.bounds.minY, splitX, splitY );
      var rightBounds = new Bounds2( splitX, this.bounds.minY, this.bounds.maxX, splitY );
      var bottomBounds = new Bounds2( this.bounds.minX, splitY, this.bounds.maxX, this.bounds.maxY );
      var mainBin = new dot.BinPacker.Bin( mainBounds, this );
      this.children.push( mainBin );
      if ( rightBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( rightBounds, this ) );
      }
      if ( bottomBounds.hasNonzeroArea() ) {
        this.children.push( new dot.BinPacker.Bin( bottomBounds, this ) );
      }
      return mainBin;
    },
    use: function() {
      assert && assert( !this.isSplit, 'Should not mark a split bin as used' );
      assert && assert( !this.isUsed, 'Should not mark a used bin as used' );
      this.isUsed = true;
    },
    unuse: function() {
      assert && assert( this.isUsed, 'Can only unuse a used instance' );
      this.isUsed = false;
      this.parent && this.parent.attemptToCollapse();
    },
    attemptToCollapse: function() {
      assert && assert( this.isSplit, 'Should only attempt to collapse split bins' );
      for ( var i = 0; i < this.children.length; i++ ) {
        var child = this.children[ i ];
        if ( child.isSplit || child.isUsed ) {
          return;
        }
      }
      this.children = [];
      this.isSplit = false;
      this.parent && this.parent.attemptToCollapse();
    },
    toString: function() {
      return this.bounds.toString() + ( this.isUsed ? ' used' : '' );
    }
  } );
  return BinPacker;
} );
define( 'SCENERY/util/SpriteSheet',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/BinPacker','DOT/Bounds2','DOT/Dimension2'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var inherit = require( 'PHET_CORE/inherit' );
  var BinPacker = require( 'DOT/BinPacker' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var MAX_DIMENSION = new Dimension2( 1024, 1024 );
  var PADDING = 1;
  function SpriteSheet( useMipmaps ) {
    this.useMipmaps = useMipmaps;
    this.gl = null; // assume later creation of context for now
    this.bounds = new Bounds2( 0, 0, MAX_DIMENSION.width, MAX_DIMENSION.height );
    assert && assert( this.bounds.minX === 0 && this.bounds.minY === 0, 'Assumed constraint later on for transforms' );
    this.width = this.bounds.width;
    this.height = this.bounds.height;
    this.canvas = document.createElement( 'canvas' );
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.context = this.canvas.getContext( '2d' );
    this.binPacker = new BinPacker( this.bounds );
    this.dirty = true; // @public [read-only] - Used to check if we need to updateTexture()
    this.usedSprites = [];
    this.unusedSprites = []; // works as a LRU cache for removing items when we need to allocate new space
  }
  scenery.register( 'SpriteSheet', SpriteSheet );
  inherit( Object, SpriteSheet, {
    initializeContext: function( gl ) {
      this.gl = gl;
      this.createTexture();
    },
    createTexture: function() {
      var gl = this.gl;
      this.texture = gl.createTexture();
      gl.bindTexture( gl.TEXTURE_2D, this.texture );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.useMipmaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR );
      gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
      gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, false );
      gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
      if ( this.useMipmaps ) {
        gl.hint( gl.GENERATE_MIPMAP_HINT, gl.NICEST );
        gl.generateMipmap( gl.TEXTURE_2D );
      }
      gl.bindTexture( gl.TEXTURE_2D, null );
      this.dirty = false;
    },
    updateTexture: function() {
      assert && assert( this.gl, 'SpriteSheet needs context to updateTexture()' );
      if ( this.dirty ) {
        this.dirty = false;
        var gl = this.gl;
        gl.bindTexture( gl.TEXTURE_2D, this.texture );
        gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas );
        if ( this.useMipmaps ) {
          gl.generateMipmap( gl.TEXTURE_2D );
        }
        gl.bindTexture( gl.TEXTURE_2D, null );
      }
    },
    addImage: function( image, width, height ) {
      var i;
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        var usedSprite = this.usedSprites[ i ];
        if ( usedSprite.image === image ) {
          usedSprite.count++;
          return usedSprite;
        }
      }
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        var unusedSprite = this.unusedSprites[ i ];
        if ( unusedSprite.image === image ) {
          unusedSprite.count++;
          assert && assert( unusedSprite.count === 1, 'Count should be exactly 1 after coming back from being unused' );
          this.unusedSprites.splice( i, 1 ); // remove it from the unused array
          this.usedSprites.push( unusedSprite ); // add it to the used array
          return unusedSprite;
        }
      }
      var bin;
      while ( !( bin = this.binPacker.allocate( width + PADDING, height + PADDING ) ) && this.unusedSprites.length ) {
        var ejectedSprite = this.unusedSprites.shift(); // LRU policy by taking first item
        this.dirty = true;
        var ejectedBounds = ejectedSprite.bin.bounds;
        this.context.clearRect( ejectedBounds.x, ejectedBounds.y, ejectedBounds.width, ejectedBounds.height );
        this.binPacker.deallocate( ejectedSprite.bin );
      }
      if ( bin ) {
        var uvBounds = new Bounds2( bin.bounds.minX / this.width, bin.bounds.minY / this.height,
          ( bin.bounds.maxX - PADDING ) / this.width, ( bin.bounds.maxY - PADDING ) / this.height );
        var sprite = new SpriteSheet.Sprite( this, bin, uvBounds, image, 1 );
        this.context.drawImage( image, bin.bounds.x, bin.bounds.y );
        this.dirty = true;
        this.usedSprites.push( sprite );
        return sprite;
      }
      else {
        return null;
      }
    },
    removeImage: function( image ) {
      var usedSprite;
      var i;
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          usedSprite = this.usedSprites[ i ];
          break;
        }
      }
      assert && assert( usedSprite, 'Sprite not found for removeImage' );
      if ( --usedSprite.count <= 0 ) {
        this.usedSprites.splice( i, 1 ); // remove it from the used list
        this.unusedSprites.push( usedSprite ); // add it to the unused list
      }
    },
    containsImage: function( image ) {
      var i;
      for ( i = 0; i < this.usedSprites.length; i++ ) {
        if ( this.usedSprites[ i ].image === image ) {
          return true;
        }
      }
      for ( i = 0; i < this.unusedSprites.length; i++ ) {
        if ( this.unusedSprites[ i ].image === image ) {
          return true;
        }
      }
      return false;
    }
  } );
  SpriteSheet.Sprite = function( spriteSheet, bin, uvBounds, image, initialCount ) {
    this.spriteSheet = spriteSheet;
    this.bin = bin;
    this.uvBounds = uvBounds;
    this.image = image;
    this.count = initialCount;
  };
  SpriteSheet.MAX_DIMENSION = MAX_DIMENSION;
  return SpriteSheet;
} );
define( 'SCENERY/display/drawables/ImageCanvasDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  function ImageCanvasDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'ImageCanvasDrawable', ImageCanvasDrawable );
  inherit( CanvasSelfDrawable, ImageCanvasDrawable, {
    initialize: function( renderer, instance ) {
      return this.initializeCanvasSelfDrawable( renderer, instance );
    },
    paintCanvas: function( wrapper, node ) {
      var hasImageOpacity = node._imageOpacity !== 1;
      if ( node._image && node._image.width !== 0 && node._image.height !== 0 ) {
        if ( hasImageOpacity ) {
          wrapper.context.save();
          wrapper.context.globalAlpha *= node._imageOpacity;
        }
        wrapper.context.drawImage( node._image, 0, 0 );
        if ( hasImageOpacity ) {
          wrapper.context.restore();
        }
      }
    },
    markDirtyImage: function() { this.markPaintDirty(); },
    markDirtyMipmap: function() { this.markPaintDirty(); },
    markDirtyImageOpacity: function() { this.markPaintDirty(); }
  } );
  SelfDrawable.Poolable.mixin( ImageCanvasDrawable );
  return ImageCanvasDrawable;
} );
define( 'SCENERY/display/drawables/ImageStatefulDrawable',['require','SCENERY/scenery'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var ImageStatefulDrawable = {
    mixin: function( drawableType ) {
      var proto = drawableType.prototype;
      proto.initializeState = function( renderer, instance ) {
        this.paintDirty = true;
        this.dirtyImage = true;
        this.dirtyImageOpacity = true;
        this.dirtyMipmap = true;
        return this; // allow for chaining
      };
      proto.disposeState = function() {
      };
      proto.markPaintDirty = function() {
        this.paintDirty = true;
        this.markDirty();
      };
      proto.markDirtyImage = function() {
        this.dirtyImage = true;
        this.markPaintDirty();
      };
      proto.markDirtyImageOpacity = function() {
        this.dirtyImageOpacity = true;
        this.markPaintDirty();
      };
      proto.markDirtyMipmap = function() {
        this.dirtyMipmap = true;
        this.markPaintDirty();
      };
      proto.setToCleanState = function() {
        this.paintDirty = false;
        this.dirtyImage = false;
        this.dirtyImageOpacity = false;
        this.dirtyMipmap = false;
      };
    }
  };
  scenery.register( 'ImageStatefulDrawable', ImageStatefulDrawable );
  return ImageStatefulDrawable;
} );
define( 'SCENERY/display/drawables/ImageDOMDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/DOMSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var DOMSelfDrawable = require( 'SCENERY/display/DOMSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );
  require( 'SCENERY/util/Util' );
  var keepDOMImageElements = true; // whether we should pool DOM elements for the DOM rendering states, or whether we should free them when possible for memory
  function ImageDOMDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
scenery.register( 'ImageDOMDrawable', ImageDOMDrawable );
  inherit( DOMSelfDrawable, ImageDOMDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeDOMSelfDrawable( renderer, instance );
      this.initializeState( renderer, instance );
      if ( !this.domElement ) {
        this.domElement = document.createElement( 'img' );
        this.domElement.style.display = 'block';
        this.domElement.style.position = 'absolute';
        this.domElement.style.pointerEvents = 'none';
        this.domElement.style.left = '0';
        this.domElement.style.top = '0';
      }
      this.hasOpacity = false;
      scenery.Util.prepareForTransform( this.domElement, this.forceAcceleration );
      return this; // allow for chaining
    },
    updateDOM: function() {
      var node = this.node;
      var img = this.domElement;
      if ( this.paintDirty && this.dirtyImage ) {
        img.src = node._image ? node._image.src : '//:0'; // NOTE: for img with no src (but with a string), see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
      }
      if ( this.dirtyImageOpacity ) {
        if ( node._imageOpacity === 1 ) {
          if ( this.hasOpacity ) {
            this.hasOpacity = false;
            img.style.opacity = '';
          }
        }
        else {
          this.hasOpacity = true;
          img.style.opacity = node._imageOpacity;
        }
      }
      if ( this.transformDirty ) {
        scenery.Util.applyPreparedTransform( this.getTransformMatrix(), this.domElement, this.forceAcceleration );
      }
      this.setToCleanState();
      this.transformDirty = false;
    },
    dispose: function() {
      this.disposeState();
      if ( !keepDOMImageElements ) {
        this.domElement = null; // clear our DOM reference if we want to toss it
      }
      DOMSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageDOMDrawable );
  SelfDrawable.Poolable.mixin( ImageDOMDrawable );
  return ImageDOMDrawable;
} );
define( 'SCENERY/display/drawables/ImageSVGDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','PHET_CORE/platform','SCENERY/display/SVGSelfDrawable','SCENERY/display/SelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var platform = require( 'PHET_CORE/platform' );
  var SVGSelfDrawable = require( 'SCENERY/display/SVGSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );
  var keepSVGImageElements = true; // whether we should pool SVG elements for the SVG rendering states, or whether we should free them when possible for memory
  function ImageSVGDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
scenery.register( 'ImageSVGDrawable', ImageSVGDrawable );
  inherit( SVGSelfDrawable, ImageSVGDrawable, {
    initialize: function( renderer, instance ) {
      this.initializeSVGSelfDrawable( renderer, instance, false, keepSVGImageElements ); // usesPaint: false
      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' initialized for ' + instance.toString() );
      var self = this;
      this.svgElement = this.svgElement || document.createElementNS( scenery.svgns, 'image' );
      this.svgElement.setAttribute( 'x', 0 );
      this.svgElement.setAttribute( 'y', 0 );
      this.hasOpacity = false;
      this._usingMipmap = false;
      this._mipmapLevel = -1; // will always be invalidated
      this._mipmapTransformListener = this._mipmapTransformListener || function() {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( self.id + ' Transform dirties mipmap' );
          self.markDirtyMipmap();
        };
      this._mipmapListener = this._mipmapListener || function() {
          self.markDirtyMipmap();
          self.updateMipmapStatus( self.node._mipmap );
        };
      this.node.onStatic( 'mipmap', this._mipmapListener );
      this.updateMipmapStatus( instance.node._mipmap );
      return this;
    },
    updateSVGSelf: function() {
      var image = this.svgElement;
      if ( this.dirtyImage ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty image' );
        if ( this.node._image ) {
          this.updateURL( image, true );
        }
        else {
          image.setAttribute( 'width', '0' );
          image.setAttribute( 'height', '0' );
          image.setAttributeNS( scenery.xlinkns, 'xlink:href', '//:0' ); // see http://stackoverflow.com/questions/5775469/whats-the-valid-way-to-include-an-image-with-no-src
        }
      }
      else if ( this.dirtyMipmap && this.node._image ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Updating dirty mipmap' );
        this.updateURL( image, false );
      }
      if ( this.dirtyImageOpacity ) {
        if ( this.node._imageOpacity === 1 ) {
          if ( this.hasOpacity ) {
            this.hasOpacity = false;
            image.removeAttribute( 'opacity' );
          }
        }
        else {
          this.hasOpacity = true;
          image.setAttribute( 'opacity', this.node._imageOpacity );
        }
      }
    },
    updateURL: function( image, forced ) {
      var level = -1; // signals a default of "we are not using mipmapping"
      if ( this.node._mipmap ) {
        var matrix = this.instance.relativeTransform.matrix;
        var approximateScale = ( Math.sqrt( matrix.m00() * matrix.m00() + matrix.m10() * matrix.m10() ) +
                                 Math.sqrt( matrix.m01() * matrix.m01() + matrix.m11() * matrix.m11() ) ) / 2;
        approximateScale *= ( window.devicePixelRatio || 1 ); // for retina-like devices
        level = this.node.getMipmapLevel( approximateScale );
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Mipmap level: ' + level );
      }
      if ( !forced && level === this._mipmapLevel ) {
        return;
      }
      if ( this._mipmapLevel >= 0 && level === -1 ) {
        ( platform.ie9 || platform.ie10 ) ? image.setAttribute( 'transform', '' ) : image.removeAttribute( 'transform' );
      }
      this._mipmapLevel = level;
      if ( this.node._mipmap && this.node.hasMipmaps() ) {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL to mipmap level ' + level );
        var url = this.node.getMipmapURL( level );
        var canvas = this.node.getMipmapCanvas( level );
        image.setAttribute( 'width', canvas.width + 'px' );
        image.setAttribute( 'height', canvas.height + 'px' );
        image.setAttribute( 'transform', 'scale(' + Math.pow( 2, level ).toFixed( 20 ) + ')' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', url );
      }
      else {
        sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Setting image URL' );
        image.setAttribute( 'width', this.node.getImageWidth() + 'px' );
        image.setAttribute( 'height', this.node.getImageHeight() + 'px' );
        image.setAttributeNS( scenery.xlinkns, 'xlink:href', this.node.getImageURL() );
      }
    },
    updateMipmapStatus: function( usingMipmap ) {
      if ( this._usingMipmap !== usingMipmap ) {
        this._usingMipmap = usingMipmap;
        if ( usingMipmap ) {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Adding mipmap compute/listener needs' );
          this.instance.relativeTransform.addListener( this._mipmapTransformListener ); // when our relative tranform changes, notify us in the pre-repaint phase
          this.instance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
        }
        else {
          sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' Removing mipmap compute/listener needs' );
          this.instance.relativeTransform.removeListener( this._mipmapTransformListener );
          this.instance.relativeTransform.removePrecompute();
        }
        this.markDirtyMipmap();
      }
    },
    dispose: function() {
      sceneryLog && sceneryLog.ImageSVGDrawable && sceneryLog.ImageSVGDrawable( this.id + ' disposing' );
      this.updateMipmapStatus( false );
      this.node.offStatic( 'mipmap', this._mipmapListener );
      SVGSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageSVGDrawable );
  SelfDrawable.Poolable.mixin( ImageSVGDrawable );
  return ImageSVGDrawable;
} );
define( 'SCENERY/display/drawables/ImageWebGLDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','SCENERY/display/Renderer','SCENERY/display/SelfDrawable','SCENERY/display/WebGLSelfDrawable','SCENERY/display/drawables/ImageStatefulDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var WebGLSelfDrawable = require( 'SCENERY/display/WebGLSelfDrawable' );
  var ImageStatefulDrawable = require( 'SCENERY/display/drawables/ImageStatefulDrawable' );
  var WEBGL_COMPONENTS = 5; // format [X Y U V A] for 6 vertices
  var VERTEX_0_OFFSET = WEBGL_COMPONENTS * 0;
  var VERTEX_1_OFFSET = WEBGL_COMPONENTS * 1;
  var VERTEX_2_OFFSET = WEBGL_COMPONENTS * 2;
  var VERTEX_3_OFFSET = WEBGL_COMPONENTS * 3;
  var VERTEX_4_OFFSET = WEBGL_COMPONENTS * 4;
  var VERTEX_5_OFFSET = WEBGL_COMPONENTS * 5;
  var VERTEX_X_OFFSET = 0;
  var VERTEX_Y_OFFSET = 1;
  var VERTEX_U_OFFSET = 2;
  var VERTEX_V_OFFSET = 3;
  var VERTEX_A_OFFSET = 4;
  function ImageWebGLDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'ImageWebGLDrawable', ImageWebGLDrawable );
  inherit( WebGLSelfDrawable, ImageWebGLDrawable, {
    webglRenderer: Renderer.webglTexturedTriangles,
    initialize: function( renderer, instance ) {
      this.initializeWebGLSelfDrawable( renderer, instance );
      if ( !this.vertexArray ) {
        this.vertexArray = new Float32Array( WEBGL_COMPONENTS * 6 ); // 5-length components for 6 vertices (2 tris).
      }
      this.upperLeft = new Vector2();
      this.lowerLeft = new Vector2();
      this.upperRight = new Vector2();
      this.lowerRight = new Vector2();
      this.xyDirty = true; // is our vertex position information out of date?
      this.uvDirty = true; // is our UV information out of date?
      this.updatedOnce = false;
      this.sprite = null;
      return this;
    },
    onAddToBlock: function( webglBlock ) {
      this.webglBlock = webglBlock; // TODO: do we need this reference?
      this.markDirty();
      this.reserveSprite();
    },
    onRemoveFromBlock: function( webglBlock ) {
      this.unreserveSprite();
    },
    reserveSprite: function() {
      if ( this.sprite ) {
        if ( this.sprite.image === this.node._image ) {
          return;
        }
        else {
          this.unreserveSprite();
        }
      }
      var width = this.node.getImageWidth();
      var height = this.node.getImageHeight();
      this.sprite = ( width > 0 && height > 0 ) ? this.webglBlock.addSpriteSheetImage( this.node._image, width, height ) : null;
      this.xyDirty = true;
      this.uvDirty = true;
    },
    unreserveSprite: function() {
      if ( this.sprite ) {
        this.webglBlock.removeSpriteSheetImage( this.sprite );
      }
      this.sprite = null;
    },
    markTransformDirty: function() {
      this.xyDirty = true;
      WebGLSelfDrawable.prototype.markTransformDirty.call( this );
    },
    markPaintDirty: function() {
      this.xyDirty = true; // vertex positions can depend on image width/height
      this.uvDirty = true;
      this.markDirty();
    },
    update: function() {
      if ( this.dirty ) {
        this.dirty = false;
        this.reserveSprite();
        if ( this.dirtyImageOpacity || !this.updatedOnce ) {
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_A_OFFSET ] = this.node._imageOpacity;
        }
        this.updatedOnce = true;
        if ( !this.sprite ) {
          return;
        }
        if ( this.uvDirty ) {
          this.uvDirty = false;
          var uvBounds = this.sprite.uvBounds;
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // upper left U
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper left V
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // lower left U
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower left V
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // upper right U
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper right V
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // upper right U
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_V_OFFSET ] = uvBounds.minY; // upper right V
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_U_OFFSET ] = uvBounds.minX; // lower left U
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower left V
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_U_OFFSET ] = uvBounds.maxX; // lower right U
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_V_OFFSET ] = uvBounds.maxY; // lower right V
        }
        if ( this.xyDirty ) {
          this.xyDirty = false;
          var width = this.node.getImageWidth();
          var height = this.node.getImageHeight();
          var transformMatrix = this.instance.relativeTransform.matrix; // with compute need, should always be accurate
          transformMatrix.multiplyVector2( this.upperLeft.setXY( 0, 0 ) );
          transformMatrix.multiplyVector2( this.lowerLeft.setXY( 0, height ) );
          transformMatrix.multiplyVector2( this.upperRight.setXY( width, 0 ) );
          transformMatrix.multiplyVector2( this.lowerRight.setXY( width, height ) );
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_X_OFFSET ] = this.upperLeft.x;
          this.vertexArray[ VERTEX_0_OFFSET + VERTEX_Y_OFFSET ] = this.upperLeft.y;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_X_OFFSET ] = this.lowerLeft.x;
          this.vertexArray[ VERTEX_1_OFFSET + VERTEX_Y_OFFSET ] = this.lowerLeft.y;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_X_OFFSET ] = this.upperRight.x;
          this.vertexArray[ VERTEX_2_OFFSET + VERTEX_Y_OFFSET ] = this.upperRight.y;
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_X_OFFSET ] = this.upperRight.x;
          this.vertexArray[ VERTEX_3_OFFSET + VERTEX_Y_OFFSET ] = this.upperRight.y;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_X_OFFSET ] = this.lowerLeft.x;
          this.vertexArray[ VERTEX_4_OFFSET + VERTEX_Y_OFFSET ] = this.lowerLeft.y;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_X_OFFSET ] = this.lowerRight.x;
          this.vertexArray[ VERTEX_5_OFFSET + VERTEX_Y_OFFSET ] = this.lowerRight.y;
        }
      }
    },
    dispose: function() {
      WebGLSelfDrawable.prototype.dispose.call( this );
    }
  } );
  ImageStatefulDrawable.mixin( ImageWebGLDrawable );
  SelfDrawable.Poolable.mixin( ImageWebGLDrawable );
  return ImageWebGLDrawable;
} );
define( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','PHET_CORE/extendDefined','SCENERY/scenery','PHET_CORE/cleanArray','DOT/Bounds2','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/util/SpriteSheet','SCENERY/display/drawables/ImageCanvasDrawable','SCENERY/display/drawables/ImageDOMDrawable','SCENERY/display/drawables/ImageSVGDrawable','SCENERY/display/drawables/ImageWebGLDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var extendDefined = require( 'PHET_CORE/extendDefined' );
  var scenery = require( 'SCENERY/scenery' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var SpriteSheet = require( 'SCENERY/util/SpriteSheet' );
  var ImageCanvasDrawable = require( 'SCENERY/display/drawables/ImageCanvasDrawable' );
  var ImageDOMDrawable = require( 'SCENERY/display/drawables/ImageDOMDrawable' );
  var ImageSVGDrawable = require( 'SCENERY/display/drawables/ImageSVGDrawable' );
  var ImageWebGLDrawable = require( 'SCENERY/display/drawables/ImageWebGLDrawable' );
  var log2 = Math.log2 || function( x ) { return Math.log( x ) / Math.LN2; };
  var IMAGE_OPTION_KEYS = [
    'image', // Changes the image displayed, see setImage() for documentation
    'imageOpacity', // Controls opacity of this image (and not children), see setImageOpacity() for documentation
    'initialWidth', // Width of an image not-yet loaded (for layout), see setInitialWidth() for documentation
    'initialHeight', // Height of an image not-yet loaded (for layout), see setInitialHeight() for documentation
    'mipmap', // Whether mipmapped output is supported, see setMipmap() for documentation
    'mipmapBias', // Whether mipmapping tends towards sharp/aliased or blurry, see setMipmapBias() for documentation
    'mipmapInitialLevel', // How many mipmap levels to generate if needed, see setMipmapInitialLevel() for documentation
    'mipmapMaxLevel' // The maximum mipmap level to compute if needed, see setMipmapMaxLevel() for documentation
  ];
  function Image( image, options ) {
    assert && assert( image, 'image should be available' );
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    this._initialWidth = 0;
    this._initialHeight = 0;
    this._imageOpacity = 1;
    this._mipmap = false;
    this._mipmapBias = -0.7;
    this._mipmapInitialLevel = 4;
    this._mipmapMaxLevel = 5;
    this._mipmapCanvases = [];
    this._mipmapURLs = [];
    this._mipmapData = null;
    this._imageLoadListener = this.onImageLoad.bind( this );
    this._imageLoadListenerAttached = false;
    options = extendDefined( {
      image: image
    }, options );
    Node.call( this, options );
    this.invalidateSupportedRenderers();
  }
  scenery.register( 'Image', Image );
  inherit( Node, Image, {
    _mutatorKeys: IMAGE_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    drawableMarkFlags: Node.prototype.drawableMarkFlags.concat( [ 'image', 'imageOpacity', 'mipmap' ] ),
    setImage: function( image ) {
      assert && assert( image, 'image should be available' );
      assert && assert( typeof image === 'string' ||
                        image instanceof HTMLImageElement ||
                        image instanceof HTMLCanvasElement ||
                        image instanceof Array, 'image is not of the correct type' );
      var hasImageChanged = this._image !== image;
      if ( hasImageChanged && typeof image === 'string' ) {
        if ( this._image && image === this._image.src ) {
          hasImageChanged = false;
        }
        if ( image === this._mipmapData ) {
          hasImageChanged = false;
        }
      }
      if ( hasImageChanged ) {
        this._initialWidth = 0;
        this._initialHeight = 0;
        if ( this._image && this._imageLoadListenerAttached ) {
          this.detachImageLoadListener();
        }
        this._mipmapData = null;
        if ( typeof image === 'string' ) {
          var src = image;
          image = document.createElement( 'img' );
          image.src = src;
        }
        else if ( image instanceof Array ) {
          this._mipmapData = image;
          image = image[ 0 ].img; // presumes we are already loaded
          this._mipmapInitialLevel = this._mipmapMaxLevel = this._mipmapData.length;
          this._mipmap = true;
        }
        this._image = image;
        if ( this._image instanceof HTMLImageElement && ( !this._image.width || !this._image.height ) ) {
          this.attachImageLoadListener();
        }
        this.invalidateImage();
      }
      return this;
    },
    set image( value ) { this.setImage( value ); },
    getImage: function() {
      return this._image;
    },
    get image() { return this.getImage(); },
    invalidateImage: function() {
      if ( this._image ) {
        this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );
      }
      else {
        this.invalidateSelf( Bounds2.NOTHING );
      }
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirtyImage();
      }
      this.invalidateMipmaps();
      this.invalidateSupportedRenderers();
    },
    invalidateSupportedRenderers: function() {
      var r = Renderer.bitmaskCanvas;
      var fitsWithinSpriteSheet = this.getImageWidth() <= SpriteSheet.MAX_DIMENSION.width &&
                                  this.getImageHeight() <= SpriteSheet.MAX_DIMENSION.height;
      if ( fitsWithinSpriteSheet ) {
        r |= Renderer.bitmaskWebGL;
      }
      if ( !( this._image instanceof HTMLCanvasElement ) ) {
        r |= Renderer.bitmaskSVG | Renderer.bitmaskDOM;
      }
      this.setRendererBitmask( r );
    },
    setImageWithSize: function( image, width, height ) {
      this.setImage( image );
      this.setInitialWidth( width );
      this.setInitialHeight( height );
      return this;
    },
    setImageOpacity: function( imageOpacity ) {
      assert && assert( typeof imageOpacity === 'number', 'imageOpacity was not a number' );
      assert && assert( isFinite( imageOpacity ) && imageOpacity >= 0 && imageOpacity <= 1,
        'imageOpacity out of range: ' + imageOpacity );
      if ( this._imageOpacity !== imageOpacity ) {
        this._imageOpacity = imageOpacity;
        var stateLen = this._drawables.length;
        for ( var i = 0; i < stateLen; i++ ) {
          this._drawables[ i ].markDirtyImageOpacity();
        }
      }
    },
    set imageOpacity( value ) { this.setImageOpacity( value ); },
    getImageOpacity: function() {
      return this._imageOpacity;
    },
    get imageOpacity() { return this.getImageOpacity(); },
    setInitialWidth: function( width ) {
      assert && assert( typeof width === 'number' &&
                        width >= 0 &&
                        ( width % 1 === 0 ), 'initialWidth should be a non-negative integer' );
      if ( width !== this._initialWidth ) {
        this._initialWidth = width;
        this.invalidateImage();
      }
      return this;
    },
    set initialWidth( value ) { this.setInitialWidth( value ); },
    getInitialWidth: function() {
      return this._initialWidth;
    },
    get initialWidth() { return this.getInitialWidth(); },
    setInitialHeight: function( height ) {
      assert && assert( typeof height === 'number' &&
                        height >= 0 &&
                        ( height % 1 === 0 ), 'initialHeight should be a non-negative integer' );
      if ( height !== this._initialHeight ) {
        this._initialHeight = height;
        this.invalidateImage();
      }
      return this;
    },
    set initialHeight( value ) { this.setInitialHeight( value ); },
    getInitialHeight: function() {
      return this._initialHeight;
    },
    get initialHeight() { return this.getInitialHeight(); },
    setMipmap: function( mipmap ) {
      assert && assert( typeof mipmap === 'boolean' );
      if ( this._mipmap !== mipmap ) {
        this._mipmap = mipmap;
        this.invalidateMipmaps();
      }
      return this;
    },
    set mipmap( value ) { this.setMipmap( value ); },
    isMipmap: function() {
      return this._mipmap;
    },
    get mipmap() { return this.isMipmap(); },
    setMipmapBias: function( bias ) {
      assert && assert( typeof bias === 'number' );
      if ( this._mipmapBias !== bias ) {
        this._mipmapBias = bias;
        this.invalidateMipmaps();
      }
      return this;
    },
    set mipmapBias( value ) { this.setMipmapBias( value ); },
    getMipmapBias: function() {
      return this._mipmapBias;
    },
    get mipmapBias() { return this.getMipmapBias(); },
    setMipmapInitialLevel: function( level ) {
      assert && assert( typeof level === 'number' && level % 1 === 0 && level >= 0,
        'mipmapInitialLevel should be a non-negative integer' );
      if ( this._mipmapInitialLevel !== level ) {
        this._mipmapInitialLevel = level;
        this.invalidateMipmaps();
      }
      return this;
    },
    set mipmapInitialLevel( value ) { this.setMipmapInitialLevel( value ); },
    getMipmapInitialLevel: function() {
      return this._mipmapInitialLevel;
    },
    get mipmapInitialLevel() { return this.getMipmapInitialLevel(); },
    setMipmapMaxLevel: function( level ) {
      assert && assert( typeof level === 'number' && level % 1 === 0 && level >= 0,
        'mipmapMaxLevel should be a non-negative integer' );
      if ( this._mipmapMaxLevel !== level ) {
        this._mipmapMaxLevel = level;
        this.invalidateMipmaps();
      }
      return this;
    },
    set mipmapMaxLevel( value ) { this.setMipmapMaxLevel( value ); },
    getMipmapMaxLevel: function() {
      return this._mipmapMaxLevel;
    },
    get mipmapMaxLevel() { return this.getMipmapMaxLevel(); },
    constructNextMipmap: function() {
      var level = this._mipmapCanvases.length;
      var biggerCanvas = this._mipmapCanvases[ level - 1 ];
      if ( biggerCanvas.width * biggerCanvas.height > 2 ) {
        var canvas = document.createElement( 'canvas' );
        canvas.width = Math.ceil( biggerCanvas.width / 2 );
        canvas.height = Math.ceil( biggerCanvas.height / 2 );
        if ( canvas.width > 0 && canvas.height > 0 ) {
          var context = canvas.getContext( '2d' );
          context.scale( 0.5, 0.5 );
          context.drawImage( biggerCanvas, 0, 0 );
          this._mipmapCanvases.push( canvas );
          this._mipmapURLs.push( canvas.toDataURL() );
        }
      }
    },
    invalidateMipmaps: function() {
      cleanArray( this._mipmapCanvases );
      cleanArray( this._mipmapURLs );
      if ( this._image && this._mipmap ) {
        if ( this._mipmapData ) {
          for ( var k = 0; k < this._mipmapData.length; k++ ) {
            var url = this._mipmapData[ k ].url;
            this._mipmapURLs.push( url );
            this._mipmapData[ k ].updateCanvas && this._mipmapData[ k ].updateCanvas();
            this._mipmapCanvases.push( this._mipmapData[ k ].canvas );
          }
        }
        else {
          var baseCanvas = document.createElement( 'canvas' );
          baseCanvas.width = this.getImageWidth();
          baseCanvas.height = this.getImageHeight();
          if ( baseCanvas.width && baseCanvas.height ) {
            var baseContext = baseCanvas.getContext( '2d' );
            baseContext.drawImage( this._image, 0, 0 );
            this._mipmapCanvases.push( baseCanvas );
            this._mipmapURLs.push( baseCanvas.toDataURL() );
            var level = 0;
            while ( ++level < this._mipmapInitialLevel ) {
              this.constructNextMipmap();
            }
          }
          var stateLen = this._drawables.length;
          for ( var i = 0; i < stateLen; i++ ) {
            this._drawables[ i ].markDirtyMipmap();
          }
        }
      }
      this.trigger0( 'mipmap' );
    },
    getMipmapLevel: function( scale ) {
      assert && assert( typeof scale === 'number' && scale > 0, 'scale should be a positive number' );
      if ( scale >= 1 ) {
        return 0;
      }
      var level = log2( 1 / scale ); // our approximate level of detail
      level = Math.round( level + this._mipmapBias ); // convert to an integer level
      if ( level < 0 ) {
        level = 0;
      }
      if ( level > this._mipmapMaxLevel ) {
        level = this._mipmapMaxLevel;
      }
      if ( this.mipmap && !this._mipmapCanvases[ level ] ) {
        var currentLevel = this._mipmapCanvases.length - 1;
        while ( ++currentLevel <= level ) {
          this.constructNextMipmap();
        }
        return Math.min( level, this._mipmapCanvases.length - 1 );
      }
      else {
        return level;
      }
    },
    getMipmapCanvas: function( level ) {
      assert && assert( typeof level === 'number' &&
                        level >= 0 &&
                        level < this._mipmapCanvases.length &&
                        ( level % 1 ) === 0 );
      if ( this._mipmapData ) {
        this._mipmapData[ level ] && this._mipmapData[ level ].updateCanvas && this._mipmapData[ level ].updateCanvas();
      }
      return this._mipmapCanvases[ level ];
    },
    getMipmapURL: function( level ) {
      assert && assert( typeof level === 'number' &&
                        level >= 0 &&
                        level < this._mipmapCanvases.length &&
                        ( level % 1 ) === 0 );
      return this._mipmapURLs[ level ];
    },
    hasMipmaps: function() {
      return this._mipmapCanvases.length > 0;
    },
    getImageWidth: function() {
      var detectedWidth = this._mipmapData ? this._mipmapData[ 0 ].width : ( this._image.naturalWidth || this._image.width );
      if ( detectedWidth === 0 ) {
        return this._initialWidth; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialWidth === 0 || this._initialWidth === detectedWidth, 'Bad Image.initialWidth' );
        return detectedWidth;
      }
    },
    get imageWidth() { return this.getImageWidth(); },
    getImageHeight: function() {
      var detectedHeight = this._mipmapData ? this._mipmapData[ 0 ].height : ( this._image.naturalHeight || this._image.height );
      if ( detectedHeight === 0 ) {
        return this._initialHeight; // either 0 (default), or the overridden value
      }
      else {
        assert && assert( this._initialHeight === 0 || this._initialHeight === detectedHeight, 'Bad Image.initialHeight' );
        return detectedHeight;
      }
    },
    get imageHeight() { return this.getImageHeight(); },
    getImageURL: function() {
      assert && assert( this._image instanceof HTMLImageElement, 'Only supported for HTML image elements' );
      return this._image.src;
    },
    isPainted: function() {
      return true;
    },
    canvasPaintSelf: function( wrapper ) {
      ImageCanvasDrawable.prototype.paintCanvas( wrapper, this );
    },
    createDOMDrawable: function( renderer, instance ) {
      return ImageDOMDrawable.createFromPool( renderer, instance );
    },
    createSVGDrawable: function( renderer, instance ) {
      return ImageSVGDrawable.createFromPool( renderer, instance );
    },
    createCanvasDrawable: function( renderer, instance ) {
      return ImageCanvasDrawable.createFromPool( renderer, instance );
    },
    createWebGLDrawable: function( renderer, instance ) {
      return ImageWebGLDrawable.createFromPool( renderer, instance );
    },
    attachImageLoadListener: function() {
      assert && assert( !this._imageLoadListenerAttached, 'Should only be attached to one thing at a time' );
      if ( !this._isDisposed ) {
        this._image.addEventListener( 'load', this._imageLoadListener );
        this._imageLoadListenerAttached = true;
      }
    },
    detachImageLoadListener: function() {
      assert && assert( this._imageLoadListenerAttached, 'Needs to be attached first to be detached.' );
      this._image.removeEventListener( 'load', this._imageLoadListener );
      this._imageLoadListenerAttached = false;
    },
    onImageLoad: function() {
      assert && assert( this._imageLoadListenerAttached, 'If onImageLoad is firing, it should be attached' );
      this.invalidateImage();
      this.detachImageLoadListener();
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.Image( \'' + ( this._image.src ? this._image.src.replace( /'/g, '\\\'' ) : 'other' ) + '\', {' + propLines + '} )';
    },
    dispose: function() {
      if ( this._image && this._imageLoadListenerAttached ) {
        this.detachImageLoadListener();
      }
      Node.prototype.dispose.call( this );
    }
  } );
  Image.createSVGImage = function( url, width, height ) {
    assert && assert( typeof url === 'string', 'Requires the URL as a string' );
    assert && assert( typeof width === 'number' && isFinite( width ) && width >= 0 && ( width % 1 ) === 0,
      'width should be a non-negative finite integer' );
    assert && assert( typeof height === 'number' && isFinite( height ) && height >= 0 && ( height % 1 ) === 0,
      'height should be a non-negative finite integer' );
    var element = document.createElementNS( scenery.svgns, 'image' );
    element.setAttribute( 'x', 0 );
    element.setAttribute( 'y', 0 );
    element.setAttribute( 'width', width + 'px' );
    element.setAttribute( 'height', height + 'px' );
    element.setAttributeNS( scenery.xlinkns, 'xlink:href', url );
    return element;
  };
  Image.createFastMipmapFromCanvas = function( baseCanvas ) {
    var mipmaps = [];
    var baseURL = baseCanvas.toDataURL();
    var baseImage = new window.Image();
    baseImage.src = baseURL;
    mipmaps.push( {
      img: baseImage,
      url: baseURL,
      width: baseCanvas.width,
      height: baseCanvas.height
    } );
    var largeCanvas = baseCanvas;
    while ( largeCanvas.width >= 2 && largeCanvas.height >= 2 ) {
      var mipmap = {};
      var canvas = document.createElement( 'canvas' );
      canvas.width = mipmap.width = Math.ceil( largeCanvas.width / 2 );
      canvas.height = mipmap.height = Math.ceil( largeCanvas.height / 2 );
      var context = canvas.getContext( '2d' );
      context.setTransform( 0.5, 0, 0, 0.5, 0, 0 );
      context.drawImage( largeCanvas, 0, 0 );
      mipmap.canvas = canvas;
      mipmap.url = canvas.toDataURL();
      mipmap.img = new window.Image();
      mipmap.img.src = mipmap.url;
      largeCanvas = canvas;
      mipmaps.push( mipmap );
    }
    return mipmaps;
  };
  return Image;
} );
(function() {
  function loadFileAsDataURI( filename ) {
    var filenameParts = filename.split( '.' );
    var suffix = filenameParts[ filenameParts.length - 1 ];
    var mimeType = {
      'png': 'image/png',
      'svg': 'image/svg+xml',
      'jpg': 'image/jpeg',
      'gif': 'image/gif',
      'cur': 'image/x-icon', // cursor files (used in build-a-molecule). x-win-bitmap gives off warnings in Chrome
      'mp3': 'audio/mpeg',
      'm4a': 'audio/mp4',
      'ogg': 'audio/ogg',
      'oga': 'audio/ogg',
      'bma': 'audio/webm', // webma is the full extension
      'wav': 'audio/wav',
      'woff': 'application/x-font-woff'
    }[ suffix ];
    if ( !mimeType ) {
      throw new Error( 'Unknown mime type for filename: ' + filename );
    }
    var base64 = 'data:' + mimeType + ';base64,' + new Buffer( global.phet.chipper.fs.readFileSync( filename ) ).toString( 'base64' );
    return base64;
  }
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/loadFileAsDataURI',[],function() {
      return loadFileAsDataURI;
    } );
  }
  if ( typeof module !== 'undefined' ) {
    module.exports = loadFileAsDataURI;
  }
})();
define( '../../chipper/js/requirejs-plugins/getProjectURL',[],function() {
  'use strict';
  return function( name, parentRequire ) {
    var url = parentRequire.toUrl( name.substring( 0, name.indexOf( '/' ) ) );
    return (url.indexOf( '?' ) >= 0 ? url.substring( 0, url.indexOf( '?' ) ) : url) + '/../';
  };
} );
define( '../../chipper/js/requirejs-plugins/registerLicenseEntry',[],function() {
  'use strict';
  function isCompatibleLicenseEntry( entry, brand ) {
    if ( brand === 'phet' || brand === 'phet-io' ) {
      return entry && ( entry.projectURL === 'http://phet.colorado.edu' ||
                        entry.license === 'Public Domain' ||
                        entry.license === 'NASA' );
    }
    else {
      return true;
    }
  }
  function isAcceptableLicenseEntry( name, entry, brand ) {
    var acceptable = isCompatibleLicenseEntry( entry, brand ) || (entry && !!entry.exception);
    if ( acceptable && entry && !!entry.exception ) {
      var warningMessage = 'license exception for ' + name + ': ' + entry.exception;
      if ( global.phet.chipper.grunt ) {
        global.phet.chipper.grunt.log.warn( warningMessage );
      }
      else {
        console.log( 'WARNING: ' + warningMessage );
      }
    }
    return acceptable;
  }
  function registerLicenseEntry( name, licenseEntry, brand, mediaType, onload ) {
    if ( isAcceptableLicenseEntry( name, licenseEntry, brand ) ) {
      global.phet.chipper.licenseEntries = global.phet.chipper.licenseEntries || {}; // initialize if this is the first entry
      global.phet.chipper.licenseEntries[ mediaType ] = global.phet.chipper.licenseEntries[ mediaType ] || {};
      global.phet.chipper.licenseEntries[ mediaType ][ name ] = licenseEntry;
      onload( null );
    }
    else {
      onload.error( new Error( 'unacceptable license entry for ' + name ) );
    }
  }
  return registerLicenseEntry;
} );
(function() {
  function getLicenseEntry( absolutePath ) {
    var lastSlashIndex = absolutePath.lastIndexOf( '/' );
    var prefix = absolutePath.substring( 0, lastSlashIndex );
    var licenseFilename = prefix + '/license.json'; // license.json is a sibling of the media file
    var mediaFilename = absolutePath.substring( lastSlashIndex + 1 ); // field name in license.json
    var fileContents = global.phet.chipper.fs.readFileSync( licenseFilename, 'utf8' );
    var json = null;
    try {
      json = JSON.parse( fileContents );
    }
    catch( err ) {
      if ( err instanceof SyntaxError ) {
        throw new Error( 'syntax error in ' + licenseFilename + ': ' + err.message );
      }
      else {
        throw err;
      }
    }
    var entry = json[ mediaFilename ];
    if ( !entry ) {
      return null; // Not annotated in file
    }
    return entry;
  }
  if ( typeof define !== 'undefined' ) {
    define( '../../chipper/js/common/getLicenseEntry',[],function() {
      return getLicenseEntry;
    } );
  }
  if ( typeof module !== 'undefined' ) {
    module.exports = getLicenseEntry;
  }
})();
define('image',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define("image!BUILD_AN_ATOM/scale.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define( 'BUILD_AN_ATOM/buildanatom/view/MassNumberDisplay',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','DOT/Dimension2','SCENERY/nodes/Image','image!BUILD_AN_ATOM/scale.png','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','DOT/Vector2'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Image = require( 'SCENERY/nodes/Image' );
  var scaleIcon = require( 'image!BUILD_AN_ATOM/scale.png' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var WIDTH = 122; // In screen coords, which are roughly pixels, empirically determined.
  var READOUT_SIZE = new Dimension2( WIDTH * 0.25, WIDTH * 0.165 ); // In screen coords, which are roughly pixels.
  function MassNumberDisplay( numberAtom, tandem, options ) {
    Node.call( this ); // Call super constructor.
    var scaleImage = new Image( scaleIcon, { tandem: tandem.createTandem( 'scaleImage' ) } );
    scaleImage.scale( WIDTH / scaleImage.width ); // Scale to the targeted width.
    this.addChild( scaleImage );
    var readoutBackground = new Rectangle( 0, 0, READOUT_SIZE.width, READOUT_SIZE.height, 4, 4, {
      fill: 'white',
      stroke: 'black',
      lineWidth: 1,
      bottom: scaleImage.bottom - 6,
      centerX: scaleImage.centerX,
      tandem: tandem.createTandem( 'readoutBackground' )
    } );
    this.addChild( readoutBackground );
    var numericalText = new Text( ' ', {
      font: new PhetFont( { size: 24, weight: 'bold' } ),
      tandem: tandem.createTandem( 'numericalText' )
    } );
    readoutBackground.addChild( numericalText );
    numberAtom.massNumberProperty.link( function( massNumber ) {
      var newText = '' + massNumber; // cast to a string explicitly just in case
      if ( newText !== numericalText.text ) {
        numericalText.text = newText;
        numericalText.resetTransform();
        numericalText.scale( Math.min( READOUT_SIZE.height * 0.9 / numericalText.height,
          READOUT_SIZE.width * 0.9 / numericalText.width ) );
        numericalText.center = new Vector2( READOUT_SIZE.width / 2, READOUT_SIZE.height / 2 );
      }
    } );
    options.tandem = tandem;
    this.mutate( options );
  }
  buildAnAtom.register( 'MassNumberDisplay', MassNumberDisplay );
  return inherit( Node, MassNumberDisplay );
} );
define("string!BUILD_AN_ATOM/massNumber",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/massNumber");});
define("string!BUILD_AN_ATOM/netCharge",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/netCharge");});
define( 'BUILD_AN_ATOM/buildanatom/view/BuildAnAtomView',['require','SUN/AccordionBox','BUILD_AN_ATOM/common/view/AtomView','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/buildanatom/view/ChargeComparisonDisplay','BUILD_AN_ATOM/common/view/ChargeMeter','SCENERY/nodes/HBox','PHET_CORE/inherit','BUILD_AN_ATOM/buildanatom/view/MassNumberDisplay','AXON/Property','SHRED/ShredConstants','SCENERY/nodes/Text','ifphetio!PHET_IO/types/TBoolean','string!BUILD_AN_ATOM/massNumber','string!BUILD_AN_ATOM/netCharge'],function( require ) {
  'use strict';
  var AccordionBox = require( 'SUN/AccordionBox' );
  var AtomView = require( 'BUILD_AN_ATOM/common/view/AtomView' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var ChargeComparisonDisplay = require( 'BUILD_AN_ATOM/buildanatom/view/ChargeComparisonDisplay' );
  var ChargeMeter = require( 'BUILD_AN_ATOM/common/view/ChargeMeter' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MassNumberDisplay = require( 'BUILD_AN_ATOM/buildanatom/view/MassNumberDisplay' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var massNumberString = require( 'string!BUILD_AN_ATOM/massNumber' );
  var netChargeString = require( 'string!BUILD_AN_ATOM/netCharge' );
  var INTER_BOX_SPACING = 7;
  var ACCORDION_BOX_BUTTON_DILATION = 8;
  function BuildAnAtomView( model, tandem ) {
    AtomView.call( this, model, tandem ); // Call super constructor.
    this.netChargeAccordionBoxExpandedProperty = new Property( false, {
      tandem: tandem.createTandem( 'netChargeAccordionBoxExpandedProperty' ),
      phetioValueType: TBoolean
    } );
    this.massNumberAccordionBoxExpandedProperty = new Property( false, {
      tandem: tandem.createTandem( 'massNumberAccordionBoxExpandedProperty' ),
      phetioValueType: TBoolean
    } );
    var netChargeAccordionBoxContents = new HBox( {
      children: [
        new ChargeMeter( model.particleAtom, tandem.createTandem( 'chargeMeter' ) ),
        new ChargeComparisonDisplay(
          model.particleAtom,
          tandem.createTandem( 'chargeComparisonDisplay' ),
          { pickable: false }
        )
      ],
      spacing: 5,
      scale: 0.85, // empirically determined to keep the box height reasonable
      pickable: false,
      tandem: tandem.createTandem( 'netChargeAccordionBoxContents' ),
      tagName: 'h6',
      accessibleLabel: 'Net Charge Content'
    } );
    var netChargeAccordionBox = new AccordionBox( netChargeAccordionBoxContents, {
      titleNode: new Text( netChargeString, {
        font: ShredConstants.ACCORDION_BOX_TITLE_FONT,
        maxWidth: ShredConstants.ACCORDION_BOX_TITLE_MAX_WIDTH,
        tandem: tandem.createTandem( 'netChargeAccordionBoxTitle' )
      } ),
      fill: ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR,
      expandedProperty: this.netChargeAccordionBoxExpandedProperty,
      minWidth: this.periodicTableAccordionBox.width,
      contentAlign: 'left',
      titleAlignX: 'left',
      buttonAlign: 'right',
      buttonTouchAreaXDilation: ACCORDION_BOX_BUTTON_DILATION,
      buttonTouchAreaYDilation: ACCORDION_BOX_BUTTON_DILATION,
      tandem: tandem.createTandem( 'netChargeAccordionBox' ),
      accessibleAccordionTitle: netChargeString
    } );
    this.controlPanelLayer.addChild( netChargeAccordionBox );
    var massNumberDisplay = new MassNumberDisplay(
      model.particleAtom,
      tandem.createTandem( 'massNumberDisplay' ),
      {
        pickable: false,
        scale: 0.85, // empirically determined to make the control panels all fit on the screen
        tagName: 'h6',
        accessibleLabel: 'Mass Number Content'
      }
    );
    var massNumberAccordionBox = new AccordionBox( massNumberDisplay, {
      titleNode: new Text( massNumberString, {
        font: ShredConstants.ACCORDION_BOX_TITLE_FONT,
        maxWidth: ShredConstants.ACCORDION_BOX_TITLE_MAX_WIDTH,
        tandem: tandem.createTandem( 'massNumberAccordionBoxTitle' )
      } ),
      fill: ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR,
      expandedProperty: this.massNumberAccordionBoxExpandedProperty,
      minWidth: this.periodicTableAccordionBox.width,
      contentAlign: 'left',
      titleAlignX: 'left',
      buttonAlign: 'right',
      buttonTouchAreaXDilation: ACCORDION_BOX_BUTTON_DILATION,
      buttonTouchAreaYDilation: ACCORDION_BOX_BUTTON_DILATION,
      tandem: tandem.createTandem( 'massNumberAccordionBox' ),
      accessibleAccordionTitle: massNumberString
    } );
    this.controlPanelLayer.addChild( massNumberAccordionBox );
    netChargeAccordionBox.right = this.periodicTableAccordionBox.right;
    netChargeAccordionBox.top = this.periodicTableAccordionBox.bottom + INTER_BOX_SPACING;
    massNumberAccordionBox.right = this.periodicTableAccordionBox.right;
    massNumberAccordionBox.top = netChargeAccordionBox.top + netChargeAccordionBox.height + INTER_BOX_SPACING;
    this.accessibleOrder = [ this.periodicTableAccordionBox, netChargeAccordionBox, massNumberAccordionBox ];
  }
  buildAnAtom.register( 'BuildAnAtomView', BuildAnAtomView );
  return inherit( AtomView, BuildAnAtomView, {
    reset: function() {
      AtomView.prototype.reset.call( this );
      this.netChargeAccordionBoxExpandedProperty.reset();
      this.massNumberAccordionBoxExpandedProperty.reset();
    }
  } );
} );
define( 'JOIST/TScreen',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','JOIST/joist','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var joist = require( 'JOIST/joist' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  function TScreen( screen, phetioID ) {
    assertInstanceOf( screen, phet.joist.Screen );
    TObject.call( this, screen, phetioID );
  }
  phetioInherit( TObject, 'TScreen', TScreen, {}, {
    documentation: 'A single screen for a PhET simulation'
  } );
  joist.register( 'TScreen', TScreen );
  return TScreen;
} );
define( 'JOIST/Screen',['require','DOT/Dimension2','PHET_CORE/inherit','JOIST/joist','SCENERY/nodes/Path','AXON/Property','SCENERY/nodes/Rectangle','KITE/Shape','TANDEM/Tandem','JOIST/TScreen','ifphetio!PHET_IO/types/TBoolean'],function( require ) {
  'use strict';
  var Dimension2 = require( 'DOT/Dimension2' );
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TScreen = require( 'JOIST/TScreen' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var MINIMUM_HOME_SCREEN_ICON_SIZE = new Dimension2( 548, 373 );
  var MINIMUM_NAVBAR_ICON_SIZE = new Dimension2( 147, 100 );
  var NAVBAR_ICON_ASPECT_RATIO = MINIMUM_NAVBAR_ICON_SIZE.width / MINIMUM_NAVBAR_ICON_SIZE.height;
  var HOME_SCREEN_ICON_ASPECT_RATIO = MINIMUM_HOME_SCREEN_ICON_SIZE.width / MINIMUM_HOME_SCREEN_ICON_SIZE.height;
  var ICON_ASPECT_RATIO_TOLERANCE = 5E-3; // how close to the ideal aspect ratio an icon must be
  assert && assert( Math.abs( HOME_SCREEN_ICON_ASPECT_RATIO - HOME_SCREEN_ICON_ASPECT_RATIO ) < ICON_ASPECT_RATIO_TOLERANCE,
    'MINIMUM_HOME_SCREEN_ICON_SIZE and MINIMUM_NAVBAR_ICON_SIZE must have the same aspect ratio' );
  function Screen( createModel, createView, options ) {
    options = _.extend( {
      name: null,
      backgroundColorProperty: new Property( 'white' ),
      homeScreenIcon: new Rectangle( 0, 0, MINIMUM_HOME_SCREEN_ICON_SIZE.width, MINIMUM_HOME_SCREEN_ICON_SIZE.height, {
        fill: 'white',
        stroke: 'black'
      } ),
      navigationBarIcon: null,
      maxDT: 0.5,
      tandem: Tandem.tandemRequired()
    }, options );
    if ( !options.navigationBarIcon ) {
      options.navigationBarIcon = options.homeScreenIcon;
    }
    validateIconSize( options.homeScreenIcon, MINIMUM_HOME_SCREEN_ICON_SIZE, HOME_SCREEN_ICON_ASPECT_RATIO, 'homeScreenIcon' );
    validateIconSize( options.navigationBarIcon, MINIMUM_NAVBAR_ICON_SIZE, NAVBAR_ICON_ASPECT_RATIO, 'navigationBarIcon' );
    this.tandem = options.tandem;
    assert && assert( !options.backgroundColor, 'Please provide backgroundColorProperty instead' );
    this.backgroundColorProperty = options.backgroundColorProperty;
    this.name = options.name;
    this.homeScreenIcon = options.homeScreenIcon;
    this.navigationBarIcon = options.navigationBarIcon;
    this.maxDT = options.maxDT;
    this.createModel = createModel;
    this.createView = createView;
    this._model = null; // @private
    this._view = null;  // @private
    this.activeProperty = new Property( false, {
      tandem: options.tandem.createTandem( 'activeProperty' ),
      phetioValueType: TBoolean,
      phetioInstanceDocumentation: 'this Property is read-only, do not attempt to set its value'
    } );
    var self = this;
    assert && this.activeProperty.lazyLink( function( isActive ) {
      assert( self._view, 'isActive should not change before the Screen view has been initialized' );
      assert( !self._view.isVisible(), 'isActive should not change while the Screen view is visible' );
    } );
    options.tandem.addInstance( this, TScreen );
  }
  joist.register( 'Screen', Screen );
  var validateIconSize = function( icon, minimumSize, aspectRatio, name ) {
    assert && assert( icon.width >= minimumSize.width, name + ' is too small: ' + icon.width );
    assert && assert( icon.height >= minimumSize.height, name + ' is too small: ' + icon.height );
    var actualAspectRatio = icon.width / icon.height;
    assert && assert(
      Math.abs( aspectRatio - actualAspectRatio ) < ICON_ASPECT_RATIO_TOLERANCE,
      name + ' has invalid aspect ratio: ' + actualAspectRatio
    );
  };
  var devCreateLayoutBoundsNode = function( layoutBounds ) {
    return new Path( Shape.bounds( layoutBounds ), {
      stroke: 'red',
      lineWidth: 3,
      pickable: false
    } );
  };
  var devCreateVisibleBoundsNode = function( screenView ) {
    var path = new Path( Shape.bounds( screenView.visibleBoundsProperty.value ), {
      stroke: 'blue',
      lineWidth: 6,
      pickable: false
    } );
    screenView.visibleBoundsProperty.link( function( visibleBounds ) {
      path.shape = Shape.bounds( visibleBounds );
    } );
    return path;
  };
  return inherit( Object, Screen, {
    reset: function() {
    },
    get model() {
      assert && assert( this._model, 'Model has not yet been constructed' );
      return this._model;
    },
    get view() {
      assert && assert( this._view, 'View has not yet been constructed' );
      return this._view;
    },
    initializeModel: function() {
      assert && assert( this._model === null, 'there was already a model' );
      this._model = this.createModel();
    },
    initializeView: function() {
      assert && assert( this._view === null, 'there was already a view' );
      this._view = this.createView( this.model );
      this._view.setVisible( false ); // a Screen is invisible until selected
      if ( phet.chipper.queryParameters.dev ) {
        this._view.addChild( devCreateLayoutBoundsNode( this._view.layoutBounds ) );
      }
      if ( phet.chipper.queryParameters.showVisibleBounds ) {
        this._view.addChild( devCreateVisibleBoundsNode( this._view ) );
      }
    },
    initializeModelAndView: function() {
      this.initializeModel();
      this.initializeView();
    }
  }, {
    MINIMUM_HOME_SCREEN_ICON_SIZE: MINIMUM_HOME_SCREEN_ICON_SIZE,
    MINIMUM_NAVBAR_ICON_SIZE: MINIMUM_NAVBAR_ICON_SIZE
  } );
} );
define("string!BUILD_AN_ATOM/atom",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/atom");});
define("image!BUILD_AN_ATOM/atom_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define("image!BUILD_AN_ATOM/atom_icon_small.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define( 'BUILD_AN_ATOM/buildanatom/BuildAnAtomScreen',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/common/model/BuildAnAtomModel','BUILD_AN_ATOM/buildanatom/view/BuildAnAtomView','SCENERY/nodes/Image','PHET_CORE/inherit','JOIST/Screen','string!BUILD_AN_ATOM/atom','image!BUILD_AN_ATOM/atom_icon.png','image!BUILD_AN_ATOM/atom_icon_small.png'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BuildAnAtomModel = require( 'BUILD_AN_ATOM/common/model/BuildAnAtomModel' );
  var BuildAnAtomView = require( 'BUILD_AN_ATOM/buildanatom/view/BuildAnAtomView' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Screen = require( 'JOIST/Screen' );
  var atomString = require( 'string!BUILD_AN_ATOM/atom' );
  var atomIcon = require( 'image!BUILD_AN_ATOM/atom_icon.png' );
  var atomIconSmall = require( 'image!BUILD_AN_ATOM/atom_icon_small.png' );
  function BuildAnAtomScreen( tandem ) {
    Screen.call(
      this,
      function() { return new BuildAnAtomModel( tandem.createTandem( 'model' ) ); },
      function( model ) { return new BuildAnAtomView( model, tandem.createTandem( 'view' ) ); },
      {
        name: atomString,
        homeScreenIcon: new Image( atomIcon ),
        navigationBarIcon: new Image( atomIconSmall ),
        tandem: tandem
      }
    );
  }
  buildAnAtom.register( 'BuildAnAtomScreen', BuildAnAtomScreen );
  return inherit( Screen, BuildAnAtomScreen );
} );
define( 'SHRED/model/NumberAtom',['require','SHRED/AtomIdentifier','AXON/DerivedProperty','TANDEM/axon/TandemEmitter','PHET_CORE/inherit','AXON/Property','SHRED/shred','TANDEM/Tandem','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var TandemEmitter = require( 'TANDEM/axon/TandemEmitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  function NumberAtom( options ) {
    options = _.extend( {
      protonCount: 0,
      neutronCount: 0,
      electronCount: 0,
      tandem: Tandem.tandemRequired() // Tandem must be supplied when running in PhET-iO
    }, options );
    this.protonCountProperty = new Property( options.protonCount, {
      tandem: options.tandem.createTandem( 'protonCountProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } ),
      documentation: 'this property is updated by the model and should not be set by users'
    } );
    this.neutronCountProperty = new Property( options.neutronCount, {
      tandem: options.tandem.createTandem( 'neutronCountProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } ),
      documentation: 'this property is updated by the model and should not be set by users'
    } );
    this.electronCountProperty = new Property( options.electronCount, {
      tandem: options.tandem.createTandem( 'electronCountProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } ),
      documentation: 'this property is updated by the model and should not be set by users'
    } );
    this.chargeProperty = new DerivedProperty( [ this.protonCountProperty, this.electronCountProperty ],
      function( protonCount, electronCount ) {
        return protonCount - electronCount;
      }, {
        tandem: options.tandem.createTandem( 'chargeProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.massNumberProperty = new DerivedProperty( [ this.protonCountProperty, this.neutronCountProperty ],
      function( protonCount, neutronCount ) {
        return protonCount + neutronCount;
      }, {
        tandem: options.tandem.createTandem( 'massNumberProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.particleCountProperty = new DerivedProperty( [ this.protonCountProperty, this.neutronCountProperty, this.electronCountProperty ],
      function( protonCount, neutronCount, electronCount ) {
        return protonCount + neutronCount + electronCount;
      }, {
        tandem: options.tandem.createTandem( 'particleCountProperty' ),
        phetioValueType: TNumber( { type: 'Integer' } )
      }
    );
    this.atomUpdated = new TandemEmitter( {
      phetioArgumentTypes: [],
      tandem: options.tandem.createTandem( 'atomUpdatedEmitter' )
    } );
  }
  shred.register( 'NumberAtom', NumberAtom );
  return inherit( Object, NumberAtom, {
    equals: function( otherAtom ) {
      return this.protonCountProperty.get() === otherAtom.protonCountProperty.get() &&
             this.neutronCountProperty.get() === otherAtom.neutronCountProperty.get() &&
             this.electronCountProperty.get() === otherAtom.electronCountProperty.get();
    },
    getStandardAtomicMass: function() {
      return AtomIdentifier.getStandardAtomicMass( this.protonCountProperty.get() + this.neutronCountProperty.get() );
    },
    getIsotopeAtomicMass: function() {
      return AtomIdentifier.getIsotopeAtomicMass( this.protonCountProperty.get(), this.neutronCountProperty.get() );
    },
    setSubAtomicParticleCount: function( protonCount, neutronCount, electronCount ) {
      this.protonCountProperty.set( protonCount );
      this.electronCountProperty.set( electronCount );
      this.neutronCountProperty.set( neutronCount );
      this.atomUpdated.emit();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/AtomValuePool',['require','BUILD_AN_ATOM/buildAnAtom','SHRED/model/NumberAtom'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var PROBLEM_POOLS = [
    [
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 2 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 2, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 3 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 3 } ),
      new NumberAtom( { protonCount: 4, neutronCount: 5, electronCount: 4 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 5, electronCount: 5 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 6, electronCount: 5 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 6, electronCount: 6 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 7, electronCount: 6 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 10 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 9 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 11, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 12, electronCount: 10 } )
    ],
    [
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 2 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 2, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 3 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 3 } ),
      new NumberAtom( { protonCount: 4, neutronCount: 5, electronCount: 4 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 5, electronCount: 5 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 6, electronCount: 5 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 6, electronCount: 6 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 7, electronCount: 6 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 10 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 9 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 11, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 12, electronCount: 10 } )
    ],
    [
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 2 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 2, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 3 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 3 } ),
      new NumberAtom( { protonCount: 4, neutronCount: 5, electronCount: 4 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 5, electronCount: 5 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 6, electronCount: 5 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 6, electronCount: 6 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 7, electronCount: 6 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 10 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 9 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 11, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 11, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 11, neutronCount: 12, electronCount: 11 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 12, electronCount: 12 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 13, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 13, electronCount: 12 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 14, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 14, electronCount: 12 } ),
      new NumberAtom( { protonCount: 13, neutronCount: 14, electronCount: 10 } ),
      new NumberAtom( { protonCount: 13, neutronCount: 14, electronCount: 13 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 14, electronCount: 14 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 15, electronCount: 14 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 16, electronCount: 14 } ),
      new NumberAtom( { protonCount: 15, neutronCount: 16, electronCount: 15 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 16, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 16, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 17, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 17, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 18, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 18, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 19, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 19, electronCount: 18 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 18, electronCount: 17 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 18, electronCount: 18 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 20, electronCount: 17 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 20, electronCount: 18 } ),
      new NumberAtom( { protonCount: 18, neutronCount: 20, electronCount: 18 } ),
      new NumberAtom( { protonCount: 18, neutronCount: 22, electronCount: 18 } )
    ],
    [
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 0, electronCount: 2 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 0 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 1 } ),
      new NumberAtom( { protonCount: 1, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 1, electronCount: 2 } ),
      new NumberAtom( { protonCount: 2, neutronCount: 2, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 3, electronCount: 3 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 2 } ),
      new NumberAtom( { protonCount: 3, neutronCount: 4, electronCount: 3 } ),
      new NumberAtom( { protonCount: 4, neutronCount: 5, electronCount: 4 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 5, electronCount: 5 } ),
      new NumberAtom( { protonCount: 5, neutronCount: 6, electronCount: 5 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 6, electronCount: 6 } ),
      new NumberAtom( { protonCount: 6, neutronCount: 7, electronCount: 6 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 7, electronCount: 10 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 7 } ),
      new NumberAtom( { protonCount: 7, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 8, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 9, electronCount: 10 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 8 } ),
      new NumberAtom( { protonCount: 8, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 9 } ),
      new NumberAtom( { protonCount: 9, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 10, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 11, electronCount: 10 } ),
      new NumberAtom( { protonCount: 10, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 11, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 11, neutronCount: 12, electronCount: 11 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 12, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 12, electronCount: 12 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 13, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 13, electronCount: 12 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 14, electronCount: 10 } ),
      new NumberAtom( { protonCount: 12, neutronCount: 14, electronCount: 12 } ),
      new NumberAtom( { protonCount: 13, neutronCount: 14, electronCount: 10 } ),
      new NumberAtom( { protonCount: 13, neutronCount: 14, electronCount: 13 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 14, electronCount: 14 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 15, electronCount: 14 } ),
      new NumberAtom( { protonCount: 14, neutronCount: 16, electronCount: 14 } ),
      new NumberAtom( { protonCount: 15, neutronCount: 16, electronCount: 15 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 16, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 16, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 17, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 17, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 18, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 18, electronCount: 18 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 19, electronCount: 16 } ),
      new NumberAtom( { protonCount: 16, neutronCount: 19, electronCount: 18 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 18, electronCount: 17 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 18, electronCount: 18 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 20, electronCount: 17 } ),
      new NumberAtom( { protonCount: 17, neutronCount: 20, electronCount: 18 } ),
      new NumberAtom( { protonCount: 18, neutronCount: 20, electronCount: 18 } ),
      new NumberAtom( { protonCount: 18, neutronCount: 22, electronCount: 18 } )
    ]
  ];
  function AtomValuePool( level ) {
    this.remainingAtomValues = PROBLEM_POOLS[ level ];
    this.usedAtomValues = [];
  }
  AtomValuePool.prototype.markAtomAsUsed = function( atomValueToRemove ) {
    if ( this.remainingAtomValues.indexOf( atomValueToRemove ) !== -1 ) {
      this.remainingAtomValues = _.without( this.remainingAtomValues, atomValueToRemove );
      this.usedAtomValues.push( atomValueToRemove );
    }
  };
  AtomValuePool.prototype.getRandomAtomValue = function( minProtonCount, maxProtonCount, requireCharged ) {
    var meetsCriteria = function( numberAtom ) {
      return numberAtom.protonCountProperty.get() >= minProtonCount &&
             numberAtom.protonCountProperty.get() < maxProtonCount &&
             ( !requireCharged || numberAtom.chargeProperty.get() !== 0 );
    };
    var allowableAtomValues = [];
    this.remainingAtomValues.forEach( function( numberAtom ) {
      if ( meetsCriteria( numberAtom ) ) {
        allowableAtomValues.push( numberAtom );
      }
    } );
    if ( allowableAtomValues.length === 0 ) {
      this.usedAtomValues.forEach( function( numberAtom ) {
        if ( meetsCriteria( numberAtom ) ) {
          allowableAtomValues.push( numberAtom );
        }
      } );
    }
    var atomValue = null;
    if ( allowableAtomValues.length > 0 ) {
      atomValue = allowableAtomValues[ Math.floor( phet.joist.random.nextDouble() * allowableAtomValues.length ) ];
    }
    else {
      throw 'Error: No atoms found that match the specified criteria';
    }
    return atomValue;
  };
  buildAnAtom.register( 'AtomValuePool', AtomValuePool );
  return AtomValuePool;
} );
define( 'BUILD_AN_ATOM/game/model/BAAGameProblem',['require','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','AXON/Property','SHRED/ShredConstants'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  function BAAGameProblem( buildAnAtomGameModel, answerAtom ) {
    this.problemStateProperty  = new Property( 'presentingProblem' );
    this.numSubmissionsProperty =new Property( 0 );
    this.scoreProperty =  new Property( 0 );
    this.answerAtom = answerAtom;
    this.model = buildAnAtomGameModel;
  }
  buildAnAtom.register( 'BAAGameProblem', BAAGameProblem );
  return inherit( Object, BAAGameProblem, {
    checkAnswer: function( submittedAtom ) {
      assert && assert( this.problemStateProperty.get() === 'presentingProblem', 'Unexpected problem state: ' +
                                                                                 this.problemStateProperty.get() );
      this.numSubmissionsProperty.set( this.numSubmissionsProperty.get() + 1 );
      var pointsIfCorrect = this.numSubmissionsProperty.get() === 1 ? 2 : 1;
      var isCorrect = this.answerAtom.equals( submittedAtom );
      this.model.emitCheckAnswer( isCorrect, pointsIfCorrect, this.answerAtom, submittedAtom, {
        correctElectronCount: this.answerAtom.electronCountProperty.get(),
        submittedElectronCount: submittedAtom.electronCountProperty.get()
      } );
      if ( isCorrect ) {
        this.scoreProperty.set( pointsIfCorrect );
        this.model.scoreProperty.set(  this.model.scoreProperty.get() + this.scoreProperty.get() );
        this.problemStateProperty.set( 'problemSolvedCorrectly' );
      }
      else {
        if ( this.numSubmissionsProperty.get() < ShredConstants.MAX_PROBLEM_ATTEMPTS ) {
          this.problemStateProperty.set( 'presentingTryAgain' );
        }
        else {
          this.problemStateProperty.set( 'attemptsExhausted' );
        }
      }
    },
    tryAgain: function() {
      this.problemStateProperty.set( 'presentingProblem' );
    },
    next: function() {
      this.model.next();
    },
    displayCorrectAnswer: function() {
      this.problemStateProperty.set( 'displayingCorrectAnswer' );
    }
  } );
} );
define( 'PHETCOMMON/util/StringUtils',['require','PHETCOMMON/phetcommon'],function( require ) {
  'use strict';
  var phetcommon = require( 'PHETCOMMON/phetcommon' );
  var LTR = '\u202a';
  var RTL = '\u202b';
  var POP = '\u202c';
  var StringUtils = {
    format: function( pattern ) {
      var args = arguments;
      return pattern.replace( /{(\d)}/g, function( r, n ) { return args[ +n + 1 ];} );
    },
    fillIn: function( template, values ) {
      var newString = template;
      var placeholders = template.match( /\{\{[^\{\}]+\}\}/g ) || [];
      for ( var i = 0; i < placeholders.length; i++ ) {
        var placeholder = placeholders[ i ];
        var key = placeholder.replace( '{{', '' ).replace( '}}', '' );
        assert && assert( values[ key ] !== undefined, 'missing key ' + key );
        newString = newString.replace( placeholder, values[ key ] );
      }
      return newString;
    },
    isEmbeddingMark: function( chr ) {
      return chr === LTR || chr === RTL || chr === POP;
    },
    embeddedSlice: function( string, startIndex, endIndex ) {
      var stack = [];
      var chr;
      if ( endIndex === undefined ) {
        endIndex = string.length;
      }
      if ( endIndex < 0 ) {
        endIndex += string.length;
      }
      while ( startIndex < string.length && StringUtils.isEmbeddingMark( string.charAt( startIndex ) ) ) {
        startIndex++;
      }
      while ( endIndex >= 1 && StringUtils.isEmbeddingMark( string.charAt( endIndex - 1 ) ) ) {
        endIndex--;
      }
      if ( startIndex >= endIndex || startIndex >= string.length ) {
        return '';
      }
      for ( var i = 0; i < startIndex; i++ ) {
        chr = string.charAt( i );
        if ( chr === LTR || chr === RTL ) {
          stack.push( chr );
        }
        else if ( chr === POP ) {
          stack.pop();
        }
      }
      var minimumStackSize = stack.length;
      var startStack = stack.slice();
      var slice = string.slice( startIndex, endIndex );
      for ( var j = 0; j < slice.length; j++ ) {
        chr = slice.charAt( j );
        if ( chr === LTR || chr === RTL ) {
          stack.push( chr );
        }
        else if ( chr === POP ) {
          stack.pop();
          minimumStackSize = Math.min( stack.length, minimumStackSize );
        }
      }
      var endStack = stack;
      var numSkippedStackLevels = Math.max( 0, minimumStackSize - 1 );
      startStack = startStack.slice( numSkippedStackLevels );
      endStack = endStack.slice( numSkippedStackLevels );
      var prefix = startStack.join( '' );
      var suffix = endStack.join( '' ).replace( /./g, POP );
      return prefix + slice + suffix;
    },
    embeddedSplit: function( string, separator, limit ) {
      if ( separator === undefined ) {
        return [ string ];
      }
      var result = [];
      var separatorMatch;
      var stringToSplit = string;
      function findSeparatorMatch() {
        var index;
        var length;
        if ( separator instanceof window.RegExp ) {
          var match = stringToSplit.match( separator );
          if ( match ) {
            index = match.index;
            length = match[ 0 ].length;
          }
          else {
            index = -1;
          }
        }
        else {
          assert && assert( typeof separator === 'string' );
          index = stringToSplit.indexOf( separator );
          length = separator.length;
        }
        return {
          index: index,
          length: length
        };
      }
      var indexOffset = 0;
      while ( ( separatorMatch = findSeparatorMatch() ).index >= 0 ) {
        result.push( StringUtils.embeddedSlice( string, indexOffset, indexOffset + separatorMatch.index ) );
        var offset = separatorMatch.index + separatorMatch.length;
        stringToSplit = stringToSplit.slice( offset );
        indexOffset += offset;
      }
      result.push( StringUtils.embeddedSlice( string, indexOffset ) );
      if ( limit !== undefined ) {
        assert && assert( typeof limit === 'number' );
        result = _.first( result, limit );
      }
      return result;
    },
    stripEmbeddingMarks: function( string ) {
      return string.replace( /\u202a|\u202b|\u202c/g, '' );
    },
    embeddedDebugString: function( string ) {
      return string.replace( /\u202a/g, '[LTR]' ).replace( /\u202b/g, '[RTL]' ).replace( /\u202c/g, '[POP]' );
    },
    wrapLTR: function( string ) {
      return LTR + string + POP;
    },
    wrapRTL: function( string ) {
      return RTL + string + POP;
    },
    wrapDirection: function( string, direction ) {
      assert && assert( direction === 'ltr' || direction === 'rtl' );
      if ( direction === 'ltr' ) {
        return StringUtils.wrapLTR( string );
      }
      else {
        return StringUtils.wrapRTL( string );
      }
    },
    localeToLocalizedName: function( locale ) {
      assert && assert( phet.chipper.localeData[ locale ], 'locale needs to be a valid locale code defined in phet.chipper.localeData' );
      return StringUtils.wrapDirection(
        phet.chipper.localeData[ locale ].localizedName,
        phet.chipper.localeData[ locale ].direction
      );
    },
    endsWith: function( string, searchString, position ) {
      var subjectString = string.toString();
      if ( typeof position !== 'number' || !isFinite( position ) || Math.floor( position ) !== position || position > subjectString.length ) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf( searchString, position );
      return lastIndex !== -1 && lastIndex === position;
    }
  };
  phetcommon.register( 'StringUtils', StringUtils );
  return StringUtils;
} );
define( 'SCENERY_PHET/TMultiLineText',['require','SCENERY_PHET/sceneryPhet','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/phetioEvents','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var phetioEvents = require( 'ifphetio!PHET_IO/phetioEvents' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  function TMultiLineText( text, phetioID ) {
    TNode.call( this, text, phetioID );
    assertInstanceOf( text, phet.sceneryPhet.MultiLineText );
    text.on( 'text', function( oldText, newText ) {
      phetioEvents.trigger( 'model', phetioID, TMultiLineText, 'textChanged', {
        oldText: oldText,
        newText: newText
      } );
    } );
  }
  phetioInherit( TNode, 'TMultiLineText', TMultiLineText, {
    setText: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( text ) {
        this.instance.text = text;
      },
      documentation: 'Set the text content'
    },
    getText: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return this.instance.text;
      },
      documentation: 'Get the text content'
    }
  }, {
    documentation: 'The tandem wrapper type for the scenery phet\'s MultiLineText node'
  } );
  sceneryPhet.register( 'TMultiLineText', TMultiLineText );
  return TMultiLineText;
} );
define( 'SCENERY_PHET/MultiLineText',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/nodes/Text','SCENERY/nodes/VBox','SCENERY_PHET/sceneryPhet','PHETCOMMON/util/StringUtils','TANDEM/Tandem','SCENERY_PHET/TMultiLineText'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TMultiLineText = require( 'SCENERY_PHET/TMultiLineText' );
  function MultiLineText( text, options ) {
    options = _.extend( {
      font: new PhetFont(),
      align: 'center', // 'center', 'left' or 'right' (as supported by VBox)
      tandem: Tandem.tandemRequired(),
      phetioType: TMultiLineText
    }, options );
    this.options = options; // @private
    Node.call( this );
    this._text = null; // @private underscore prefix because it has ES5 set/get
    this.textParent = null; // @private
    this.text = text; // call ES5 setter
    this.tagName = 'p';
    this.accessibleLabel = text;
    this.mutate( _.omit( options, 'align' ) ); // mutate after removing options that are specific to this subtype
  }
  sceneryPhet.register( 'MultiLineText', MultiLineText );
  return inherit( Node, MultiLineText, {
    setText: function( text ) {
      this._text = text;
      var self = this;
      var textNodes = StringUtils.embeddedSplit( text, '\n' ).map( function( line ) {
        if ( line.length === 0 ) { line = ' '; }
        return new Text( line, _.omit( self.options, 'align', 'maxWidth', 'tandem' ) );
      } );
      var index = this.textParent ? this.indexOfChild( this.textParent ) : 0;
      if ( this.textParent ) {
        this.removeChild( this.textParent );
      }
      this.textParent = new VBox( {
        children: textNodes,
        align: this.options.align
      } );
      this.insertChild( index, this.textParent );
    },
    set text( value ) { this.setText( value ); }, // ES5 setter
    getText: function() { return this._text; },
    get text() { return this.getText(); }, // ES5 getter
    setFill: function( fill ) {
      this.options.fill = fill;
      var children = this.textParent.getChildren();
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].setFill( fill );
      }
    },
    set fill( value ) { this.setFill( value ); }, // ES5 setter
    getFill: function() { return this.options.fill; },
    get fill() { return this.getFill(); } // ES5 getter
  } );
} );
define( 'SCENERY/nodes/AlignBox',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var ALIGNMENT_CONTAINER_OPTION_KEYS = [
    'alignBounds', // {Bounds2|null} - See setAlignBounds() for more documentation
    'xAlign', // {string} - 'left', 'center', or 'right', see setXAlign() for more documentation
    'yAlign', // {string} - 'top', 'center', or 'bottom', see setYAlign() for more documentation
    'margin', // {number} - Sets all margins, see setMargin() for more documentation
    'xMargin', // {number} - Sets horizontal margins, see setXMargin() for more documentation
    'yMargin', // {number} - Sets vertical margins, see setYMargin() for more documentation
    'leftMargin', // {number} - Sets left margin, see setLeftMargin() for more documentation
    'rightMargin', // {number} - Sets right margin, see setRightMargin() for more documentation
    'topMargin', // {number} - Sets top margin, see setTopMargin() for more documentation
    'bottomMargin', // {number} - Sets bottom margin, see setBottomMargin() for more documentation
    'group' // {AlignGroup|null} - Share bounds with others, see setGroup() for more documentation
  ];
  function AlignBox( content, options ) {
    assert && assert( options === undefined || Object.getPrototypeOf( options ) === Object.prototype,
      'Extra prototype on Node options object is a code smell' );
    this._content = content;
    this._alignBounds = null;
    this._xAlign = 'center';
    this._yAlign = 'center';
    this._leftMargin = 0;
    this._rightMargin = 0;
    this._topMargin = 0;
    this._bottomMargin = 0;
    this._group = null;
    this._contentBoundsListener = this.invalidateAlignment.bind( this );
    this._layoutLock = false;
    this._content.on( 'bounds', this._contentBoundsListener );
    Node.call( this, _.extend( {}, options, {
      children: [ this._content ]
    } ) );
  }
  scenery.register( 'AlignBox', AlignBox );
  inherit( Node, AlignBox, {
    _mutatorKeys: ALIGNMENT_CONTAINER_OPTION_KEYS.concat( Node.prototype._mutatorKeys ),
    invalidateAlignment: function() {
      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' invalidateAlignment' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();
      if ( this._group ) {
        this._group.onAlignBoxResized( this );
      }
      this.updateLayout();
      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();
    },
    setAlignBounds: function( alignBounds ) {
      assert && assert( alignBounds === null || ( alignBounds instanceof Bounds2 && !alignBounds.isEmpty() && alignBounds.isFinite() ),
        'alignBounds should be a non-empty finite Bounds2' );
      if ( this._alignBounds !== alignBounds &&
           ( !alignBounds ||
             !this._alignBounds ||
             !alignBounds.equals( this._alignBounds ) ) ) {
        this._alignBounds = alignBounds;
        this.updateLayout();
      }
      return this;
    },
    set alignBounds( value ) { this.setAlignBounds( value ); },
    getAlignBounds: function() {
      return this._alignBounds;
    },
    get alignBounds() { return this.getAlignBounds(); },
    setGroup: function( group ) {
      assert && assert( group === null || group instanceof scenery.AlignGroup, 'group should be an AlignGroup' );
      if ( this._group !== group ) {
        if ( this._group ) {
          this._group.removeAlignBox( this );
        }
        this._group = group;
        if ( this._group ) {
          this._group.addAlignBox( this );
        }
      }
      return this;
    },
    set group( value ) { this.setGroup( value ); },
    getGroup: function() {
      return this._group;
    },
    get group() { return this.getGroup(); },
    setXAlign: function( xAlign ) {
      assert && assert( xAlign === 'left' || xAlign === 'center' || xAlign === 'right',
        'xAlign should be one of: \'left\', \'center\', or \'right\'' );
      if ( this._xAlign !== xAlign ) {
        this._xAlign = xAlign;
        this.invalidateAlignment();
      }
      return this;
    },
    set xAlign( value ) { this.setXAlign( value ); },
    getXAlign: function() {
      return this._xAlign;
    },
    get xAlign() { return this.getXAlign(); },
    setYAlign: function( yAlign ) {
      assert && assert( yAlign === 'top' || yAlign === 'center' || yAlign === 'bottom',
        'yAlign should be one of: \'top\', \'center\', or \'bottom\'' );
      if ( this._yAlign !== yAlign ) {
        this._yAlign = yAlign;
        this.invalidateAlignment();
      }
      return this;
    },
    set yAlign( value ) { this.setYAlign( value ); },
    getYAlign: function() {
      return this._yAlign;
    },
    get yAlign() { return this.getYAlign(); },
    setMargin: function( margin ) {
      assert && assert( typeof margin === 'number' && isFinite( margin ) && margin >= 0,
        'margin should be a finite non-negative number' );
      if ( this._leftMargin !== margin ||
           this._rightMargin !== margin ||
           this._topMargin !== margin ||
           this._bottomMargin !== margin ) {
        this._leftMargin = this._rightMargin = this._topMargin = this._bottomMargin = margin;
        this.invalidateAlignment();
      }
      return this;
    },
    set margin( value ) { this.setMargin( value ); },
    getMargin: function() {
      assert && assert( this._leftMargin === this._rightMargin &&
                        this._leftMargin === this._topMargin &&
                        this._leftMargin === this._bottomMargin,
        'Getting margin does not have a unique result if the left and right margins are different' );
      return this._leftMargin;
    },
    get margin() { return this.getMargin(); },
    setXMargin: function( xMargin ) {
      assert && assert( typeof xMargin === 'number' && isFinite( xMargin ) && xMargin >= 0,
        'xMargin should be a finite non-negative number' );
      if ( this._leftMargin !== xMargin || this._rightMargin !== xMargin ) {
        this._leftMargin = this._rightMargin = xMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set xMargin( value ) { this.setXMargin( value ); },
    getXMargin: function() {
      assert && assert( this._leftMargin === this._rightMargin,
        'Getting xMargin does not have a unique result if the left and right margins are different' );
      return this._leftMargin;
    },
    get xMargin() { return this.getXMargin(); },
    setYMargin: function( yMargin ) {
      assert && assert( typeof yMargin === 'number' && isFinite( yMargin ) && yMargin >= 0,
        'yMargin should be a finite non-negative number' );
      if ( this._topMargin !== yMargin || this._bottomMargin !== yMargin ) {
        this._topMargin = this._bottomMargin = yMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set yMargin( value ) { this.setYMargin( value ); },
    getYMargin: function() {
      assert && assert( this._topMargin === this._bottomMargin,
        'Getting yMargin does not have a unique result if the top and bottom margins are different' );
      return this._topMargin;
    },
    get yMargin() { return this.getYMargin(); },
    setLeftMargin: function( leftMargin ) {
      assert && assert( typeof leftMargin === 'number' && isFinite( leftMargin ) && leftMargin >= 0,
        'leftMargin should be a finite non-negative number' );
      if ( this._leftMargin !== leftMargin ) {
        this._leftMargin = leftMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set leftMargin( value ) { this.setLeftMargin( value ); },
    getLeftMargin: function() {
      return this._leftMargin;
    },
    get leftMargin() { return this.getLeftMargin(); },
    setRightMargin: function( rightMargin ) {
      assert && assert( typeof rightMargin === 'number' && isFinite( rightMargin ) && rightMargin >= 0,
        'rightMargin should be a finite non-negative number' );
      if ( this._rightMargin !== rightMargin ) {
        this._rightMargin = rightMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set rightMargin( value ) { this.setRightMargin( value ); },
    getRightMargin: function() {
      return this._rightMargin;
    },
    get rightMargin() { return this.getRightMargin(); },
    setTopMargin: function( topMargin ) {
      assert && assert( typeof topMargin === 'number' && isFinite( topMargin ) && topMargin >= 0,
        'topMargin should be a finite non-negative number' );
      if ( this._topMargin !== topMargin ) {
        this._topMargin = topMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set topMargin( value ) { this.setTopMargin( value ); },
    getTopMargin: function() {
      return this._topMargin;
    },
    get topMargin() { return this.getTopMargin(); },
    setBottomMargin: function( bottomMargin ) {
      assert && assert( typeof bottomMargin === 'number' && isFinite( bottomMargin ) && bottomMargin >= 0,
        'bottomMargin should be a finite non-negative number' );
      if ( this._bottomMargin !== bottomMargin ) {
        this._bottomMargin = bottomMargin;
        this.invalidateAlignment();
      }
      return this;
    },
    set bottomMargin( value ) { this.setBottomMargin( value ); },
    getBottomMargin: function() {
      return this._bottomMargin;
    },
    get bottomMargin() { return this.getBottomMargin(); },
    getContentBounds: function() {
      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' getContentBounds' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();
      var bounds = this._content.bounds;
      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();
      return new Bounds2( bounds.left - this._leftMargin,
                          bounds.top - this._topMargin,
                          bounds.right + this._rightMargin,
                          bounds.bottom + this._bottomMargin );
    },
    updateProperty: function( propName, offset ) {
      var currentValue = this._content[ propName ];
      var newValue = this.localBounds[ propName ] + offset;
      if ( Math.abs( currentValue - newValue ) > 1e-5 ) {
        this._content[ propName ] = newValue;
      }
    },
    updateLayout: function() {
      if ( this._layoutLock ) { return; }
      this._layoutLock = true;
      sceneryLog && sceneryLog.AlignBox && sceneryLog.AlignBox( 'AlignBox#' + this.id + ' updateLayout' );
      sceneryLog && sceneryLog.AlignBox && sceneryLog.push();
      if ( this._alignBounds !== null ) {
        this.localBounds = this._alignBounds;
      }
      else {
        var widthWithMargin = this._leftMargin + this._content.width + this._rightMargin;
        var heightWithMargin = this._topMargin + this._content.height + this._bottomMargin;
        this.localBounds = new Bounds2( 0, 0, widthWithMargin, heightWithMargin );
      }
      if ( !this._content.localBounds.isEmpty() ) {
        if ( this._xAlign === 'center' ) {
          this.updateProperty( 'centerX', ( this.leftMargin - this.rightMargin ) / 2 );
        }
        else if ( this._xAlign === 'left' ) {
          this.updateProperty( 'left', this._leftMargin );
        }
        else if ( this._xAlign === 'right' ) {
          this.updateProperty( 'right', -this._rightMargin );
        }
        else {
          assert && assert( 'Bad xAlign: ' + this._xAlign );
        }
        if ( this._yAlign === 'center' ) {
          this.updateProperty( 'centerY', ( this.topMargin - this.bottomMargin ) / 2 );
        }
        else if ( this._yAlign === 'top' ) {
          this.updateProperty( 'top', this._topMargin );
        }
        else if ( this._yAlign === 'bottom' ) {
          this.updateProperty( 'bottom', -this._bottomMargin );
        }
        else {
          assert && assert( 'Bad yAlign: ' + this._yAlign );
        }
      }
      sceneryLog && sceneryLog.AlignBox && sceneryLog.pop();
      this._layoutLock = false;
    },
    dispose: function() {
      this._content.off( 'bounds', this._contentBoundsListener );
      this.group = null;
      Node.prototype.dispose.call( this );
    }
  } );
  return AlignBox;
} );
define( 'SUN/buttons/RectangularButtonView',['require','SCENERY/nodes/AlignBox','DOT/Bounds2','SUN/buttons/ButtonListener','SCENERY/util/Color','SUN/ColorConstants','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SCENERY/nodes/Path','AXON/Property','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';
  var AlignBox = require( 'SCENERY/nodes/AlignBox' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var Color = require( 'SCENERY/util/Color' );
  var ColorConstants = require( 'SUN/ColorConstants' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var VERTICAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
  var HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH = 7; // In screen coords, which are roughly pixels.
  var SHADE_GRADIENT_LENGTH = 3; // In screen coords, which are roughly pixels.
  var DEFAULT_COLOR = ColorConstants.LIGHT_BLUE;
  var X_ALIGN_VALUES = [ 'center', 'left', 'right' ];
  var Y_ALIGN_VALUES = [ 'center', 'top', 'bottom' ];
  function createButtonShape( width, height, options ) {
    return Shape.roundedRectangleWithRadii( 0, 0, width, height, {
      topLeft: typeof( options.leftTopCornerRadius ) === 'number' ? options.leftTopCornerRadius : options.cornerRadius,
      topRight: typeof( options.rightTopCornerRadius ) === 'number' ? options.rightTopCornerRadius : options.cornerRadius,
      bottomLeft: typeof( options.leftBottomCornerRadius ) === 'number' ? options.leftBottomCornerRadius : options.cornerRadius,
      bottomRight: typeof( options.rightBottomCornerRadius ) === 'number' ? options.rightBottomCornerRadius : options.cornerRadius
    } );
  }
  function RectangularButtonView( buttonModel, interactionStateProperty, options ) {
    this.buttonModel = buttonModel; // @protected
    options = _.extend( {
      content: null,
      minWidth: HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
      minHeight: VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH,
      cursor: 'pointer',
      cornerRadius: 4,
      baseColor: DEFAULT_COLOR,
      disabledBaseColor: ColorConstants.LIGHT_GRAY,
      xMargin: 8, // should be visibly greater than yMargin, see issue #109
      yMargin: 5,
      fireOnDown: false,
      touchAreaXDilation: 0,
      touchAreaYDilation: 0,
      stroke: undefined, // undefined by default, which will cause a stroke to be derived from the base color
      lineWidth: 0.5, // Only meaningful if stroke is non-null
      xAlign: 'center', // {string} see X_ALIGN_VALUES
      yAlign: 'center', // {string} see Y_ALIGN_VALUES
      buttonAppearanceStrategy: RectangularButtonView.ThreeDAppearanceStrategy,
      contentAppearanceStrategy: RectangularButtonView.FadeContentWhenDisabled,
      tagName: 'button'
    }, options );
    assert && assert( _.includes( X_ALIGN_VALUES, options.xAlign ), 'invalid xAlign: ' + options.xAlign );
    assert && assert( _.includes( Y_ALIGN_VALUES, options.yAlign ), 'invalid yAlign: ' + options.yAlign );
    Node.call( this );
    var content = options.content; // convenience variable
    this.addInputListener( new ButtonListener( buttonModel ) );
    this.baseColorProperty = new Property( Color.toColor( options.baseColor ) ); // @private
    var buttonWidth = Math.max( content ? content.width + options.xMargin * 2 : 0, options.minWidth );
    var buttonHeight = Math.max( content ? content.height + options.yMargin * 2 : 0, options.minHeight );
    var button = new Path( createButtonShape( buttonWidth, buttonHeight, options ), {
      fill: options.baseColor,
      lineWidth: options.lineWidth
    } );
    this.addChild( button );
    if ( content ) {
      if ( content ) {
        content.pickable = false;
      }
      this.addChild( new AlignBox( content, {
        alignBounds: new Bounds2(
          options.xMargin,
          options.yMargin,
          button.width - options.xMargin,
          buttonHeight - options.yMargin
        ),
        xAlign: options.xAlign,
        yAlign: options.yAlign
      } ) );
    }
    var buttonAppearanceStrategy = new options.buttonAppearanceStrategy(
      button,
      interactionStateProperty,
      this.baseColorProperty,
      options
    );
    var contentAppearanceStrategy = new options.contentAppearanceStrategy( content, interactionStateProperty, options );
    var self = this;
    function handleInteractionStateChanged( state ) {
      self.cursor = state === 'disabled' || state === 'disabled-pressed' ? null : 'pointer';
    }
    interactionStateProperty.link( handleInteractionStateChanged );
    this.mouseArea = Shape.rectangle( 0, 0, buttonWidth, buttonHeight );
    this.touchArea = Shape.rectangle(
      -options.touchAreaXDilation,
      -options.touchAreaYDilation,
      buttonWidth + options.touchAreaXDilation * 2,
      buttonHeight + options.touchAreaYDilation * 2
    );
    this.mutate( options );
    this.disposeRectangularButtonView = function() {
      buttonAppearanceStrategy.dispose();
      contentAppearanceStrategy.dispose();
      interactionStateProperty.unlink( handleInteractionStateChanged );
    };
  }
  sun.register( 'RectangularButtonView', RectangularButtonView );
  RectangularButtonView.ThreeDAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {
    var buttonWidth = button.width;
    var buttonHeight = button.height;
    assert && assert( buttonWidth >= HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH );
    assert && assert( buttonHeight >= VERTICAL_HIGHLIGHT_GRADIENT_LENGTH + SHADE_GRADIENT_LENGTH );
    var verticalHighlightStop = Math.min( VERTICAL_HIGHLIGHT_GRADIENT_LENGTH / buttonHeight, 1 );
    var verticalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonHeight, 0 );
    var horizontalHighlightStop = Math.min( HORIZONTAL_HIGHLIGHT_GRADIENT_LENGTH / buttonWidth, 1 );
    var horizontalShadowStop = Math.max( 1 - SHADE_GRADIENT_LENGTH / buttonWidth, 0 );
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var transparentDisabledBaseColor = new Color( disabledBaseColor.getRed(), disabledBaseColor.getGreen(), disabledBaseColor.getBlue(), 0 );
    var transparentWhite = new Color( 256, 256, 256, 0.7 );
    var overlayForHorizGradient = new Path( createButtonShape( buttonWidth, buttonHeight, options ), {
      lineWidth: options.lineWidth,
      pickable: false
    } );
    button.addChild( overlayForHorizGradient );
    var upFillVertical;
    var upFillHorizontal;
    var overFillVertical;
    var overFillHorizontal;
    var downFillVertical;
    var disabledFillVertical;
    var disabledFillHorizontal;
    var disabledPressedFillVertical;
    var enabledStroke;
    var disabledStroke;
    function updateAppearance( interactionState ) {
      switch( interactionState ) {
        case 'idle':
          button.fill = upFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = upFillHorizontal;
          break;
        case 'over':
          button.fill = overFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = overFillHorizontal;
          break;
        case 'pressed':
          button.fill = downFillVertical;
          overlayForHorizGradient.stroke = enabledStroke;
          overlayForHorizGradient.fill = overFillHorizontal;
          break;
        case 'disabled':
          button.fill = disabledFillVertical;
          button.stroke = disabledStroke;
          overlayForHorizGradient.stroke = disabledStroke;
          overlayForHorizGradient.fill = disabledFillHorizontal;
          break;
        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          overlayForHorizGradient.stroke = disabledStroke;
          overlayForHorizGradient.fill = disabledFillHorizontal;
          break;
        default:
          throw new Error( 'unsupported interactionState: ' + interactionState );
      }
    }
    function updateFillsAndStrokes( baseColor ) {
      var transparentBaseColor = new Color( baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 0 );
      upFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, baseColor )
        .addColorStop( verticalShadowStop, baseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      upFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, transparentWhite )
        .addColorStop( horizontalHighlightStop, transparentBaseColor )
        .addColorStop( horizontalShadowStop, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      overFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, baseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      overFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, transparentWhite )
        .addColorStop( horizontalHighlightStop / 2, new Color( 256, 256, 256, 0 ) )
        .addColorStop( horizontalShadowStop, transparentBaseColor )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.3 ) );
      downFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, baseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop * 0.67, baseColor.colorUtilsDarker( 0.3 ) )
        .addColorStop( verticalShadowStop, baseColor.colorUtilsBrighter( 0.2 ) )
        .addColorStop( 1, baseColor.colorUtilsDarker( 0.5 ) );
      disabledFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.5 ) )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
      disabledFillHorizontal = new LinearGradient( 0, 0, buttonWidth, 0 )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( horizontalHighlightStop, transparentDisabledBaseColor )
        .addColorStop( horizontalShadowStop, transparentDisabledBaseColor )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
      disabledPressedFillVertical = new LinearGradient( 0, 0, 0, buttonHeight )
        .addColorStop( 0, disabledBaseColor.colorUtilsBrighter( 0.7 ) )
        .addColorStop( verticalHighlightStop * 0.67, disabledBaseColor.colorUtilsDarker( 0.3 ) )
        .addColorStop( verticalShadowStop, disabledBaseColor.colorUtilsBrighter( 0.2 ) )
        .addColorStop( 1, disabledBaseColor.colorUtilsDarker( 0.5 ) );
      if ( options.stroke === null ) {
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      button.cachedPaints = [
        upFillVertical, overFillVertical, downFillVertical, disabledFillVertical, disabledPressedFillVertical,
        disabledStroke
      ];
      overlayForHorizGradient.cachedPaints = [
        upFillHorizontal, overFillHorizontal, disabledFillHorizontal, enabledStroke, disabledStroke
      ];
      updateAppearance( interactionStateProperty.value );
    }
    updateFillsAndStrokes( baseColorProperty.value );
    updateAppearance( interactionStateProperty.value );
    baseColorProperty.lazyLink( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };
  RectangularButtonView.FlatAppearanceStrategy = function( button, interactionStateProperty, baseColorProperty, options ) {
    var disabledBaseColor = Color.toColor( options.disabledBaseColor );
    var upFill;
    var overFill;
    var downFill;
    var disabledFill;
    var disabledPressedFillVertical;
    var enabledStroke;
    var disabledStroke;
    function updateAppearance( interactionState ) {
      switch( interactionState ) {
        case 'idle':
          button.fill = upFill;
          button.stroke = enabledStroke;
          break;
        case 'over':
          button.fill = overFill;
          button.stroke = enabledStroke;
          break;
        case 'pressed':
          button.fill = downFill;
          button.stroke = enabledStroke;
          break;
        case 'disabled':
          button.fill = disabledFill;
          button.stroke = disabledStroke;
          break;
        case 'disabled-pressed':
          button.fill = disabledPressedFillVertical;
          button.stroke = disabledStroke;
          break;
        default:
          throw new Error( 'upsupported interactionState: ' + interactionState );
      }
    }
    function updateFillsAndStrokes( baseColor ) {
      upFill = baseColor;
      overFill = baseColor.colorUtilsBrighter( 0.4 );
      downFill = baseColor.colorUtilsDarker( 0.4 );
      disabledFill = disabledBaseColor;
      disabledPressedFillVertical = disabledFill;
      if ( options.stroke === null ) {
        enabledStroke = null;
        disabledStroke = null;
      }
      else if ( typeof( options.stroke ) === 'undefined' ) {
        enabledStroke = baseColor.colorUtilsDarker( 0.4 );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      else {
        enabledStroke = Color.toColor( options.stroke );
        disabledStroke = disabledBaseColor.colorUtilsDarker( 0.4 );
      }
      button.cachedPaints = [
        upFill, overFill, downFill, disabledFill, disabledPressedFillVertical,
        enabledStroke, disabledStroke
      ];
      updateAppearance( interactionStateProperty.value );
    }
    baseColorProperty.link( updateFillsAndStrokes );
    interactionStateProperty.lazyLink( updateAppearance );
    this.dispose = function() {
      baseColorProperty.unlink( updateFillsAndStrokes );
      interactionStateProperty.unlink( updateAppearance );
    };
  };
  RectangularButtonView.FadeContentWhenDisabled = function( content, interactionStateProperty ) {
    function updateOpacity( state ) {
      if ( content ) {
        content.opacity = state === 'disabled' || state === 'disabled-pressed' ? 0.3 : 1;
      }
    }
    interactionStateProperty.link( updateOpacity );
    this.dispose = function() {
      interactionStateProperty.unlink( updateOpacity );
    };
  };
  return inherit( Node, RectangularButtonView, {
    setEnabled: function( value ) {
      assert && assert( typeof value === 'boolean', 'RectangularButtonView.enabled must be a boolean value' );
      this.buttonModel.enabledProperty.set( value );
    },
    set enabled( value ) { this.setEnabled( value ); },
    getEnabled: function() { return this.buttonModel.enabledProperty.get(); },
    get enabled() { return this.getEnabled(); },
    setBaseColor: function( baseColor ) { this.baseColorProperty.value = Color.toColor( baseColor ); },
    set baseColor( baseColor ) { this.setBaseColor( baseColor ); },
    getBaseColor: function() { return this.baseColorProperty.value; },
    get baseColor() { return this.getBaseColor(); },
    dispose: function() {
      this.disposeRectangularButtonView();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'SUN/buttons/RectangularPushButton',['require','PHET_CORE/inherit','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','SUN/buttons/RectangularButtonView','SUN/sun','TANDEM/Tandem','SUN/buttons/TPushButton'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var sun = require( 'SUN/sun' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TPushButton = require( 'SUN/buttons/TPushButton' );
  function RectangularPushButton( options ) {
    var self = this;
    options = _.extend( {
      tandem: Tandem.tandemRequired(), // {Tandem|null}
      phetioType: TPushButton,
      accessibleFire: function() {}
    }, options );
    var listener = options.listener;
    options = _.omit( options, [ 'listener' ] );
    this.buttonModel = new PushButtonModel( options ); // @public, listen only
    listener && this.addListener( listener );
    RectangularButtonView.call( this, this.buttonModel, new PushButtonInteractionStateProperty( this.buttonModel ), options );
    this.clickListener = this.addAccessibleInputListener( {
      click: function() {
        self.buttonModel.fire();
        options.accessibleFire();
      }
    } );
    this.disposeRectangularPushButton = function() {
      this.buttonModel.dispose(); //TODO this fails when assertions are enabled, see sun#212
      this.removeAccessibleInputListener( this.clickListener );
      options.tandem.removeInstance( this );
    };
  }
  sun.register( 'RectangularPushButton', RectangularPushButton );
  return inherit( RectangularButtonView, RectangularPushButton, {
      dispose: function() {
        this.disposeRectangularPushButton();
        RectangularButtonView.prototype.dispose.call( this );
      },
      addListener: function( listener ) {
        this.buttonModel.addListener( listener );
      },
      removeListener: function( listener ) {
        this.buttonModel.removeListener( listener );
      }
    }
  );
} );
define( 'SUN/buttons/ArrowButton',['require','PHET_CORE/inherit','SCENERY/nodes/Path','SUN/buttons/RectangularPushButton','KITE/Shape','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Path = require( 'SCENERY/nodes/Path' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var Shape = require( 'KITE/Shape' );
  var sun = require( 'SUN/sun' );
  var DEFAULT_ARROW_HEIGHT = 20;
  function ArrowButton( direction, callback, options ) {
    options = _.extend( {
      cursor: 'pointer',
      baseColor: 'white',
      stroke: 'black',
      lineWidth: 1,
      cornerRadius: 4,
      xMargin: 7,
      yMargin: 5,
      touchAreaXDilation: 7,
      touchAreaYDilation: 7,
      arrowHeight: DEFAULT_ARROW_HEIGHT, // from tip to base
      arrowWidth: DEFAULT_ARROW_HEIGHT * Math.sqrt( 3 ) / 2, // width of base
      arrowFill: 'black',
      arrowStroke: null,
      arrowLineWidth: 1,
      numberOfArrows: 1, // each arrow will have the same shape and styling
      arrowSpacing: -DEFAULT_ARROW_HEIGHT * ( 1 / 2 ), // spacing for each arrow such that they overlap slightly
      fireOnHold: true,
      fireOnHoldDelay: 400, // start to fire continuously after pressing for this long (milliseconds)
      fireOnHoldInterval: 100, // fire continuously at this interval (milliseconds)
      startCallback: function() {}, // called when the pointer is pressed
      endCallback: function( over ) {} // called when the pointer is released, {boolean} over indicates whether the pointer was over when released
    }, options );
    options.listener = callback;
    var arrowShape = new Shape();
    for ( var i = 0; i < options.numberOfArrows; i++ ) {
      var arrowOffset = i * ( options.arrowHeight + options.arrowSpacing );
      if ( direction === 'up' ) {
        arrowShape.moveTo( options.arrowHeight / 2, arrowOffset ).lineTo( options.arrowHeight, options.arrowWidth + arrowOffset ).lineTo( 0, options.arrowWidth + arrowOffset ).close();
      }
      else if ( direction === 'down' ) {
        arrowShape.moveTo( 0, arrowOffset ).lineTo( options.arrowHeight, arrowOffset ).lineTo( options.arrowHeight / 2, options.arrowWidth + arrowOffset ).close();
      }
      else if ( direction === 'left' ) {
        arrowShape.moveTo( arrowOffset, options.arrowHeight / 2 ).lineTo( options.arrowWidth + arrowOffset, 0 ).lineTo( options.arrowWidth + arrowOffset, options.arrowHeight ).close();
      }
      else if ( direction === 'right' ) {
        arrowShape.moveTo( arrowOffset, 0 ).lineTo( options.arrowWidth + arrowOffset, options.arrowHeight / 2 ).lineTo( arrowOffset, options.arrowHeight ).close();
      }
      else {
        throw new Error( 'unsupported direction: ' + direction );
      }
    }
    options.content = new Path( arrowShape, {
      fill: options.arrowFill,
      stroke: options.arrowStroke,
      lineWidth: options.arrowLineWidth,
      pickable: false
    } );
    RectangularPushButton.call( this, options );
  }
  sun.register( 'ArrowButton', ArrowButton );
  return inherit( RectangularPushButton, ArrowButton );
} );
define( 'BUILD_AN_ATOM/game/view/NumberEntryNode',['require','SUN/buttons/ArrowButton','BUILD_AN_ATOM/common/BAASharedConstants','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','KITE/Shape','SCENERY/nodes/Text'],function( require ) {
  'use strict';
  var ArrowButton = require( 'SUN/buttons/ArrowButton' );
  var BAASharedConstants = require( 'BUILD_AN_ATOM/common/BAASharedConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Shape = require( 'KITE/Shape' );
  var Text = require( 'SCENERY/nodes/Text' );
  var NUMBER_BOX_SIZE = { width: 55, height: 48 }; // Size empirically determined.
  var NUMBER_FONT = new PhetFont( 28 );
  function NumberEntryNode( numberProperty, tandem, options ) {
    Node.call( this ); // Call super constructor.
    var self = this;
    options = _.extend( {
      showPlusForPositive: false,
      signAfterValue: true,
      getTextColor: function() { return 'black'; },
      minValue: Number.NEGATIVE_INFINITY,
      maxValue: Number.POSITIVE_INFINITY
    }, options );
    var arrowButtonOptions = { arrowHeight: 12, arrowWidth: 15, fireOnHoldDelay: 200 };
    var upArrowButton = new ArrowButton( 'up', function() {
      numberProperty.value = numberProperty.value + 1;
    }, _.extend( {
      tandem: tandem.createTandem( 'upArrowButton' )
    }, arrowButtonOptions ) );
    self.addChild( upArrowButton );
    var downArrowButton = new ArrowButton( 'down', function() {
      numberProperty.value = numberProperty.value - 1;
    }, _.extend( {
      tandem: tandem.createTandem( 'downArrowButton' )
    }, arrowButtonOptions ) );
    self.addChild( downArrowButton );
    var answerValueBackground = new Rectangle( 0, 0, NUMBER_BOX_SIZE.width, NUMBER_BOX_SIZE.height, 4, 4, {
      fill: 'white',
      stroke: 'black',
      lineWidth: 1
    } );
    self.addChild( answerValueBackground );
    numberProperty.link( function( newValue ) {
      answerValueBackground.removeAllChildren();
      var minusSign = options.signAfterValue ? BAASharedConstants.MINUS_SIGN : '-';
      var sign = newValue < 0 ? minusSign :
                 newValue > 0 && options.showPlusForPositive ? '+' :
                 '';
      var absoluteValueString = Math.abs( newValue ).toString();
      var valueText = options.signAfterValue ? absoluteValueString + sign : sign + absoluteValueString;
      var textNode = new Text( valueText, {
        font: NUMBER_FONT,
        fill: options.getTextColor( newValue )
      } );
      textNode.scale( Math.min( 1, Math.min( ( answerValueBackground.width * 0.8 ) / textNode.width, ( answerValueBackground.height * 0.9 ) / textNode.height ) ) );
      textNode.centerX = answerValueBackground.width / 2;
      textNode.centerY = answerValueBackground.height / 2;
      answerValueBackground.addChild( textNode );
      upArrowButton.enabled = ( newValue < options.maxValue );
      downArrowButton.enabled = ( newValue > options.minValue );
    } );
    var interNodeSpacing = upArrowButton.height * 0.2;
    var totalHeight = Math.max( answerValueBackground.height, upArrowButton.height + downArrowButton.height + interNodeSpacing );
    answerValueBackground.left = 0;
    answerValueBackground.centerY = totalHeight / 2;
    upArrowButton.left = answerValueBackground.right + interNodeSpacing;
    upArrowButton.bottom = totalHeight / 2 - interNodeSpacing / 2;
    downArrowButton.top = totalHeight / 2 + interNodeSpacing / 2;
    downArrowButton.left = answerValueBackground.right + interNodeSpacing;
    var touchAreaXDilation = upArrowButton.width * 2.5;
    var touchAreaYDilation = upArrowButton.height * 1.45; // Tweaked for minimal overlap in most layouts that use this.
    upArrowButton.touchArea = Shape.rectangle(
      -touchAreaXDilation / 2 + upArrowButton.width / 2,
      -touchAreaYDilation + upArrowButton.height,
      touchAreaXDilation,
      touchAreaYDilation
    );
    downArrowButton.touchArea = Shape.rectangle(
      -touchAreaXDilation / 2 + upArrowButton.width / 2,
      0,
      touchAreaXDilation,
      touchAreaYDilation
    );
    self.mutate( options );
  }
  buildAnAtom.register( 'NumberEntryNode', NumberEntryNode );
  return inherit( Node, NumberEntryNode );
} );
define("string!BUILD_AN_ATOM/protonsColonPattern",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/protonsColonPattern");});
define("string!BUILD_AN_ATOM/neutronsColonPattern",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/neutronsColonPattern");});
define("string!BUILD_AN_ATOM/electronsColonPattern",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/electronsColonPattern");});
define( 'BUILD_AN_ATOM/game/view/ParticleCountsNode',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','SCENERY/nodes/Node','SCENERY/nodes/Text','PHET_CORE/inherit','PHETCOMMON/util/StringUtils','string!BUILD_AN_ATOM/protonsColonPattern','string!BUILD_AN_ATOM/neutronsColonPattern','string!BUILD_AN_ATOM/electronsColonPattern'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var protonsColonPatternString = require( 'string!BUILD_AN_ATOM/protonsColonPattern' );
  var neutronsColonPatternString = require( 'string!BUILD_AN_ATOM/neutronsColonPattern' );
  var electronsColonPatternString = require( 'string!BUILD_AN_ATOM/electronsColonPattern' );
  var MAX_WIDTH = 280;
  function ParticleCountsNode( numberAtom, options ) {
    Node.call( this, options ); // Call super constructor.
    options = _.extend( { font: new PhetFont( 24 ) }, options );
    var protonCountTitle = new Text( StringUtils.format( protonsColonPatternString, numberAtom.protonCountProperty.get() ), {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( protonCountTitle );
    var neutronCountTitle = new Text( StringUtils.format( neutronsColonPatternString, numberAtom.neutronCountProperty.get() ), {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( neutronCountTitle );
    var electronCountTitle = new Text( StringUtils.format( electronsColonPatternString, numberAtom.electronCountProperty.get() ), {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( electronCountTitle );
    var interLineSpacing = protonCountTitle.height * 0.9; // Multiplier empirically determined.
    protonCountTitle.left = 0;
    protonCountTitle.top = 0;
    neutronCountTitle.left = 0;
    neutronCountTitle.top = protonCountTitle.bottom + interLineSpacing;
    electronCountTitle.left = 0;
    electronCountTitle.top = neutronCountTitle.bottom + interLineSpacing;
  }
  buildAnAtom.register( 'ParticleCountsNode', ParticleCountsNode );
  return inherit( Node, ParticleCountsNode );
} );
define( 'SCENERY_PHET/FaceNode',['require','PHET_CORE/inherit','SCENERY/nodes/Circle','SCENERY/util/Color','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  function FaceNode( headDiameter, options ) {
    options = _.extend( {
      headFill: 'yellow',
      eyeFill: 'black',
      mouthStroke: 'black',
      headLineWidth: 1
    }, options );
    options.headStroke = options.headStroke || Color.toColor( options.headFill ).darkerColor();
    Node.call( this );
    this.addChild( new Circle( headDiameter / 2, {
      fill: options.headFill,
      stroke: options.headStroke,
      lineWidth: options.headLineWidth
    } ) );
    var eyeDiameter = headDiameter * 0.075;
    this.addChild( new Circle( eyeDiameter, {
      fill: options.eyeFill,
      centerX: -headDiameter * 0.2,
      centerY: -headDiameter * 0.1
    } ) );
    this.addChild( new Circle( eyeDiameter, {
      fill: options.eyeFill,
      centerX: headDiameter * 0.2,
      centerY: -headDiameter * 0.1
    } ) );
    var mouthLineWidth = headDiameter * 0.05;
    this.smileMouth = new Path( new Shape().arc( 0, headDiameter * 0.05, headDiameter * 0.25, Math.PI * 0.2, Math.PI * 0.8 ), {
      stroke: options.mouthStroke,
      lineWidth: mouthLineWidth,
      lineCap: 'round'
    } );
    this.addChild( this.smileMouth );
    this.frownMouth = new Path( new Shape().arc( 0, headDiameter * 0.4, headDiameter * 0.20, -Math.PI * 0.75, -Math.PI * 0.25 ), {
      stroke: options.mouthStroke,
      lineWidth: mouthLineWidth,
      lineCap: 'round'
    } );
    this.addChild( this.frownMouth );
    this.smile();
    this.mutate( options );
  }
  sceneryPhet.register( 'FaceNode', FaceNode );
  return inherit( Node, FaceNode, {
    smile: function() {
      this.smileMouth.visible = true;
      this.frownMouth.visible = false;
      return this; // allow chaining
    },
    frown: function() {
      this.smileMouth.visible = false;
      this.frownMouth.visible = true;
      return this; // allow chaining
    }
  } );
} );
define( 'SCENERY/display/Block',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  function Block( display, renderer ) {
    throw new Error( 'Should never be called' );
  }
  scenery.register( 'Block', Block );
  inherit( Drawable, Block, {
    initializeBlock: function( display, renderer ) {
      this.initializeDrawable( renderer );
      this.display = display;
      this.drawableCount = 0;
      this.used = true; // flag handled in the stitch
      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;
      this.previousBlock = null;
      this.nextBlock = null;
      this.zIndex = 0;
      if ( assertSlow ) {
        this.drawableList = cleanArray( this.drawableList );
      }
      return this;
    },
    dispose: function() {
      assert && assert( this.drawableCount === 0, 'There should be no drawables on a block when it is disposed' );
      this.display = null;
      this.firstDrawable = null;
      this.lastDrawable = null;
      this.pendingFirstDrawable = null;
      this.pendingLastDrawable = null;
      this.previousBlock = null;
      this.nextBlock = null;
      if ( assertSlow ) {
        cleanArray( this.drawableList );
      }
      Drawable.prototype.dispose.call( this );
    },
    addDrawable: function( drawable ) {
      this.drawableCount++;
      this.markDirtyDrawable( drawable );
      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx === -1, 'Drawable should not be added when it has not been removed' );
        this.drawableList.push( drawable );
        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },
    removeDrawable: function( drawable ) {
      this.drawableCount--;
      this.markDirty();
      if ( assertSlow ) {
        var idx = _.indexOf( this.drawableList, drawable );
        assertSlow && assertSlow( idx !== -1, 'Drawable should be already added when it is removed' );
        this.drawableList.splice( idx, 1 );
        assertSlow && assertSlow( this.drawableCount === this.drawableList.length, 'Count sanity check, to make sure our assertions are not buggy' );
      }
    },
    onIntervalChange: function( firstDrawable, lastDrawable ) {
    },
    updateInterval: function() {
      if ( this.pendingFirstDrawable !== this.firstDrawable ||
           this.pendingLastDrawable !== this.lastDrawable ) {
        this.onIntervalChange( this.pendingFirstDrawable, this.pendingLastDrawable );
        this.firstDrawable = this.pendingFirstDrawable;
        this.lastDrawable = this.pendingLastDrawable;
      }
    },
    notifyInterval: function( firstDrawable, lastDrawable ) {
      this.pendingFirstDrawable = firstDrawable;
      this.pendingLastDrawable = lastDrawable;
      this.updateInterval();
    },
    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );
        var count = 0;
        if ( !allowPendingList ) {
          for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
            drawable.audit( allowPendingBlock, allowPendingList, allowDirty );
            count++;
            if ( drawable === this.lastDrawable ) { break; }
          }
          if ( !allowPendingBlock ) {
            assertSlow && assertSlow( count === this.drawableCount, 'drawableCount should match' );
            assertSlow && assertSlow( this.firstDrawable === this.pendingFirstDrawable, 'No pending first drawable' );
            assertSlow && assertSlow( this.lastDrawable === this.pendingLastDrawable, 'No pending last drawable' );
            for ( var d = this.firstDrawable; d !== null; d = d.nextDrawable ) {
              assertSlow && assertSlow( d.renderer === this.renderer, 'Renderers should match' );
              assertSlow && assertSlow( d.parentDrawable === this, 'This block should be this drawable\'s parent' );
              assertSlow && assertSlow( _.indexOf( this.drawableList, d ) >= 0 );
              if ( d === this.lastDrawable ) { break; }
            }
          }
        }
      }
    }
  } );
  return Block;
} );
define( 'SCENERY/display/FittedBlock',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Vector2 = require( 'DOT/Vector2' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );
  var scratchBounds2 = Bounds2.NOTHING.copy();
  function FittedBlock( display, renderer, transformRootInstance ) {
    this.initialize( display, renderer, transformRootInstance );
  }
  scenery.register( 'FittedBlock', FittedBlock );
  inherit( Block, FittedBlock, {
    initializeFittedBlock: function( display, renderer, transformRootInstance, preferredFit ) {
      this.initializeBlock( display, renderer );
      this.transformRootInstance = transformRootInstance;
      assert && assert( typeof transformRootInstance.isDisplayRoot === 'boolean' );
      this.canBeFullDisplay = transformRootInstance.isDisplayRoot;
      assert && assert( preferredFit === FittedBlock.FULL_DISPLAY || preferredFit === FittedBlock.COMMON_ANCESTOR );
      this.preferredFit = preferredFit;
      this.fit = preferredFit;
      this.dirtyFit = true;
      this.dirtyFitListener = this.dirtyFitListener || this.markDirtyFit.bind( this );
      this.commonFitInstance = null; // filled in if COMMON_ANCESTOR
      this.fitBounds = Bounds2.NOTHING.copy(); // tracks the "tight" bounds for fitting, not the actually-displayed bounds
      this.oldFitBounds = Bounds2.NOTHING.copy(); // copy for storage
      this.fitOffset = new Vector2();
      this.unfittableDrawableCount = 0;
      this.fittableListener = this.onFittabilityChange.bind( this );
      this.forceAcceleration = false;
      this.display.onStatic( 'displaySize', this.dirtyFitListener );
      return this;
    },
    setFit: function( fit ) {
      if ( !this.canBeFullDisplay && fit === FittedBlock.FULL_DISPLAY ) {
        fit = FittedBlock.COMMON_ANCESTOR;
      }
      if ( this.fit !== fit ) {
        this.fit = fit;
        this.markDirtyFit();
        this.oldFitBounds.set( Bounds2.NOTHING );
        if ( fit === FittedBlock.COMMON_ANCESTOR ) {
          this.removeCommonFitInstance();
        }
      }
    },
    markDirtyFit: function() {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyFit on FittedBlock#' + this.id );
      this.dirtyFit = true;
      this.markDirty();
    },
    updateFit: function() {
      assert && assert( this.fit === FittedBlock.FULL_DISPLAY || this.fit === FittedBlock.COMMON_ANCESTOR,
        'Unsupported fit' );
      if ( !this.dirtyFit && this.fit === FittedBlock.FULL_DISPLAY ) {
        return;
      }
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'updateFit #' + this.id );
      this.dirtyFit = false;
      if ( this.fit === FittedBlock.COMMON_ANCESTOR && this.commonFitInstance === null ) {
        this.addCommonFitInstance( this.computeCommonAncestorInstance() );
      }
      if ( this.fit === FittedBlock.COMMON_ANCESTOR &&
           this.commonFitInstance.fittability.subtreeUnfittableCount > 0 &&
           this.canBeFullDisplay ) {
        this.oldFitBounds.set( Bounds2.NOTHING );
        this.fit = FittedBlock.FULL_DISPLAY;
      }
      if ( this.fit === FittedBlock.FULL_DISPLAY ) {
        this.setSizeFullDisplay();
      }
      else if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        assert && assert( this.commonFitInstance.trail.length >= this.transformRootInstance.trail.length );
        this.fitBounds.set( this.commonFitInstance.node.getLocalBounds() );
        var instance = this.commonFitInstance;
        while ( instance !== this.transformRootInstance ) {
          this.fitBounds.transform( instance.node.getMatrix() );
          instance = instance.parent;
        }
        this.fitBounds.roundOut();
        this.fitBounds.dilate( 4 ); // for safety, modify in the future
        if ( this.transformRootInstance.isDisplayRoot ) {
          scratchBounds2.setMinMax( 0, 0, this.display.width, this.display.height );
          this.fitBounds.constrainBounds( scratchBounds2 );
        }
        if ( !this.fitBounds.isValid() ) {
          this.fitBounds.setMinMax( 0, 0, 0, 0 );
        }
        if ( !this.fitBounds.equals( this.oldFitBounds ) ) {
          this.oldFitBounds.set( this.fitBounds );
          this.setSizeFitBounds();
        }
      }
      else {
        throw new Error( 'unknown fit' );
      }
    },
    setSizeFullDisplay: function() {
    },
    setSizeFitBounds: function() {
    },
    addCommonFitInstance: function( instance ) {
      assert && assert( this.commonFitInstance === null );
      if ( instance ) {
        this.commonFitInstance = instance;
        this.commonFitInstance.fittability.subtreeFittabilityChange.addListener( this.dirtyFitListener );
      }
    },
    removeCommonFitInstance: function() {
      if ( this.commonFitInstance ) {
        this.commonFitInstance.fittability.subtreeFittabilityChange.removeListener( this.dirtyFitListener );
        this.commonFitInstance = null;
      }
    },
    dispose: function() {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( 'dispose #' + this.id );
      this.display.offStatic( 'displaySize', this.dirtyFitListener );
      this.removeCommonFitInstance();
      this.transformRootInstance = null;
      Block.prototype.dispose.call( this );
    },
    addDrawable: function( drawable ) {
      Block.prototype.addDrawable.call( this, drawable );
      drawable.onStatic( 'fittability', this.fittableListener );
      if ( !drawable.fittable ) {
        this.incrementUnfittable();
      }
    },
    removeDrawable: function( drawable ) {
      Block.prototype.removeDrawable.call( this, drawable );
      drawable.offStatic( 'fittability', this.fittableListener );
      if ( !drawable.fittable ) {
        this.decrementUnfittable();
      }
    },
    onFittabilityChange: function( drawable ) {
      assert && assert( drawable.parentDrawable === this );
      if ( drawable.isFittable() ) {
        this.decrementUnfittable();
      }
      else {
        this.incrementUnfittable();
      }
    },
    incrementUnfittable: function() {
      this.unfittableDrawableCount++;
      if ( this.unfittableDrawableCount === 1 ) {
        this.checkFitConstraints();
      }
    },
    decrementUnfittable: function() {
      this.unfittableDrawableCount--;
      if ( this.unfittableDrawableCount === 0 ) {
        this.checkFitConstraints();
      }
    },
    checkFitConstraints: function() {
      if ( this.unfittableDrawableCount > 0 && this.canBeFullDisplay ) {
        this.setFit( FittedBlock.FULL_DISPLAY );
      }
      else {
        this.setFit( this.preferredFit );
      }
    },
    computeCommonAncestorInstance: function() {
      assert && assert( this.firstDrawable.instance && this.lastDrawable.instance,
        'For common-ancestor fits, we need the first and last drawables to have direct instance references' );
      var firstInstance = this.firstDrawable.instance;
      var lastInstance = this.lastDrawable.instance;
      var minLength = Math.min( firstInstance.trail.length, lastInstance.trail.length );
      while ( firstInstance.trail.length > minLength ) {
        firstInstance = firstInstance.parent;
      }
      while ( lastInstance.trail.length > minLength ) {
        lastInstance = lastInstance.parent;
      }
      while ( firstInstance !== lastInstance ) {
        firstInstance = firstInstance.parent;
        lastInstance = lastInstance.parent;
      }
      var commonFitInstance = firstInstance;
      assert && assert( commonFitInstance.trail.length >= this.transformRootInstance.trail.length );
      return commonFitInstance;
    },
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.FittedBlock && sceneryLog.FittedBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      Block.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
      if ( this.fit === FittedBlock.COMMON_ANCESTOR ) {
        this.removeCommonFitInstance();
        this.markDirtyFit();
      }
    }
  } );
  FittedBlock.FULL_DISPLAY = 1;
  FittedBlock.COMMON_ANCESTOR = 2;
  FittedBlock.fitString = {
    1: 'fullDisplay',
    2: 'commonAncestor'
  };
  return FittedBlock;
} );
define( 'SCENERY/display/CanvasBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','DOT/Vector2','DOT/Matrix3','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/util/CanvasContextWrapper','SCENERY/display/Renderer','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Util = require( 'SCENERY/util/Util' );
  var scratchMatrix = new Matrix3();
  var scratchMatrix2 = new Matrix3();
  function CanvasBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }
  scenery.register( 'CanvasBlock', CanvasBlock );
  inherit( FittedBlock, CanvasBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );
      this.filterRootInstance = filterRootInstance;
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );
      if ( !this.domElement ) {
        this.canvas = document.createElement( 'canvas' );
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        this.canvas.style.pointerEvents = 'none';
        this.canvasId = this.canvas.id = 'scenery-canvas' + this.id;
        this.context = this.canvas.getContext( '2d' );
        this.context.save(); // We always immediately save every Canvas so we can restore/save for clipping
        this.context.miterLimit = 20;
        this.context.miterLimit = 10;
        this.wrapper = new CanvasContextWrapper( this.canvas, this.context );
        this.domElement = this.canvas;
        this.wrapperStack = [ this.wrapper ];
      }
      this.wrapperStackIndex = 0;
      this.opacityListenerCountMap = this.opacityListenerCountMap || {};
      Util.prepareForTransform( this.canvas, this.forceAcceleration ); // Apply CSS needed for future CSS transforms to work properly.
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied
      this.canvasDrawOffset = new Vector2();
      this.currentDrawable = null;
      this.clipDirty = true; // Whether we need to re-apply clipping to our current Canvas
      this.clipCount = 0; // How many clips should be applied
      this.backingScale = ( renderer & Renderer.bitmaskCanvasLowResolution ) ? 1 : scenery.Util.backingScale( this.context );
      this.clipDirtyListener = this.markDirty.bind( this );
      this.opacityDirtyListener = this.markDirty.bind( this );
      this.filterRootNode = this.filterRootInstance.node;
      this.filterRootNode.onStatic( 'clip', this.clipDirtyListener );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'initialized #' + this.id );
      return this;
    },
    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = size.width * this.backingScale;
      this.canvas.height = size.height * this.backingScale;
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
      this.wrapper.resetStyles();
      this.canvasDrawOffset.setXY( 0, 0 );
      Util.unsetTransform( this.canvas );
    },
    setSizeFitBounds: function() {
      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;
      this.canvasDrawOffset.setXY( -x, -y ); // subtract off so we have a tight fit
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.canvas, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.canvas.width = this.fitBounds.width * this.backingScale;
      this.canvas.height = this.fitBounds.height * this.backingScale;
      this.canvas.style.width = this.fitBounds.width + 'px';
      this.canvas.style.height = this.fitBounds.height + 'px';
      this.wrapper.resetStyles();
    },
    update: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;
        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }
        this.updateFit();
        this.context.restore(); // just in case we were clipping/etc.
        this.context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
        this.context.clearRect( 0, 0, this.canvas.width, this.canvas.height ); // clear everything
        this.context.save();
        this.wrapper.resetStyles();
        this.currentDrawable = null; // we haven't rendered a drawable this frame yet
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          this.renderDrawable( drawable );
          if ( drawable === this.lastDrawable ) { break; }
        }
        if ( this.currentDrawable ) {
          this.walkDown( this.currentDrawable.instance.trail, 0 );
        }
      }
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },
    applyClip: function( drawable ) {
      this.clipDirty = false;
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Apply clip ' + drawable.instance.trail.toString() + ' ' + drawable.instance.trail.subtrailTo( node ).toPathString() );
      var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
      var context = wrapper.context;
      context.restore();
      context.save();
      wrapper.resetStyles();
      if ( this.clipCount ) {
        var instance = drawable.instance;
        var trail = instance.trail;
        scratchMatrix.rowMajor( this.backingScale, 0, this.canvasDrawOffset.x * this.backingScale,
                                0, this.backingScale, this.canvasDrawOffset.y * this.backingScale,
                                0, 0, 1 );
        scratchMatrix2.set( this.transformRootInstance.trail.getMatrix() ).invert();
        scratchMatrix2.multiplyMatrix( scratchMatrix ).canvasSetTransform( context );
        for ( var i = 0; i < trail.length; i++ ) {
          var node = trail.nodes[ i ];
          node.getMatrix().canvasAppendTransform( context );
          if ( node.hasClipArea() ) {
            context.beginPath();
            node.clipArea.writeToContext( context );
            context.clip();
          }
        }
      }
    },
    walkDown: function( trail, branchIndex ) {
      var filterRootIndex = this.filterRootInstance.trail.length - 1;
      for ( var i = trail.length - 1; i >= branchIndex; i-- ) {
        var node = trail.nodes[ i ];
        if ( node.hasClipArea() ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Pop clip ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          this.clipCount--;
          this.clipDirty = true;
        }
        if ( i > filterRootIndex && node.getOpacity() !== 1 ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Pop opacity ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          var topWrapper = this.wrapperStack[ this.wrapperStackIndex ];
          var bottomWrapper = this.wrapperStack[ this.wrapperStackIndex - 1 ];
          this.wrapperStackIndex--;
          bottomWrapper.context.setTransform( 1, 0, 0, 1, 0, 0 );
          bottomWrapper.context.globalAlpha = node.getOpacity();
          bottomWrapper.context.drawImage( topWrapper.canvas, 0, 0 );
          bottomWrapper.context.globalAlpha = 1;
        }
      }
    },
    walkUp: function( trail, branchIndex ) {
      var filterRootIndex = this.filterRootInstance.trail.length - 1;
      for ( var i = branchIndex; i < trail.length; i++ ) {
        var node = trail.nodes[ i ];
        if ( i > filterRootIndex && node.getOpacity() !== 1 ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Push opacity ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          this.wrapperStackIndex++;
          if ( this.wrapperStackIndex === this.wrapperStack.length ) {
            var newCanvas = document.createElement( 'canvas' );
            var newContext = newCanvas.getContext( '2d' );
            newContext.save();
            this.wrapperStack.push( new CanvasContextWrapper( newCanvas, newContext ) );
          }
          var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
          var context = wrapper.context;
          wrapper.setDimensions( this.canvas.width, this.canvas.height );
          context.setTransform( 1, 0, 0, 1, 0, 0 ); // identity
          context.clearRect( 0, 0, this.canvas.width, this.canvas.height ); // clear everything
        }
        if ( node.hasClipArea() ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'Push clip ' + trail.subtrailTo( node ).toString() + ' ' + trail.subtrailTo( node ).toPathString() );
          this.clipCount++;
          this.clipDirty = true;
        }
      }
    },
    renderDrawable: function( drawable ) {
      if ( !drawable.visible ) {
        return;
      }
      var branchIndex = this.currentDrawable ? drawable.instance.getBranchIndexTo( this.currentDrawable.instance ) : 0;
      if ( this.currentDrawable ) {
        this.walkDown( this.currentDrawable.instance.trail, branchIndex );
      }
      this.walkUp( drawable.instance.trail, branchIndex );
      var wrapper = this.wrapperStack[ this.wrapperStackIndex ];
      var context = wrapper.context;
      if ( this.clipDirty ) {
        this.applyClip( drawable );
      }
      assert && assert( drawable.instance.relativeTransform.isValidationNotNeeded() );
      var matrix = drawable.instance.relativeTransform.matrix;
      context.setTransform( this.backingScale, 0, 0, this.backingScale, this.canvasDrawOffset.x * this.backingScale, this.canvasDrawOffset.y * this.backingScale );
      if ( drawable.instance !== this.transformRootInstance ) {
        matrix.canvasAppendTransform( context );
      }
      drawable.paintCanvas( wrapper, drawable.instance.node );
      this.currentDrawable = drawable;
    },
    dispose: function() {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'dispose #' + this.id );
      this.filterRootNode.offStatic( 'clip', this.clipDirtyListener );
      this.filterRootNode = null;
      this.transformRootInstance = null;
      cleanArray( this.dirtyDrawables );
      this.canvas.width = 0;
      this.canvas.height = 0;
      FittedBlock.prototype.dispose.call( this );
    },
    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on CanvasBlock#' + this.id + ' with ' + drawable.toString() );
      assert && assert( drawable );
      if ( assert ) {
        this.display.ensureNotPainting();
      }
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },
    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      FittedBlock.prototype.addDrawable.call( this, drawable );
      for ( var instance = drawable.instance; instance && instance !== this.filterRootInstance; instance = instance.parent ) {
        var node = instance.node;
        if ( this.opacityListenerCountMap[ node.id ] ) {
          this.opacityListenerCountMap[ node.id ]++;
        }
        else {
          this.opacityListenerCountMap[ node.id ] = 1;
          node.onStatic( 'opacity', this.opacityDirtyListener );
        }
      }
    },
    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      for ( var instance = drawable.instance; instance && instance !== this.filterRootInstance; instance = instance.parent ) {
        var node = instance.node;
        assert && assert( this.opacityListenerCountMap[ node.id ] > 0 );
        this.opacityListenerCountMap[ node.id ]--;
        if ( this.opacityListenerCountMap[ node.id ] === 0 ) {
          delete this.opacityListenerCountMap[ node.id ];
          node.offStatic( 'opacity', this.opacityDirtyListener );
        }
      }
      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
      this.markDirty();
    },
    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.push();
      assert && assert( drawable.parentDrawable === this );
      drawable.markDirty();
      sceneryLog && sceneryLog.CanvasBlock && sceneryLog.pop();
    },
    toString: function() {
      return 'CanvasBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );
  Poolable.mixin( CanvasBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.CanvasBlock && sceneryLog.CanvasBlock( 'new from constructor' );
          return new CanvasBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );
  return CanvasBlock;
} );
define( 'SCENERY/display/SVGGroup',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','PHET_CORE/platform','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var platform = require( 'PHET_CORE/platform' );
  var scenery = require( 'SCENERY/scenery' );
  function SVGGroup( block, instance, parent ) {
    this.initialize( block, instance, parent );
  }
  scenery.register( 'SVGGroup', SVGGroup );
  inherit( Object, SVGGroup, {
    initialize: function( block, instance, parent ) {
      this.block = block;
      this.instance = instance;
      this.node = instance.trail.lastNode();
      this.parent = parent;
      this.children = cleanArray( this.children );
      this.hasSelfDrawable = false;
      this.selfDrawable = null; // reference to a self drawable
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'initializing ' + this.toString() );
      this.dirty = true;
      this.willApplyTransforms = this.block.transformRootInstance.trail.nodes.length < this.instance.trail.nodes.length;
      this.willApplyFilters = this.block.filterRootInstance.trail.nodes.length < this.instance.trail.nodes.length;
      this.transformDirty = true;
      this.hasTransform = this.hasTransform !== undefined ? this.hasTransform : false; // persists across disposal
      this.transformDirtyListener = this.transformDirtyListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransforms ) {
        this.node.onStatic( 'transform', this.transformDirtyListener );
      }
      this.opacityDirty = true;
      this.visibilityDirty = true;
      this.clipDirty = true;
      this.hasOpacity = this.hasOpacity !== undefined ? this.hasOpacity : false; // persists across disposal
      this.clipDefinition = this.clipDefinition !== undefined ? this.clipDefinition : null; // persists across disposal
      this.clipPath = this.clipPath !== undefined ? this.clipPath : null; // persists across disposal
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.visibilityDirtyListener = this.visibilityDirtyListener || this.markVisibilityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      this.node.onStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.onStatic( 'opacity', this.opacityDirtyListener );
      }
      this.node.onStatic( 'clip', this.clipDirtyListener );
      this.orderDirty = true;
      this.orderDirtyListener = this.orderDirtyListener || this.markOrderDirty.bind( this );
      this.node.onStatic( 'childInserted', this.orderDirtyListener );
      this.node.onStatic( 'childRemoved', this.orderDirtyListener );
      if ( !this.svgGroup ) {
        this.svgGroup = document.createElementNS( scenery.svgns, 'g' );
      }
      this.instance.addSVGGroup( this );
      this.block.markDirtyGroup( this ); // so we are marked and updated properly
      return this;
    },
    addSelfDrawable: function( drawable ) {
      this.selfDrawable = drawable;
      this.svgGroup.insertBefore( drawable.svgElement, this.children.length ? this.children[ 0 ].svgGroup : null );
      this.hasSelfDrawable = true;
    },
    removeSelfDrawable: function( drawable ) {
      this.hasSelfDrawable = false;
      this.svgGroup.removeChild( drawable.svgElement );
      this.selfDrawable = null;
    },
    addChildGroup: function( group ) {
      this.markOrderDirty();
      group.parent = this;
      this.children.push( group );
      this.svgGroup.appendChild( group.svgGroup );
    },
    removeChildGroup: function( group ) {
      this.markOrderDirty();
      group.parent = null;
      this.children.splice( _.indexOf( this.children, group ), 1 );
      this.svgGroup.removeChild( group.svgGroup );
    },
    markDirty: function() {
      if ( !this.dirty ) {
        this.dirty = true;
        this.block.markDirtyGroup( this );
      }
    },
    markOrderDirty: function() {
      if ( !this.orderDirty ) {
        this.orderDirty = true;
        this.markDirty();
      }
    },
    markTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.transformDirty = true;
        this.markDirty();
      }
    },
    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },
    markVisibilityDirty: function() {
      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },
    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },
    update: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'update: ' + this.toString() );
      if ( !this.block ) {
        return;
      }
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();
      var svgGroup = this.svgGroup;
      this.dirty = false;
      if ( this.transformDirty ) {
        this.transformDirty = false;
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'transform update: ' + this.toString() );
        if ( this.willApplyTransforms ) {
          var isIdentity = this.node.transform.isIdentity();
          if ( !isIdentity ) {
            this.hasTransform = true;
            svgGroup.setAttribute( 'transform', this.node.transform.getMatrix().getSVGTransform() );
          }
          else if ( this.hasTransform ) {
            this.hasTransform = false;
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
        else {
          if ( this.hasTransform ) {
            this.hasTransform = false;
            ( platform.ie9 || platform.ie10 ) ? svgGroup.setAttribute( 'transform', '' ) : svgGroup.removeAttribute( 'transform' );
          }
        }
      }
      if ( this.visibilityDirty ) {
        this.visibilityDirty = false;
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'visibility update: ' + this.toString() );
        svgGroup.style.display = this.node.isVisible() ? '' : 'none';
      }
      if ( this.opacityDirty ) {
        this.opacityDirty = false;
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'opacity update: ' + this.toString() );
        if ( this.willApplyFilters && this.node.opacity !== 1 ) {
          this.hasOpacity = true;
          svgGroup.setAttribute( 'opacity', this.node.opacity );
        }
        else if ( this.hasOpacity ) {
          this.hasOpacity = false;
          svgGroup.removeAttribute( 'opacity' );
        }
      }
      if ( this.clipDirty ) {
        this.clipDirty = false;
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'clip update: ' + this.toString() );
        if ( this.node.clipArea ) {
          if ( !this.clipDefinition ) {
            var clipId = 'clip' + this.node.getId();
            this.clipDefinition = document.createElementNS( scenery.svgns, 'clipPath' );
            this.clipDefinition.setAttribute( 'id', clipId );
            this.clipDefinition.setAttribute( 'clipPathUnits', 'userSpaceOnUse' );
            this.block.defs.appendChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)
            this.clipPath = document.createElementNS( scenery.svgns, 'path' );
            this.clipDefinition.appendChild( this.clipPath );
            svgGroup.setAttribute( 'clip-path', 'url(#' + clipId + ')' );
          }
          this.clipPath.setAttribute( 'd', this.node.clipArea.getSVGPath() );
        }
        else if ( this.clipDefinition ) {
          svgGroup.removeAttribute( 'clip-path' );
          this.block.defs.removeChild( this.clipDefinition ); // TODO: method? evaluate with future usage of defs (not done yet)
          this.clipDefinition = null;
          this.clipPath = null;
        }
      }
      if ( this.orderDirty ) {
        this.orderDirty = false;
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'order update: ' + this.toString() );
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();
        var idx = this.children.length - 1;
        var instanceChildren = this.instance.children;
        for ( var i = instanceChildren.length - 1; i >= 0; i-- ) {
          var group = instanceChildren[ i ].lookupSVGGroup( this.block );
          if ( group ) {
            if ( this.children[ idx ] !== group ) {
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group out of order: ' + idx + ' for ' + group.toString() );
              svgGroup.insertBefore( group.svgGroup, idx + 1 >= this.children.length ? null : this.children[ idx + 1 ].svgGroup );
              var oldIndex = _.indexOf( this.children, group );
              assert && assert( oldIndex < idx, 'The item we are moving backwards to location [idx] should not have an index greater than that' );
              this.children.splice( oldIndex, 1 );
              this.children.splice( idx, 0, group );
            }
            else {
              sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'group in place: ' + idx + ' for ' + group.toString() );
            }
            idx--;
          }
        }
        sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
      }
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },
    isReleasable: function() {
      return !this.hasSelfDrawable && !this.children.length && this.parent;
    },
    dispose: function() {
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.push();
      assert && assert( this.children.length === 0, 'Should be empty by now' );
      if ( this.willApplyTransforms ) {
        this.node.offStatic( 'transform', this.transformDirtyListener );
      }
      this.node.offStatic( 'visibility', this.visibilityDirtyListener );
      if ( this.willApplyFilters ) {
        this.node.offStatic( 'opacity', this.opacityDirtyListener );
      }
      this.node.offStatic( 'clip', this.clipDirtyListener );
      this.node.offStatic( 'childInserted', this.orderDirtyListener );
      this.node.offStatic( 'childRemoved', this.orderDirtyListener );
      if ( this.instance.active ) {
        this.instance.removeSVGGroup( this );
      }
      if ( this.clipDefinition ) {
        this.svgGroup.removeAttribute( 'clip-path' );
        this.block.defs.removeChild( this.clipDefinition );
        this.clipDefinition = null;
        this.clipPath = null;
      }
      this.parent = null;
      this.block = null;
      this.instance = null;
      this.node = null;
      cleanArray( this.children );
      this.selfDrawable = null;
      this.freeToPool();
      sceneryLog && sceneryLog.SVGGroup && sceneryLog.pop();
    },
    toString: function() {
      return 'SVGGroup:' + this.block.toString() + '_' + this.instance.toString();
    }
  } );
  SVGGroup.addDrawable = function( block, drawable ) {
    assert && assert( drawable.instance, 'Instance is required for a drawable to be grouped correctly in SVG' );
    var group = SVGGroup.ensureGroupsToInstance( block, drawable.instance );
    group.addSelfDrawable( drawable );
  };
  SVGGroup.removeDrawable = function( block, drawable ) {
    drawable.instance.lookupSVGGroup( block ).removeSelfDrawable( drawable );
    SVGGroup.releaseGroupsToInstance( block, drawable.instance );
  };
  SVGGroup.ensureGroupsToInstance = function( block, instance ) {
    var group = instance.lookupSVGGroup( block );
    if ( !group ) {
      assert && assert( instance !== block.rootGroup.instance, 'Making sure we do not walk past our rootGroup' );
      var parentGroup = SVGGroup.ensureGroupsToInstance( block, instance.parent );
      group = SVGGroup.createFromPool( block, instance, parentGroup );
      parentGroup.addChildGroup( group );
    }
    return group;
  };
  SVGGroup.releaseGroupsToInstance = function( block, instance ) {
    var group = instance.lookupSVGGroup( block );
    if ( group.isReleasable() ) {
      var parentGroup = group.parent;
      parentGroup.removeChildGroup( group );
      SVGGroup.releaseGroupsToInstance( block, parentGroup.instance );
      group.dispose();
    }
  };
  Poolable.mixin( SVGGroup, {
    constructorDuplicateFactory: function( pool ) {
      return function( block, instance, parent ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from pool' );
          return pool.pop().initialize( block, instance, parent );
        }
        else {
          sceneryLog && sceneryLog.SVGGroup && sceneryLog.SVGGroup( 'new from constructor' );
          return new SVGGroup( block, instance, parent );
        }
      };
    }
  } );
  return SVGGroup;
} );
define( 'SCENERY/display/SVGBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/FittedBlock','SCENERY/display/SVGGroup','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var SVGGroup = require( 'SCENERY/display/SVGGroup' );
  var Util = require( 'SCENERY/util/Util' );
  function SVGBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }
  scenery.register( 'SVGBlock', SVGBlock );
  inherit( FittedBlock, SVGBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.COMMON_ANCESTOR );
      this.filterRootInstance = filterRootInstance;
      this.dirtyGradients = cleanArray( this.dirtyGradients );
      this.dirtyGroups = cleanArray( this.dirtyGroups );
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );
      this.paintMap = {};
      if ( !this.domElement ) {
        this.svg = document.createElementNS( scenery.svgns, 'svg' );
        this.svg.style.position = 'absolute';
        this.svg.style.left = '0';
        this.svg.style.top = '0';
        this.svg.setAttribute( 'focusable', false );
        this.svg.style[ 'pointer-events' ] = 'none';
        this.defs = document.createElementNS( scenery.svgns, 'defs' );
        this.svg.appendChild( this.defs );
        this.baseTransformGroup = document.createElementNS( scenery.svgns, 'g' );
        this.svg.appendChild( this.baseTransformGroup );
        this.domElement = this.svg;
      }
      Util.prepareForTransform( this.svg, this.forceAcceleration ); // Apply CSS needed for future CSS transforms to work properly.
      Util.unsetTransform( this.svg ); // clear out any transforms that could have been previously applied
      this.baseTransformGroup.setAttribute( 'transform', '' ); // no base transform
      var instanceClosestToRoot = transformRootInstance.trail.nodes.length > filterRootInstance.trail.nodes.length ?
                                  filterRootInstance : transformRootInstance;
      this.rootGroup = SVGGroup.createFromPool( this, instanceClosestToRoot, null );
      this.baseTransformGroup.appendChild( this.rootGroup.svgGroup );
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'initialized #' + this.id );
      return this;
    },
    incrementPaint: function( paint ) {
      assert && assert( paint.isPaint );
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'incrementPaint ' + this.toString() + ' ' + paint.id );
      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        this.paintMap[ paint.id ].count++;
      }
      else {
        var svgPaint = paint.createSVGPaint( this );
        svgPaint.definition.setAttribute( 'id', paint.id + '-' + this.id );
        this.paintMap[ paint.id ] = {
          count: 1,
          paint: paint,
          svgPaint: svgPaint
        };
        this.defs.appendChild( svgPaint.definition );
      }
    },
    decrementPaint: function( paint ) {
      assert && assert( paint.isPaint );
      sceneryLog && sceneryLog.Paints && sceneryLog.Paints( 'decrementPaint ' + this.toString() + ' ' + paint.id );
      if ( this.paintMap.hasOwnProperty( paint.id ) ) {
        var entry = this.paintMap[ paint.id ];
        assert && assert( entry.count >= 1 );
        if ( entry.count === 1 ) {
          this.defs.removeChild( entry.svgPaint.definition );
          entry.svgPaint.dispose();
          delete this.paintMap[ paint.id ]; // delete, so we don't memory leak if we run through MANY paints
        }
        else {
          entry.count--;
        }
      }
    },
    markDirtyGradient: function( gradient ) {
      this.dirtyGradients.push( gradient );
      this.markDirty();
    },
    markDirtyGroup: function( block ) {
      this.dirtyGroups.push( block );
      this.markDirty();
    },
    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on SVGBlock#' + this.id + ' with ' + drawable.toString() );
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },
    setSizeFullDisplay: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFullDisplay #' + this.id );
      var size = this.display.getSize();
      this.svg.setAttribute( 'width', size.width );
      this.svg.setAttribute( 'height', size.height );
    },
    setSizeFitBounds: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'setSizeFitBounds #' + this.id + ' with ' + this.fitBounds.toString() );
      var x = this.fitBounds.minX;
      var y = this.fitBounds.minY;
      assert && assert( isFinite( x ) && isFinite( y ), 'Invalid SVG transform for SVGBlock' );
      assert && assert( this.fitBounds.isValid(), 'Invalid fitBounds' );
      this.baseTransformGroup.setAttribute( 'transform', 'translate(' + (-x) + ',' + (-y) + ')' ); // subtract off so we have a tight fit
      Util.setTransform( 'matrix(1,0,0,1,' + x + ',' + y + ')', this.svg, this.forceAcceleration ); // reapply the translation as a CSS transform
      this.svg.setAttribute( 'width', this.fitBounds.width );
      this.svg.setAttribute( 'height', this.fitBounds.height );
    },
    update: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'update #' + this.id );
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;
        while ( this.dirtyGroups.length ) {
          var group = this.dirtyGroups.pop();
          if ( group.block === this ) {
            group.update();
          }
        }
        while ( this.dirtyGradients.length ) {
          this.dirtyGradients.pop().update();
        }
        while ( this.dirtyDrawables.length ) {
          var drawable = this.dirtyDrawables.pop();
          if ( drawable.parentDrawable === this ) {
            drawable.update();
          }
        }
        this.updateFit();
      }
    },
    dispose: function() {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'dispose #' + this.id );
      this.svg.setAttribute( 'width', 0 );
      this.svg.setAttribute( 'height', 0 );
      this.filterRootInstance = null;
      cleanArray( this.dirtyGradients );
      cleanArray( this.dirtyGroups );
      cleanArray( this.dirtyDrawables );
      this.paintMap = {};
      this.baseTransformGroup.removeChild( this.rootGroup.svgGroup );
      this.rootGroup.dispose();
      this.rootGroup = null;
      while ( this.defs.childNodes.length ) {
        this.defs.removeChild( this.defs.childNodes[ 0 ] );
      }
      FittedBlock.prototype.dispose.call( this );
    },
    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      FittedBlock.prototype.addDrawable.call( this, drawable );
      SVGGroup.addDrawable( this, drawable );
      drawable.updateSVGBlock( this );
    },
    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      SVGGroup.removeDrawable( this, drawable );
      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
    },
    toString: function() {
      return 'SVGBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );
  Poolable.mixin( SVGBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.SVGBlock && sceneryLog.SVGBlock( 'new from constructor' );
          return new SVGBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );
  return SVGBlock;
} );
define( 'SCENERY/display/DOMBlock',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Block'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Block = require( 'SCENERY/display/Block' );
  function DOMBlock( display, domDrawable ) {
    this.initialize( display, domDrawable );
  }
  scenery.register( 'DOMBlock', DOMBlock );
  inherit( Block, DOMBlock, {
    initialize: function( display, domDrawable ) {
      this.initializeBlock( display, domDrawable.renderer );
      this.domDrawable = domDrawable;
      this.domElement = domDrawable.domElement;
      return this;
    },
    dispose: function() {
      this.domDrawable = null;
      this.domElement = null;
      Block.prototype.dispose.call( this );
    },
    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;
        this.domDrawable.update();
      }
    },
    markDirtyDrawable: function( drawable ) {
      this.markDirty();
    },
    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );
      Block.prototype.addDrawable.call( this, drawable );
    },
    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.DOMBlock && sceneryLog.DOMBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      assert && assert( this.domDrawable === drawable, 'DOMBlock should only be used with one drawable for now (the one it was initialized with)' );
      Block.prototype.removeDrawable.call( this, drawable );
    }
  } );
  Poolable.mixin( DOMBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, domDrawable ) {
        if ( pool.length ) {
          return pool.pop().initialize( display, domDrawable );
        }
        else {
          return new DOMBlock( display, domDrawable );
        }
      };
    }
  } );
  return DOMBlock;
} );
define( 'SCENERY/util/ShaderProgram',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Util = require( 'SCENERY/util/Util' );
  function ShaderProgram( gl, vertexSource, fragmentSource, options ) {
    options = _.extend( {
      attributes: [], // {Array.<string>} (vertex) attribute names in the shader source
      uniforms: [] // {Array.<string>} uniform names in the shader source
    }, options );
    this.vertexSource = vertexSource;
    this.fragmentSource = fragmentSource;
    this.attributeNames = options.attributes;
    this.uniformNames = options.uniforms;
    this.initialize( gl );
  }
  scenery.register( 'ShaderProgram', ShaderProgram );
  return inherit( Object, ShaderProgram, {
    initialize: function( gl ) {
      var self = this;
      this.gl = gl; // TODO: create them with separate contexts
      this.used = false;
      this.program = this.gl.createProgram();
      this.vertexShader = Util.createShader( this.gl, this.vertexSource, this.gl.VERTEX_SHADER );
      this.fragmentShader = Util.createShader( this.gl, this.fragmentSource, this.gl.FRAGMENT_SHADER );
      this.gl.attachShader( this.program, this.vertexShader );
      this.gl.attachShader( this.program, this.fragmentShader );
      this.gl.linkProgram( this.program );
      if ( !this.gl.getProgramParameter( this.program, this.gl.LINK_STATUS ) ) {
        console.log( 'GLSL link error:' );
        console.log( this.gl.getProgramInfoLog( this.program ) );
        console.log( 'for vertex shader' );
        console.log( this.vertexSource );
        console.log( 'for fragment shader' );
        console.log( this.fragmentSource );
      }
      this.gl.deleteShader( this.vertexShader );
      this.gl.deleteShader( this.fragmentShader );
      this.uniformLocations = {}; // map name => uniform location for program
      this.attributeLocations = {}; // map name => attribute location for program
      this.activeAttributes = {}; // map name => boolean (enabled)
      _.each( this.attributeNames, function( attributeName ) {
        self.attributeLocations[ attributeName ] = self.gl.getAttribLocation( self.program, attributeName );
        self.activeAttributes[ attributeName ] = true; // default to enabled
      } );
      _.each( this.uniformNames, function( uniformName ) {
        self.uniformLocations[ uniformName ] = self.gl.getUniformLocation( self.program, uniformName );
      } );
      this.isInitialized = true;
    },
    use: function() {
      if ( this.used ) { return; }
      var self = this;
      this.used = true;
      this.gl.useProgram( this.program );
      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.enableVertexAttribArray( attributeName );
        }
      } );
    },
    activateAttribute: function( attributeName ) {
      if ( !this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = true;
        if ( this.used ) {
          this.enableVertexAttribArray( attributeName );
        }
      }
    },
    enableVertexAttribArray: function( attributeName ) {
      this.gl.enableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },
    unuse: function() {
      if ( !this.used ) { return; }
      var self = this;
      this.used = false;
      _.each( this.attributeNames, function( attributeName ) {
        if ( self.activeAttributes[ attributeName ] ) {
          self.disableVertexAttribArray( attributeName );
        }
      } );
    },
    disableVertexAttribArray: function( attributeName ) {
      this.gl.disableVertexAttribArray( this.attributeLocations[ attributeName ] );
    },
    deactivateAttribute: function( attributeName ) {
      if ( this.activeAttributes[ attributeName ] ) {
        this.activeAttributes[ attributeName ] = false;
        if ( this.used ) {
          this.disableVertexAttribArray( attributeName );
        }
      }
    },
    dispose: function() {
      this.gl.deleteProgram( this.program );
    }
  } );
} );
define( 'SCENERY/display/WebGLBlock',['require','SCENERY/scenery','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','DOT/Matrix3','SCENERY/display/FittedBlock','SCENERY/display/Renderer','SCENERY/util/Util','SCENERY/util/SpriteSheet','SCENERY/util/ShaderProgram'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var FittedBlock = require( 'SCENERY/display/FittedBlock' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Util = require( 'SCENERY/util/Util' );
  var SpriteSheet = require( 'SCENERY/util/SpriteSheet' );
  var ShaderProgram = require( 'SCENERY/util/ShaderProgram' );
  function WebGLBlock( display, renderer, transformRootInstance, filterRootInstance ) {
    this.initialize( display, renderer, transformRootInstance, filterRootInstance );
  }
  scenery.register( 'WebGLBlock', WebGLBlock );
  inherit( FittedBlock, WebGLBlock, {
    initialize: function( display, renderer, transformRootInstance, filterRootInstance ) {
      this.initializeFittedBlock( display, renderer, transformRootInstance, FittedBlock.FULL_DISPLAY );
      this.filterRootInstance = filterRootInstance;
      this.preserveDrawingBuffer = display.options.preserveDrawingBuffer;
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );
      this.spriteSheets = this.spriteSheets || [];
      if ( !this.domElement ) {
        this.canvas = document.createElement( 'canvas' );
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = '0';
        this.canvas.style.top = '0';
        this.canvas.style.pointerEvents = 'none';
        this.canvasId = this.canvas.id = 'scenery-webgl' + this.id;
        var contextOptions = {
          antialias: true,
          preserveDrawingBuffer: this.preserveDrawingBuffer
        };
        this.gl = this.canvas.getContext( 'webgl', contextOptions ) || this.canvas.getContext( 'experimental-webgl', contextOptions );
        assert && assert( this.gl, 'We should have a context by now' );
        var gl = this.gl;
        this.backingScale = this.originalBackingScale = Util.backingScale( gl );
        Util.applyWebGLContextDefaults( gl ); // blending defaults, etc.
        this.domElement = this.canvas;
        this.customProcessor = new WebGLBlock.CustomProcessor( this );
        this.vertexColorPolygonsProcessor = new WebGLBlock.VertexColorPolygons( this );
        this.texturedTrianglesProcessor = new WebGLBlock.TexturedTrianglesProcessor( this );
      }
      this.gl.clear( this.gl.COLOR_BUFFER_BIT );
      Util.prepareForTransform( this.canvas, false ); // Apply CSS needed for future CSS transforms to work properly.
      Util.unsetTransform( this.canvas ); // clear out any transforms that could have been previously applied
      this.projectionMatrix = this.projectionMatrix || new Matrix3().setTo32Bit();
      this.projectionMatrixArray = this.projectionMatrix.entries;
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'initialized #' + this.id );
      return this;
    },
    setSizeFullDisplay: function() {
      var size = this.display.getSize();
      this.canvas.width = Math.ceil( size.width * this.backingScale );
      this.canvas.height = Math.ceil( size.height * this.backingScale );
      this.canvas.style.width = size.width + 'px';
      this.canvas.style.height = size.height + 'px';
    },
    setSizeFitBounds: function() {
      throw new Error( 'setSizeFitBounds unimplemented for WebGLBlock' );
    },
    update: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'update #' + this.id );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();
      var gl = this.gl;
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;
        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }
        var numSpriteSheets = this.spriteSheets.length;
        for ( var i = 0; i < numSpriteSheets; i++ ) {
          this.spriteSheets[ i ].updateTexture();
        }
        if ( this.firstDrawable &&
             this.firstDrawable === this.lastDrawable &&
             this.firstDrawable.node &&
             this.firstDrawable.node._hints.webglScale !== null &&
             this.backingScale !== this.originalBackingScale * this.firstDrawable.node._hints.webglScale ) {
          this.backingScale = this.originalBackingScale * this.firstDrawable.node._hints.webglScale;
          this.dirtyFit = true;
        }
        this.updateFit();
        this.projectionMatrix.rowMajor(
          2 / this.display.width, 0, -1,
          0, -2 / this.display.height, 1,
          0, 0, 1 );
        if ( this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }
        gl.viewport( 0.0, 0.0, this.canvas.width, this.canvas.height );
        var currentProcessor = null;
        var cumulativeDrawCount = 0;
        for ( var drawable = this.firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
          if ( drawable.visible ) {
            var desiredProcessor = null;
            if ( drawable.webglRenderer === Renderer.webglTexturedTriangles ) {
              desiredProcessor = this.texturedTrianglesProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglCustom ) {
              desiredProcessor = this.customProcessor;
            }
            else if ( drawable.webglRenderer === Renderer.webglVertexColorPolygons ) {
              desiredProcessor = this.vertexColorPolygonsProcessor;
            }
            assert && assert( desiredProcessor );
            if ( desiredProcessor !== currentProcessor ) {
              if ( currentProcessor ) {
                cumulativeDrawCount += currentProcessor.deactivate();
              }
              currentProcessor = desiredProcessor;
              currentProcessor.activate();
            }
            currentProcessor.processDrawable( drawable );
          }
          if ( drawable === this.lastDrawable ) { break; }
        }
        if ( currentProcessor ) {
          cumulativeDrawCount += currentProcessor.deactivate();
        }
        if ( cumulativeDrawCount === 0 && !this.preserveDrawingBuffer ) {
          gl.clear( gl.COLOR_BUFFER_BIT );
        }
        gl.flush();
      }
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },
    dispose: function() {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'dispose #' + this.id );
      cleanArray( this.dirtyDrawables );
      FittedBlock.prototype.dispose.call( this );
    },
    markDirtyDrawable: function( drawable ) {
      sceneryLog && sceneryLog.dirty && sceneryLog.dirty( 'markDirtyDrawable on WebGLBlock#' + this.id + ' with ' + drawable.toString() );
      assert && assert( drawable );
      assert && assert( !drawable.disposed );
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },
    addDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.addDrawable ' + drawable.toString() );
      FittedBlock.prototype.addDrawable.call( this, drawable );
      drawable.onAddToBlock( this );
    },
    removeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.removeDrawable ' + drawable.toString() );
      var index = 0;
      while ( ( index = this.dirtyDrawables.indexOf( drawable, index ) ) >= 0 ) {
        this.dirtyDrawables.splice( index, 1 );
      }
      drawable.onRemoveFromBlock( this );
      FittedBlock.prototype.removeDrawable.call( this, drawable );
    },
    addSpriteSheetImage: function( image, width, height ) {
      var sprite = null;
      var numSpriteSheets = this.spriteSheets.length;
      for ( var i = 0; i < numSpriteSheets; i++ ) {
        var spriteSheet = this.spriteSheets[ i ];
        sprite = spriteSheet.addImage( image, width, height );
        if ( sprite ) {
          break;
        }
      }
      if ( !sprite ) {
        var newSpriteSheet = new SpriteSheet( true ); // use mipmaps for now?
        sprite = newSpriteSheet.addImage( image, width, height );
        newSpriteSheet.initializeContext( this.gl );
        this.spriteSheets.push( newSpriteSheet );
        if ( !sprite ) {
          throw new Error( 'Attempt to load image that is too large for sprite sheets' );
        }
      }
      return sprite;
    },
    removeSpriteSheetImage: function( sprite ) {
      sprite.spriteSheet.removeImage( sprite.image );
    },
    onIntervalChange: function( firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onIntervalChange ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      FittedBlock.prototype.onIntervalChange.call( this, firstDrawable, lastDrawable );
      this.markDirty();
    },
    onPotentiallyMovedDrawable: function( drawable ) {
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( '#' + this.id + '.onPotentiallyMovedDrawable ' + drawable.toString() );
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.push();
      assert && assert( drawable.parentDrawable === this );
      this.markDirty();
      sceneryLog && sceneryLog.WebGLBlock && sceneryLog.pop();
    },
    toString: function() {
      return 'WebGLBlock#' + this.id + '-' + FittedBlock.fitString[ this.fit ];
    }
  } );
  WebGLBlock.CustomProcessor = function( webglBlock ) {
    this.webglBlock = webglBlock;
    this.drawable = null;
  };
  inherit( Object, WebGLBlock.CustomProcessor, {
    activate: function() {
      this.drawCount = 0;
    },
    processDrawable: function( drawable ) {
      assert && assert( drawable.webglRenderer === Renderer.webglCustom );
      this.drawable = drawable;
      this.draw();
    },
    deactivate: function() {
      return this.drawCount;
    },
    draw: function() {
      if ( this.drawable ) {
        var count = this.drawable.draw();
        assert && assert( typeof count === 'number' );
        this.drawCount += count;
        this.drawable = null;
      }
    }
  } );
  WebGLBlock.VertexColorPolygons = function( webglBlock ) {
    this.webglBlock = webglBlock;
    var gl = this.gl = webglBlock.gl;
    assert && assert( webglBlock.gl );
    this.shaderProgram = new ShaderProgram( gl, [
      'attribute vec2 aVertex;',
      'attribute vec4 aColor;',
      'varying vec4 vColor;',
      'uniform mat3 uProjectionMatrix;',
      'void main() {',
      '  vColor = aColor;',
      '  vec3 ndc = uProjectionMatrix * vec3( aVertex, 1.0 );', // homogeneous map to to normalized device coordinates
      '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
      '}'
    ].join( '\n' ), [
      'precision mediump float;',
      'varying vec4 vColor;',
      'void main() {',
      '  gl_FragColor = vColor;',
      '}'
    ].join( '\n' ), {
      attributes: [ 'aVertex', 'aColor' ],
      uniforms: [ 'uProjectionMatrix' ]
    } );
    this.vertexBuffer = gl.createBuffer();
    this.lastArrayLength = 128; // initial vertex buffer array length
    this.vertexArray = new Float32Array( this.lastArrayLength );
    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
  };
  inherit( Object, WebGLBlock.VertexColorPolygons, {
    activate: function() {
      this.shaderProgram.use();
      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },
    processDrawable: function( drawable ) {
      if ( drawable.includeVertices ) {
        var vertexData = drawable.vertexArray;
        while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
          var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
          newVertexArray.set( this.vertexArray );
          this.vertexArray = newVertexArray;
        }
        this.vertexArray.set( vertexData, this.vertexArrayIndex );
        this.vertexArrayIndex += vertexData.length;
        this.drawCount++;
      }
    },
    deactivate: function() {
      if ( this.drawCount ) {
        this.draw();
      }
      this.shaderProgram.unuse();
      return this.drawCount;
    },
    draw: function() {
      var gl = this.gl;
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.webglBlock.projectionMatrixArray );
      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }
      var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;
      var stride = 6 * sizeOfFloat;
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, stride, 0 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aColor, 4, gl.FLOAT, false, stride, 2 * sizeOfFloat );
      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / 6 );
      this.vertexArrayIndex = 0;
    }
  } );
  WebGLBlock.TexturedTrianglesProcessor = function( webglBlock ) {
    this.webglBlock = webglBlock;
    var gl = this.gl = webglBlock.gl;
    assert && assert( webglBlock.gl );
    this.shaderProgram = new ShaderProgram( gl, [
      'attribute vec2 aVertex;',
      'attribute vec2 aTextureCoord;',
      'attribute float aAlpha;',
      'varying vec2 vTextureCoord;',
      'varying float vAlpha;',
      'uniform mat3 uProjectionMatrix;',
      'void main() {',
      '  vTextureCoord = aTextureCoord;',
      '  vAlpha = aAlpha;',
      '  vec3 ndc = uProjectionMatrix * vec3( aVertex, 1.0 );', // homogeneous map to to normalized device coordinates
      '  gl_Position = vec4( ndc.xy, 0.0, 1.0 );',
      '}'
    ].join( '\n' ), [
      'precision mediump float;',
      'varying vec2 vTextureCoord;',
      'varying float vAlpha;',
      'uniform sampler2D uTexture;',
      'void main() {',
      '  vec4 color = texture2D( uTexture, vTextureCoord, -0.7 );', // mipmap LOD bias of -0.7 (for now)
      '  color.a *= vAlpha;',
      '  gl_FragColor = color;',
      '}'
    ].join( '\n' ), {
      attributes: [ 'aVertex', 'aTextureCoord', 'aAlpha' ],
      uniforms: [ 'uTexture', 'uProjectionMatrix' ]
    } );
    this.vertexBuffer = gl.createBuffer();
    this.lastArrayLength = 128; // initial vertex buffer array length
    this.vertexArray = new Float32Array( this.lastArrayLength );
    gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
  };
  inherit( Object, WebGLBlock.TexturedTrianglesProcessor, {
    activate: function() {
      this.shaderProgram.use();
      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
      this.drawCount = 0;
    },
    processDrawable: function( drawable ) {
      if ( !drawable.sprite ) {
        return;
      }
      assert && assert( drawable.webglRenderer === Renderer.webglTexturedTriangles );
      if ( this.currentSpriteSheet && drawable.sprite.spriteSheet !== this.currentSpriteSheet ) {
        this.draw();
      }
      this.currentSpriteSheet = drawable.sprite.spriteSheet;
      var vertexData = drawable.vertexArray;
      while ( vertexData.length + this.vertexArrayIndex > this.vertexArray.length ) {
        var newVertexArray = new Float32Array( this.vertexArray.length * 2 );
        newVertexArray.set( this.vertexArray );
        this.vertexArray = newVertexArray;
      }
      this.vertexArray.set( vertexData, this.vertexArrayIndex );
      this.vertexArrayIndex += vertexData.length;
    },
    deactivate: function() {
      if ( this.currentSpriteSheet ) {
        this.draw();
      }
      this.shaderProgram.unuse();
      return this.drawCount;
    },
    draw: function() {
      assert && assert( this.currentSpriteSheet );
      var gl = this.gl;
      gl.uniformMatrix3fv( this.shaderProgram.uniformLocations.uProjectionMatrix, false, this.webglBlock.projectionMatrixArray );
      gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
      if ( this.vertexArray.length > this.lastArrayLength ) {
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexArray, gl.DYNAMIC_DRAW ); // fully buffer at the start
      }
      else {
        gl.bufferSubData( gl.ARRAY_BUFFER, 0, this.vertexArray.subarray( 0, this.vertexArrayIndex ) );
      }
      var numComponents = 5;
      var sizeOfFloat = Float32Array.BYTES_PER_ELEMENT;
      var stride = numComponents * sizeOfFloat;
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aVertex, 2, gl.FLOAT, false, stride, 0 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * sizeOfFloat );
      gl.vertexAttribPointer( this.shaderProgram.attributeLocations.aAlpha, 1, gl.FLOAT, false, stride, 4 * sizeOfFloat );
      gl.activeTexture( gl.TEXTURE0 );
      gl.bindTexture( gl.TEXTURE_2D, this.currentSpriteSheet.texture );
      gl.uniform1i( this.shaderProgram.uniformLocations.uTexture, 0 );
      gl.drawArrays( gl.TRIANGLES, 0, this.vertexArrayIndex / numComponents );
      gl.bindTexture( gl.TEXTURE_2D, null );
      this.drawCount++;
      this.currentSpriteSheet = null;
      this.vertexArrayIndex = 0;
    }
  } );
  Poolable.mixin( WebGLBlock, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, renderer, transformRootInstance, filterRootInstance ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from pool' );
          return pool.pop().initialize( display, renderer, transformRootInstance, filterRootInstance );
        }
        else {
          sceneryLog && sceneryLog.WebGLBlock && sceneryLog.WebGLBlock( 'new from constructor' );
          return new WebGLBlock( display, renderer, transformRootInstance, filterRootInstance );
        }
      };
    }
  } );
  return WebGLBlock;
} );
define( 'SCENERY/display/Stitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/CanvasBlock','SCENERY/display/SVGBlock','SCENERY/display/DOMBlock','SCENERY/display/WebGLBlock'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CanvasBlock = require( 'SCENERY/display/CanvasBlock' );
  var SVGBlock = require( 'SCENERY/display/SVGBlock' );
  var DOMBlock = require( 'SCENERY/display/DOMBlock' );
  var WebGLBlock = require( 'SCENERY/display/WebGLBlock' );
  function Stitcher( display, renderer ) {
    throw new Error( 'We are too abstract for that!' );
  }
  scenery.register( 'Stitcher', Stitcher );
  inherit( Object, Stitcher, {
    initialize: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      assert && assert( firstChangeInterval && lastChangeInterval, 'We are guaranteed at least one change interval' );
      assert && assert( !firstDrawable || firstDrawable.previousDrawable === null,
        'End boundary of drawable linked list should link to null' );
      assert && assert( !lastDrawable || lastDrawable.nextDrawable === null,
        'End boundary of drawable linked list should link to null' );
      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'stitch ' + backbone.toString() +
                           ' first:' + ( firstDrawable ? firstDrawable.toString() : 'null' ) +
                           ' last:' + ( lastDrawable ? lastDrawable.toString() : 'null' ) +
                           ' oldFirst:' + ( oldFirstDrawable ? oldFirstDrawable.toString() : 'null' ) +
                           ' oldLast:' + ( oldLastDrawable ? oldLastDrawable.toString() : 'null' ) );
        sceneryLog.push();
      }
      if ( sceneryLog && sceneryLog.StitchDrawables ) {
        sceneryLog.StitchDrawables( 'Before:' );
        sceneryLog.push();
        Stitcher.debugDrawables( oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval, false );
        sceneryLog.pop();
        sceneryLog.StitchDrawables( 'After:' );
        sceneryLog.push();
        Stitcher.debugDrawables( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, true );
        sceneryLog.pop();
      }
      this.backbone = backbone;
      this.firstDrawable = firstDrawable;
      this.lastDrawable = lastDrawable;
      this.touchedBlocks = cleanArray( this.touchedBlocks );
      if ( assertSlow ) {
        assertSlow( !this.initialized, 'We should not be already initialized (clean should be called)' );
        this.initialized = true;
        this.reindexed = false;
        this.pendingAdditions = [];
        this.pendingRemovals = [];
        this.pendingMoves = [];
        this.createdBlocks = [];
        this.disposedBlocks = [];
        this.intervalsNotified = [];
        this.boundariesRecorded = false;
        this.previousBlocks = backbone.blocks.slice( 0 ); // copy of previous blocks
      }
    },
    clean: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'clean' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( '-----------------------------------' );
      if ( assertSlow ) {
        this.auditStitch();
        this.initialized = false;
      }
      this.backbone = null;
      this.firstDrawable = null;
      this.lastDrawable = null;
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    recordBackboneBoundaries: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'recording backbone boundaries: ' +
                                                            ( this.firstDrawable ? this.firstDrawable.toString() : 'null' ) +
                                                            ' to ' +
                                                            ( this.lastDrawable ? this.lastDrawable.toString() : 'null' ) );
      this.backbone.previousFirstDrawable = this.firstDrawable;
      this.backbone.previousLastDrawable = this.lastDrawable;
      if ( assertSlow ) {
        this.boundariesRecorded = true;
      }
    },
    notePendingAddition: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending add: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      drawable.notePendingAddition( this.backbone.display, block, this.backbone );
      if ( assertSlow ) {
        this.pendingAdditions.push( {
          drawable: drawable,
          block: block
        } );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    notePendingMove: function( drawable, block ) {
      assert && assert( drawable.renderer === block.renderer );
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending move: ' + drawable.toString() + ' to ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      drawable.notePendingMove( this.backbone.display, block );
      if ( assertSlow ) {
        this.pendingMoves.push( {
          drawable: drawable,
          block: block
        } );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    notePendingRemoval: function( drawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'pending remove: ' + drawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      drawable.notePendingRemoval( this.backbone.display );
      if ( assertSlow ) {
        this.pendingRemovals.push( {
          drawable: drawable
        } );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    markBlockForDisposal: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'block for disposal: ' + block.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      if ( block.domElement.parentNode === this.backbone.domElement ) {
        this.backbone.domElement.removeChild( block.domElement );
      }
      block.markForDisposal( this.backbone.display );
      if ( assertSlow ) {
        this.disposedBlocks.push( {
          block: block
        } );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    removeAllBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking all blocks for disposal (count ' + this.backbone.blocks.length + ')' );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      while ( this.backbone.blocks.length ) {
        var block = this.backbone.blocks[ 0 ];
        this.removeBlock( block );
        this.markBlockForDisposal( block );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    notifyInterval: function( block, firstDrawable, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'notify interval: ' + block.toString() + ' ' +
                                                            firstDrawable.toString() + ' to ' + lastDrawable.toString() );
      sceneryLog && sceneryLog.Stitch && sceneryLog.push();
      block.notifyInterval( firstDrawable, lastDrawable );
      this.backbone.markDirtyDrawable( block );
      if ( assertSlow ) {
        this.intervalsNotified.push( {
          block: block,
          firstDrawable: firstDrawable,
          lastDrawable: lastDrawable
        } );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.pop();
    },
    markBeforeBlock: function( block, firstDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block first drawable ' + block.toString() + ' with ' + firstDrawable.toString() );
      block.pendingFirstDrawable = firstDrawable;
      this.touchedBlocks.push( block );
    },
    markAfterBlock: function( block, lastDrawable ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'marking block last drawable ' + block.toString() + ' with ' + lastDrawable.toString() );
      block.pendingLastDrawable = lastDrawable;
      this.touchedBlocks.push( block );
    },
    updateBlockIntervals: function() {
      while ( this.touchedBlocks.length ) {
        var block = this.touchedBlocks.pop();
        if ( block.used ) {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'update interval: ' + block.toString() + ' ' +
                                                                block.pendingFirstDrawable.toString() + ' to ' + block.pendingLastDrawable.toString() );
          block.updateInterval();
          this.backbone.markDirtyDrawable( block );
          if ( assertSlow ) {
            this.intervalsNotified.push( {
              block: block,
              firstDrawable: block.pendingFirstDrawable,
              lastDrawable: block.pendingLastDrawable
            } );
          }
        }
        else {
          sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'skipping update interval: ' + block.toString() + ', unused' );
        }
      }
    },
    createBlock: function( renderer, drawable ) {
      var backbone = this.backbone;
      var block;
      if ( Renderer.isCanvas( renderer ) ) {
        block = CanvasBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isSVG( renderer ) ) {
        block = SVGBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else if ( Renderer.isDOM( renderer ) ) {
        block = DOMBlock.createFromPool( backbone.display, drawable );
      }
      else if ( Renderer.isWebGL( renderer ) ) {
        block = WebGLBlock.createFromPool( backbone.display, renderer, backbone.transformRootInstance, backbone.backboneInstance );
      }
      else {
        throw new Error( 'unsupported renderer for createBlock: ' + renderer );
      }
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'created block: ' + block.toString() +
                                                            ' with renderer: ' + renderer +
                                                            ' for drawable: ' + drawable.toString() );
      block.setBlockBackbone( backbone );
      backbone.domElement.appendChild( block.domElement );
      if ( backbone.isDisplayRoot ) {
        block.domElement.setAttribute( 'aria-hidden', true );
      }
      backbone.markDirtyDrawable( block );
      if ( assertSlow ) {
        this.createdBlocks.push( {
          block: block,
          renderer: renderer,
          drawable: drawable
        } );
      }
      return block;
    },
    appendBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'appending block: ' + block.toString() );
      this.backbone.blocks.push( block );
      if ( assertSlow ) {
        this.reindexed = false;
      }
    },
    removeBlock: function( block ) {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'removing block: ' + block.toString() );
      var blockIndex = _.indexOf( this.backbone.blocks, block );
      assert && assert( blockIndex >= 0, 'Cannot remove block, not attached: ' + block.toString() );
      this.backbone.blocks.splice( blockIndex, 1 );
      if ( assertSlow ) {
        this.reindexed = false;
      }
    },
    useNoBlocks: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'using no blocks' );
      cleanArray( this.backbone.blocks );
    },
    reindex: function() {
      sceneryLog && sceneryLog.Stitch && sceneryLog.Stitch( 'reindexing blocks' );
      this.backbone.reindexBlocks();
      if ( assertSlow ) {
        this.reindexed = true;
      }
    },
    auditStitch: function() {
      if ( assertSlow ) {
        var self = this;
        var blocks = self.backbone.blocks;
        var previousBlocks = self.previousBlocks;
        assertSlow( self.initialized, 'We seem to have finished a stitch without proper initialization' );
        assertSlow( self.boundariesRecorded, 'Our stitch API requires recordBackboneBoundaries() to be called before' +
                                                 ' it is finished.' );
        assertSlow( self.reindexed || blocks.length === 0 ||
                    ( previousBlocks.length === blocks.length &&
                      _.every( _.zip( previousBlocks, blocks ), function( arr ) {
                        return arr[ 0 ] === arr[ 1 ];
                      } ) ),
          'Did not reindex on a block change where we are left with blocks' );
        _.each( self.createdBlocks, function( blockData ) {
          assertSlow( _.some( self.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Created block does not seem to have an interval notified: ' + blockData.block.toString() );
        } );
        _.each( self.disposedBlocks, function( blockData ) {
          assertSlow( !_.some( self.intervalsNotified, function( intervalData ) {
            return blockData.block === intervalData.block;
          } ), 'Removed block seems to have an interval notified: ' + blockData.block.toString() );
        } );
        _.each( self.disposedBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.oldListToArray( block.firstDrawable, block.lastDrawable ), function( drawable ) {
            assertSlow( _.some( self.pendingRemovals, function( removalData ) {
                return removalData.drawable === drawable;
              } ) || _.some( self.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable;
              } ), 'Drawable ' + drawable.toString() + ' originally listed for disposed block ' + block.toString() +
                   ' does not seem to be marked for pending removal or move!' );
          } );
        } );
        _.each( self.createdBlocks, function( blockData ) {
          var block = blockData.block;
          _.each( Drawable.listToArray( block.pendingFirstDrawable, block.pendingLastDrawable ), function( drawable ) {
            assertSlow( _.some( self.pendingAdditions, function( additionData ) {
                return additionData.drawable === drawable && additionData.block === block;
              } ) || _.some( self.pendingMoves, function( moveData ) {
                return moveData.drawable === drawable && moveData.block === block;
              } ), 'Drawable ' + drawable.toString() + ' now listed for created block ' + block.toString() +
                   ' does not seem to be marked for pending addition or move!' );
          } );
        } );
        _.each( self.disposedBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx < 0, 'Disposed block ' + blockData.block.toString() + ' still present at index ' + blockIdx );
        } );
        _.each( self.createdBlocks, function( blockData ) {
          var blockIdx = _.indexOf( blocks, blockData.block );
          assertSlow( blockIdx >= 0, 'Created block ' + blockData.block.toString() + ' is not in the blocks array' );
        } );
        _.each( blocks, function( block ) {
          assertSlow( block.used, 'All current blocks should be marked as used' );
        } );
        assertSlow( blocks.length - previousBlocks.length === self.createdBlocks.length - self.disposedBlocks.length,
          'The count of unmodified blocks should be constant (equal differences):\n' +
          'created: ' + _.map( self.createdBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'disposed: ' + _.map( self.disposedBlocks, function( n ) { return n.block.id; } ).join( ',' ) + '\n' +
          'before: ' + _.map( previousBlocks, function( n ) { return n.id; } ).join( ',' ) + '\n' +
          'after: ' + _.map( blocks, function( n ) { return n.id; } ).join( ',' ) );
        assertSlow( this.touchedBlocks.length === 0,
          'If we marked any blocks for changes, we should have called updateBlockIntervals' );
        if ( blocks.length ) {
          assertSlow( self.backbone.previousFirstDrawable !== null &&
                      self.backbone.previousLastDrawable !== null,
            'If we are left with at least one block, we must be tracking at least one drawable' );
          assertSlow( blocks[ 0 ].pendingFirstDrawable === self.backbone.previousFirstDrawable,
            'Our first drawable should match the first drawable of our first block' );
          assertSlow( blocks[ blocks.length - 1 ].pendingLastDrawable === self.backbone.previousLastDrawable,
            'Our last drawable should match the last drawable of our last block' );
          for ( var i = 0; i < blocks.length - 1; i++ ) {
            assertSlow( blocks[ i ].pendingLastDrawable.nextDrawable === blocks[ i + 1 ].pendingFirstDrawable &&
                        blocks[ i ].pendingLastDrawable === blocks[ i + 1 ].pendingFirstDrawable.previousDrawable,
              'Consecutive blocks should have boundary drawables that are also consecutive in the linked list' );
          }
        }
        else {
          assertSlow( self.backbone.previousFirstDrawable === null &&
                      self.backbone.previousLastDrawable === null,
            'If we are left with no blocks, it must mean we are tracking precisely zero drawables' );
        }
      }
    }
  } );
  Stitcher.debugIntervals = function( firstChangeInterval ) {
    if ( sceneryLog && sceneryLog.Stitch ) {
      for ( var debugInterval = firstChangeInterval; debugInterval !== null; debugInterval = debugInterval.nextChangeInterval ) {
        sceneryLog.Stitch( '  interval: ' +
                           ( debugInterval.isEmpty() ? '(empty) ' : '' ) +
                           ( debugInterval.drawableBefore ? debugInterval.drawableBefore.toString() : '-' ) + ' to ' +
                           ( debugInterval.drawableAfter ? debugInterval.drawableAfter.toString() : '-' ) );
      }
    }
  };
  Stitcher.debugDrawables = function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval, useCurrent ) {
    if ( sceneryLog && sceneryLog.StitchDrawables ) {
      if ( firstDrawable === null ) {
        sceneryLog.StitchDrawables( 'nothing', 'color: #666;' );
        return;
      }
      var isChanged = firstChangeInterval.drawableBefore === null;
      var currentInterval = firstChangeInterval;
      for ( var drawable = firstDrawable; ; drawable = ( useCurrent ? drawable.nextDrawable : drawable.oldNextDrawable ) ) {
        if ( isChanged && drawable === currentInterval.drawableAfter ) {
          isChanged = false;
          currentInterval = currentInterval.nextChangeInterval;
        }
        var drawableString = drawable.renderer + ' ' + ( ( !useCurrent && drawable.parentDrawable ) ? drawable.parentDrawable.toString() : '' ) + ' ' + drawable.toDetailedString();
        sceneryLog.StitchDrawables( drawableString, isChanged ? ( useCurrent ? 'color: #0a0;' : 'color: #a00;' ) : 'color: #666' );
        if ( !isChanged && currentInterval && currentInterval.drawableBefore === drawable ) {
          isChanged = true;
        }
        if ( drawable === lastDrawable ) {
          break;
        }
      }
    }
  };
  return Stitcher;
} );
define( 'SCENERY/display/GreedyStitcher',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );
  function hasGapBetweenDrawables( a, b ) {
    return a.renderer !== b.renderer || Renderer.isDOM( a.renderer ) || Renderer.isDOM( b.renderer );
  }
  function isOpenBefore( drawable ) {
    return drawable.previousDrawable !== null && !hasGapBetweenDrawables( drawable.previousDrawable, drawable );
  }
  function isOpenAfter( drawable ) {
    return drawable.nextDrawable !== null && !hasGapBetweenDrawables( drawable, drawable.nextDrawable );
  }
  function intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.nextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.previousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return firstStitchDrawable !== null;
    }
  }
  function intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) {
    if ( interval.drawableBefore ) {
      return interval.drawableBefore.oldNextDrawable !== interval.drawableAfter; // OK for after to be null
    }
    else if ( interval.drawableAfter ) {
      return interval.drawableAfter.oldPreviousDrawable !== interval.drawableBefore; // OK for before to be null
    }
    else {
      return oldFirstStitchDrawable !== null;
    }
  }
  function intervalHasOldInternalBlocks( interval, firstStitchBlock, lastStitchBlock ) {
    var beforeBlock = interval.drawableBefore ? interval.drawableBefore.parentDrawable : null;
    var afterBlock = interval.drawableAfter ? interval.drawableAfter.parentDrawable : null;
    if ( beforeBlock && afterBlock && beforeBlock === afterBlock ) {
      return false;
    }
    if ( beforeBlock ) {
      return beforeBlock.nextBlock !== afterBlock; // OK for after to be null
    }
    else if ( afterBlock ) {
      return afterBlock.previousBlock !== beforeBlock; // OK for before to be null
    }
    else {
      return firstStitchBlock !== null;
    }
  }
  function getLastCompatibleExternalDrawable( interval ) {
    var firstDrawable = interval.drawableAfter;
    if ( firstDrawable ) {
      var renderer = firstDrawable.renderer;
      var cutoffDrawable = interval.nextChangeInterval ? interval.nextChangeInterval.drawableBefore.nextDrawable : null;
      var drawable = firstDrawable;
      while ( true ) { //eslint-disable-line no-constant-condition
        var nextDrawable = drawable.nextDrawable;
        if ( nextDrawable !== cutoffDrawable && nextDrawable.renderer === renderer ) {
          drawable = nextDrawable;
        }
        else {
          break;
        }
      }
      return drawable;
    }
    else {
      return null; // with no drawableAfter, we don't have any external drawables after our interval
    }
  }
  var prototype = {
    stitch: function( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval ) {
      this.initialize( backbone, firstStitchDrawable, lastStitchDrawable, oldFirstStitchDrawable, oldLastStitchDrawable, firstChangeInterval, lastChangeInterval );
      this.blockOrderChanged = false;
      this.reusableBlocks = cleanArray( this.reusableBlocks ); // re-use instance, since we are effectively pooled
      this.blockWasAdded = false; // we need to know if a previously-existing block was added, and remove it otherwise.
      var interval;
      this.recordBackboneBoundaries();
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 1: old linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      if ( backbone.blocks.length ) {
        var veryFirstBlock = backbone.blocks[ 0 ];
        var veryLastBlock = backbone.blocks[ backbone.blocks.length - 1 ];
        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );
          if ( intervalHasOldInternalDrawables( interval, oldFirstStitchDrawable, oldLastStitchDrawable ) ) {
            var firstRemoval = interval.drawableBefore ?
                               interval.drawableBefore.oldNextDrawable :
                               oldFirstStitchDrawable;
            var lastRemoval = interval.drawableAfter ?
                              interval.drawableAfter.oldPreviousDrawable :
                              oldLastStitchDrawable;
            for ( var removedDrawable = firstRemoval; ; removedDrawable = removedDrawable.oldNextDrawable ) {
              this.notePendingRemoval( removedDrawable );
              if ( removedDrawable === lastRemoval ) { break; }
            }
          }
          if ( intervalHasOldInternalBlocks( interval, veryFirstBlock, veryLastBlock ) ) {
            var firstBlock = interval.drawableBefore === null ? backbone.blocks[ 0 ] : interval.drawableBefore.parentDrawable.nextBlock;
            var lastBlock = interval.drawableAfter === null ? backbone.blocks[ backbone.blocks.length - 1 ] : interval.drawableAfter.parentDrawable.previousBlock;
            for ( var markedBlock = firstBlock; ; markedBlock = markedBlock.nextBlock ) {
              this.unuseBlock( markedBlock );
              if ( markedBlock === lastBlock ) { break; }
            }
          }
        }
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 2: new linked list' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      if ( firstStitchDrawable ) {
        for ( interval = firstChangeInterval; interval !== null; interval = interval.nextChangeInterval ) {
          this.processInterval( backbone, interval, firstStitchDrawable, lastStitchDrawable );
        }
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'phase 3: cleanup' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      this.removeUnusedBlocks();
      this.updateBlockIntervals();
      if ( firstStitchDrawable === null ) {
        this.useNoBlocks();
      }
      else if ( this.blockOrderChanged ) {
        this.processBlockLinkedList( backbone, firstStitchDrawable.pendingParentDrawable, lastStitchDrawable.pendingParentDrawable );
        this.reindex();
      }
      this.clean();
      cleanArray( this.reusableBlocks );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },
    processInterval: function( backbone, interval, firstStitchDrawable, lastStitchDrawable ) {
      assert && assert( interval instanceof scenery.ChangeInterval );
      assert && assert( firstStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( lastStitchDrawable instanceof scenery.Drawable, 'We assume we have a non-null remaining section' );
      assert && assert( !interval.isEmpty(), 'We now guarantee that the intervals are non-empty' );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'interval: ' +
                                                                          ( interval.drawableBefore ? interval.drawableBefore.toString() : 'null' ) +
                                                                          ' to ' +
                                                                          ( interval.drawableAfter ? interval.drawableAfter.toString() : 'null' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
      if ( !intervalHasNewInternalDrawables( interval, firstStitchDrawable, lastStitchDrawable ) ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no current internal drawables in interval' );
        if ( interval.drawableBefore && interval.drawableAfter ) {
          assert && assert( interval.drawableBefore.nextDrawable === interval.drawableAfter );
          var isOpen = !hasGapBetweenDrawables( interval.drawableBefore, interval.drawableAfter );
          this.processEdgeCases( interval, isOpen, isOpen );
        }
        if ( interval.drawableBefore && !isOpenAfter( interval.drawableBefore ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-after collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkAfterDrawable( interval.drawableBefore );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
        else if ( interval.drawableAfter && !isOpenBefore( interval.drawableAfter ) ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before collapsed link:' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.linkBeforeDrawable( interval.drawableAfter );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
      }
      else {
        var drawable = interval.drawableBefore ? interval.drawableBefore.nextDrawable : firstStitchDrawable;
        var subBlockFirstDrawable = null;
        var matchedBlock = null;
        var isFirst = true;
        while ( true ) { //eslint-disable-line no-constant-condition
          var nextDrawable = drawable.nextDrawable;
          var isLast = nextDrawable === interval.drawableAfter;
          assert && assert( nextDrawable !== null || isLast, 'If our nextDrawable is null, isLast must be true' );
          if ( !subBlockFirstDrawable ) {
            subBlockFirstDrawable = drawable;
          }
          if ( matchedBlock === null && drawable.parentDrawable && !drawable.parentDrawable.used && drawable.backbone === backbone &&
               drawable.parentDrawable.parentDrawable === backbone ) {
            matchedBlock = drawable.parentDrawable;
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'matching at ' + drawable.toString() + ' with ' + matchedBlock );
          }
          if ( isLast || hasGapBetweenDrawables( drawable, nextDrawable ) ) {
            if ( isFirst ) {
              this.processEdgeCases( interval, isOpenBefore( subBlockFirstDrawable ), isOpenAfter( drawable ) );
            }
            this.processSubBlock( interval, subBlockFirstDrawable, drawable, matchedBlock, isFirst, isLast );
            subBlockFirstDrawable = null;
            matchedBlock = null;
            isFirst = false;
          }
          if ( isLast ) {
            break;
          }
          else {
            drawable = nextDrawable;
          }
        }
      }
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },
    processSubBlock: function( interval, firstDrawable, lastDrawable, matchedBlock, isFirst, isLast ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
        'sub-block: ' + firstDrawable.toString() + ' to ' + lastDrawable.toString() + ' ' +
        ( matchedBlock ? 'with matched: ' + matchedBlock.toString() : 'with no match' ) );
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
      var openBefore = isOpenBefore( firstDrawable );
      var openAfter = isOpenAfter( lastDrawable );
      assert && assert( !openBefore || isFirst, 'openBefore implies isFirst' );
      assert && assert( !openAfter || isLast, 'openAfter implies isLast' );
      assert && assert( !openBefore || !openAfter || firstDrawable.previousDrawable.pendingParentDrawable === lastDrawable.nextDrawable.pendingParentDrawable,
        'If we would use both the before and after blocks, make sure any gluing ' );
      if ( openBefore ) {
        matchedBlock = firstDrawable.previousDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into before block: ' + matchedBlock.toString() );
      }
      if ( openAfter ) {
        matchedBlock = lastDrawable.nextDrawable.pendingParentDrawable;
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'combining into after block: ' + matchedBlock.toString() );
      }
      matchedBlock = this.ensureUsedBlock( matchedBlock, firstDrawable );
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        this.notePendingAddition( drawable, matchedBlock );
        if ( drawable === lastDrawable ) { break; }
      }
      if ( !openBefore ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'closed-before link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkBeforeDrawable( firstDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
      if ( isLast && !openAfter ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'last closed-after link:' );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        this.linkAfterDrawable( lastDrawable );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
    },
    processEdgeCases: function( interval, openBefore, openAfter ) {
      if ( interval.drawableBefore !== null && interval.drawableAfter !== null ) {
        var beforeBlock = interval.drawableBefore.pendingParentDrawable;
        var afterBlock = interval.drawableAfter.pendingParentDrawable;
        var nextAfterBlock = ( interval.nextChangeInterval && interval.nextChangeInterval.drawableAfter ) ?
                             interval.nextChangeInterval.drawableAfter.pendingParentDrawable :
                             null;
        if ( beforeBlock === afterBlock ) {
          this.blockWasAdded = true;
        }
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose(
          'edge case: ' +
          ( openBefore ? 'open-before ' : '' ) +
          ( openAfter ? 'open-after ' : '' ) +
          beforeBlock.toString() + ' to ' + afterBlock.toString() );
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
        var newAfterBlock;
        if ( openBefore && openAfter ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'glue using ' + beforeBlock.toString() );
          newAfterBlock = beforeBlock;
        }
        else {
          if ( this.blockWasAdded || beforeBlock === afterBlock ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with fresh block' );
            newAfterBlock = this.createBlock( interval.drawableAfter.renderer, interval.drawableAfter );
            this.blockOrderChanged = true; // needs to be done on block creation
          }
          else {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'split with same afterBlock ' + afterBlock.toString() );
            newAfterBlock = afterBlock;
          }
        }
        if ( afterBlock === newAfterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'no externals change here (blockWasAdded => true)' );
          this.blockWasAdded = true;
        }
        else {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'moving externals' );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.push();
          this.changeExternals( interval, newAfterBlock );
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
        }
        if ( nextAfterBlock !== afterBlock ) {
          sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'end of afterBlock stretch' );
          if ( !this.blockWasAdded ) {
            sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing ' + afterBlock.toString() );
            this.unuseBlock( afterBlock );
          }
          this.blockWasAdded = false;
        }
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.pop();
      }
    },
    changeExternals: function( interval, newBlock ) {
      var lastExternalDrawable = getLastCompatibleExternalDrawable( interval );
      this.notePendingMoves( newBlock, interval.drawableAfter, lastExternalDrawable );
      if ( !interval.nextChangeInterval || interval.nextChangeInterval.drawableBefore !== lastExternalDrawable ) {
        this.linkAfterDrawable( lastExternalDrawable );
      }
    },
    notePendingMoves: function( newBlock, firstDrawable, lastDrawable ) {
      for ( var drawable = firstDrawable; ; drawable = drawable.nextDrawable ) {
        assert && assert( !drawable.pendingAddition && !drawable.pendingRemoval,
          'Moved drawables should be thought of as unchanged, and thus have nothing pending yet' );
        this.notePendingMove( drawable, newBlock );
        if ( drawable === lastDrawable ) { break; }
      }
    },
    ensureUsedBlock: function( currentBlock, someIncludedDrawable ) {
      if ( currentBlock ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using existing block: ' + currentBlock.toString() );
        if ( !currentBlock.used ) {
          this.useBlock( currentBlock );
        }
      }
      else {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'searching for block' );
        currentBlock = this.getBlockForRenderer( someIncludedDrawable.renderer, someIncludedDrawable );
      }
      return currentBlock;
    },
    getBlockForRenderer: function( renderer, drawable ) {
      var block;
      if ( !Renderer.isDOM( renderer ) ) {
        for ( var i = this.reusableBlocks.length - 1; i >= 0; i-- ) {
          var tmpBlock = this.reusableBlocks[ i ];
          assert && assert( !tmpBlock.used );
          if ( tmpBlock.renderer === renderer ) {
            this.useBlockAtIndex( tmpBlock, i );
            block = tmpBlock;
            break;
          }
        }
      }
      if ( !block ) {
        block = this.createBlock( renderer, drawable );
      }
      this.blockOrderChanged = true; // we created a new block, this will always happen
      return block;
    },
    unuseBlock: function( block ) {
      if ( block.used ) {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'unusing block: ' + block.toString() );
        block.used = false; // mark it as unused until we pull it out (so we can reuse, or quickly identify)
        this.reusableBlocks.push( block );
      }
      else {
        sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'not using already-unused block: ' + block.toString() );
      }
    },
    useBlock: function( block ) {
      this.useBlockAtIndex( block, _.indexOf( this.reusableBlocks, block ) );
    },
    useBlockAtIndex: function( block, index ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'using reusable block: ' + block.toString() + ' with renderer: ' + block.renderer );
      assert && assert( index >= 0 && this.reusableBlocks[ index ] === block, 'bad index for useBlockAtIndex: ' + index );
      assert && assert( !block.used, 'Should be called on an unused (reusable) block' );
      this.reusableBlocks.splice( index, 1 );
      block.used = true;
    },
    removeUnusedBlocks: function() {
      sceneryLog && sceneryLog.GreedyStitcher && this.reusableBlocks.length && sceneryLog.GreedyStitcher( 'removeUnusedBlocks' );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      while ( this.reusableBlocks.length ) {
        var block = this.reusableBlocks.pop();
        this.markBlockForDisposal( block );
        this.blockOrderChanged = true;
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },
    linkBeforeDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link before ' + drawable.toString() );
      var beforeDrawable = drawable.previousDrawable;
      this.linkBlocks( beforeDrawable ? beforeDrawable.pendingParentDrawable : null,
        drawable.pendingParentDrawable,
        beforeDrawable,
        drawable );
    },
    linkAfterDrawable: function( drawable ) {
      sceneryLog && sceneryLog.GreedyVerbose && sceneryLog.GreedyVerbose( 'link after ' + drawable.toString() );
      var afterDrawable = drawable.nextDrawable;
      this.linkBlocks( drawable.pendingParentDrawable,
        afterDrawable ? afterDrawable.pendingParentDrawable : null,
        drawable,
        afterDrawable );
    },
    linkBlocks: function( beforeBlock, afterBlock, beforeDrawable, afterDrawable ) {
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'linking blocks: ' +
                                                                            ( beforeBlock ? ( beforeBlock.toString() + ' (' + beforeDrawable.toString() + ')' ) : 'null' ) +
                                                                            ' to ' +
                                                                            ( afterBlock ? ( afterBlock.toString() + ' (' + afterDrawable.toString() + ')' ) : 'null' ) );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      assert && assert( ( beforeBlock === null && beforeDrawable === null ) ||
                        ( beforeBlock instanceof scenery.Block && beforeDrawable instanceof scenery.Drawable ) );
      assert && assert( ( afterBlock === null && afterDrawable === null ) ||
                        ( afterBlock instanceof scenery.Block && afterDrawable instanceof scenery.Drawable ) );
      if ( beforeBlock ) {
        if ( beforeBlock.nextBlock !== afterBlock ) {
          this.blockOrderChanged = true;
          if ( beforeBlock.nextBlock ) {
            beforeBlock.nextBlock.previousBlock = null;
          }
          beforeBlock.nextBlock = afterBlock;
        }
        this.markAfterBlock( beforeBlock, beforeDrawable );
      }
      if ( afterBlock ) {
        if ( afterBlock.previousBlock !== beforeBlock ) {
          this.blockOrderChanged = true;
          if ( afterBlock.previousBlock ) {
            afterBlock.previousBlock.nextBlock = null;
          }
          afterBlock.previousBlock = beforeBlock;
        }
        this.markBeforeBlock( afterBlock, afterDrawable );
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    },
    processBlockLinkedList: function( backbone, firstBlock, lastBlock ) {
      while ( backbone.blocks.length ) {
        backbone.blocks.pop();
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( 'processBlockLinkedList: ' + firstBlock.toString() + ' to ' + lastBlock.toString() );
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.push();
      if ( firstBlock ) {
        for ( var block = firstBlock; ; block = block.nextBlock ) {
          sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.GreedyStitcher( block.toString() );
          backbone.blocks.push( block );
          if ( block === lastBlock ) { break; }
        }
      }
      sceneryLog && sceneryLog.GreedyStitcher && sceneryLog.pop();
    }
  };
  var GreedyStitcher = inherit( Stitcher, function GreedyStitcher() {
  }, prototype );
  scenery.register( 'GreedyStitcher', GreedyStitcher );
  GreedyStitcher.stitchPrototype = prototype;
  return GreedyStitcher;
} );
define( 'SCENERY/display/RebuildStitcher',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Renderer','SCENERY/display/Stitcher'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );
  var prototype = {
    stitch: function( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval ) {
      this.initialize( backbone, firstDrawable, lastDrawable, oldFirstDrawable, oldLastDrawable, firstChangeInterval, lastChangeInterval );
      for ( var d = backbone.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        this.notePendingRemoval( d );
        if ( d === backbone.previousLastDrawable ) { break; }
      }
      this.recordBackboneBoundaries();
      this.removeAllBlocks();
      var currentBlock = null;
      var currentRenderer = 0;
      var firstDrawableForBlock = null;
      for ( var drawable = firstDrawable; drawable !== null; drawable = drawable.nextDrawable ) {
        if ( !currentBlock || drawable.renderer !== currentRenderer ) {
          if ( currentBlock ) {
            this.notifyInterval( currentBlock, firstDrawableForBlock, drawable.previousDrawable );
          }
          currentRenderer = drawable.renderer;
          currentBlock = this.createBlock( currentRenderer, drawable );
          if ( Renderer.isDOM( currentRenderer ) ) {
            currentRenderer = 0;
          }
          this.appendBlock( currentBlock );
          firstDrawableForBlock = drawable;
        }
        this.notePendingAddition( drawable, currentBlock );
        if ( drawable === lastDrawable ) { break; }
      }
      if ( currentBlock ) {
        this.notifyInterval( currentBlock, firstDrawableForBlock, lastDrawable );
      }
      this.reindex();
      this.clean();
    }
  };
  var RebuildStitcher = inherit( Stitcher, function RebuildStitcher() {
  }, prototype );
  scenery.register( 'RebuildStitcher', RebuildStitcher );
  RebuildStitcher.stitchPrototype = prototype;
  return RebuildStitcher;
} );
define( 'SCENERY/display/BackboneDrawable',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','SCENERY/scenery','SCENERY/display/Drawable','SCENERY/display/Stitcher','SCENERY/display/GreedyStitcher','SCENERY/display/RebuildStitcher','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Stitcher = require( 'SCENERY/display/Stitcher' );
  var GreedyStitcher = require( 'SCENERY/display/GreedyStitcher' );
  var RebuildStitcher = require( 'SCENERY/display/RebuildStitcher' );
  var Util = require( 'SCENERY/util/Util' );
  var useGreedyStitcher = true;
  function BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
    this.initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
  }
  scenery.register( 'BackboneDrawable', BackboneDrawable );
  inherit( Drawable, BackboneDrawable, {
    initialize: function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
      Drawable.call( this, renderer );
      this.display = display;
      this.forceAcceleration = false;
      this.backboneInstance = backboneInstance;
      this.transformRootInstance = transformRootInstance;
      this.filterRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getFilterRootInstance() : backboneInstance;
      this.transformRootAncestorInstance = backboneInstance.parent ? backboneInstance.parent.getTransformRootInstance() : backboneInstance;
      this.willApplyTransform = this.transformRootAncestorInstance !== this.transformRootInstance;
      this.willApplyFilters = this.filterRootAncestorInstance !== this.backboneInstance;
      this.transformListener = this.transformListener || this.markTransformDirty.bind( this );
      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.addListener( this.transformListener ); // when our relative transform changes, notify us in the pre-repaint phase
        this.backboneInstance.relativeTransform.addPrecompute(); // trigger precomputation of the relative transform, since we will always need it when it is updated
      }
      this.backboneVisibilityListener = this.backboneVisibilityListener || this.updateBackboneVisibility.bind( this );
      this.backboneInstance.onStatic( 'relativeVisibility', this.backboneVisibilityListener );
      this.updateBackboneVisibility();
      this.visibilityDirty = true;
      this.renderer = renderer;
      this.domElement = isDisplayRoot ? display._domElement : BackboneDrawable.createDivBackbone();
      this.isDisplayRoot = isDisplayRoot;
      this.dirtyDrawables = cleanArray( this.dirtyDrawables );
      Util.prepareForTransform( this.domElement, this.forceAcceleration );
      this.watchedFilterNodes = cleanArray( this.watchedFilterNodes );
      this.opacityDirty = true;
      this.clipDirty = true;
      this.opacityDirtyListener = this.opacityDirtyListener || this.markOpacityDirty.bind( this );
      this.clipDirtyListener = this.clipDirtyListener || this.markClipDirty.bind( this );
      if ( this.willApplyFilters ) {
        assert && assert( this.filterRootAncestorInstance.trail.nodes.length < this.backboneInstance.trail.nodes.length,
          'Our backboneInstance should be deeper if we are applying filters' );
        for ( var instance = this.backboneInstance; instance !== this.filterRootAncestorInstance; instance = instance.parent ) {
          var node = instance.node;
          this.watchedFilterNodes.push( node );
          node.onStatic( 'opacity', this.opacityDirtyListener );
          node.onStatic( 'clip', this.clipDirtyListener );
        }
      }
      this.lastZIndex = 0; // our last zIndex is stored, so that overlays can be added easily
      this.blocks = this.blocks || []; // we are responsible for their disposal
      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;
      this.removedDrawables = false;
      this.stitcher = this.stitcher || ( useGreedyStitcher ? new GreedyStitcher() : new RebuildStitcher() );
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'initialized ' + this.toString() );
      return this; // chaining
    },
    dispose: function() {
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.push();
      while ( this.watchedFilterNodes.length ) {
        var node = this.watchedFilterNodes.pop();
        node.offStatic( 'opacity', this.opacityDirtyListener );
        node.offStatic( 'clip', this.clipDirtyListener );
      }
      this.backboneInstance.offStatic( 'relativeVisibility', this.backboneVisibilityListener );
      if ( !this.removedDrawables ) {
        for ( var d = this.previousFirstDrawable; d !== null; d = d.nextDrawable ) {
          d.parentDrawable.removeDrawable( d );
          if ( d === this.previousLastDrawable ) { break; }
        }
      }
      this.markBlocksForDisposal();
      if ( this.willApplyTransform ) {
        this.backboneInstance.relativeTransform.removeListener( this.transformListener );
        this.backboneInstance.relativeTransform.removePrecompute();
      }
      this.backboneInstance = null;
      this.transformRootInstance = null;
      this.filterRootAncestorInstance = null;
      this.transformRootAncestorInstance = null;
      cleanArray( this.dirtyDrawables );
      cleanArray( this.watchedFilterNodes );
      this.previousFirstDrawable = null;
      this.previousLastDrawable = null;
      Drawable.prototype.dispose.call( this );
      sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.pop();
    },
    markBlocksForDisposal: function() {
      while ( this.blocks.length ) {
        var block = this.blocks.pop();
        sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( this.toString() + ' removing block: ' + block.toString() );
        if ( block.domElement.parentNode === this.domElement ) {
          this.domElement.removeChild( block.domElement );
        }
        block.markForDisposal( this.display );
      }
    },
    updateBackboneVisibility: function() {
      this.visible = this.backboneInstance.relativeVisible;
      if ( !this.visibilityDirty ) {
        this.visibilityDirty = true;
        this.markDirty();
      }
    },
    markForDisposal: function( display ) {
      for ( var d = this.previousFirstDrawable; d !== null; d = d.oldNextDrawable ) {
        d.notePendingRemoval( this.display );
        if ( d === this.previousLastDrawable ) { break; }
      }
      this.removedDrawables = true;
      Drawable.prototype.markForDisposal.call( this, display );
    },
    markDirtyDrawable: function( drawable ) {
      if ( assert ) {
        this.display.ensureNotPainting();
      }
      this.dirtyDrawables.push( drawable );
      this.markDirty();
    },
    markTransformDirty: function() {
      assert && assert( this.willApplyTransform, 'Sanity check for willApplyTransform' );
      scenery.Util.applyPreparedTransform( this.backboneInstance.relativeTransform.matrix, this.domElement, this.forceAcceleration );
    },
    markOpacityDirty: function() {
      if ( !this.opacityDirty ) {
        this.opacityDirty = true;
        this.markDirty();
      }
    },
    markClipDirty: function() {
      if ( !this.clipDirty ) {
        this.clipDirty = true;
        this.markDirty();
      }
    },
    update: function() {
      if ( this.dirty && !this.disposed ) {
        this.dirty = false;
        while ( this.dirtyDrawables.length ) {
          this.dirtyDrawables.pop().update();
        }
        if ( this.opacityDirty ) {
          this.opacityDirty = false;
          var filterOpacity = this.willApplyFilters ? this.getFilterOpacity() : 1;
          this.domElement.style.opacity = ( filterOpacity !== 1 ) ? filterOpacity : '';
        }
        if ( this.visibilityDirty ) {
          this.visibilityDirty = false;
          this.domElement.style.display = this.visible ? '' : 'none';
        }
        if ( this.clipDirty ) {
          this.clipDirty = false;
        }
      }
    },
    getFilterOpacity: function() {
      var opacity = 1;
      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        opacity *= this.watchedFilterNodes[ i ].getOpacity();
      }
      return opacity;
    },
    getFilterVisibility: function() {
      var len = this.watchedFilterNodes.length;
      for ( var i = 0; i < len; i++ ) {
        if ( !this.watchedFilterNodes[ i ].isVisible() ) {
          return false;
        }
      }
      return true;
    },
    getFilterClip: function() {
      var clip = '';
      return clip;
    },
    reindexBlocks: function() {
      var zIndex = 0; // don't start below 1 (we ensure > in loop)
      for ( var k = 0; k < this.blocks.length; k++ ) {
        var block = this.blocks[ k ];
        if ( block.zIndex <= zIndex ) {
          var newIndex = ( k + 1 < this.blocks.length && this.blocks[ k + 1 ].zIndex - 1 > zIndex ) ?
                         Math.ceil( ( zIndex + this.blocks[ k + 1 ].zIndex ) / 2 ) :
                         zIndex + 20;
          block.domElement.style.zIndex = block.zIndex = newIndex;
        }
        zIndex = block.zIndex;
        if ( assert ) {
          assert( this.blocks[ k ].zIndex % 1 === 0, 'z-indices should be integers' );
          assert( this.blocks[ k ].zIndex > 0, 'z-indices should be greater than zero for our needs (see spec)' );
          if ( k > 0 ) {
            assert( this.blocks[ k - 1 ].zIndex < this.blocks[ k ].zIndex, 'z-indices should be strictly increasing' );
          }
        }
      }
      this.lastZIndex = zIndex + 1;
    },
    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
      if ( firstChangeInterval === null || lastChangeInterval === null ) {
        assert && assert( firstChangeInterval === null );
        assert && assert( lastChangeInterval === null );
        return;
      }
      assert && assert( lastChangeInterval.nextChangeInterval === null, 'This allows us to have less checks in the loop' );
      if ( sceneryLog && sceneryLog.Stitch ) {
        sceneryLog.Stitch( 'Stitch intervals before constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }
      var lastNonemptyInterval = null;
      var interval = firstChangeInterval;
      var intervalsChanged = false;
      while ( interval ) {
        intervalsChanged = interval.constrict() || intervalsChanged;
        if ( interval.isEmpty() ) {
          assert && assert( intervalsChanged );
          if ( lastNonemptyInterval ) {
            lastNonemptyInterval.nextChangeInterval = interval.nextChangeInterval;
          }
        }
        else {
          if ( !lastNonemptyInterval ) {
            firstChangeInterval = interval;
          }
          lastNonemptyInterval = interval;
        }
        interval = interval.nextChangeInterval;
      }
      if ( !lastNonemptyInterval ) {
        return;
      }
      lastChangeInterval = lastNonemptyInterval;
      lastChangeInterval.nextChangeInterval = null;
      if ( sceneryLog && sceneryLog.Stitch && intervalsChanged ) {
        sceneryLog.Stitch( 'Stitch intervals after constricting: ' + this.toString() );
        sceneryLog.push();
        Stitcher.debugIntervals( firstChangeInterval );
        sceneryLog.pop();
      }
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfStitchCount++;
        var dInterval = firstChangeInterval;
        while ( dInterval ) {
          this.display.perfIntervalCount++;
          this.display.perfDrawableOldIntervalCount += dInterval.getOldInternalDrawableCount( this.previousFirstDrawable, this.previousLastDrawable );
          this.display.perfDrawableNewIntervalCount += dInterval.getNewInternalDrawableCount( firstDrawable, lastDrawable );
          dInterval = dInterval.nextChangeInterval;
        }
      }
      this.stitcher.stitch( this, firstDrawable, lastDrawable, this.previousFirstDrawable, this.previousLastDrawable, firstChangeInterval, lastChangeInterval );
    },
    audit: function( allowPendingBlock, allowPendingList, allowDirty ) {
      if ( assertSlow ) {
        Drawable.prototype.audit.call( this, allowPendingBlock, allowPendingList, allowDirty );
        assertSlow && assertSlow( this.backboneInstance.isBackbone, 'We should reference an instance that requires a backbone' );
        assertSlow && assertSlow( this.transformRootInstance.isTransformed, 'Transform root should be transformed' );
        for ( var i = 0; i < this.blocks.length; i++ ) {
          this.blocks[ i ].audit( allowPendingBlock, allowPendingList, allowDirty );
        }
      }
    }
  } );
  BackboneDrawable.createDivBackbone = function() {
    var div = document.createElement( 'div' );
    div.style.position = 'absolute';
    div.style.left = '0';
    div.style.top = '0';
    div.style.width = '0';
    div.style.height = '0';
    return div;
  };
  BackboneDrawable.repurposeBackboneContainer = function( element ) {
    if ( element.style.position !== 'relative' || element.style.position !== 'absolute' ) {
      element.style.position = 'relative';
    }
    element.style.left = '0';
    element.style.top = '0';
    return element;
  };
  Poolable.mixin( BackboneDrawable, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from pool' );
          return pool.pop().initialize( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
        else {
          sceneryLog && sceneryLog.BackboneDrawable && sceneryLog.BackboneDrawable( 'new from constructor' );
          return new BackboneDrawable( display, backboneInstance, transformRootInstance, renderer, isDisplayRoot );
        }
      };
    }
  } );
  return BackboneDrawable;
} );
define( 'SCENERY/display/ChangeInterval',['require','PHET_CORE/inherit','PHET_CORE/Poolable','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  function ChangeInterval( drawableBefore, drawableAfter ) {
    this.initialize( drawableBefore, drawableAfter );
  }
  scenery.register( 'ChangeInterval', ChangeInterval );
  inherit( Object, ChangeInterval, {
    initialize: function( drawableBefore, drawableAfter ) {
      assert && assert( drawableBefore === null || ( drawableBefore instanceof Drawable ),
        'drawableBefore can either be null to indicate that there is no un-changed drawable before our changes, ' +
        'or it can reference an un-changed drawable' );
      assert && assert( drawableAfter === null || ( drawableAfter instanceof Drawable ),
        'drawableAfter can either be null to indicate that there is no un-changed drawable after our changes, ' +
        'or it can reference an un-changed drawable' );
      this.nextChangeInterval = null;
      this.drawableBefore = drawableBefore;
      this.drawableAfter = drawableAfter;
      this.collapsedEmpty = false;
      return this;
    },
    dispose: function() {
      this.nextChangeInterval = null;
      this.drawableBefore = null;
      this.drawableAfter = null;
      this.freeToPool();
    },
    constrict: function() {
      var changed = false;
      if ( this.isEmpty() ) { return true; }
      while ( this.drawableBefore && this.drawableBefore.nextDrawable === this.drawableBefore.oldNextDrawable ) {
        this.drawableBefore = this.drawableBefore.nextDrawable;
        changed = true;
        if ( !this.drawableBefore ) {
          assert && assert( !this.drawableAfter );
          this.collapsedEmpty = true;
        }
        if ( this.isEmpty() ) { return true; }
      }
      while ( this.drawableAfter && this.drawableAfter.previousDrawable === this.drawableAfter.oldPreviousDrawable ) {
        this.drawableAfter = this.drawableAfter.previousDrawable;
        changed = true;
        if ( !this.drawableAfter ) {
          assert && assert( !this.drawableBefore );
          this.collapsedEmpty = true;
        }
        if ( this.isEmpty() ) { return true; }
      }
      return changed;
    },
    isEmpty: function() {
      return this.collapsedEmpty || ( this.drawableBefore !== null && this.drawableBefore === this.drawableAfter );
    },
    getOldInternalDrawableCount: function( oldStitchFirstDrawable, oldStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.oldNextDrawable : oldStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here
      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.oldNextDrawable ) {
        count++;
      }
      return count;
    },
    getNewInternalDrawableCount: function( newStitchFirstDrawable, newStitchLastDrawable ) {
      var firstInclude = this.drawableBefore ? this.drawableBefore.nextDrawable : newStitchFirstDrawable;
      var lastExclude = this.drawableAfter; // null is OK here
      var count = 0;
      for ( var drawable = firstInclude; drawable !== lastExclude; drawable = drawable.nextDrawable ) {
        count++;
      }
      return count;
    }
  } );
  Poolable.mixin( ChangeInterval, {
    constructorDuplicateFactory: function( pool ) {
      return function( drawableBefore, drawableAfter ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from pool' );
          return pool.pop().initialize( drawableBefore, drawableAfter );
        }
        else {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'new from constructor' );
          return new ChangeInterval( drawableBefore, drawableAfter );
        }
      };
    }
  } );
  ChangeInterval.newForDisplay = function( drawableBefore, drawableAfter, display ) {
    var changeInterval = ChangeInterval.createFromPool( drawableBefore, drawableAfter );
    display.markChangeIntervalToDispose( changeInterval );
    return changeInterval;
  };
  return ChangeInterval;
} );
define( 'SCENERY/display/RelativeTransform',['require','PHET_CORE/inherit','PHET_CORE/cleanArray','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  function RelativeTransform( instance ) {
    this.instance = instance;
  }
  scenery.register( 'RelativeTransform', RelativeTransform );
  inherit( Object, RelativeTransform, {
    initialize: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail && trail.lastNode();
      this.transformDirty = true; // whether the node's transform has changed (until the pre-repaint phase)
      this.nodeTransformListener = this.nodeTransformListener || this.onNodeTransformDirty.bind( this );
      this.matrix = this.matrix || Matrix3.identity();
      this.relativeSelfDirty = true;
      this.relativeChildrenListenersCount = 0;
      this.relativePrecomputeCount = 0;
      this.relativeChildrenPrecomputeCount = 0;
      this.relativeFrameId = -1;
      this.relativeChildDirtyFrame = display ? display._frameId : 0;
      this.relativeTransformListeners = cleanArray( this.relativeTransformListeners );
      return this; // allow chaining
    },
    get parent() {
      return this.instance.parent ? this.instance.parent.relativeTransform : null;
    },
    insertInstance: function( instance, index ) {
      if ( instance.stateless ) {
        assert && assert( !instance.relativeTransform.hasAncestorListenerNeed(),
          'We only track changes properly if stateless instances do not have needs' );
        assert && assert( !instance.relativeTransform.hasAncestorComputeNeed(),
          'We only track changes properly if stateless instances do not have needs' );
      }
      else {
        if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
          this.incrementTransformListenerChildren();
        }
        if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
          this.incrementTransformPrecomputeChildren();
        }
      }
      instance.relativeTransform.forceMarkTransformDirty();
    },
    removeInstanceWithIndex: function( instance, index ) {
      if ( instance.relativeTransform.hasAncestorListenerNeed() ) {
        this.decrementTransformListenerChildren();
      }
      if ( instance.relativeTransform.hasAncestorComputeNeed() ) {
        this.decrementTransformPrecomputeChildren();
      }
    },
    attachNodeListeners: function() {
      this.node.onStatic( 'transform', this.nodeTransformListener );
    },
    detachNodeListeners: function() {
      this.node.offStatic( 'transform', this.nodeTransformListener );
    },
    hasDescendantListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenListenersCount > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
    },
    hasAncestorListenerNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeTransformListeners.length > 0;
      }
      else {
        return this.relativeChildrenListenersCount > 0 || this.relativeTransformListeners.length > 0;
      }
    },
    hasSelfListenerNeed: function() {
      return this.relativeTransformListeners.length > 0;
    },
    incrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();
      this.relativeChildrenListenersCount++;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );
        this.parent && this.parent.incrementTransformListenerChildren();
      }
    },
    decrementTransformListenerChildren: function() {
      var before = this.hasAncestorListenerNeed();
      this.relativeChildrenListenersCount--;
      if ( before !== this.hasAncestorListenerNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );
        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },
    addListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();
      this.relativeTransformListeners.push( listener );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.incrementTransformListenerChildren();
        if ( !this.hasAncestorComputeNeed() ) {
          this.forceMarkTransformDirty();
        }
      }
    },
    removeListener: function( listener ) {
      var before = this.hasAncestorListenerNeed();
      this.relativeTransformListeners.splice( _.indexOf( this.relativeTransformListeners, listener ), 1 );
      if ( before !== this.hasAncestorListenerNeed() ) {
        this.parent && this.parent.decrementTransformListenerChildren();
      }
    },
    hasDescendantComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativeChildrenPrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
    },
    hasAncestorComputeNeed: function() {
      if ( this.instance.isTransformed ) {
        return this.relativePrecomputeCount > 0;
      }
      else {
        return this.relativeChildrenPrecomputeCount > 0 || this.relativePrecomputeCount > 0;
      }
    },
    hasSelfComputeNeed: function() {
      return this.relativePrecomputeCount > 0;
    },
    incrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();
      this.relativeChildrenPrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );
        this.parent && this.parent.incrementTransformPrecomputeChildren();
      }
    },
    decrementTransformPrecomputeChildren: function() {
      var before = this.hasAncestorComputeNeed();
      this.relativeChildrenPrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        assert && assert( !this.instance.isTransformed, 'Should not be a change in need if we have the isTransformed flag' );
        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },
    addPrecompute: function() {
      var before = this.hasAncestorComputeNeed();
      this.relativePrecomputeCount++;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.incrementTransformPrecomputeChildren();
        if ( !this.hasAncestorListenerNeed() ) {
          this.forceMarkTransformDirty();
        }
      }
    },
    removePrecompute: function() {
      var before = this.hasAncestorComputeNeed();
      this.relativePrecomputeCount--;
      if ( before !== this.hasAncestorComputeNeed() ) {
        this.parent && this.parent.decrementTransformPrecomputeChildren();
      }
    },
    onNodeTransformDirty: function() {
      if ( !this.transformDirty ) {
        this.forceMarkTransformDirty();
      }
    },
    forceMarkTransformDirty: function() {
      this.transformDirty = true;
      this.relativeSelfDirty = true;
      var frameId = this.display._frameId;
      var instance = this.instance.parent;
      while ( instance && instance.relativeTransform.relativeChildDirtyFrame !== frameId ) {
        var parentInstance = instance.parent;
        var isTransformed = instance.isTransformed;
        instance.relativeTransform.relativeChildDirtyFrame = frameId;
        if ( parentInstance === null ) {
          this.display.markTransformRootDirty( instance, isTransformed );
          break;
        }
        else if ( isTransformed ) {
          this.display.markTransformRootDirty( instance, true ); // passTransform true
          break;
        }
        instance = parentInstance;
      }
    },
    computeRelativeTransform: function() {
      var nodeMatrix = this.node.getMatrix();
      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        this.matrix.set( this.parent.matrix );
        this.matrix.multiplyMatrix( nodeMatrix );
      }
      else {
        this.matrix.set( nodeMatrix );
      }
      this.relativeFrameId = this.display._frameId;
      this.relativeSelfDirty = false;
    },
    isValidationNotNeeded: function() {
      return this.hasAncestorComputeNeed() || this.relativeFrameId === this.display._frameId;
    },
    validate: function() {
      if ( this.isValidationNotNeeded() ) {
        return;
      }
      if ( this.instance.parent && !this.instance.parent.isTransformed ) {
        this.parent.validate();
      }
      if ( this.relativeSelfDirty ) {
        this.computeRelativeTransform();
        var len = this.instance.children.length;
        for ( var i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.relativeSelfDirty = true;
        }
      }
    },
    updateTransformListenersAndCompute: function( ancestorWasDirty, ancestorIsDirty, frameId, passTransform ) {
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.RelativeTransform(
        'update/compute: ' + this.toString() + ' ' + ancestorWasDirty + ' => ' + ancestorIsDirty +
        ( passTransform ? ' passTransform' : '' ) );
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.push();
      var len;
      var i;
      if ( passTransform ) {
        len = this.instance.children.length;
        for ( i = 0; i < len; i++ ) {
          this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( false, false, frameId, false );
        }
      }
      else {
        var wasDirty = ancestorWasDirty || this.relativeSelfDirty;
        var wasSubtreeDirty = wasDirty || this.relativeChildDirtyFrame === frameId;
        var hasComputeNeed = this.hasDescendantComputeNeed();
        var hasListenerNeed = this.hasDescendantListenerNeed();
        var hasSelfComputeNeed = this.hasSelfComputeNeed();
        var hasSelfListenerNeed = this.hasSelfListenerNeed();
        if ( !hasComputeNeed && wasDirty && !ancestorIsDirty ) {
          this.relativeSelfDirty = true;
        }
        if ( !wasSubtreeDirty || ( !hasComputeNeed && !hasListenerNeed && !hasSelfComputeNeed && !hasSelfListenerNeed ) ) {
          sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
          return;
        }
        if ( wasDirty && ( hasComputeNeed || hasSelfComputeNeed ) ) {
          this.computeRelativeTransform();
        }
        if ( this.transformDirty ) {
          this.transformDirty = false;
        }
        this.notifyRelativeTransformListeners();
        if ( !this.instance.isTransformed || passTransform ) {
          var isDirty = wasDirty && !( hasComputeNeed || hasSelfComputeNeed );
          len = this.instance.children.length;
          for ( i = 0; i < len; i++ ) {
            this.instance.children[ i ].relativeTransform.updateTransformListenersAndCompute( wasDirty, isDirty, frameId, false );
          }
        }
      }
      sceneryLog && sceneryLog.RelativeTransform && sceneryLog.pop();
    },
    notifyRelativeTransformListeners: function() {
      var len = this.relativeTransformListeners.length;
      for ( var i = 0; i < len; i++ ) {
        this.relativeTransformListeners[ i ]();
      }
    },
    audit: function( frameId, allowValidationNotNeededChecks ) {
      function currentRelativeMatrix( instance ) {
        var resultMatrix = Matrix3.dirtyFromPool();
        var nodeMatrix = instance.node.getMatrix();
        if ( !instance.parent ) {
          resultMatrix.set( Matrix3.IDENTITY );
        }
        else if ( !instance.parent.isTransformed ) {
          resultMatrix.set( currentRelativeMatrix( instance.parent ) );
          resultMatrix.multiplyMatrix( nodeMatrix );
        }
        else {
          resultMatrix.set( nodeMatrix );
        }
        return resultMatrix;
      }
      function hasRelativeSelfDirty( instance ) {
        if ( allowValidationNotNeededChecks && instance.isValidationNotNeeded() ) {
          return false;
        }
        return instance.relativeSelfDirty || ( instance.parent && hasRelativeSelfDirty( instance.parent ) );
      }
      if ( assertSlow ) {
        var notifyRelativeCount = 0;
        var precomputeRelativeCount = 0;
        for ( var i = 0; i < this.instance.children.length; i++ ) {
          var childInstance = this.instance.children[ i ];
          if ( childInstance.relativeTransform.hasAncestorListenerNeed() ) {
            notifyRelativeCount++;
          }
          if ( childInstance.relativeTransform.hasAncestorComputeNeed() ) {
            precomputeRelativeCount++;
          }
        }
        assertSlow( notifyRelativeCount === this.relativeChildrenListenersCount,
          'Relative listener count invariant' );
        assertSlow( precomputeRelativeCount === this.relativeChildrenPrecomputeCount,
          'Relative precompute count invariant' );
        assertSlow( !this.parent || this.instance.isTransformed || ( this.relativeChildDirtyFrame !== frameId ) ||
                    ( this.parent.relativeChildDirtyFrame === frameId ),
          'If we have a parent, we need to hold the invariant ' +
          'this.relativeChildDirtyFrame => parent.relativeChildDirtyFrame' );
        if ( !allowValidationNotNeededChecks && !hasRelativeSelfDirty( this ) ) {
          var matrix = currentRelativeMatrix( this );
          assertSlow( matrix.equals( this.matrix ), 'If there is no relativeSelfDirty flag set here or in our' +
                                                    ' ancestors, our matrix should be up-to-date' );
        }
      }
    }
  } );
  return RelativeTransform;
} );
define( 'SCENERY/display/Fittability',['require','PHET_CORE/inherit','AXON/Emitter','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var scenery = require( 'SCENERY/scenery' );
  function Fittability( instance ) {
    this.instance = instance;
  }
  scenery.register( 'Fittability', Fittability );
  inherit( Object, Fittability, {
    initialize: function( display, trail ) {
      this.display = display; // @private {Display}
      this.trail = trail; // @private {Trail}
      this.node = trail && trail.lastNode(); // @private {Node}
      this.selfFittable = !!trail && this.isSelfFitSupported();
      this.ancestorsFittable = this.selfFittable;
      this.subtreeUnfittableCount = this.selfFittable ? 0 : 1;
      this.subtreeFittabilityChange = this.subtreeFittabilityChange || new Emitter();
      return this; // allow chaining
    },
    get parent() {
      return this.instance.parent ? this.instance.parent.fittability : null;
    },
    checkSelfFittability: function() {
      var newSelfFittable = this.isSelfFitSupported();
      if ( this.selfFittable !== newSelfFittable ) {
        this.updateSelfFittable();
      }
    },
    isSelfFitSupported: function() {
      return !this.node.isPreventFit();
    },
    markSubtreeFittable: function() {
      if ( !this.selfFittable ) {
        return;
      }
      this.ancestorsFittable = true;
      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].fittability.markSubtreeFittable();
      }
      this.instance.updateDrawableFittability( true );
    },
    markSubtreeUnfittable: function() {
      if ( !this.ancestorsFittable ) {
        return;
      }
      this.ancestorsFittable = false;
      var children = this.instance.children;
      for ( var i = 0; i < children.length; i++ ) {
        children[ i ].fittability.markSubtreeUnfittable();
      }
      this.instance.updateDrawableFittability( false );
    },
    updateSelfFittable: function() {
      var newSelfFittable = this.isSelfFitSupported();
      assert && assert( this.selfFittable !== newSelfFittable );
      this.selfFittable = newSelfFittable;
      if ( this.selfFittable && ( !this.parent || this.parent.ancestorsFittable ) ) {
        this.markSubtreeFittable();
      }
      else if ( !this.selfFittable ) {
        this.markSubtreeUnfittable();
      }
      if ( this.selfFittable ) {
        this.decrementSubtreeUnfittableCount();
      }
      else {
        this.incrementSubtreeUnfittableCount();
      }
    },
    incrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount++;
      if ( this.subtreeUnfittableCount === 1 ) {
        this.parent && this.parent.incrementSubtreeUnfittableCount();
        this.subtreeFittabilityChange.emit();
      }
    },
    decrementSubtreeUnfittableCount: function() {
      this.subtreeUnfittableCount--;
      if ( this.subtreeUnfittableCount === 0 ) {
        this.parent && this.parent.decrementSubtreeUnfittableCount();
        this.subtreeFittabilityChange.emit();
      }
    },
    onInsert: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeUnfittable();
      }
      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.incrementSubtreeUnfittableCount();
      }
    },
    onRemove: function( childFittability ) {
      if ( !this.ancestorsFittable ) {
        childFittability.markSubtreeFittable();
      }
      if ( childFittability.subtreeUnfittableCount > 0 ) {
        this.decrementSubtreeUnfittableCount();
      }
    },
    audit: function() {
      if ( assertSlow ) {
        assertSlow( this.selfFittable === this.isSelfFitSupported(),
          'selfFittable diverged from isSelfFitSupported()' );
        assertSlow( this.ancestorsFittable === ( ( this.parent ? this.parent.ancestorsFittable : true ) && this.selfFittable ),
          'Our ancestorsFittable should be false if our parent or our self is not fittable.' );
        var subtreeUnfittableCount = 0;
        if ( !this.selfFittable ) {
          subtreeUnfittableCount++;
        }
        _.each( this.instance.children, function( instance ) {
          if ( instance.fittability.subtreeUnfittableCount > 0 ) {
            subtreeUnfittableCount++;
          }
        } );
        assertSlow( this.subtreeUnfittableCount === subtreeUnfittableCount, 'Incorrect subtreeUnfittableCount' );
      }
    }
  } );
  return Fittability;
} );
define( 'SCENERY/display/Instance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','PHET_CORE/cleanArray','PHET_CORE/arrayRemove','SCENERY/scenery','SCENERY/display/ChangeInterval','SCENERY/display/Drawable','SCENERY/display/Renderer','SCENERY/display/RelativeTransform','SCENERY/display/Fittability','SCENERY/util/Util','AXON/Events'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var arrayRemove = require( 'PHET_CORE/arrayRemove' );
  var scenery = require( 'SCENERY/scenery' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var RelativeTransform = require( 'SCENERY/display/RelativeTransform' );
  var Fittability = require( 'SCENERY/display/Fittability' );
  var Util = require( 'SCENERY/util/Util' );
  var Events = require( 'AXON/Events' );
  var globalIdCounter = 1;
  var defaultPreferredRenderers = Renderer.createOrderBitmask(
    Renderer.bitmaskSVG, Renderer.bitmaskCanvas, Renderer.bitmaskDOM, Renderer.bitmaskWebGL );
  function Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
    Events.call( this );
    this.active = false;
    this.initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
  }
  scenery.register( 'Instance', Instance );
  inherit( Events, Instance, {
    initialize: function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
      assert && assert( !this.active,
        'We should never try to initialize an already active object' );
      trail.setImmutable();
      this.id = this.id || globalIdCounter++;
      this.isWebGLSupported = display._allowWebGL && Util.isWebGLSupported;
      this.relativeTransform = ( this.relativeTransform || new RelativeTransform( this ) );
      this.fittability = ( this.fittability || new Fittability( this ) );
      this.visible = true; // global visibility (whether this instance will end up appearing on the display)
      this.relativeVisible = true; // relative visibility (ignores the closest ancestral visibility root and below)
      this.selfVisible = true; // like relative visibility, but is always true if we are a visibility root
      this.visibilityDirty = true; // entire subtree of visibility will need to be updated
      this.childVisibilityDirty = true; // an ancestor needs its visibility updated
      this.branchIndexMap = {}; // TODO: Can we not recreate an object?
      this.branchIndexReferences = cleanArray( this.branchIndexReferences );
      this.addRemoveCounter = 0;
      this.stitchChangeFrame = display._frameId;
      this.stitchChangeBefore = 0;
      this.stitchChangeAfter = 0;
      this.stitchChangeOnChildren = 0;
      this.stitchChangeIncluded = false;
      this.childInsertedListener = this.childInsertedListener || this.onChildInserted.bind( this );
      this.childRemovedListener = this.childRemovedListener || this.onChildRemoved.bind( this );
      this.visibilityListener = this.visibilityListener || this.onVisibilityChange.bind( this );
      this.markRenderStateDirtyListener = this.markRenderStateDirtyListener || this.markRenderStateDirty.bind( this );
      this.cleanInstance( display, trail );
      this.node.addInstance( this );
      this.externalReferenceCount = 0;
      this.stateless = true; // {boolean} - Whether we have had our state initialized yet
      this.isDisplayRoot = isDisplayRoot; // {boolean} - Whether we are the root instance for a Display
      this.isSharedCanvasCacheRoot = isSharedCanvasCacheRoot; // {boolean} - Whether we are the root of a Canvas cache
      this.preferredRenderers = 0; // {number} - Packed renderer order bitmask (what our renderer preferences are)
      this.isUnderCanvasCache = isSharedCanvasCacheRoot; // {boolean} - Whether we are beneath a Canvas cache (Canvas required)
      this.isBackbone = false; // {boolean} - Whether we will have a BackboneDrawable group drawable
      this.isTransformed = false;  // {boolean} - Whether this instance creates a new "root" for the relative trail transforms
      this.isVisibilityApplied = false; // {boolean} - Whether this instance handles visibility with a group drawable
      this.isInstanceCanvasCache = false; // {boolean} - Whether we have a Canvas cache specific to this instance's position
      this.isSharedCanvasCachePlaceholder = false; // {boolean}
      this.isSharedCanvasCacheSelf = isSharedCanvasCacheRoot; // {boolean}
      this.selfRenderer = 0; // {number} Renderer bitmask for the 'self' drawable (if our Node is painted)
      this.groupRenderer = 0; // {number} Renderer bitmask for the 'group' drawable (if applicable)
      this.sharedCacheRenderer = 0; // {number} Renderer bitmask for the cache drawable (if applicable)
      this.renderStateDirtyFrame = display._frameId; // {number} - When equal to the current frame it is considered "dirty"
      this.skipPruningFrame = display._frameId; // {number} - When equal to the current frame we can't prune at this instance
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'initialized ' + this.toString() );
      this.active = true;
      return this;
    },
    cleanInstance: function( display, trail ) {
      this.display = display;
      this.trail = trail;
      this.node = trail ? trail.lastNode() : null;
      this.parent = null; // will be set as needed
      this.oldParent = null; // set when removed from us, so that we can easily reattach it when necessary
      this.children = cleanArray( this.children ); // Array[Instance].
      this.sharedCacheInstance = null; // reference to a shared cache instance (different than a child)
      this.relativeTransform.initialize( display, trail );
      this.fittability.initialize( display, trail );
      this.instanceRemovalCheckList = cleanArray( this.instanceRemovalCheckList );
      this.selfDrawable = null;
      this.groupDrawable = null; // e.g. backbone or non-shared cache
      this.sharedCacheDrawable = null; // our drawable if we are a shared cache
      this.firstDrawable = null;
      this.lastDrawable = null;
      this.firstInnerDrawable = null;
      this.lastInnerDrawable = null;
      this.svgGroups = cleanArray( this.svgGroups );
      this.cleanSyncTreeResults();
    },
    cleanSyncTreeResults: function() {
      this.beforeStableIndex = this.children.length;
      this.afterStableIndex = -1;
      this.firstChangeInterval = null;
      this.lastChangeInterval = null;
      this.incompatibleStateChange = false; // {boolean} - Whether we need to recreate the instance tree
      this.groupChanged = false; // {boolean} - Whether we need to force a rebuild of the group drawable
      this.cascadingStateChange = false; // {boolean} - Whether we had a render state change that requires visiting all children
      this.anyStateChange = false; // {boolean} - Whether there was any change of rendering state with the last updateRenderingState()
    },
    updateRenderingState: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'updateRenderingState ' + this.toString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'old: ' + this.getStateString() );
      var wasBackbone = this.isBackbone;
      var wasTransformed = this.isTransformed;
      var wasVisibilityApplied = this.isVisibilityApplied;
      var wasInstanceCanvasCache = this.isInstanceCanvasCache;
      var wasSharedCanvasCacheSelf = this.isSharedCanvasCacheSelf;
      var wasSharedCanvasCachePlaceholder = this.isSharedCanvasCachePlaceholder;
      var wasUnderCanvasCache = this.isUnderCanvasCache;
      var oldSelfRenderer = this.selfRenderer;
      var oldGroupRenderer = this.groupRenderer;
      var oldSharedCacheRenderer = this.sharedCacheRenderer;
      var oldPreferredRenderers = this.preferredRenderers;
      this.isBackbone = false;
      this.isTransformed = false;
      this.isVisibilityApplied = false;
      this.isInstanceCanvasCache = false;
      this.isSharedCanvasCacheSelf = false;
      this.isSharedCanvasCachePlaceholder = false;
      this.selfRenderer = 0;
      this.groupRenderer = 0;
      this.sharedCacheRenderer = 0;
      var hints = this.node._hints;
      this.isUnderCanvasCache = this.isSharedCanvasCacheRoot ||
                                ( this.parent ? ( this.parent.isUnderCanvasCache || this.parent.isInstanceCanvasCache || this.parent.isSharedCanvasCacheSelf ) : false );
      this.preferredRenderers = this.parent ? this.parent.preferredRenderers : defaultPreferredRenderers;
      if ( hints.renderer ) {
        this.preferredRenderers = Renderer.pushOrderBitmask( this.preferredRenderers, hints.renderer );
      }
      var hasClip = this.node.hasClipArea();
      var hasTransparency = this.node.opacity !== 1 || hints.usesOpacity;
      var requiresSplit = hints.requireElement || hints.cssTransform || hints.layerSplit;
      var backboneRequired = this.isDisplayRoot || ( !this.isUnderCanvasCache && requiresSplit );
      var applyTransparencyWithBlock = !backboneRequired &&
                                       ( hasTransparency || hasClip ) &&
                                       ( this.node._rendererSummary.isSubtreeRenderedExclusivelySVG( this.preferredRenderers ) ||
                                         this.node._rendererSummary.isSubtreeRenderedExclusivelyCanvas( this.preferredRenderers ) );
      var useBackbone = applyTransparencyWithBlock ? false : ( backboneRequired || hasTransparency || hasClip );
      if ( useBackbone ) {
        this.isBackbone = true;
        this.isVisibilityApplied = true;
        this.isTransformed = this.isDisplayRoot || !!hints.cssTransform; // for now, only trigger CSS transform if we have the specific hint
        this.groupRenderer = Renderer.bitmaskDOM; // probably won't be used
      }
      else if ( !applyTransparencyWithBlock && ( hasTransparency || hasClip || hints.canvasCache ) ) {
        assert && assert( this.node._rendererSummary.isSingleCanvasSupported(),
          'hints.canvasCache provided, but not all node contents can be rendered with Canvas under ' +
          this.node.constructor.name );
        if ( hints.singleCache ) {
          if ( this.isSharedCanvasCacheRoot ) {
            this.isSharedCanvasCacheSelf = true;
            this.sharedCacheRenderer = this.isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
          }
          else {
            assert && assert( this.node._rendererSummary.areBoundsValid(),
              'hints.singleCache provided, but not all node contents have valid bounds under ' +
              this.node.constructor.name );
            this.isSharedCanvasCachePlaceholder = true;
          }
        }
        else {
          this.isInstanceCanvasCache = true;
          this.isUnderCanvasCache = true;
          this.groupRenderer = this.isWebGLSupported ? Renderer.bitmaskWebGL : Renderer.bitmaskCanvas;
        }
      }
      if ( this.node.isPainted() ) {
        if ( this.isUnderCanvasCache ) {
          this.selfRenderer = Renderer.bitmaskCanvas;
        }
        else {
          var supportedNodeBitmask = this.node._rendererBitmask;
          if ( !this.isWebGLSupported ) {
            var invalidBitmasks = Renderer.bitmaskWebGL;
            supportedNodeBitmask = supportedNodeBitmask ^ ( supportedNodeBitmask & invalidBitmasks );
          }
          this.selfRenderer = ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 0 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 1 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 2 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskOrder( this.preferredRenderers, 3 ) ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskSVG ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskCanvas ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskDOM ) ||
                              ( supportedNodeBitmask & Renderer.bitmaskWebGL ) ||
                              0;
          assert && assert( this.selfRenderer, 'setSelfRenderer failure?' );
        }
      }
      this.groupChanged = ( wasBackbone !== this.isBackbone ) ||
                          ( wasInstanceCanvasCache !== this.isInstanceCanvasCache ) ||
                          ( wasSharedCanvasCacheSelf !== this.isSharedCanvasCacheSelf );
      this.cascadingStateChange = ( wasUnderCanvasCache !== this.isUnderCanvasCache ) ||
                                  ( oldPreferredRenderers !== this.preferredRenderers );
      this.incompatibleStateChange = ( this.isTransformed !== wasTransformed ) ||
                                     ( this.isSharedCanvasCachePlaceholder !== wasSharedCanvasCachePlaceholder );
      this.anyStateChange = this.groupChanged || this.cascadingStateChange || this.incompatibleStateChange ||
                            ( oldSelfRenderer !== this.selfRenderer ) ||
                            ( oldGroupRenderer !== this.groupRenderer ) ||
                            ( oldSharedCacheRenderer !== this.sharedCacheRenderer );
      if ( wasVisibilityApplied !== this.isVisibilityApplied ) {
        this.visibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }
      this.fittability.checkSelfFittability();
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new: ' + this.getStateString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },
    getStateString: function() {
      var result = 'S[ ' +
                   ( this.isDisplayRoot ? 'displayRoot ' : '' ) +
                   ( this.isBackbone ? 'backbone ' : '' ) +
                   ( this.isInstanceCanvasCache ? 'instanceCache ' : '' ) +
                   ( this.isSharedCanvasCachePlaceholder ? 'sharedCachePlaceholder ' : '' ) +
                   ( this.isSharedCanvasCacheSelf ? 'sharedCacheSelf ' : '' ) +
                   ( this.isTransformed ? 'TR ' : '' ) +
                   ( this.isVisibilityApplied ? 'VIS ' : '' ) +
                   ( this.selfRenderer ? this.selfRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.groupRenderer ? this.groupRenderer.toString( 16 ) : '-' ) + ',' +
                   ( this.sharedCacheRenderer ? this.sharedCacheRenderer.toString( 16 ) : '-' ) + ' ';
      return result + ']';
    },
    baseSyncTree: function() {
      assert && assert( this.isDisplayRoot, 'baseSyncTree() should only be called on the root instance' );
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- START baseSyncTree ' + this.toString() + ' --------' );
      this.syncTree();
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( '-------- END baseSyncTree ' + this.toString() + ' --------' );
      this.cleanSyncTreeResults();
    },
    syncTree: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'syncTree ' + this.toString() + ' ' + this.getStateString() +
                                                                ( this.stateless ? ' (stateless)' : '' ) );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.display.perfSyncTreeCount++;
      }
      assert && assert( !this.parent || !this.parent.stateless, 'We should not have a stateless parent instance' );
      var wasStateless = this.stateless;
      if ( wasStateless ||
           ( this.parent && this.parent.cascadingStateChange ) || // if our parent had cascading state changes, we need to recompute
           ( this.renderStateDirtyFrame === this.display._frameId ) ) { // if our render state is dirty
        this.updateRenderingState();
      }
      else {
        if ( assertSlow ) {
          this.updateRenderingState();
          assertSlow( !this.anyStateChange );
        }
      }
      if ( !wasStateless && this.incompatibleStateChange ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'incompatible instance ' + this.toString() + ' ' + this.getStateString() + ', aborting' );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();
        return false;
      }
      this.stateless = false;
      assert && assert( !wasStateless || this.children.length === 0,
        'We should not have child instances on an instance without state' );
      if ( wasStateless ) {
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }
        this.attachNodeListeners();
      }
      if ( this.isSharedCanvasCachePlaceholder ) {
        this.sharedSyncTree();
      }
      else if ( wasStateless || this.skipPruningFrame === this.display._frameId || this.anyStateChange ) {
        this.prepareChildInstances( wasStateless );
        var oldFirstDrawable = this.firstDrawable;
        var oldLastDrawable = this.lastDrawable;
        var oldFirstInnerDrawable = this.firstInnerDrawable;
        var oldLastInnerDrawable = this.lastInnerDrawable;
        var selfChanged = this.updateSelfDrawable();
        this.localSyncTree( selfChanged );
        if ( assertSlow ) {
          this.auditChangeIntervals( oldFirstInnerDrawable, oldLastInnerDrawable, this.firstInnerDrawable, this.lastInnerDrawable );
        }
        this.groupSyncTree( wasStateless );
        if ( assertSlow ) {
          this.auditChangeIntervals( oldFirstDrawable, oldLastDrawable, this.firstDrawable, this.lastDrawable );
        }
      }
      else {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'pruned' );
      }
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
      return true;
    },
    localSyncTree: function( selfChanged ) {
      var frameId = this.display._frameId;
      var firstDrawable = this.selfDrawable; // possibly null
      var currentDrawable = firstDrawable; // possibly null
      assert && assert( this.firstChangeInterval === null && this.lastChangeInterval === null,
        'sanity checks that cleanSyncTreeResults were called' );
      var firstChangeInterval = null;
      if ( selfChanged ) {
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'self' );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
        firstChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }
      var currentChangeInterval = firstChangeInterval;
      var lastUnchangedDrawable = selfChanged ? null : this.selfDrawable; // possibly null
      for ( var i = 0; i < this.children.length; i++ ) {
        var childInstance = this.children[ i ];
        var isCompatible = childInstance.syncTree();
        if ( !isCompatible ) {
          childInstance = this.updateIncompatibleChildInstance( childInstance, i );
          childInstance.syncTree();
        }
        var includeChildDrawables = childInstance.shouldIncludeInParentDrawables();
        if ( includeChildDrawables ) {
          if ( childInstance.firstDrawable ) {
            if ( currentDrawable ) {
              Drawable.connectDrawables( currentDrawable, childInstance.firstDrawable, this.display );
            }
            else {
              firstDrawable = childInstance.firstDrawable;
            }
            currentDrawable = childInstance.lastDrawable;
          }
        }
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'changes for ' + childInstance.toString() +
                                                                              ' in ' + this.toString() );
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
        var wasIncluded = childInstance.stitchChangeIncluded;
        var isIncluded = includeChildDrawables;
        childInstance.stitchChangeIncluded = isIncluded;
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'included: ' + wasIncluded + ' => ' + isIncluded );
        if ( childInstance.stitchChangeFrame === frameId ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'stitchChangeFrame full change interval' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
          childInstance.firstChangeInterval = childInstance.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }
        else {
          assert && assert( wasIncluded === isIncluded,
            'If we do not have stitchChangeFrame activated, our inclusion should not have changed' );
        }
        var firstChildChangeInterval = childInstance.firstChangeInterval;
        var isBeforeOpen = currentChangeInterval && currentChangeInterval.drawableAfter === null;
        var isAfterOpen = firstChildChangeInterval && firstChildChangeInterval.drawableBefore === null;
        var needsBridge = childInstance.stitchChangeBefore === frameId && !isBeforeOpen && !isAfterOpen;
        if ( needsBridge ) {
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.ChangeInterval( 'bridge' );
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.push();
          var bridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
          if ( currentChangeInterval ) {
            currentChangeInterval.nextChangeInterval = bridge;
          }
          currentChangeInterval = bridge;
          firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          isBeforeOpen = true;
          sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
        }
        if ( wasIncluded || isIncluded ) {
          if ( isBeforeOpen ) {
            if ( firstChildChangeInterval ) {
              if ( firstChildChangeInterval.drawableBefore === null ) {
                currentChangeInterval.drawableAfter = firstChildChangeInterval.drawableAfter;
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval.nextChangeInterval;
                currentChangeInterval = childInstance.lastChangeInterval === firstChildChangeInterval ?
                                        currentChangeInterval : // since we are replacing, don't give an origin reference
                                        childInstance.lastChangeInterval;
              }
              else {
                currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
                currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
                currentChangeInterval = childInstance.lastChangeInterval;
              }
            }
            else {
              currentChangeInterval.drawableAfter = childInstance.firstDrawable; // either null or the correct drawable
            }
          }
          else if ( firstChildChangeInterval ) {
            firstChangeInterval = firstChangeInterval || firstChildChangeInterval; // store if it is the first
            if ( firstChildChangeInterval.drawableBefore === null ) {
              assert && assert( !currentChangeInterval || lastUnchangedDrawable,
                'If we have a current change interval, we should be guaranteed a non-null ' +
                'lastUnchangedDrawable' );
              firstChildChangeInterval.drawableBefore = lastUnchangedDrawable; // either null or the correct drawable
            }
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = firstChildChangeInterval;
            }
            currentChangeInterval = childInstance.lastChangeInterval;
          }
          lastUnchangedDrawable = ( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ?
                                  null :
                                  ( childInstance.lastDrawable ?
                                    childInstance.lastDrawable :
                                    lastUnchangedDrawable );
        }
        if ( i === this.children.length - 1 ) {
          if ( childInstance.stitchChangeAfter === frameId && !( currentChangeInterval && currentChangeInterval.drawableAfter === null ) ) {
            var endingBridge = ChangeInterval.newForDisplay( lastUnchangedDrawable, null, this.display );
            if ( currentChangeInterval ) {
              currentChangeInterval.nextChangeInterval = endingBridge;
            }
            currentChangeInterval = endingBridge;
            firstChangeInterval = firstChangeInterval || currentChangeInterval; // store if it is the first
          }
        }
        childInstance.cleanSyncTreeResults();
        sceneryLog && sceneryLog.ChangeInterval && sceneryLog.pop();
      }
      assert && assert( !!firstChangeInterval === !!currentChangeInterval,
        'Presence of first and current change intervals should be equal' );
      if ( !firstChangeInterval && this.stitchChangeOnChildren === this.display._frameId && this.children.length === 0 ) {
        firstChangeInterval = currentChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
      this.firstChangeInterval = firstChangeInterval;
      this.lastChangeInterval = currentChangeInterval;
      this.firstDrawable = this.firstInnerDrawable = firstDrawable;
      this.lastDrawable = this.lastInnerDrawable = currentDrawable; // either null, or the drawable itself
      if ( assertSlow ) {
        var firstDrawableCheck = null;
        for ( var j = 0; j < this.children.length; j++ ) {
          if ( this.children[ j ].shouldIncludeInParentDrawables() && this.children[ j ].firstDrawable ) {
            firstDrawableCheck = this.children[ j ].firstDrawable;
            break;
          }
        }
        if ( this.selfDrawable ) {
          firstDrawableCheck = this.selfDrawable;
        }
        var lastDrawableCheck = this.selfDrawable;
        for ( var k = this.children.length - 1; k >= 0; k-- ) {
          if ( this.children[ k ].shouldIncludeInParentDrawables() && this.children[ k ].lastDrawable ) {
            lastDrawableCheck = this.children[ k ].lastDrawable;
            break;
          }
        }
        assertSlow( firstDrawableCheck === this.firstDrawable );
        assertSlow( lastDrawableCheck === this.lastDrawable );
      }
    },
    updateSelfDrawable: function() {
      if ( this.node.isPainted() ) {
        var selfRenderer = this.selfRenderer; // our new self renderer bitmask
        if ( !this.selfDrawable || ( ( this.selfDrawable.renderer & selfRenderer & Renderer.bitmaskRendererArea ) === 0 ) ) {
          if ( this.selfDrawable ) {
            sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing old drawable ' + this.selfDrawable.toString() + ' with new renderer' );
            this.selfDrawable.markForDisposal( this.display );
          }
          this.selfDrawable = Renderer.createSelfDrawable( this, this.node, selfRenderer, this.fittability.ancestorsFittable );
          assert && assert( this.selfDrawable );
          return true;
        }
      }
      else {
        assert && assert( this.selfDrawable === null, 'Non-painted nodes should not have a selfDrawable' );
      }
      return false;
    },
    updateIncompatibleChildInstance: function( childInstance, index ) {
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var affectedInstanceCount = childInstance.getDescendantCount() + 1; // +1 for itself
        if ( affectedInstanceCount > 100 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 40 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
        else if ( affectedInstanceCount > 0 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( 'incompatible instance rebuild at ' + this.trail.toPathString() + ': ' + affectedInstanceCount );
        }
      }
      this.display.markInstanceRootForDisposal( childInstance );
      var replacementInstance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childInstance.node, index ), false, false );
      this.replaceInstanceWithIndex( childInstance, replacementInstance, index );
      return replacementInstance;
    },
    groupSyncTree: function( wasStateless ) {
      var groupRenderer = this.groupRenderer;
      assert && assert( ( this.isBackbone ? 1 : 0 ) +
                        ( this.isInstanceCanvasCache ? 1 : 0 ) +
                        ( this.isSharedCanvasCacheSelf ? 1 : 0 ) === ( groupRenderer ? 1 : 0 ),
        'We should have precisely one of these flags set for us to have a groupRenderer' );
      var groupChanged = ( !!groupRenderer !== !!this.groupDrawable ) ||
                         ( !wasStateless && this.groupChanged ) ||
                         ( this.groupDrawable && this.groupDrawable.renderer !== groupRenderer );
      if ( groupChanged ) {
        if ( this.groupDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing group drawable ' + this.groupDrawable.toString() );
          this.groupDrawable.markForDisposal( this.display );
          this.groupDrawable = null;
        }
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
      if ( groupRenderer ) {
        this.firstDrawable && Drawable.disconnectBefore( this.firstDrawable, this.display );
        this.lastDrawable && Drawable.disconnectAfter( this.lastDrawable, this.display );
        if ( this.isBackbone ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.BackboneDrawable.createFromPool( this.display, this, this.getTransformRootInstance(), groupRenderer, this.isDisplayRoot );
            if ( this.isTransformed ) {
              this.display.markTransformRootDirty( this, true );
            }
          }
          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isInstanceCanvasCache ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.InlineCanvasCacheDrawable.createFromPool( groupRenderer, this );
          }
          if ( this.firstChangeInterval ) {
            this.groupDrawable.stitch( this.firstDrawable, this.lastDrawable, this.firstChangeInterval, this.lastChangeInterval );
          }
        }
        else if ( this.isSharedCanvasCacheSelf ) {
          if ( groupChanged ) {
            this.groupDrawable = scenery.CanvasBlock.createFromPool( groupRenderer, this );
          }
        }
        this.groupDrawable.setFittable( this.fittability.ancestorsFittable );
        this.firstDrawable = this.lastDrawable = this.groupDrawable;
      }
      if ( groupChanged ) {
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
      else if ( groupRenderer ) {
        this.firstChangeInterval = this.lastChangeInterval = null;
      }
    },
    sharedSyncTree: function() {
      this.ensureSharedCacheInitialized();
      var sharedCacheRenderer = this.sharedCacheRenderer;
      if ( !this.sharedCacheDrawable || this.sharedCacheDrawable.renderer !== sharedCacheRenderer ) {
        if ( this.sharedCacheDrawable ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'replacing shared cache drawable ' + this.sharedCacheDrawable.toString() );
          this.sharedCacheDrawable.markForDisposal( this.display );
        }
        this.sharedCacheDrawable = new scenery.SharedCanvasCacheDrawable( this.trail, sharedCacheRenderer, this, this.sharedCacheInstance );
        this.firstDrawable = this.sharedCacheDrawable;
        this.lastDrawable = this.sharedCacheDrawable;
        this.firstChangeInterval = this.lastChangeInterval = ChangeInterval.newForDisplay( null, null, this.display );
      }
    },
    prepareChildInstances: function( wasStateless ) {
      while ( this.instanceRemovalCheckList.length ) {
        var instanceToMark = this.instanceRemovalCheckList.pop();
        if ( instanceToMark.addRemoveCounter === -1 ) {
          instanceToMark.addRemoveCounter = 0; // reset it, so we don't mark it for disposal more than once
          this.display.markInstanceRootForDisposal( instanceToMark );
        }
      }
      if ( wasStateless ) {
        for ( var k = 0; k < this.node.children.length; k++ ) {
          var child = this.node.children[ k ];
          this.appendInstance( Instance.createFromPool( this.display, this.trail.copy().addDescendant( child, k ), false, false ) );
        }
      }
    },
    ensureSharedCacheInitialized: function() {
      if ( !this.sharedCacheInstance ) {
        var instanceKey = this.node.getId();
        this.sharedCacheInstance = this.display._sharedCanvasInstances[ instanceKey ];
        if ( !this.sharedCacheInstance ) {
          this.sharedCacheInstance = Instance.createFromPool( this.display, new scenery.Trail( this.node ), false, true );
          this.sharedCacheInstance.syncTree();
          this.display._sharedCanvasInstances[ instanceKey ] = this.sharedCacheInstance;
          this.display.markTransformRootDirty( this.sharedCacheInstance, true );
        }
        this.sharedCacheInstance.externalReferenceCount++;
        if ( this.isTransformed ) {
          this.display.markTransformRootDirty( this, true );
        }
      }
    },
    shouldIncludeInParentDrawables: function() {
      return this.node.isVisible() || !this.node.isExcludeInvisible();
    },
    findPreviousDrawable: function( childIndex ) {
      for ( var i = childIndex - 1; i >= 0; i-- ) {
        var option = this.children[ i ].lastDrawable;
        if ( option !== null ) {
          return option;
        }
      }
      return null;
    },
    findNextDrawable: function( childIndex ) {
      var len = this.children.length;
      for ( var i = childIndex + 1; i < len; i++ ) {
        var option = this.children[ i ].firstDrawable;
        if ( option !== null ) {
          return option;
        }
      }
      return null;
    },
    appendInstance: function( instance ) {
      this.insertInstance( instance, this.children.length );
    },
    insertInstance: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index <= this.children.length,
        'Instance insertion bounds check for index ' + index + ' with previous children length ' +
        this.children.length );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'inserting ' + instance.toString() + ' into ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();
      instance.stitchChangeFrame = this.display._frameId;
      this.stitchChangeOnChildren = this.display._frameId;
      this.children.splice( index, 0, instance );
      instance.parent = this;
      instance.oldParent = this;
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index > this.afterStableIndex ) {
        this.afterStableIndex = index + 1;
      }
      else {
        this.afterStableIndex++;
      }
      this.fittability.onInsert( instance.fittability );
      this.relativeTransform.insertInstance( instance, index );
      this.markChildVisibilityDirty();
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },
    removeInstance: function( instance ) {
      return this.removeInstanceWithIndex( instance, _.indexOf( this.children, instance ) );
    },
    removeInstanceWithIndex: function( instance, index ) {
      assert && assert( instance instanceof Instance );
      assert && assert( index >= 0 && index < this.children.length,
        'Instance removal bounds check for index ' + index + ' with previous children length ' +
        this.children.length );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.InstanceTree(
        'removing ' + instance.toString() + ' from ' + this.toString() );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.push();
      var frameId = this.display._frameId;
      instance.stitchChangeFrame = frameId;
      this.stitchChangeOnChildren = frameId;
      if ( index - 1 >= 0 ) {
        this.children[ index - 1 ].stitchChangeAfter = frameId;
      }
      if ( index + 1 < this.children.length ) {
        this.children[ index + 1 ].stitchChangeBefore = frameId;
      }
      this.children.splice( index, 1 ); // TODO: replace with a 'remove' function call
      instance.parent = null;
      instance.oldParent = this;
      if ( index <= this.beforeStableIndex ) {
        this.beforeStableIndex = index - 1;
      }
      if ( index >= this.afterStableIndex ) {
        this.afterStableIndex = index;
      }
      else {
        this.afterStableIndex--;
      }
      this.fittability.onRemove( instance.fittability );
      this.relativeTransform.removeInstanceWithIndex( instance, index );
      sceneryLog && sceneryLog.InstanceTree && sceneryLog.pop();
    },
    replaceInstanceWithIndex: function( childInstance, replacementInstance, index ) {
      this.removeInstanceWithIndex( childInstance, index );
      this.insertInstance( replacementInstance, index );
    },
    findChildInstanceOnNode: function( node ) {
      var instances = node.getInstances();
      for ( var i = 0; i < instances.length; i++ ) {
        if ( instances[ i ].oldParent === this ) {
          return instances[ i ];
        }
      }
      return null;
    },
    onChildInserted: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'inserting child node ' + childNode.constructor.name + '#' + childNode.id + ' into ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      var instance = this.findChildInstanceOnNode( childNode );
      if ( instance ) {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'instance already exists' );
        instance.addRemoveCounter += 1;
        assert && assert( instance.addRemoveCounter === 0 );
      }
      else {
        sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'creating stub instance' );
        sceneryLog && sceneryLog.Instance && sceneryLog.push();
        instance = Instance.createFromPool( this.display, this.trail.copy().addDescendant( childNode, index ), false, false );
        sceneryLog && sceneryLog.Instance && sceneryLog.pop();
      }
      this.insertInstance( instance, index );
      this.markSkipPruning();
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },
    onChildRemoved: function( childNode, index ) {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance(
        'removing child node ' + childNode.constructor.name + '#' + childNode.id + ' from ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      assert && assert( this.children[ index ].node === childNode, 'Ensure that our instance matches up' );
      var instance = this.findChildInstanceOnNode( childNode );
      assert && assert( instance !== null, 'We should always have a reference to a removed instance' );
      instance.addRemoveCounter -= 1;
      assert && assert( instance.addRemoveCounter === -1 );
      this.instanceRemovalCheckList.push( instance );
      this.removeInstanceWithIndex( instance, index );
      this.markSkipPruning();
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },
    onVisibilityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      this.stitchChangeFrame = this.display._frameId;
      this.parent && this.parent.markSkipPruning();
      this.visibilityDirty = true;
      this.parent && this.parent.markChildVisibilityDirty();
    },
    onOpacityChange: function() {
      assert && assert( !this.stateless, 'If we are stateless, we should not receive these notifications' );
      this.markRenderStateDirty();
    },
    markChildVisibilityDirty: function() {
      if ( !this.childVisibilityDirty ) {
        this.childVisibilityDirty = true;
        this.parent && this.parent.markChildVisibilityDirty();
      }
    },
    updateDrawableFittability: function( fittable ) {
      this.selfDrawable && this.selfDrawable.setFittable( fittable );
      this.groupDrawable && this.groupDrawable.setFittable( fittable );
    },
    updateVisibility: function( parentGloballyVisible, parentRelativelyVisible, updateFullSubtree ) {
      if ( this.visibilityDirty ) {
        updateFullSubtree = true;
      }
      var nodeVisible = this.node.isVisible();
      var wasVisible = this.visible;
      var wasRelativeVisible = this.relativeVisible;
      var wasSelfVisible = this.selfVisible;
      this.visible = parentGloballyVisible && nodeVisible;
      this.relativeVisible = parentRelativelyVisible && nodeVisible;
      this.selfVisible = this.isVisibilityApplied ? true : this.relativeVisible;
      var len = this.children.length;
      for ( var i = 0; i < len; i++ ) {
        var child = this.children[ i ];
        if ( updateFullSubtree || child.visibilityDirty || child.childVisibilityDirty ) {
          child.updateVisibility( this.visible, this.isVisibilityApplied ? true : this.relativeVisible, updateFullSubtree );
        }
      }
      this.visibilityDirty = false;
      this.childVisibilityDirty = false;
      if ( this.visible !== wasVisible ) {
        this.trigger0( 'visibility' );
      }
      if ( this.relativeVisible !== wasRelativeVisible ) {
        this.trigger0( 'relativeVisibility' );
      }
      if ( this.selfVisible !== wasSelfVisible ) {
        this.trigger0( 'selfVisibility' );
      }
    },
    getDescendantCount: function() {
      var count = this.children.length;
      for ( var i = 0; i < this.children.length; i++ ) {
        count += this.children[ i ].getDescendantCount();
      }
      return count;
    },
    addSVGGroup: function( group ) {
      this.svgGroups.push( group );
    },
    removeSVGGroup: function( group ) {
      var index = _.indexOf( this.svgGroups, group );
      assert && assert( index >= 0, 'Tried to remove an SVGGroup from an Instance when it did not exist' );
      this.svgGroups.splice( index, 1 ); // TODO: remove function
    },
    lookupSVGGroup: function( block ) {
      var len = this.svgGroups.length;
      for ( var i = 0; i < len; i++ ) {
        var group = this.svgGroups[ i ];
        if ( group.block === block ) {
          return group;
        }
      }
      return null;
    },
    getFilterRootInstance: function() {
      if ( this.isBackbone || this.isInstanceCanvasCache || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getFilterRootInstance();
      }
    },
    getTransformRootInstance: function() {
      if ( this.isTransformed || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getTransformRootInstance();
      }
    },
    getVisibilityRootInstance: function() {
      if ( this.isVisibilityApplied || !this.parent ) {
        return this;
      }
      else {
        return this.parent.getVisibilityRootInstance();
      }
    },
    attachNodeListeners: function() {
      this.relativeTransform.attachNodeListeners();
      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.onStatic( 'childInserted', this.childInsertedListener );
        this.node.onStatic( 'childRemoved', this.childRemovedListener );
        this.node.onStatic( 'visibility', this.visibilityListener );
        this.node.onStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.onStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.onStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.onStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },
    detachNodeListeners: function() {
      this.relativeTransform.detachNodeListeners();
      if ( !this.isSharedCanvasCachePlaceholder ) {
        this.node.offStatic( 'childInserted', this.childInsertedListener );
        this.node.offStatic( 'childRemoved', this.childRemovedListener );
        this.node.offStatic( 'visibility', this.visibilityListener );
        this.node.offStatic( 'opacity', this.markRenderStateDirtyListener );
        this.node.offStatic( 'hint', this.markRenderStateDirtyListener );
        this.node.offStatic( 'clip', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererBitmask', this.markRenderStateDirtyListener );
        this.node.offStatic( 'rendererSummary', this.markRenderStateDirtyListener );
      }
    },
    markRenderStateDirty: function() {
      this.renderStateDirtyFrame = this.display._frameId;
      this.parent && this.parent.markSkipPruning();
    },
    markSkipPruning: function() {
      this.skipPruningFrame = this.display._frameId;
      this.parent && this.parent.markSkipPruning();
    },
    getBranchIndexTo: function( instance ) {
      var cachedValue = this.branchIndexMap[ instance.id ];
      if ( cachedValue !== undefined ) {
        return cachedValue;
      }
      var branchIndex = this.trail.getBranchIndexTo( instance.trail );
      this.branchIndexMap[ instance.id ] = branchIndex;
      instance.branchIndexMap[ this.id ] = branchIndex;
      this.branchIndexReferences.push( instance );
      instance.branchIndexReferences.push( this );
      return branchIndex;
    },
    dispose: function() {
      sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'dispose ' + this.toString() );
      sceneryLog && sceneryLog.Instance && sceneryLog.push();
      assert && assert( this.active, 'Seems like we tried to dispose this Instance twice, it is not active' );
      this.active = false;
      while ( this.branchIndexReferences.length ) {
        var branchIndexReference = this.branchIndexReferences.pop(); // {Instance}
        delete this.branchIndexMap[ branchIndexReference.id ];
        delete branchIndexReference.branchIndexMap[ this.id ];
        arrayRemove( branchIndexReference.branchIndexReferences, this );
      }
      this.groupDrawable && this.groupDrawable.disposeImmediately( this.display );
      this.sharedCacheDrawable && this.sharedCacheDrawable.disposeImmediately( this.display );
      this.selfDrawable && this.selfDrawable.disposeImmediately( this.display );
      var numChildren = this.children.length;
      for ( var i = 0; i < numChildren; i++ ) {
        this.children[ i ].dispose();
      }
      while ( this.instanceRemovalCheckList.length ) {
        var child = this.instanceRemovalCheckList.pop();
        if ( child.active ) {
          child.dispose();
        }
      }
      if ( !this.stateless ) {
        this.detachNodeListeners();
      }
      this.node.removeInstance( this );
      if ( this.sharedCacheInstance ) {
        this.sharedCacheInstance.externalReferenceCount--;
        if ( this.sharedCacheInstance.externalReferenceCount === 0 ) {
          delete this.display._sharedCanvasInstances[ this.node.getId() ];
          this.sharedCacheInstance.dispose();
        }
      }
      this.cleanInstance( null, null );
      this.removeAllEventListeners();
      this.freeToPool();
      sceneryLog && sceneryLog.Instance && sceneryLog.pop();
    },
    audit: function( frameId, allowValidationNotNeededChecks ) {
      if ( assertSlow ) {
        if ( frameId === undefined ) {
          frameId = this.display._frameId;
        }
        assertSlow( !this.stateless,
          'State is required for all display instances' );
        assertSlow( ( this.firstDrawable === null ) === ( this.lastDrawable === null ),
          'First/last drawables need to both be null or non-null' );
        assertSlow( ( !this.isBackbone && !this.isSharedCanvasCachePlaceholder ) || this.groupDrawable,
          'If we are a backbone or shared cache, we need to have a groupDrawable reference' );
        assertSlow( !this.isSharedCanvasCachePlaceholder || !this.node.isPainted() || this.selfDrawable,
          'We need to have a selfDrawable if we are painted and not a shared cache' );
        assertSlow( ( !this.isTransformed && !this.isCanvasCache ) || this.groupDrawable,
          'We need to have a groupDrawable if we are a backbone or any type of canvas cache' );
        assertSlow( !this.isSharedCanvasCachePlaceholder || this.sharedCacheDrawable,
          'We need to have a sharedCacheDrawable if we are a shared cache' );
        assertSlow( this.addRemoveCounter === 0,
          'Our addRemoveCounter should always be 0 at the end of syncTree' );
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];
          childInstance.audit( frameId, allowValidationNotNeededChecks );
        }
        this.relativeTransform.audit( frameId, allowValidationNotNeededChecks );
        this.fittability.audit();
      }
    },
    auditVisibility: function( parentVisible ) {
      if ( assertSlow ) {
        var visible = parentVisible && this.node.isVisible();
        var trailVisible = this.trail.isVisible();
        assertSlow( visible === trailVisible, 'Trail visibility failure' );
        assertSlow( visible === this.visible, 'Visible flag failure' );
        for ( var i = 0; i < this.children.length; i++ ) {
          var childInstance = this.children[ i ];
          childInstance.auditVisibility( visible );
        }
      }
    },
    auditChangeIntervals: function( oldFirstDrawable, oldLastDrawable, newFirstDrawable, newLastDrawable ) {
      if ( oldFirstDrawable ) {
        var oldOne = oldFirstDrawable;
        while ( oldOne !== oldLastDrawable ) {
          oldOne = oldOne.oldNextDrawable;
        }
      }
      if ( newFirstDrawable ) {
        var newOne = newFirstDrawable;
        while ( newOne !== newLastDrawable ) {
          newOne = newOne.nextDrawable;
        }
      }
      function checkBetween( a, b ) {
        if ( assertSlow ) {
          assertSlow( a !== null );
          assertSlow( b !== null );
          while ( a !== b ) {
            assertSlow( a.nextDrawable === a.oldNextDrawable, 'Change interval mismatch' );
            a = a.nextDrawable;
          }
        }
      }
      if ( assertSlow ) {
        var firstChangeInterval = this.firstChangeInterval;
        var lastChangeInterval = this.lastChangeInterval;
        if ( !firstChangeInterval || firstChangeInterval.drawableBefore !== null ) {
          assertSlow( oldFirstDrawable === newFirstDrawable,
            'If we have no changes, or our first change interval is not open, our firsts should be the same' );
        }
        if ( !lastChangeInterval || lastChangeInterval.drawableAfter !== null ) {
          assertSlow( oldLastDrawable === newLastDrawable,
            'If we have no changes, or our last change interval is not open, our lasts should be the same' );
        }
        if ( !firstChangeInterval ) {
          assertSlow( !lastChangeInterval, 'We should not be missing only one change interval' );
          oldFirstDrawable && checkBetween( oldFirstDrawable, oldLastDrawable );
        }
        else {
          assertSlow( lastChangeInterval, 'We should not be missing only one change interval' );
          if ( firstChangeInterval.drawableBefore !== null ) {
            checkBetween( oldFirstDrawable, firstChangeInterval.drawableBefore );
          }
          if ( lastChangeInterval.drawableAfter !== null ) {
            checkBetween( lastChangeInterval.drawableAfter, oldLastDrawable );
          }
          var interval = firstChangeInterval;
          while ( interval && interval.nextChangeInterval ) {
            var nextInterval = interval.nextChangeInterval;
            assertSlow( interval.drawableAfter !== null );
            assertSlow( nextInterval.drawableBefore !== null );
            checkBetween( interval.drawableAfter, nextInterval.drawableBefore );
            interval = nextInterval;
          }
        }
      }
    },
    toString: function() {
      return this.id + '#' + ( this.node ? ( this.node.constructor.name ? this.node.constructor.name : '?' ) + '#' + this.node.id : '-' );
    }
  } );
  Poolable.mixin( Instance, {
    constructorDuplicateFactory: function( pool ) {
      return function( display, trail, isDisplayRoot, isSharedCanvasCacheRoot ) {
        if ( pool.length ) {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from pool' );
          return pool.pop().initialize( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
        else {
          sceneryLog && sceneryLog.Instance && sceneryLog.Instance( 'new from constructor' );
          return new Instance( display, trail, isDisplayRoot, isSharedCanvasCacheRoot );
        }
      };
    }
  } );
  return Instance;
} );
define( 'SCENERY/display/InlineCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  function InlineCanvasCacheDrawable( renderer, instance ) {
    Drawable.call( this, renderer );
    this.instance = instance; // will need this so we can get bounds for layer fitting
  }
  scenery.register( 'InlineCanvasCacheDrawable', InlineCanvasCacheDrawable );
  inherit( Drawable, InlineCanvasCacheDrawable, {
    stitch: function( firstDrawable, lastDrawable, firstChangeInterval, lastChangeInterval ) {
    }
  } );
  return InlineCanvasCacheDrawable;
} );
define( 'SCENERY/display/SharedCanvasCacheDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/Drawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  function SharedCanvasCacheDrawable( trail, renderer, instance, sharedInstance ) {
    Drawable.call( this, renderer );
    this.instance = instance; // will need this so we can get bounds for layer fitting
    this.sharedInstance = sharedInstance;
  }
  scenery.register( 'SharedCanvasCacheDrawable', SharedCanvasCacheDrawable );
  inherit( Drawable, SharedCanvasCacheDrawable, {
  } );
  return SharedCanvasCacheDrawable;
} );
define( 'SCENERY/accessibility/AccessibleInstance',['require','PHET_CORE/inherit','PHET_CORE/Poolable','AXON/Events','SCENERY/scenery','PHET_CORE/cleanArray'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Poolable = require( 'PHET_CORE/Poolable' );
  var Events = require( 'AXON/Events' );
  var scenery = require( 'SCENERY/scenery' );
  var cleanArray = require( 'PHET_CORE/cleanArray' );
  var globalId = 1;
  function AccessibleInstance( parent, display, trail ) {
    this.initializeAccessibleInstance( parent, display, trail );
  }
  scenery.register( 'AccessibleInstance', AccessibleInstance );
  inherit( Events, AccessibleInstance, {
    initializeAccessibleInstance: function( parent, display, trail ) {
      Events.call( this ); // TODO: is Events worth mixing in by default? Will we need to listen to events?
      assert && assert( !this.id || this.disposed, 'If we previously existed, we need to have been disposed' );
      this.id = this.id || globalId++;
      this.parent = parent;
      this.display = display;
      this.trail = trail;
      this.node = trail.lastNode();
      this.isRootInstance = this.trail.length === 0;
      this.children = cleanArray( this.children );
      if ( this.node ) {
        this.node.addAccessibleInstance( this );
      }
      this.isSorted = true;
      if ( this.isRootInstance ) {
        var accessibilityContainer = document.createElement( 'div' );
        accessibilityContainer.className = 'accessibility';
        accessibilityContainer.style.position = 'absolute';
        accessibilityContainer.style.left = '0';
        accessibilityContainer.style.top = '0';
        accessibilityContainer.style.width = '0';
        accessibilityContainer.style.height = '0';
        accessibilityContainer.style.clip = 'rect(0,0,0,0)';
        accessibilityContainer.style.pointerEvents = 'none';
        this.peer = new scenery.AccessiblePeer( this, accessibilityContainer );
      }
      else {
        this.peer = this.node.accessibleContent.createPeer( this );
        var childContainerElement = this.parent.peer.getChildContainerElement();
        childContainerElement.insertBefore( this.peer.getParentContainerElement(), childContainerElement.childNodes[ 0 ] );
      }
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Initialized ' + this.toString() );
      return this;
    },
    addSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'addSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();
      var node = trail.lastNode();
      var nextInstance = this; // eslint-disable-line consistent-this
      if ( node.accessibleContent ) {
        var accessibleInstance = AccessibleInstance.createFromPool( this, this.display, trail.copy() ); // TODO: Pooling
        sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
          'Insert parent: ' + this.toString() + ', (new) child: ' + accessibleInstance.toString() );
        this.children.push( accessibleInstance ); // TODO: Mark us as dirty for performance.
        this.markAsUnsorted();
        nextInstance = accessibleInstance;
      }
      var children = node._children;
      for ( var i = 0; i < children.length; i++ ) {
        trail.addDescendant( children[ i ], i );
        nextInstance.addSubtree( trail );
        trail.removeDescendant();
      }
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },
    removeSubtree: function( trail ) {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'removeSubtree on ' + this.toString() + ' with trail ' + trail.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();
      for ( var i = this.children.length - 1; i >= 0; i-- ) {
        var childInstance = this.children[ i ];
        if ( childInstance.trail.isExtensionOf( trail, true ) ) {
          sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
            'Remove parent: ' + this.toString() + ', child: ' + childInstance.toString() );
          this.children.splice( i, 1 ); // remove it from the children array
          childInstance.dispose();
        }
      }
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },
    markAsUnsorted: function() {
      if ( this.isSorted ) {
        this.isSorted = false;
        this.display.markUnsortedAccessibleInstance( this );
      }
    },
    sortChildren: function() {
      assert && assert( !this.isSorted, 'No need to sort children if it is already marked as sorted' );
      this.isSorted = true;
      var parentInstance = this; // eslint-disable-line consistent-this
      for ( var m = 0; m < this.children.length; m++ ) {
        this.children[ m ].trail.reindex();
      }
      this.children.sort( function( a, b ) {
        var aNodes = a.trail.nodes;
        var bNodes = b.trail.nodes;
        for ( var i = Math.max( 0, parentInstance.trail.length - 1 ); aNodes[ i ] === bNodes[ i ]; i++ ) {
          var currentNode = aNodes[ i ];
          var order = currentNode.accessibleOrder;
          if ( !order ) {
            continue;
          }
          for ( var j = 0; j < order.length; j++ ) {
            var orderedNode = order[ j ];
            var aIndex = aNodes.indexOf( orderedNode );
            var bIndex = bNodes.indexOf( orderedNode );
            if ( aIndex >= 0 && bIndex >= 0 ) {
              var branchIndex = i + 1;
              while ( aNodes[ branchIndex ] === bNodes[ branchIndex ] ) {
                branchIndex++;
              }
              if ( aIndex < branchIndex ) {
                i = aIndex - 1;
                break;
              }
              else {
                var aChildIndex = a.trail.indices[ branchIndex - 1 ];
                var bChildIndex = b.trail.indices[ branchIndex - 1 ];
                if ( aChildIndex < bChildIndex ) {
                  return -1;
                }
                else if ( aChildIndex > bChildIndex ) {
                  return 1;
                }
                else {
                  throw new Error( 'Two different children have the same child index' );
                }
              }
            }
            else if ( aIndex >= 0 ) {
              return -1;
            }
            else if ( bIndex >= 0 ) {
              return 1;
            }
          }
        }
        var aEndChildIndex = a.trail.indices[ i - 1 ];
        var bEndChildIndex = b.trail.indices[ i - 1 ];
        if ( aEndChildIndex < bEndChildIndex ) {
          return -1;
        }
        else if ( aEndChildIndex > bEndChildIndex ) {
          return 1;
        }
        else {
          throw new Error( 'Two different children have the same child index' );
        }
      } );
      var containerElement = this.peer.getChildContainerElement();
      for ( var n = this.children.length - 1; n >= 0; n-- ) {
        var peerDOMElement = this.children[ n ].peer.domElement;
        if ( this.children[ n ].peer.hasParentContainer() ) {
          peerDOMElement = this.children[ n ].peer.getParentContainerElement();
        }
        if ( peerDOMElement === containerElement.childNodes[ n ] ) {
          continue;
        }
        containerElement.insertBefore( peerDOMElement, containerElement.childNodes[ n + 1 ] );
      }
    },
    dispose: function() {
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Disposing ' + this.toString() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.push();
      if ( !this.isRootInstance ) {
        this.peer.dispose();
        this.parent.peer.getChildContainerElement().removeChild( this.peer.getParentContainerElement() );
      }
      while ( this.children.length ) {
        this.children.pop().dispose();
      }
      if ( this.node ) {
        this.node.removeAccessibleInstance( this );
      }
      this.display = null;
      this.trail = null;
      this.node = null;
      this.peer = null;
      this.disposed = true;
      this.freeToPool();
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.pop();
    },
    toString: function() {
      return this.id + '#{' + this.trail.toString() + '}';
    },
    auditRoot: function() {
      assert && assert( this.trail.length === 0,
        'Should only call auditRoot() on the root AccessibleInstance for a display' );
      function audit( nestedOrderArray, accessibleInstance ) {
        assert && assert( nestedOrderArray.length === accessibleInstance.children.length,
          'Different number of children in accessible instance' );
        _.each( nestedOrderArray, function( nestedChild ) {
          var instance = _.find( accessibleInstance.children, function( childInstance ) {
            return childInstance.trail.equals( nestedChild.trail );
          } );
          assert && assert( instance, 'Missing child accessible instance' );
          audit( nestedChild.children, instance );
        } );
        for ( var i = 0; i < nestedOrderArray.length; i++ ) {
          assert && assert( nestedOrderArray[ i ].trail.lastNode() === accessibleInstance.children[ i ].node,
            'Accessible order mismatch' );
        }
      }
      audit( this.display.rootNode.getNestedAccessibleOrder(), this );
    }
  } );
  Poolable.mixin( AccessibleInstance, {
    constructorDuplicateFactory: function( pool ) {
      return function( parent, display, trail ) {
        if ( pool.length ) {
          return pool.pop().initializeAccessibleInstance( parent, display, trail );
        }
        else {
          return new AccessibleInstance( parent, display, trail );
        }
      };
    }
  } );
  return AccessibleInstance;
} );
define( 'SCENERY/util/SceneryStyle',['require','SCENERY/scenery'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var styleElement = document.createElement( 'style' );
  styleElement.type = 'text/css';
  document.head.appendChild( styleElement );
  var stylesheet = document.styleSheets[ document.styleSheets.length - 1 ];
  assert && assert( stylesheet.disabled === false );
  return scenery.register( 'SceneryStyle', {
    stylesheet: stylesheet,
    styleElement: styleElement,
    addRule: function( ruleString ) {
      this.stylesheet.insertRule( ruleString, 0 );
    }
  } );
} );
define( 'SCENERY/util/TransformTracker',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  function TransformTracker( trail, options ) {
    var self = this;
    options = _.extend( {
      isStatic: false // {boolean} - Whether the bounds listeners should be added with on() or onStatic().
    }, options );
    this._isStatic = options.isStatic;
    this.trail = trail;
    this._matrices = null; // Will be initialized on first need.
    this._dirtyIndex = 0;
    this._listeners = [];
    this._nodeTransformListeners = [];
    for ( var j = 1; j < this.trail.length; j++ ) {
      var nodeTransformListener = (function( index ) {
        return function() {
          self.onTransformChange( index );
        };
      })( j - 1 );
      this._nodeTransformListeners.push( nodeTransformListener );
      if ( this._isStatic ) {
        trail.nodes[ j ].onStatic( 'transform', nodeTransformListener );
      }
      else {
        trail.nodes[ j ].on( 'transform', nodeTransformListener );
      }
    }
  }
  scenery.register( 'TransformTracker', TransformTracker );
  inherit( Object, TransformTracker, {
    dispose: function() {
      for ( var j = 1; j < this.trail.length; j++ ) {
        var nodeTransformListener = this._nodeTransformListeners[ j - 1 ];
        if ( this._isStatic ) {
          this.trail.nodes[ j ].offStatic( 'transform', nodeTransformListener );
        }
        else {
          this.trail.nodes[ j ].off( 'transform', nodeTransformListener );
        }
      }
    },
    addListener: function( listener ) {
      assert && assert( typeof listener === 'function' );
      this._listeners.push( listener );
    },
    removeListener: function( listener ) {
      assert && assert( typeof listener === 'function' );
      var index = _.indexOf( this._listeners, listener );
      assert && assert( index >= 0, 'TransformTracker listener not found' );
      this._listeners.splice( index, 1 );
    },
    notifyListeners: function() {
      var listeners = this._listeners;
      if ( !this._isStatic ) {
        listeners = listeners.slice();
      }
      var length = listeners.length;
      for ( var i = 0; i < length; i++ ) {
        listeners[ i ]();
      }
    },
    onTransformChange: function( matrixIndex ) {
      this._dirtyIndex = Math.min( this._dirtyIndex, matrixIndex );
      this.notifyListeners();
    },
    getMatrix: function() {
      if ( this._matrices === null ) {
        this._matrices = [];
        for ( var i = 1; i < this.trail.length; i++ ) {
          this._matrices.push( new Matrix3() );
        }
      }
      if ( this._matrices.length <= 0 ) {
        return Matrix3.IDENTITY;
      }
      var numMatrices = this._matrices.length;
      for ( var index = this._dirtyIndex; index < numMatrices; index++ ) {
        var nodeMatrix = this.trail.nodes[ index + 1 ].matrix;
        if ( index === 0 ) {
          this._matrices[ index ].set( nodeMatrix );
        }
        else {
          this._matrices[ index ].set( this._matrices[ index - 1 ] );
          this._matrices[ index ].multiplyMatrix( nodeMatrix );
        }
      }
      this._dirtyIndex = numMatrices;
      return this._matrices[ numMatrices - 1 ];
    },
    get matrix() { return this.getMatrix(); }
  } );
  return TransformTracker;
} );
define( 'SCENERY/overlays/FocusOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Vector2','SCENERY/nodes/Rectangle','SCENERY/util/Color','SCENERY/util/TransformTracker','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Vector2 = require( 'DOT/Vector2' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Color = require( 'SCENERY/util/Color' );
  var TransformTracker = require( 'SCENERY/util/TransformTracker' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  function FocusOverlay( display, focusRootNode ) {
    this.display = display; // @private {Display}
    this.focusRootNode = focusRootNode; // @private {Node} - The root Node of our child display
    this.trail = null; // @private {Trail|null}
    this.node = null; // @private {Node|null}
    this.mode = null; // @private {String|null}
    this.transformTracker = null; // @private {TransformTracker|null}
    this.transformDirty = true;
    this.highlightNode = new Node();
    this.focusRootNode.addChild( this.highlightNode );
    this.focusDisplay = new scenery.Display( this.focusRootNode, {
      width: this.width,
      height: this.height,
      allowWebGL: display._allowWebGL,
      allowCSSHacks: false,
      accessibility: false,
      isApplication: false,
      interactive: false
    } );
    this.domElement = this.focusDisplay.domElement;
    this.domElement.style.pointerEvents = 'none';
    this.boundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerBoundsHighlight = new Rectangle( 0, 0, 0, 0, { stroke: FocusOverlay.innerFocusColor } );
    this.boundsHighlight.addChild( this.innerBoundsHighlight );
    this.shapeHighlight = new Path( null, { stroke: FocusOverlay.focusColor, visible: false } );
    this.innerShapeHighlight = new Path( null, { stroke: FocusOverlay.innerFocusColor } );
    this.shapeHighlight.addChild( this.innerShapeHighlight );
    this.nodeHighlight = null;
    this.highlightNode.addChild( this.boundsHighlight );
    this.highlightNode.addChild( this.shapeHighlight );
    this.boundsListener = this.onBoundsChange.bind( this );
    this.transformListener = this.onTransformChange.bind( this );
    this.focusListener = this.onFocusChange.bind( this );
    scenery.Display.focusProperty.link( this.focusListener );
  }
  scenery.register( 'FocusOverlay', FocusOverlay );
  inherit( Object, FocusOverlay, {
    dispose: function() {
      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }
      scenery.Display.focusProperty.unlink( this.focusListener );
    },
    hasHighlight: function() {
      return !!this.trail;
    },
    activateHighlight: function( trail ) {
      this.trail = trail;
      this.node = trail.lastNode();
      this.transformTracker = new TransformTracker( trail, {
        isStatic: true
      } );
      this.transformTracker.addListener( this.transformListener );
      if ( this.node.accessibleContent.focusHighlight === 'invisible' ) {
        this.mode = 'invisible';
      }
      else if ( this.node.accessibleContent.focusHighlight instanceof Shape ) {
        this.mode = 'shape';
        this.shapeHighlight.visible = true;
        this.shapeHighlight.shape = this.innerShapeHighlight.shape = this.node.accessibleContent.focusHighlight;
      }
      else if ( this.node.accessibleContent.focusHighlight instanceof Node ) {
        this.mode = 'node';
        if ( this.node.accessibleContent.focusHighlightLayerable ) {
          this.node.accessibleContent.focusHighlight.visible = true;
        }
        else {
          this.nodeHighlight = this.node.accessibleContent.focusHighlight;
          this.highlightNode.addChild( this.nodeHighlight );
        }
      }
      else {
        this.mode = 'bounds';
        this.boundsHighlight.visible = true;
        this.node.onStatic( 'localBounds', this.boundsListener );
        this.onBoundsChange();
      }
      this.transformDirty = true;
    },
    deactivateHighlight: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.visible = false;
      }
      else if ( this.mode === 'node' ) {
        if ( this.node.accessibleContent.focusHighlightLayerable ) {
          this.node.accessibleContent.focusHighlight.visible = false;
        }
        else {
          this.highlightNode.removeChild( this.nodeHighlight );
          this.nodeHighlight = null;
        }
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.visible = false;
        this.node.offStatic( 'localBounds', this.boundsListener );
      }
      this.trail = null;
      this.node = null;
      this.mode = null;
      this.transformTracker.removeListener( this.transformListener );
      this.transformTracker.dispose();
    },
    afterTransform: function() {
      if ( this.mode === 'shape' ) {
        this.shapeHighlight.lineWidth = 4 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerShapeHighlight.lineWidth = 2.5 / this.shapeHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
      else if ( this.mode === 'bounds' ) {
        this.boundsHighlight.lineWidth = 4 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
        this.innerBoundsHighlight.lineWidth = 2.5 / this.boundsHighlight.transform.transformDelta2( Vector2.X_UNIT ).magnitude();
      }
    },
    onTransformChange: function() {
      this.transformDirty = true;
    },
    onBoundsChange: function() {
      this.boundsHighlight.setRectBounds( this.node.localBounds );
      this.innerBoundsHighlight.setRectBounds( this.node.localBounds );
    },
    onFocusChange: function( focus ) {
      var newTrail = ( focus && focus.display === this.display ) ? focus.trail : null;
      if ( this.hasHighlight() ) {
        this.deactivateHighlight();
      }
      if ( newTrail ) {
        this.activateHighlight( newTrail );
      }
    },
    update: function() {
      if ( this.hasHighlight() && this.transformDirty ) {
        this.transformDirty = false;
        this.highlightNode.setMatrix( this.transformTracker.matrix );
        this.afterTransform();
      }
      if ( !this.display.size.equals( this.focusDisplay.size ) ) {
        this.focusDisplay.setWidthHeight( this.display.width, this.display.height );
      }
      this.focusDisplay.updateDisplay();
    }
  }, {
    focusColor: new Color( 'rgba(212,19,106,0.5)' ),
    innerFocusColor: new Color( 'rgba(250,40,135,0.9)' )
  } );
  return FocusOverlay;
} );
define( 'SCENERY/overlays/ShapeBasedOverlay',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  function ShapeBasedOverlay( display, rootNode, name ) {
    this.display = display;
    this.rootNode = rootNode;
    var svg = this.svg = document.createElementNS( scenery.svgns, 'svg' );
    svg.style.position = 'absolute';
    svg.setAttribute( 'class', name );
    svg.style.top = 0;
    svg.style.left = 0;
    svg.style[ 'pointer-events' ] = 'none';
    function resize( width, height ) {
      svg.setAttribute( 'width', width );
      svg.setAttribute( 'height', height );
      svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';
    }
    display.onStatic( 'displaySize', function( dimension ) {
      resize( dimension.width, dimension.height );
    } );
    resize( display.width, display.height );
    this.domElement = svg;
  }
  scenery.register( 'ShapeBasedOverlay', ShapeBasedOverlay );
  inherit( Object, ShapeBasedOverlay, {
    addShape: function( shape, color, isOffset ) {
      var path = document.createElementNS( scenery.svgns, 'path' );
      var svgPath = shape.getSVGPath();
      if ( !svgPath ) { svgPath = 'M0 0'; }
      if ( svgPath ) {
        path.setAttribute( 'd', svgPath );
      }
      else if ( path.hasAttribute( 'd' ) ) {
        path.removeAttribute( 'd' );
      }
      path.setAttribute( 'style', 'fill: none; stroke: ' + color + '; stroke-dasharray: 5, 3; stroke-dashoffset: ' + ( isOffset ? 5 : 0 ) + '; stroke-width: 3;' );
      this.svg.appendChild( path );
    },
    update: function() {
      while ( this.svg.childNodes.length ) {
        this.svg.removeChild( this.svg.childNodes[ this.svg.childNodes.length - 1 ] );
      }
      this.addShapes();
    },
    addShapes: function() {
    },
    dispose: function() {
    }
  } );
  return ShapeBasedOverlay;
} );
define( 'SCENERY/overlays/PointerAreaOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  function PointerAreaOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'mouseTouchAreaOverlay' );
  }
  scenery.register( 'PointerAreaOverlay', PointerAreaOverlay );
  inherit( ShapeBasedOverlay, PointerAreaOverlay, {
    addShapes: function() {
      var self = this;
      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          return true;
        }
        if ( ( node.mouseArea || node.touchArea ) && trail.isVisible() ) {
          var transform = trail.getTransform();
          if ( node.mouseArea ) {
            self.addShape( transform.transformShape( node.mouseArea.isBounds ? Shape.bounds( node.mouseArea ) : node.mouseArea ), 'rgba(0,0,255,0.8)', true );
          }
          if ( node.touchArea ) {
            self.addShape( transform.transformShape( node.touchArea.isBounds ? Shape.bounds( node.touchArea ) : node.touchArea ), 'rgba(255,0,0,0.8)', false );
          }
        }
      } );
    }
  } );
  return PointerAreaOverlay;
} );
define( 'SCENERY/overlays/PointerOverlay',['require','PHET_CORE/inherit','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  var Util = require( 'SCENERY/util/Util' );
  function PointerOverlay( display, rootNode ) {
    var self = this;
    this.display = display;
    this.rootNode = rootNode;
    this.pointerSVGContainer = document.createElement( 'div' );
    this.pointerSVGContainer.style.position = 'absolute';
    this.pointerSVGContainer.style.top = 0;
    this.pointerSVGContainer.style.left = 0;
    this.pointerSVGContainer.style[ 'pointer-events' ] = 'none';
    var innerRadius = 10;
    var strokeWidth = 1;
    var diameter = (innerRadius + strokeWidth / 2) * 2;
    var radius = diameter / 2;
    display.onStatic( 'displaySize', function( dimension ) {
      self.pointerSVGContainer.setAttribute( 'width', dimension.width );
      self.pointerSVGContainer.setAttribute( 'height', dimension.height );
      self.pointerSVGContainer.style.clip = 'rect(0px,' + dimension.width + 'px,' + dimension.height + 'px,0px)';
    } );
    var scratchMatrix = Matrix3.IDENTITY.copy();
    var pointerAdded = this.pointerAdded = function( pointer ) {
      if ( pointer.isKey ) { return; }
      var svg = document.createElementNS( scenery.svgns, 'svg' );
      svg.style.position = 'absolute';
      svg.style.top = 0;
      svg.style.left = 0;
      svg.style[ 'pointer-events' ] = 'none';
      Util.prepareForTransform( svg, false );
      svg.setAttribute( 'width', diameter );
      svg.setAttribute( 'height', diameter );
      var circle = document.createElementNS( scenery.svgns, 'circle' );
      circle.setAttribute( 'cx', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'cy', innerRadius + strokeWidth / 2 );
      circle.setAttribute( 'r', innerRadius );
      circle.setAttribute( 'style', 'fill:black;' );
      circle.setAttribute( 'style', 'stroke:white;' );
      circle.setAttribute( 'opacity', 0.4 );
      var pointerRemoved = function() {
        if ( pointer.isTouch ) {
          self.pointerSVGContainer.removeChild( svg );
          pointer.removeInputListener( moveListener );
        }
      };
      var moveListener = {
        move: function() {
          if ( pointer.point ) {
            Util.applyPreparedTransform( scratchMatrix.setToTranslation( pointer.point.x - radius, pointer.point.y - radius ), svg, false );
          }
        },
        up: pointerRemoved,
        cancel: pointerRemoved
      };
      pointer.addInputListener( moveListener );
      moveListener.move();
      svg.appendChild( circle );
      self.pointerSVGContainer.appendChild( svg );
    };
    display._input.addPointerAddedListener( pointerAdded );
    if ( display._input && display._input.mouse ) {
      pointerAdded( display._input.mouse );
    }
    this.domElement = this.pointerSVGContainer;
  }
  scenery.register( 'PointerOverlay', PointerOverlay );
  inherit( Object, PointerOverlay, {
    dispose: function() {
      this.display._input.removePointerAddedListener( this.pointerAdded );
    },
    update: function() {
    }
  } );
  return PointerOverlay;
} );
define( 'SCENERY/overlays/CanvasNodeBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  function CanvasNodeBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }
  scenery.register( 'CanvasNodeBoundsOverlay', CanvasNodeBoundsOverlay );
  inherit( ShapeBasedOverlay, CanvasNodeBoundsOverlay, {
    addShapes: function() {
      var self = this;
      new scenery.Trail( this.rootNode ).eachTrailUnder( function( trail ) {
        var node = trail.lastNode();
        if ( !node.isVisible() ) {
          return true;
        }
        if ( ( node instanceof scenery.CanvasNode ) && trail.isVisible() ) {
          var transform = trail.getTransform();
          self.addShape( transform.transformShape( Shape.bounds( node.selfBounds ) ), 'rgba(0,255,0,0.8)', true );
        }
      } );
    }
  } );
  return CanvasNodeBoundsOverlay;
} );
define( 'SCENERY/overlays/FittedBlockBoundsOverlay',['require','PHET_CORE/inherit','SCENERY/overlays/ShapeBasedOverlay','KITE/Shape','DOT/Matrix3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var ShapeBasedOverlay = require( 'SCENERY/overlays/ShapeBasedOverlay' );
  var Shape = require( 'KITE/Shape' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var scenery = require( 'SCENERY/scenery' );
  require( 'SCENERY/util/Trail' );
  function FittedBlockBoundsOverlay( display, rootNode ) {
    ShapeBasedOverlay.call( this, display, rootNode, 'canvasNodeBoundsOverlay' );
  }
  scenery.register( 'FittedBlockBoundsOverlay', FittedBlockBoundsOverlay );
  inherit( ShapeBasedOverlay, FittedBlockBoundsOverlay, {
    addShapes: function() {
      var self = this;
      function processBackbone( backbone, matrix ) {
        if ( backbone.willApplyTransform ) {
          matrix = matrix.timesMatrix( backbone.backboneInstance.relativeTransform.matrix );
        }
        backbone.blocks.forEach( function( block ) {
          processBlock( block, matrix );
        } );
      }
      function processBlock( block, matrix ) {
        if ( block.fitBounds && !block.fitBounds.isEmpty() ) {
          self.addShape( Shape.bounds( block.fitBounds ).transformed( matrix ), 'rgba(255,0,0,0.8)', true );
        }
        if ( block.firstDrawable && block.lastDrawable ) {
          for ( var childDrawable = block.firstDrawable; childDrawable !== block.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            processDrawable( childDrawable, matrix );
          }
          processDrawable( block.lastDrawable, matrix );
        }
      }
      function processDrawable( drawable, matrix ) {
        if ( drawable.backboneInstance ) {
          processBackbone( drawable, matrix );
        }
      }
      processBackbone( this.display._rootBackbone, Matrix3.IDENTITY );
    }
  } );
  return FittedBlockBoundsOverlay;
} );
define( 'SCENERY/accessibility/TFocus',['require','SCENERY/scenery','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/types/TObject'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  function TFocus( focus, phetioID ) {
    TObject.call( this, focus, phetioID );
    assertInstanceOf( focus, Object );
  }
  phetioInherit( TObject, 'TFocus', TFocus, {}, {
    toStateObject: function( focus ) {
      if ( focus === null ) {
        return null;
      }
      else {
        return focus.trail.indices;
      }
    },
    fromStateObject: function( indices ) {
      if ( indices === null ) {
        return null;
      }
      else {
        var currentNode = phet.joist.sim.display.rootNode;
        var nodes = [ currentNode ];
        for ( var i = 0; i < indices.length; i++ ) {
          var index = indices[ i ];
          currentNode = currentNode.children[ index ];
          nodes.push( currentNode );
        }
        return { display: phet.joist.sim.display, trail: new phet.scenery.Trail( nodes ) };
      }
    },
    documentation: 'A wrapper type for the instance in the simulation which currently has keyboard focus.'
  } );
  scenery.register( 'TFocus', TFocus );
  return TFocus;
} );
define( 'SCENERY/display/Display',['require','PHET_CORE/inherit','AXON/Emitter','PHET_CORE/extend','AXON/Events','AXON/Property','DOT/Dimension2','DOT/Vector2','DOT/Matrix3','TANDEM/Tandem','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Features','SCENERY/display/BackboneDrawable','SCENERY/display/CanvasBlock','SCENERY/display/CanvasSelfDrawable','SCENERY/display/ChangeInterval','SCENERY/display/DOMSelfDrawable','SCENERY/display/Drawable','SCENERY/display/Instance','SCENERY/display/InlineCanvasCacheDrawable','SCENERY/display/Renderer','SCENERY/display/SharedCanvasCacheDrawable','SCENERY/display/SVGSelfDrawable','SCENERY/input/Input','SCENERY/util/Trail','SCENERY/accessibility/AccessibleInstance','SCENERY/util/SceneryStyle','SCENERY/overlays/FocusOverlay','SCENERY/overlays/PointerAreaOverlay','SCENERY/overlays/PointerOverlay','SCENERY/overlays/CanvasNodeBoundsOverlay','SCENERY/overlays/FittedBlockBoundsOverlay','SCENERY/accessibility/TFocus'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Emitter = require( 'AXON/Emitter' );
  var extend = require( 'PHET_CORE/extend' );
  var Events = require( 'AXON/Events' );
  var Property = require( 'AXON/Property' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Vector2 = require( 'DOT/Vector2' );
  var Matrix3 = require( 'DOT/Matrix3' );
  var Tandem = require( 'TANDEM/Tandem' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Features = require( 'SCENERY/util/Features' );
  require( 'SCENERY/display/BackboneDrawable' );
  require( 'SCENERY/display/CanvasBlock' );
  require( 'SCENERY/display/CanvasSelfDrawable' );
  var ChangeInterval = require( 'SCENERY/display/ChangeInterval' );
  require( 'SCENERY/display/DOMSelfDrawable' );
  var Drawable = require( 'SCENERY/display/Drawable' );
  var Instance = require( 'SCENERY/display/Instance' );
  require( 'SCENERY/display/InlineCanvasCacheDrawable' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  require( 'SCENERY/display/SharedCanvasCacheDrawable' );
  require( 'SCENERY/display/SVGSelfDrawable' );
  var Input = require( 'SCENERY/input/Input' );
  require( 'SCENERY/util/Trail' );
  var AccessibleInstance = require( 'SCENERY/accessibility/AccessibleInstance' );
  var SceneryStyle = require( 'SCENERY/util/SceneryStyle' );
  var FocusOverlay = require( 'SCENERY/overlays/FocusOverlay' );
  var PointerAreaOverlay = require( 'SCENERY/overlays/PointerAreaOverlay' );
  var PointerOverlay = require( 'SCENERY/overlays/PointerOverlay' );
  var CanvasNodeBoundsOverlay = require( 'SCENERY/overlays/CanvasNodeBoundsOverlay' );
  var FittedBlockBoundsOverlay = require( 'SCENERY/overlays/FittedBlockBoundsOverlay' );
  var TFocus = require( 'SCENERY/accessibility/TFocus' );
  function Display( rootNode, options ) {
    assert && assert( rootNode, 'rootNode is a required parameter' );
    Events.call( this );
    var ua = navigator.userAgent;
    function isMobileSafari() {
      return !!( ua.match( /(iPod|iPhone|iPad)/ ) && ua.match( /AppleWebKit/ ) );
    }
    var safari = isMobileSafari() || !!( ua.match( /Version\// ) && ua.match( /Safari\// ) && ua.match( /AppleWebKit/ ) );
    options = _.extend( {
      width: ( options && options.container && options.container.clientWidth ) || 640,
      height: ( options && options.container && options.container.clientHeight ) || 480,
      allowCSSHacks: true,       // applies CSS styles to the root DOM element that make it amenable to interactive content
      allowSceneOverflow: false, // usually anything displayed outside of our dom element is hidden with CSS overflow
      defaultCursor: 'default',  // what cursor is used when no other cursor is specified
      backgroundColor: null,      // initial background color
      preserveDrawingBuffer: false,
      allowWebGL: true,
      accessibility: true,
      isApplication: false,      // adds the aria-role: 'application' when accessibility is enabled
      interactive: true,
      listenToOnlyElement: false,
      batchDOMEvents: false,
      assumeFullWindow: false,
      passiveEvents: safari ? false : null
    }, options );
    this.options = options; // @private
    this._allowWebGL = options.allowWebGL;
    this._size = new Dimension2( this.options.width, this.options.height );
    this._currentSize = new Dimension2( -1, -1 ); // used to check against new size to see what we need to change
    this._rootNode = rootNode;
    this._rootNode.addRootedDisplay( this );
    this._rootBackbone = null; // to be filled in later
    this._domElement = ( options && options.container ) ?
                       scenery.BackboneDrawable.repurposeBackboneContainer( options.container ) :
                       scenery.BackboneDrawable.createDivBackbone();
    this._sharedCanvasInstances = {}; // map from Node ID to Instance, for fast lookup
    this._baseInstance = null; // will be filled with the root Instance
    this._frameId = 0; // {number}
    this._dirtyTransformRoots = [];
    this._dirtyTransformRootsWithoutPass = [];
    this._instanceRootsToDispose = [];
    this._drawablesToDispose = [];
    this._drawablesToChangeBlock = []; // {[Drawable]}
    this._drawablesToUpdateLinks = []; // {[Drawable]}
    this._changeIntervalsToDispose = []; // {[ChangeInterval]}
    this._lastCursor = null;
    this._currentBackgroundCSS = null;
    this._backgroundColor = null;
    this._requestAnimationFrameID = 0;
    this._input = null;
    this._interactive = this.options.interactive;
    this._listenToOnlyElement = options.listenToOnlyElement; // TODO: doc
    this._batchDOMEvents = options.batchDOMEvents; // TODO: doc
    this._assumeFullWindow = options.assumeFullWindow; // TODO: doc
    this._passiveEvents = options.passiveEvents;
    this._overlays = [];
    this._pointerOverlay = null;
    this._pointerAreaOverlay = null;
    this._canvasAreaBoundsOverlay = null;
    this._fittedBlockBoundsOverlay = null;
    this._fuzzMouseIsDown = false;
    this._fuzzMousePosition = new Vector2(); // start at 0,0
    this._fuzzMouseLastMoved = false; // whether the last mouse event was a move (we skew probabilities based on this)
    if ( assert ) {
      this._isPainting = false;
    }
    this.applyCSSHacks();
    this.setBackgroundColor( this.options.backgroundColor );
    this.scenery = scenery;
    if ( this.options.accessibility ) {
      if ( this.options.isApplication ) {
        this._domElement.setAttribute( 'aria-role', 'application' );
      }
      SceneryStyle.addRule( '.accessibility * { position: absolute; left: 0; top: 0; width: 0; height: 0, clip: rect(0,0,0,0); }' );
      this._focusRootNode = new Node();
      this._focusOverlay = new FocusOverlay( this, this._focusRootNode );
      this.addOverlay( this._focusOverlay );
      this._unsortedAccessibleInstances = [];
      this._rootAccessibleInstance = AccessibleInstance.createFromPool( null, this, new scenery.Trail() );
      sceneryLog && sceneryLog.AccessibleInstance && sceneryLog.AccessibleInstance(
        'Display root instance: ' + this._rootAccessibleInstance.toString() );
      this._rootAccessibleInstance.addSubtree( new scenery.Trail( this._rootNode ) );
      this._domElement.appendChild( this._rootAccessibleInstance.peer.domElement );
    }
  }
  scenery.register( 'Display', Display );
  inherit( Object, Display, extend( {
    getDOMElement: function() {
      return this._domElement;
    },
    get domElement() { return this.getDOMElement(); },
    updateDisplay: function() {
      if ( window.sceneryDebugPause ) {
        return;
      }
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        this.perfSyncTreeCount = 0;
        this.perfStitchCount = 0;
        this.perfIntervalCount = 0;
        this.perfDrawableBlockChangeCount = 0;
        this.perfDrawableOldIntervalCount = 0;
        this.perfDrawableNewIntervalCount = 0;
      }
      if ( assert ) {
        Display.assertSubtreeDisposed( this._rootNode );
      }
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'updateDisplay frame ' + this._frameId );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      var firstRun = !!this._baseInstance;
      if ( this._input ) {
        this._input.validatePointers();
      }
      this._rootNode.validateWatchedBounds();
      if ( assertSlow ) { this.options.accessibility && this._rootAccessibleInstance.auditRoot(); }
      if ( assertSlow ) { this._rootNode._picker.audit(); }
      this._baseInstance = this._baseInstance || scenery.Instance.createFromPool( this, new scenery.Trail( this._rootNode ), true, false );
      this._baseInstance.baseSyncTree();
      if ( firstRun ) {
        this.markTransformRootDirty( this._baseInstance, this._baseInstance.isTransformed ); // marks the transform root as dirty (since it is)
      }
      while ( this._drawablesToUpdateLinks.length ) {
        this._drawablesToUpdateLinks.pop().updateLinks();
      }
      while ( this._changeIntervalsToDispose.length ) {
        this._changeIntervalsToDispose.pop().dispose();
      }
      this._rootBackbone = this._rootBackbone || this._baseInstance.groupDrawable;
      assert && assert( this._rootBackbone, 'We are guaranteed a root backbone as the groupDrawable on the base instance' );
      assert && assert( this._rootBackbone === this._baseInstance.groupDrawable, 'We don\'t want the base instance\'s groupDrawable to change' );
      if ( assertSlow ) { this._rootBackbone.audit( true, false, true ); } // allow pending blocks / dirty
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable block change phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      while ( this._drawablesToChangeBlock.length ) {
        var changed = this._drawablesToChangeBlock.pop().updateBlock();
        if ( sceneryLog && scenery.isLoggingPerformance() && changed ) {
          this.perfDrawableBlockChangeCount++;
        }
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();
      if ( assertSlow ) { this._rootBackbone.audit( false, false, true ); } // allow only dirty
      if ( assertSlow ) { this._baseInstance.audit( this._frameId, false ); }
      this.updateDirtyTransformRoots();
      this._baseInstance.updateVisibility( true, true, false );
      if ( assertSlow ) { this._baseInstance.auditVisibility( true ); }
      if ( assertSlow ) { this._baseInstance.audit( this._frameId, true ); }
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'instance root disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      while ( this._instanceRootsToDispose.length ) {
        this._instanceRootsToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();
      if ( assertSlow ) { this._rootNode.auditInstanceSubtreeForDisplay( this ); } // make sure trails are valid
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'drawable disposal phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      while ( this._drawablesToDispose.length ) {
        this._drawablesToDispose.pop().dispose();
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();
      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }
      if ( assert ) {
        assert( !this._isPainting, 'Display was already updating paint, may have thrown an error on the last update' );
        this._isPainting = true;
      }
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'repaint phase' );
      sceneryLog && sceneryLog.Display && sceneryLog.push();
      this._rootBackbone.update();
      sceneryLog && sceneryLog.Display && sceneryLog.pop();
      if ( assert ) {
        this._isPainting = false;
      }
      if ( assertSlow ) { this._rootBackbone.audit( false, false, false ); } // allow nothing
      if ( assertSlow ) { this._baseInstance.audit( this._frameId ); }
      this.updateCursor();
      this.updateBackgroundColor();
      this.updateSize();
      if ( this._overlays.length ) {
        var zIndex = this._rootBackbone.lastZIndex;
        for ( var i = 0; i < this._overlays.length; i++ ) {
          var overlay = this._overlays[ i ];
          overlay.domElement.style.zIndex = zIndex++;
          overlay.update();
        }
      }
      this._frameId++;
      if ( sceneryLog && scenery.isLoggingPerformance() ) {
        var syncTreeMessage = 'syncTree count: ' + this.perfSyncTreeCount;
        if ( this.perfSyncTreeCount > 500 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 100 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 20 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( syncTreeMessage );
        }
        else if ( this.perfSyncTreeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( syncTreeMessage );
        }
        var drawableBlockCountMessage = 'drawable block changes: ' + this.perfDrawableBlockChangeCount + ' for' +
                                        ' -' + this.perfDrawableOldIntervalCount +
                                        ' +' + this.perfDrawableNewIntervalCount;
        if ( this.perfDrawableBlockChangeCount > 200 ) {
          sceneryLog.PerfCritical && sceneryLog.PerfCritical( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 60 ) {
          sceneryLog.PerfMajor && sceneryLog.PerfMajor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 10 ) {
          sceneryLog.PerfMinor && sceneryLog.PerfMinor( drawableBlockCountMessage );
        }
        else if ( this.perfDrawableBlockChangeCount > 0 ) {
          sceneryLog.PerfVerbose && sceneryLog.PerfVerbose( drawableBlockCountMessage );
        }
      }
      sceneryLog && sceneryLog.Display && sceneryLog.pop();
    },
    updateSize: function() {
      var sizeDirty = false;
      if ( this._size.width !== this._currentSize.width ) {
        sizeDirty = true;
        this._currentSize.width = this._size.width;
        this._domElement.style.width = this._size.width + 'px';
      }
      if ( this._size.height !== this._currentSize.height ) {
        sizeDirty = true;
        this._currentSize.height = this._size.height;
        this._domElement.style.height = this._size.height + 'px';
      }
      if ( sizeDirty && !this.options.allowSceneOverflow ) {
        this._domElement.style.clip = 'rect(0px,' + this._size.width + 'px,' + this._size.height + 'px,0px)';
      }
    },
    getRootNode: function() {
      return this._rootNode;
    },
    get rootNode() { return this.getRootNode(); },
    getSize: function() {
      return this._size;
    },
    get size() { return this.getSize(); },
    getBounds: function() {
      return this._size.toBounds();
    },
    get bounds() { return this.getBounds(); },
    setSize: function( size ) {
      assert && assert( size instanceof Dimension2 );
      assert && assert( size.width % 1 === 0, 'Display.width should be an integer' );
      assert && assert( size.width > 0, 'Display.width should be greater than zero' );
      assert && assert( size.height % 1 === 0, 'Display.height should be an integer' );
      assert && assert( size.height > 0, 'Display.height should be greater than zero' );
      if ( !this._size.equals( size ) ) {
        this._size = size;
        this.trigger1( 'displaySize', this._size );
      }
    },
    setWidthHeight: function( width, height ) {
      this.setSize( new Dimension2( width, height ) );
    },
    getWidth: function() {
      return this._size.width;
    },
    get width() { return this.getWidth(); },
    setWidth: function( width ) {
      assert && assert( typeof width === 'number', 'Display.width should be a number' );
      if ( this.getWidth() !== width ) {
        this.setSize( new Dimension2( width, this.getHeight() ) );
      }
    },
    set width( value ) { this.setWidth( value ); },
    getHeight: function() {
      return this._size.height;
    },
    get height() { return this.getHeight(); },
    setHeight: function( height ) {
      assert && assert( typeof height === 'number', 'Display.height should be a number' );
      if ( this.getHeight() !== height ) {
        this.setSize( new Dimension2( this.getWidth(), height ) );
      }
    },
    set height( value ) { this.setHeight( value ); },
    setBackgroundColor: function( color ) {
      assert && assert( color === null || typeof color === 'string' || color instanceof scenery.Color );
      this._backgroundColor = color;
    },
    set backgroundColor( value ) { this.setBackgroundColor( value ); },
    getBackgroundColor: function() {
      return this._backgroundColor;
    },
    get backgroundColor() { return this.getBackgroundColor(); },
    get interactive() { return this._interactive; },
    set interactive( value ) {
      this._interactive = value;
      if ( !this._interactive && this._input ) {
        this._input.clearBatchedEvents();
        this._input.removeTemporaryPointers();
        this._rootNode.interruptSubtreeInput();
      }
    },
    addOverlay: function( overlay ) {
      this._overlays.push( overlay );
      this._domElement.appendChild( overlay.domElement );
      overlay.domElement.setAttribute( 'aria-hidden', true );
    },
    removeOverlay: function( overlay ) {
      this._domElement.removeChild( overlay.domElement );
      this._overlays.splice( _.indexOf( this._overlays, overlay ), 1 );
    },
    getBaseAccessibleInstance: function( trail ) {
      var i;
      for ( i = trail.length - 2; i >= 0; i-- ) {
        if ( trail.nodes[ i ].accessibleContent ) {
          break;
        }
      }
      if ( i < 0 ) {
        return this._rootAccessibleInstance;
      }
      else {
        var leafMostAccessibleNode = trail.nodes[ i ];
        var accessibleInstances = leafMostAccessibleNode._accessibleInstances;
        for ( var j = 0; j < accessibleInstances.length; j++ ) {
          var accessibleInstance = accessibleInstances[ j ];
          if ( trail.isExtensionOf( accessibleInstance.trail ) ) {
            return accessibleInstance;
          }
        }
      }
      throw new Error( 'A base accessible instance must be defined.' );
    },
    markUnsortedAccessibleInstance: function( accessibleInstance ) {
      this._unsortedAccessibleInstances.push( accessibleInstance );
    },
    sortAccessibleInstances: function() {
      while ( this._unsortedAccessibleInstances.length ) {
        this._unsortedAccessibleInstances.pop().sortChildren();
      }
    },
    addAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }
      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.addAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();
      this.getBaseAccessibleInstance( trail ).addSubtree( trail );
      this.sortAccessibleInstances();
      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },
    removeAccessibleTrail: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }
      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.removeAccessibleTrail ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();
      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );
      this.sortAccessibleInstances();
      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },
    changedAccessibleContent: function( trail, oldAccessibleContent, newAccessibleContent ) {
      if ( !this.options.accessibility ) {
        return;
      }
      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility(
        'Display.changedAccessibleContent ' + trail.toString() +
        ' old: ' + ( !!oldAccessibleContent ) +
        ' new: ' + ( !!newAccessibleContent ) );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();
      this.getBaseAccessibleInstance( trail ).removeSubtree( trail );
      this.getBaseAccessibleInstance( trail ).addSubtree( trail );
      this.sortAccessibleInstances();
      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },
    changedAccessibleOrder: function( trail ) {
      if ( !this.options.accessibility ) {
        return;
      }
      sceneryLog && sceneryLog.Accessibility && sceneryLog.Accessibility( 'Display.changedAccessibleOrder ' + trail.toString() );
      sceneryLog && sceneryLog.Accessibility && sceneryLog.push();
      this.getBaseAccessibleInstance( trail ).markAsUnsorted();
      this.sortAccessibleInstances();
      sceneryLog && sceneryLog.Accessibility && sceneryLog.pop();
    },
    getAccessibleDOMElement: function() {
      return this._rootAccessibleInstance.peer.domElement;
    },
    get accessibleDOMElement() { return this.getAccessibleDOMElement(); },
    getUsedRenderersBitmask: function() {
      function renderersUnderBackbone( backbone ) {
        var bitmask = 0;
        _.each( backbone.blocks, function( block ) {
          if ( block instanceof scenery.DOMBlock && block.domDrawable instanceof scenery.BackboneDrawable ) {
            bitmask = bitmask | renderersUnderBackbone( block.domDrawable );
          }
          else {
            bitmask = bitmask | block.renderer;
          }
        } );
        return bitmask;
      }
      return renderersUnderBackbone( this._rootBackbone ) & Renderer.bitmaskRendererArea;
    },
    markTransformRootDirty: function( instance, passTransform ) {
      passTransform ? this._dirtyTransformRoots.push( instance ) : this._dirtyTransformRootsWithoutPass.push( instance );
    },
    updateDirtyTransformRoots: function() {
      sceneryLog && sceneryLog.transformSystem && sceneryLog.transformSystem( 'updateDirtyTransformRoots' );
      sceneryLog && sceneryLog.transformSystem && sceneryLog.push();
      while ( this._dirtyTransformRoots.length ) {
        this._dirtyTransformRoots.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, true );
      }
      while ( this._dirtyTransformRootsWithoutPass.length ) {
        this._dirtyTransformRootsWithoutPass.pop().relativeTransform.updateTransformListenersAndCompute( false, false, this._frameId, false );
      }
      sceneryLog && sceneryLog.transformSystem && sceneryLog.pop();
    },
    markDrawableChangedBlock: function( drawable ) {
      assert && assert( drawable instanceof Drawable );
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableChangedBlock: ' + drawable.toString() );
      this._drawablesToChangeBlock.push( drawable );
    },
    markInstanceRootForDisposal: function( instance ) {
      assert && assert( instance instanceof Instance, 'How would an instance not be an instance of an instance?!?!?' );
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markInstanceRootForDisposal: ' + instance.toString() );
      this._instanceRootsToDispose.push( instance );
    },
    markDrawableForDisposal: function( drawable ) {
      assert && assert( drawable instanceof Drawable );
      sceneryLog && sceneryLog.Display && sceneryLog.Display( 'markDrawableForDisposal: ' + drawable.toString() );
      this._drawablesToDispose.push( drawable );
    },
    markDrawableForLinksUpdate: function( drawable ) {
      assert && assert( drawable instanceof Drawable );
      this._drawablesToUpdateLinks.push( drawable );
    },
    markChangeIntervalToDispose: function( changeInterval ) {
      assert && assert( changeInterval instanceof ChangeInterval );
      this._changeIntervalsToDispose.push( changeInterval );
    },
    updateBackgroundColor: function() {
      assert && assert( this._backgroundColor === null ||
                        typeof this._backgroundColor === 'string' ||
                        this._backgroundColor instanceof scenery.Color );
      var newBackgroundCSS = this._backgroundColor === null ?
                             '' :
                             ( this._backgroundColor.toCSS ?
                               this._backgroundColor.toCSS() :
                               this._backgroundColor );
      if ( newBackgroundCSS !== this._currentBackgroundCSS ) {
        this._currentBackgroundCSS = newBackgroundCSS;
        this._domElement.style.backgroundColor = newBackgroundCSS;
      }
    },
    updateCursor: function() {
      if ( this._input && this._input.mouse && this._input.mouse.point ) {
        if ( this._input.mouse.cursor ) {
          sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( 'set on pointer: ' + this._input.mouse.cursor );
          return this.setSceneCursor( this._input.mouse.cursor );
        }
        var mouseTrail = this._rootNode.trailUnderPointer( this._input.mouse );
        if ( mouseTrail ) {
          for ( var i = mouseTrail.getCursorCheckIndex(); i >= 0; i-- ) {
            var node = mouseTrail.nodes[ i ];
            var cursor = node.getCursor();
            if ( cursor ) {
              sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( cursor + ' on ' + node.constructor.name + '#' + node.id );
              return this.setSceneCursor( cursor );
            }
          }
        }
        sceneryLog && sceneryLog.Cursor && sceneryLog.Cursor( '--- for ' + ( mouseTrail ? mouseTrail.toString() : '(no hit)' ) );
      }
      return this.setSceneCursor( this.options.defaultCursor );
    },
    setSceneCursor: function( cursor ) {
      if ( cursor !== this._lastCursor ) {
        this._lastCursor = cursor;
        var customCursors = Display.customCursors[ cursor ];
        if ( customCursors ) {
          for ( var i = customCursors.length - 1; i >= 0; i-- ) {
            this._domElement.style.cursor = customCursors[ i ];
            if ( this._assumeFullWindow !== false ) {
              document.body.style.cursor = customCursors[ i ];
            }
          }
        }
        else {
          this._domElement.style.cursor = cursor;
          if ( this._assumeFullWindow !== false ) {
            document.body.style.cursor = cursor;
          }
        }
      }
    },
    applyCSSHacks: function() {
      if ( !this.options.allowSceneOverflow ) {
        this._domElement.style.overflow = 'hidden';
      }
      document.onselectstart = function() {
        return false;
      };
      this._domElement.style.msTouchAction = 'none';
      Features.setStyle( this._domElement, Features.fontSmoothing, 'antialiased' );
      if ( this.options.allowCSSHacks ) {
        Features.setStyle( this._domElement, Features.userDrag, 'none' );
        Features.setStyle( this._domElement, Features.userSelect, 'none' );
        Features.setStyle( this._domElement, Features.touchAction, 'none' );
        Features.setStyle( this._domElement, Features.touchCallout, 'none' );
        Features.setStyle( this._domElement, Features.tapHighlightColor, 'rgba(0,0,0,0)' );
      }
    },
    canvasDataURL: function( callback ) {
      this.canvasSnapshot( function( canvas ) {
        callback( canvas.toDataURL() );
      } );
    },
    canvasSnapshot: function( callback ) {
      var canvas = document.createElement( 'canvas' );
      canvas.width = this._size.width;
      canvas.height = this._size.height;
      var context = canvas.getContext( '2d' );
      this._rootNode.renderToCanvas( canvas, context, function() {
        callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );
      }, this.domElement.style.backgroundColor );
    },
    setPointerDisplayVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );
      var hasOverlay = !!this._pointerOverlay;
      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerOverlay );
          this._pointerOverlay.dispose();
          this._pointerOverlay = null;
        }
        else {
          this._pointerOverlay = new PointerOverlay( this, this._rootNode );
          this.addOverlay( this._pointerOverlay );
        }
      }
    },
    setPointerAreaDisplayVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );
      var hasOverlay = !!this._pointerAreaOverlay;
      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._pointerAreaOverlay );
          this._pointerAreaOverlay.dispose();
          this._pointerAreaOverlay = null;
        }
        else {
          this._pointerAreaOverlay = new PointerAreaOverlay( this, this._rootNode );
          this.addOverlay( this._pointerAreaOverlay );
        }
      }
    },
    setCanvasNodeBoundsVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );
      var hasOverlay = !!this._canvasAreaBoundsOverlay;
      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._canvasAreaBoundsOverlay );
          this._canvasAreaBoundsOverlay.dispose();
          this._canvasAreaBoundsOverlay = null;
        }
        else {
          this._canvasAreaBoundsOverlay = new CanvasNodeBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._canvasAreaBoundsOverlay );
        }
      }
    },
    setFittedBlockBoundsVisible: function( visibility ) {
      assert && assert( typeof visibility === 'boolean' );
      var hasOverlay = !!this._fittedBlockBoundsOverlay;
      if ( visibility !== hasOverlay ) {
        if ( !visibility ) {
          this.removeOverlay( this._fittedBlockBoundsOverlay );
          this._fittedBlockBoundsOverlay.dispose();
          this._fittedBlockBoundsOverlay = null;
        }
        else {
          this._fittedBlockBoundsOverlay = new FittedBlockBoundsOverlay( this, this._rootNode );
          this.addOverlay( this._fittedBlockBoundsOverlay );
        }
      }
    },
    resizeOnWindowResize: function() {
      var self = this;
      var resizer = function() {
        self.setWidthHeight( window.innerWidth, window.innerHeight );
      };
      window.addEventListener( 'resize', resizer );
      resizer();
    },
    updateOnRequestAnimationFrame: function( stepCallback ) {
      var lastTime = 0;
      var timeElapsedInSeconds = 0;
      var self = this;
      (function step() {
        self._requestAnimationFrameID = window.requestAnimationFrame( step, self._domElement );
        var timeNow = new Date().getTime();
        if ( lastTime !== 0 ) {
          timeElapsedInSeconds = ( timeNow - lastTime ) / 1000.0;
        }
        lastTime = timeNow;
        stepCallback && stepCallback( timeElapsedInSeconds );
        self.updateDisplay();
      })();
    },
    cancelUpdateOnRequestAnimationFrame: function() {
      window.cancelAnimationFrame( this._requestAnimationFrameID );
    },
    initializeEvents: function() {
      assert && assert( !this._input, 'Events cannot be attached twice to a display (for now)' );
      var input = new Input( this, !this._listenToOnlyElement, this._batchDOMEvents, this._assumeFullWindow, this._passiveEvents );
      this._input = input;
      input.connectListeners();
    },
    detachEvents: function() {
      assert && assert( this._input, 'detachEvents() should be called only when events are attached' );
      this._input.disconnectListeners();
      this._input = null;
    },
    dispose: function() {
      if ( this._input ) {
        this.detachEvents();
      }
      this._rootNode.removeRootedDisplay( this );
    },
    ensureNotPainting: function() {
      assert && assert( !this._isPainting,
        'This should not be run in the call tree of updateDisplay(). If you see this, it is likely that either the ' +
        'last updateDisplay() had a thrown error and it is trying to be run again (in which case, investigate that ' +
        'error), OR code was run/triggered from inside an updateDisplay() that has the potential to cause an infinite ' +
        'loop, e.g. CanvasNode paintCanvas() call manipulating another Node, or a bounds listener that Scenery missed.' );
    },
    fuzzMouseEvents: function( averageEventQuantity ) {
      var chance;
      assert && assert( averageEventQuantity > 0, 'averageEventQuantity must be positive: ' + averageEventQuantity );
      while ( ( chance = Math.random() ) < 1 - 1 / ( averageEventQuantity + 1 ) ) {
        var domEvent;
        if ( chance < ( this._fuzzMouseLastMoved ? 0.7 : 0.4 ) ) {
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec
          domEvent.initMouseEvent( this._fuzzMouseIsDown ? 'mouseup' : 'mousedown', true, true, window, 1, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );
          this._input.validatePointers();
          if ( this._fuzzMouseIsDown ) {
            this._input.mouseUp( this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = false;
          }
          else {
            this._input.mouseDown( null, this._fuzzMousePosition, domEvent );
            this._fuzzMouseIsDown = true;
          }
          this._fuzzMouseLastMoved = false;
        }
        else {
          this._fuzzMousePosition = new Vector2(
            Math.floor( Math.random() * this.width ),
            Math.floor( Math.random() * this.height )
          );
          domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec
          domEvent.initMouseEvent( 'mousemove', true, true, window, 0, // click count
            this._fuzzMousePosition.x, this._fuzzMousePosition.y, this._fuzzMousePosition.x, this._fuzzMousePosition.y,
            false, false, false, false,
            0, // button
            null );
          this._input.validatePointers();
          this._input.mouseMove( this._fuzzMousePosition, domEvent );
          this._fuzzMouseLastMoved = true;
        }
      }
    },
    getDebugHTML: function() {
      function str( ob ) {
        return ob ? ob.toString() : ob + '';
      }
      var headerStyle = 'font-weight: bold; font-size: 120%; margin-top: 5px;';
      var depth = 0;
      var result = '';
      result += '<div style="' + headerStyle + '">Display Summary</div>';
      result += this._size.toString() + ' frame:' + this._frameId + ' input:' + !!this._input + ' cursor:' + this._lastCursor + '<br>';
      function nodeCount( node ) {
        var count = 1; // for us
        for ( var i = 0; i < node.children.length; i++ ) {
          count += nodeCount( node.children[ i ] );
        }
        return count;
      }
      result += 'Nodes: ' + nodeCount( this._rootNode ) + '<br>';
      function instanceCount( instance ) {
        var count = 1; // for us
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += instanceCount( instance.children[ i ] );
        }
        return count;
      }
      result += this._baseInstance ? ( 'Instances: ' + instanceCount( this._baseInstance ) + '<br>' ) : '';
      function drawableCount( drawable ) {
        var count = 1; // for us
        if ( drawable.blocks ) {
          _.each( drawable.blocks, function( childDrawable ) {
            count += drawableCount( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            count += drawableCount( childDrawable );
          }
          count += drawableCount( drawable.lastDrawable );
        }
        return count;
      }
      result += this._rootBackbone ? ( 'Drawables: ' + drawableCount( this._rootBackbone ) + '<br>' ) : '';
      var drawableCountMap = {}; // {string} drawable constructor name => {number} count of seen
      function countRetainedDrawable( drawable ) {
        var name = drawable.constructor.name;
        if ( drawableCountMap[ name ] ) {
          drawableCountMap[ name ]++;
        }
        else {
          drawableCountMap[ name ] = 1;
        }
      }
      function retainedDrawableCount( instance ) {
        var count = 0;
        if ( instance.selfDrawable ) {
          countRetainedDrawable( instance.selfDrawable );
          count++;
        }
        if ( instance.groupDrawable ) {
          countRetainedDrawable( instance.groupDrawable );
          count++;
        }
        if ( instance.sharedCacheDrawable ) {
          countRetainedDrawable( instance.sharedCacheDrawable );
          count++;
        }
        for ( var i = 0; i < instance.children.length; i++ ) {
          count += retainedDrawableCount( instance.children[ i ] );
        }
        return count;
      }
      result += this._baseInstance ? ( 'Retained Drawables: ' + retainedDrawableCount( this._baseInstance ) + '<br>' ) : '';
      for ( var drawableName in drawableCountMap ) {
        result += '&nbsp;&nbsp;&nbsp;&nbsp;' + drawableName + ': ' + drawableCountMap[ drawableName ] + '<br>';
      }
      function blockSummary( block ) {
        if ( !block.firstDrawable || !block.lastDrawable ) {
          return;
        }
        var hasBackbone = block.domDrawable && block.domDrawable.blocks;
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';
        div += block.toString();
        if ( !hasBackbone ) {
          div += ' (' + block.drawableCount + ' drawables)';
        }
        div += '</div>';
        depth += 1;
        if ( hasBackbone ) {
          for ( var k = 0; k < block.domDrawable.blocks.length; k++ ) {
            div += blockSummary( block.domDrawable.blocks[ k ] );
          }
        }
        depth -= 1;
        return div;
      }
      if ( this._rootBackbone ) {
        result += '<div style="' + headerStyle + '">Block Summary</div>';
        for ( var i = 0; i < this._rootBackbone.blocks.length; i++ ) {
          result += blockSummary( this._rootBackbone.blocks[ i ] );
        }
      }
      function instanceSummary( instance ) {
        var iSummary = '';
        function addQualifier( text ) {
          iSummary += ' <span style="color: #008">' + text + '</span>';
        }
        var node = instance.node;
        iSummary += instance.id;
        iSummary += ' ' + ( node.constructor.name ? node.constructor.name : '?' );
        iSummary += ' <span style="font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '">' + node.id + '</span>';
        iSummary += node.getDebugHTMLExtras();
        if ( !node.visible ) {
          addQualifier( 'invis' );
        }
        if ( !instance.visible ) {
          addQualifier( 'I-invis' );
        }
        if ( !instance.relativeVisible ) {
          addQualifier( 'I-rel-invis' );
        }
        if ( !instance.selfVisible ) {
          addQualifier( 'I-self-invis' );
        }
        if ( !instance.fittability.ancestorsFittable ) {
          addQualifier( 'nofit-ancestor' );
        }
        if ( !instance.fittability.selfFittable ) {
          addQualifier( 'nofit-self' );
        }
        if ( node.pickable === true ) {
          addQualifier( 'pickable' );
        }
        if ( node.pickable === false ) {
          addQualifier( 'unpickable' );
        }
        if ( instance.trail.isPickable() ) {
          addQualifier( '<span style="color: #808">hits</span>' );
        }
        if ( node.clipArea ) {
          addQualifier( 'clipArea' );
        }
        if ( node.mouseArea ) {
          addQualifier( 'mouseArea' );
        }
        if ( node.touchArea ) {
          addQualifier( 'touchArea' );
        }
        if ( node.getInputListeners().length ) {
          addQualifier( 'inputListeners' );
        }
        if ( node.getRenderer() ) {
          addQualifier( 'renderer:' + node.getRenderer() );
        }
        if ( node.isLayerSplit() ) {
          addQualifier( 'layerSplit' );
        }
        if ( node.opacity < 1 ) {
          addQualifier( 'opacity:' + node.opacity );
        }
        if ( node._boundsEventCount > 0 ) {
          addQualifier( '<span style="color: #800">boundsListen:' + node._boundsEventCount + ':' + node._boundsEventSelfCount + '</span>' );
        }
        var transformType = '';
        switch( node.transform.getMatrix().type ) {
          case Matrix3.Types.IDENTITY:
            transformType = '';
            break;
          case Matrix3.Types.TRANSLATION_2D:
            transformType = 'translated';
            break;
          case Matrix3.Types.SCALING:
            transformType = 'scale';
            break;
          case Matrix3.Types.AFFINE:
            transformType = 'affine';
            break;
          case Matrix3.Types.OTHER:
            transformType = 'other';
            break;
          default:
            throw new Error( 'invalid matrix type: ' + node.transform.getMatrix().type );
        }
        if ( transformType ) {
          iSummary += ' <span style="color: #88f" title="' + node.transform.getMatrix().toString().replace( '\n', '&#10;' ) + '">' + transformType + '</span>';
        }
        iSummary += ' <span style="color: #888">[Trail ' + instance.trail.indices.join( '.' ) + ']</span>';
        iSummary += ' <span style="color: #c88">' + str( instance.state ) + '</span>';
        iSummary += ' <span style="color: #8c8">' + node._rendererSummary.bitmask.toString( 16 ) + ( node._rendererBitmask !== Renderer.bitmaskNodeDefault ? ' (' + node._rendererBitmask.toString( 16 ) + ')' : '' ) + '</span>';
        return iSummary;
      }
      function drawableSummary( drawable ) {
        var drawableString = drawable.toString();
        if ( drawable.visible ) {
          drawableString = '<strong>' + drawableString + '</strong>';
        }
        if ( drawable.dirty ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #c00;">[x]</span>' : '' );
        }
        if ( !drawable.fittable ) {
          drawableString += ( drawable.dirty ? ' <span style="color: #0c0;">[no-fit]</span>' : '' );
        }
        return drawableString;
      }
      function printInstanceSubtree( instance ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';
        function addDrawable( name, drawable ) {
          div += ' <span style="color: #888">' + name + ':' + drawableSummary( drawable ) + '</span>';
        }
        div += instanceSummary( instance );
        instance.selfDrawable && addDrawable( 'self', instance.selfDrawable );
        instance.groupDrawable && addDrawable( 'group', instance.groupDrawable );
        instance.sharedCacheDrawable && addDrawable( 'sharedCache', instance.sharedCacheDrawable );
        div += '</div>';
        result += div;
        depth += 1;
        _.each( instance.children, function( childInstance ) {
          printInstanceSubtree( childInstance );
        } );
        depth -= 1;
      }
      if ( this._baseInstance ) {
        result += '<div style="' + headerStyle + '">Root Instance Tree</div>';
        printInstanceSubtree( this._baseInstance );
      }
      _.each( this._sharedCanvasInstances, function( instance ) {
        result += '<div style="' + headerStyle + '">Shared Canvas Instance Tree</div>';
        printInstanceSubtree( instance );
      } );
      function printDrawableSubtree( drawable ) {
        var div = '<div style="margin-left: ' + ( depth * 20 ) + 'px">';
        div += drawableSummary( drawable );
        if ( drawable.instance ) {
          div += ' <span style="color: #0a0;">(' + drawable.instance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.instance );
        }
        else if ( drawable.backboneInstance ) {
          div += ' <span style="color: #a00;">(' + drawable.backboneInstance.trail.toPathString() + ')</span>';
          div += '&nbsp;&nbsp;&nbsp;' + instanceSummary( drawable.backboneInstance );
        }
        div += '</div>';
        result += div;
        if ( drawable.blocks ) {
          depth += 1;
          _.each( drawable.blocks, function( childDrawable ) {
            printDrawableSubtree( childDrawable );
          } );
          depth -= 1;
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          depth += 1;
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            printDrawableSubtree( childDrawable );
          }
          printDrawableSubtree( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop
          depth -= 1;
        }
      }
      if ( this._rootBackbone ) {
        result += '<div style="font-weight: bold;">Root Drawable Tree</div>';
        printDrawableSubtree( this._rootBackbone );
      }
      return result;
    },
    popupDebug: function() {
      var htmlContent = '<!DOCTYPE html>' +
                        '<html lang="en">' +
                        '<head><title>Scenery Debug Snapshot</title></head>' +
                        '<body style="font-size: 12px;">' + this.getDebugHTML() + '</body>' +
                        '</html>';
      window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );
    },
    toStringWithChildren: function( mutateRoot, rootName ) {
      rootName = rootName || 'scene';
      var rootNode = this._rootNode;
      var result = '';
      var nodes = this._rootNode.getTopologicallySortedNodes().slice( 0 ).reverse(); // defensive slice, in case we store the order somewhere
      function name( node ) {
        return node === rootNode ? rootName : ( ( node.constructor.name ? node.constructor.name.toLowerCase() : '(node)' ) + node.id );
      }
      _.each( nodes, function( node ) {
        if ( result ) {
          result += '\n';
        }
        if ( mutateRoot && node === rootNode ) {
          var props = rootNode.getPropString( '  ', false );
          var mutation = ( props ? ( '\n' + props + '\n' ) : '' );
          if ( mutation !== '' ) {
            result += rootName + '.mutate( {' + mutation + '} )';
          }
          else {
            result = result.slice( 0, -1 );
          }
        }
        else {
          result += 'var ' + name( node ) + ' = ' + node.toString( '', false );
        }
        _.each( node.children, function( child ) {
          result += '\n' + name( node ) + '.addChild( ' + name( child ) + ' );';
        } );
      } );
      return result;
    },
    foreignObjectRasterization: function( callback ) {
      var canvasUrlMap = {};
      function scanForCanvases( drawable ) {
        if ( drawable.blocks ) {
          _.each( drawable.blocks, function( childDrawable ) {
            scanForCanvases( childDrawable );
          } );
        }
        else if ( drawable.firstDrawable && drawable.lastDrawable ) {
          for ( var childDrawable = drawable.firstDrawable; childDrawable !== drawable.lastDrawable; childDrawable = childDrawable.nextDrawable ) {
            scanForCanvases( childDrawable );
          }
          scanForCanvases( drawable.lastDrawable ); // wasn't hit in our simplified (and safer) loop
          if ( drawable.domElement && drawable.domElement instanceof window.HTMLCanvasElement ) {
            canvasUrlMap[ drawable.canvasId ] = drawable.domElement.toDataURL();
          }
        }
      }
      scanForCanvases( this._rootBackbone );
      var doc = document.implementation.createHTMLDocument( '' );
      doc.documentElement.innerHTML = this.domElement.outerHTML;
      doc.documentElement.setAttribute( 'xmlns', doc.documentElement.namespaceURI );
      var displayCanvases = doc.documentElement.getElementsByTagName( 'canvas' );
      displayCanvases = Array.prototype.slice.call( displayCanvases ); // don't use a live HTMLCollection copy!
      for ( var i = 0; i < displayCanvases.length; i++ ) {
        var displayCanvas = displayCanvases[ i ];
        var cssText = displayCanvas.style.cssText;
        var displayImg = doc.createElement( 'img' );
        var src = canvasUrlMap[ displayCanvas.id ];
        assert && assert( src, 'Must have missed a toDataURL() on a Canvas' );
        displayImg.src = src;
        displayImg.setAttribute( 'style', cssText );
        displayCanvas.parentNode.replaceChild( displayImg, displayCanvas );
      }
      var displayWidth = this.width;
      var displayHeight = this.height;
      var completeFunction = function() {
        Display.elementToSVGDataURL( doc.documentElement, displayWidth, displayHeight, callback );
      };
      var replacedImages = 0; // Count how many images get replaced. We'll decrement with each finished image.
      var hasReplacedImages = false; // Whether any images are replaced
      var displaySVGImages = Array.prototype.slice.call( doc.documentElement.getElementsByTagName( 'image' ) );
      for ( var j = 0; j < displaySVGImages.length; j++ ) {
        var displaySVGImage = displaySVGImages[ j ];
        var currentHref = displaySVGImage.getAttribute( 'xlink:href' );
        if ( currentHref.slice( 0, 5 ) !== 'data:' ) {
          replacedImages++;
          hasReplacedImages = true;
          (function() {
            var refImage = new window.Image();
            var svgImage = displaySVGImage;
            refImage.onload = function() {
              var refCanvas = document.createElement( 'canvas' );
              refCanvas.width = refImage.width;
              refCanvas.height = refImage.height;
              var refContext = refCanvas.getContext( '2d' );
              refContext.drawImage( refImage, 0, 0 );
              svgImage.setAttribute( 'xlink:href', refCanvas.toDataURL() );
              if ( --replacedImages === 0 ) {
                completeFunction();
              }
              assert && assert( replacedImages >= 0 );
            };
            refImage.onerror = function() {
              if ( --replacedImages === 0 ) {
                completeFunction();
              }
              assert && assert( replacedImages >= 0 );
            };
            refImage.src = currentHref;
          })();
        }
      }
      if ( !hasReplacedImages ) {
        completeFunction();
      }
    },
    popupRasterization: function() {
      this.foreignObjectRasterization( window.open );
    }
  }, Events.prototype ), {
    elementToSVGDataURL: function( domElement, width, height, callback ) {
      var canvas = document.createElement( 'canvas' );
      var context = canvas.getContext( '2d' );
      canvas.width = width;
      canvas.height = height;
      var xhtml = new window.XMLSerializer().serializeToString( domElement );
      var data = '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                 '<foreignObject width="100%" height="100%">' +
                 '<div xmlns="http://www.w3.org/1999/xhtml">' +
                 xhtml +
                 '</div>' +
                 '</foreignObject>' +
                 '</svg>';
      var img = new window.Image();
      img.onload = function() {
        context.drawImage( img, 0, 0 );
        callback( canvas.toDataURL() ); // Endpoint here
      };
      img.onerror = function() {
        callback( null );
      };
      var uint8array = new window.TextEncoderLite( 'utf-8' ).encode( data );
      var base64 = window.fromByteArray( uint8array );
      img.src = 'data:image/svg+xml;base64,' + base64;
    },
    set focus( value ) {
      this.focusProperty.value = value;
    },
    get focus() {
      return this.focusProperty.value;
    }
  } );
  Display.customCursors = {
    'scenery-grab-pointer': [ 'grab', '-moz-grab', '-webkit-grab', 'pointer' ],
    'scenery-grabbing-pointer': [ 'grabbing', '-moz-grabbing', '-webkit-grabbing', 'pointer' ]
  };
  Display.focusProperty = new Property( null, {
    tandem: Tandem.createStaticTandem( 'display' ).createTandem( 'focusProperty' ),
    phetioValueType: TFocus
  } );
  Display.assertSubtreeDisposed = function( node ) {
    assert && assert( !node.isDisposed(), 'Disposed nodes should not be included in a scene graph to display.' );
    if ( assert ) {
      for ( var i = 0; i < node.children.length; i++ ) {
        Display.assertSubtreeDisposed( node.children[ i ] );
      }
    }
  };
  Display.userGestureEmitter = new Emitter();
  return Display;
} );
define( 'VIBE/vibe',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'vibe' );
} );
define('audio',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define("audio!VIBE/empty.mp3", function(){ return [{base64:'data:audio/mpeg;base64,//s0wAAAAAABLgAAACAAACXAAAAE//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////s0wD2AAAABLgAAACAAACXAAAAE//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAAAAAAAAAAAAAAAAAAAAAAAA//s0wHsAAAABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wLiAAAABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wPYADQABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//s0wP+AD2ABLgAAACAAACXAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'}
];});
define( 'VIBE/Sound',['require','SCENERY/display/Display','PHET_CORE/inherit','PHET_CORE/platform','AXON/Property','VIBE/vibe','audio!VIBE/empty.mp3'],function( require ) {
  'use strict';
  var Display = require( 'SCENERY/display/Display' );
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var Property = require( 'AXON/Property' );
  var vibe = require( 'VIBE/vibe' );
  var empty = require( 'audio!VIBE/empty.mp3' );
  var audioEnabledProperty = new Property( true );
  var audioContext;
  if ( 'AudioContext' in window ) {
    audioContext = new AudioContext();
  }
  else if ( 'webkitAudioContext' in window ) {
    audioContext = new webkitAudioContext(); // eslint-disable-line no-undef
  }
  if ( audioContext ) {
    var gainNode = audioContext.createGain();
    gainNode.connect( audioContext.destination );
    gainNode.gain.value = phet.chipper.queryParameters.audioVolume;
  }
  function Sound( soundInfoArray ) {
    var self = this;
    var localSoundInfoArray = soundInfoArray;
    if ( !( soundInfoArray instanceof Array ) ) {
      localSoundInfoArray = new Array( soundInfoArray );
    }
    localSoundInfoArray.forEach( function( soundInfo ) {
      if ( typeof( soundInfo ) !== 'object' || ( typeof( soundInfo.base64 ) === 'undefined' && typeof( soundInfo.url ) === 'undefined' ) ) {
        throw new Error( 'Error with soundInfo object: Does not contain a necessary value.' );
      }
    } );
    this.sound = document.createElement( 'audio' );
    var supportedFormatFound = false;
    var soundInfo = null;
    for ( var i = 0; i < localSoundInfoArray.length && !supportedFormatFound; i++ ) {
      soundInfo = localSoundInfoArray[ i ];
      var audioFormat;
      if ( soundInfo.url ) {
        audioFormat = 'audio/' + soundInfo.url.slice( soundInfo.url.lastIndexOf( '.' ) + 1,
            soundInfo.url.lastIndexOf( '?' ) >= 0 ? soundInfo.url.lastIndexOf( '?' ) : soundInfo.url.length );
      }
      else {
        audioFormat = soundInfo.base64.slice( soundInfo.base64.indexOf( ':' ) + 1, soundInfo.base64.indexOf( ';' ) );
      }
      if ( this.sound.canPlayType && this.sound.canPlayType( audioFormat ) ) {
        supportedFormatFound = true;
      }
      else {
        if ( i === localSoundInfoArray.length - 1 ) {
          console.log( 'Warning: No supported audio formats found, sound will not be played.' );
        }
      }
    }
    if ( supportedFormatFound ) {
      if ( audioContext ) {
        var arrayBuff;
        if ( soundInfo.base64 ) {
          var soundData = ( soundInfo.base64 ? soundInfo.base64 : this.sound.getAttribute( 'src' )).replace( new RegExp( '^.*,' ), '' );
          var byteChars = window.atob( soundData );
          var byteArray = new window.Uint8Array( byteChars.length );
          for ( var j = 0; j < byteArray.length; j++ ) {
            byteArray[ j ] = byteChars.charCodeAt( j ); // need check to make sure this cast doesn't give problems?
          }
          arrayBuff = byteArray.buffer;
          audioContext.decodeAudioData( arrayBuff,
            function( audioData ) {
              self.audioBuffer = audioData;
            },
            function() {
              console.log( 'Error: Unable to decode audio data.' );
            } );
        }
        else {
          var request = new XMLHttpRequest();
          request.open( 'GET', soundInfo.url, true );
          request.responseType = 'arraybuffer';
          request.onload = function() {
            audioContext.decodeAudioData( request.response,
              function( audioData ) {
                self.audioBuffer = audioData;
              },
              function() { console.log( 'Error loading and decoding sound, sound name: ' + soundInfo.url ); }
            );
          };
          request.onerror = function() {
            console.log( 'Error occurred on attempt to load sound data.' );
          };
          request.send();
        }
      }
      else {
        this.sound.setAttribute( 'src', soundInfo.base64 ? soundInfo.base64 : soundInfo.url );
        this.sound.load();
      }
    }
  }
  vibe.register( 'Sound', Sound );
  inherit( Object, Sound, {
    play: function() {
      if ( !Sound.audioEnabledProperty.get() ) {
        return;
      }
      if ( audioContext ) {
        if ( this.audioBuffer ) {
          this.soundSource = audioContext.createBufferSource();
          this.soundSource.buffer = this.audioBuffer;
          this.soundSource.connect( gainNode );
          if ( typeof this.soundSource.start === 'function' ) {
            this.soundSource.start( 0 );
          }
          else if ( typeof this.soundSource.noteOn === 'function' ) {
            this.soundSource.noteOn( 0 );
          }
        }
      }
      else {
        this.sound.play && this.sound.play();
      }
    },
    stop: function() {
      if ( audioContext && this.soundSource ) {
        this.soundSource.stop();
      }
      else {
        this.sound.pause && this.sound.pause();
        this.sound.currentTime = 0;
      }
    }
  }, {
    audioEnabledProperty: audioEnabledProperty
  } );
  if ( audioContext ) {
    var removeUserInteractionListeners = function(){
      window.removeEventListener( 'touchstart', resumeAudioContext, false );
      if ( Display.userGestureEmitter.hasListener( resumeAudioContext ) ) {
        Display.userGestureEmitter.removeListener( resumeAudioContext );
      }
    };
    var resumeAudioContext = function(){
      if ( audioContext.state !== 'running' ) {
        audioContext.resume()
          .then( function(){
            removeUserInteractionListeners();
          } )
          .catch( function(){
            var errorMessage = 'error when trying to resume audio context, err = ' + err;
            console.error( errorMessage );
            assert && alert( errorMessage );
          } );
      }
      else {
        removeUserInteractionListeners();
      }
    };
    window.addEventListener( 'touchstart', resumeAudioContext, false );
    Display.userGestureEmitter.addListener( resumeAudioContext );
  }
  return Sound;
} );
define( 'VEGAS/vegas',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'vegas' );
} );
define("audio!VEGAS/ding", function(){ return [{base64:'data:audio/mpeg;base64,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'},
{base64:'data:audio/ogg;base64,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'}
];});
define("audio!VEGAS/boing", function(){ return [{base64:'data:audio/mpeg;base64,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'},
{base64:'data:audio/ogg;base64,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'}
];});
define("audio!VEGAS/trumpet", function(){ return [{base64:'data:audio/mpeg;base64,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'},
{base64:'data:audio/ogg;base64,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'}
];});
define("audio!VEGAS/cheer", function(){ return [{base64:'data:audio/mpeg;base64,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'},
{base64:'data:audio/ogg;base64,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'}
];});
define( 'VEGAS/GameAudioPlayer',['require','PHET_CORE/inherit','VIBE/Sound','VEGAS/vegas','audio!VEGAS/ding','audio!VEGAS/boing','audio!VEGAS/trumpet','audio!VEGAS/cheer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Sound = require( 'VIBE/Sound' );
  var vegas = require( 'VEGAS/vegas' );
  var dingSound = require( 'audio!VEGAS/ding' );
  var boingSound = require( 'audio!VEGAS/boing' );
  var trumpetSound = require( 'audio!VEGAS/trumpet' );
  var cheerSound = require( 'audio!VEGAS/cheer' );
  var CORRECT_ANSWER = new Sound( dingSound );
  var WRONG_ANSWER = new Sound( boingSound );
  var IMPERFECT_SCORE = new Sound( trumpetSound );
  var PERFECT_SCORE = new Sound( cheerSound );
  function GameAudioPlayer( soundEnabledProperty ) {
    this.soundEnabledProperty = soundEnabledProperty; // @private
  }
  vegas.register( 'GameAudioPlayer', GameAudioPlayer );
  return inherit( Object, GameAudioPlayer, {
    correctAnswer: function() {
      if ( this.soundEnabledProperty.value ) {
        CORRECT_ANSWER.play();
      }
    },
    wrongAnswer: function() {
      if ( this.soundEnabledProperty.value ) {
        WRONG_ANSWER.play();
      }
    },
    gameOverZeroScore: function() {
      if ( this.soundEnabledProperty.value ) {
        WRONG_ANSWER.play();
      }
    },
    gameOverImperfectScore: function() {
      if ( this.soundEnabledProperty.value ) {
        IMPERFECT_SCORE.play();
      }
    },
    gameOverPerfectScore: function() {
      if ( this.soundEnabledProperty.value ) {
        PERFECT_SCORE.play();
      }
    }
  } );
} );
define( 'SUN/buttons/TextPushButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularPushButton','SUN/sun','SCENERY/nodes/Text','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var sun = require( 'SUN/sun' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  function TextPushButton( text, options ) {
    options = _.extend( {
      textFill: 'black',
      maxTextWidth: null,
      tandem: Tandem.tandemRequired(),
      accessibleLabel: text
    }, options );
    var textNode = new Text( text, {
      font: options.font,
      fill: options.textFill,
      maxWidth: options.maxTextWidth,
      tandem: options.tandem.createTandem( 'textNode' )
    } );
    RectangularPushButton.call( this, _.extend( { content: textNode }, options ) );
  }
  sun.register( 'TextPushButton', TextPushButton );
  return inherit( RectangularPushButton, TextPushButton );
} );
define("string!VEGAS/check",function(){return window.phet.chipper.strings.get("VEGAS/check");});
define("string!VEGAS/tryAgain",function(){return window.phet.chipper.strings.get("VEGAS/tryAgain");});
define("string!VEGAS/showAnswer",function(){return window.phet.chipper.strings.get("VEGAS/showAnswer");});
define("string!VEGAS/next",function(){return window.phet.chipper.strings.get("VEGAS/next");});
define( 'BUILD_AN_ATOM/game/view/ProblemView',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY/util/Color','SCENERY_PHET/FaceNode','VEGAS/GameAudioPlayer','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/nodes/Text','SUN/buttons/TextPushButton','string!VEGAS/check','string!VEGAS/tryAgain','string!VEGAS/showAnswer','string!VEGAS/next'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var Color = require( 'SCENERY/util/Color' );
  var FaceNode = require( 'SCENERY_PHET/FaceNode' );
  var GameAudioPlayer = require( 'VEGAS/GameAudioPlayer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TextPushButton = require( 'SUN/buttons/TextPushButton' );
  var checkString = require( 'string!VEGAS/check' );
  var tryAgainString = require( 'string!VEGAS/tryAgain' );
  var showAnswerString = require( 'string!VEGAS/showAnswer' );
  var nextString = require( 'string!VEGAS/next' );
  var BUTTON_FONT = new PhetFont( 20 );
  var BUTTON_FILL = new Color( 0, 255, 153 );
  var POINT_TEXT_OPTIONS = { font: new PhetFont( { size: 20, weight: 'bold' } ) };
  var BUTTON_MAX_WIDTH = 350;
  var BUTTON_TOUCH_AREA_DILATION = 8;
  function ProblemView( problem, layoutBounds, tandem ) {
    Node.call( this ); // Call super constructor.
    var self = this;
    this.problem = problem;
    this.gameAudioPlayer = new GameAudioPlayer( problem.model.soundEnabledProperty );
    assert && assert( layoutBounds.minX === 0 && layoutBounds.minY === 0 );
    this.problemPresentationNode = new Node();
    this.addChild( this.problemPresentationNode );
    this.interactiveAnswerNode = new Node();
    this.addChild( this.interactiveAnswerNode );
    var faceNode = new FaceNode( layoutBounds.width * 0.4, { visible: false, opacity: 0.75 } );
    var pointDisplay = new Text( '+0', POINT_TEXT_OPTIONS );
    pointDisplay.centerX = 0;
    pointDisplay.top = faceNode.height / 2;
    faceNode.addChild( pointDisplay );
    this.addChild( faceNode );
    this.buttons = [];
    this.checkAnswerButton = new TextPushButton( checkString, {
      listener: function() { self.checkAnswer(); },
      font: BUTTON_FONT,
      baseColor: BUTTON_FILL,
      maxWidth: BUTTON_MAX_WIDTH,
      touchAreaXDilation: BUTTON_TOUCH_AREA_DILATION,
      touchAreaYDilation: BUTTON_TOUCH_AREA_DILATION,
      tandem: tandem.createTandem( 'checkAnswerButton' )
    } );
    this.addChild( this.checkAnswerButton );
    this.buttons.push( this.checkAnswerButton );
    this.nextButton = new TextPushButton( nextString, {
      listener: function() { problem.next(); },
      font: BUTTON_FONT,
      baseColor: BUTTON_FILL,
      maxWidth: BUTTON_MAX_WIDTH,
      touchAreaXDilation: BUTTON_TOUCH_AREA_DILATION,
      touchAreaYDilation: BUTTON_TOUCH_AREA_DILATION,
      tandem: tandem.createTandem( 'nextButton' )
    } );
    this.addChild( this.nextButton );
    this.buttons.push( this.nextButton );
    this.tryAgainButton = new TextPushButton( tryAgainString, {
      listener: function() { problem.tryAgain(); },
      font: BUTTON_FONT,
      baseColor: BUTTON_FILL,
      maxWidth: BUTTON_MAX_WIDTH,
      touchAreaXDilation: BUTTON_TOUCH_AREA_DILATION,
      touchAreaYDilation: BUTTON_TOUCH_AREA_DILATION,
      tandem: tandem.createTandem( 'tryAgainButton' )
    } );
    this.addChild( this.tryAgainButton );
    this.buttons.push( this.tryAgainButton );
    this.displayCorrectAnswerButton = new TextPushButton( showAnswerString, {
      listener: function() { problem.displayCorrectAnswer(); },
      font: BUTTON_FONT,
      baseColor: BUTTON_FILL,
      maxWidth: BUTTON_MAX_WIDTH,
      touchAreaXDilation: BUTTON_TOUCH_AREA_DILATION,
      touchAreaYDilation: BUTTON_TOUCH_AREA_DILATION,
      tandem: tandem.createTandem( 'displayCorrectAnswerButton' )
    } );
    this.addChild( this.displayCorrectAnswerButton );
    this.buttons.push( this.displayCorrectAnswerButton );
    var hideButtonsAndFace = function hideButtonsAndFace() {
      self.buttons.forEach( function( button ) {
        button.visible = false;
      } );
      faceNode.visible = false;
    };
    hideButtonsAndFace();
    var setAnswerNodeInteractive = function( interactive ) {
      self.interactiveAnswerNode.pickable = interactive;
    };
    var stateChangeHandlers = {
      presentingProblem: function() {
        self.clearAnswer();
        setAnswerNodeInteractive( true );
        self.checkAnswerButton.visible = true;
      },
      problemSolvedCorrectly: function() {
        setAnswerNodeInteractive( false );
        faceNode.smile();
        pointDisplay.text = '+' + problem.scoreProperty.get();
        faceNode.visible = true;
        self.nextButton.visible = true;
        self.gameAudioPlayer.correctAnswer();
      },
      presentingTryAgain: function() {
        setAnswerNodeInteractive( false );
        faceNode.frown();
        pointDisplay.text = '';
        faceNode.visible = true;
        self.tryAgainButton.visible = true;
        self.gameAudioPlayer.wrongAnswer();
      },
      attemptsExhausted: function() {
        setAnswerNodeInteractive( false );
        self.displayCorrectAnswerButton.visible = true;
        faceNode.frown();
        pointDisplay.text = '';
        faceNode.visible = true;
        self.gameAudioPlayer.wrongAnswer();
      },
      displayingCorrectAnswer: function() {
        setAnswerNodeInteractive( false );
        self.nextButton.visible = true;
        self.displayCorrectAnswer();
      }
    };
    problem.problemStateProperty.link( function( problemState ) {
      hideButtonsAndFace();
      if ( stateChangeHandlers[ problemState ] !== undefined ) {
        stateChangeHandlers[ problemState ]();
      }
    } );
    this.setButtonCenter( layoutBounds.width * 0.75, layoutBounds.height * 0.92 );
    faceNode.centerX = layoutBounds.width / 2;
    faceNode.centerY = layoutBounds.height / 2;
  }
  buildAnAtom.register( 'ProblemView', ProblemView );
  return inherit( Node, ProblemView, {
    clearAnswer: function() {},
    displayCorrectAnswer: function() {},
    checkAnswer: function() {},
    setButtonCenter: function( x, y ) {
      this.buttons.forEach( function( button ) {
        button.centerX = x;
        button.centerY = y;
      } );
    }
  } );
} );
define("string!BUILD_AN_ATOM/whatIsTheTotalCharge",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/whatIsTheTotalCharge");});
define( 'BUILD_AN_ATOM/game/view/CountsToChargeProblemView',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY_PHET/MultiLineText','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/NumberEntryNode','BUILD_AN_ATOM/game/view/ParticleCountsNode','BUILD_AN_ATOM/game/view/ProblemView','AXON/Property','SHRED/ShredConstants','ifphetio!PHET_IO/types/TNumber','string!BUILD_AN_ATOM/whatIsTheTotalCharge'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var ParticleCountsNode = require( 'BUILD_AN_ATOM/game/view/ParticleCountsNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var whatIsTheTotalChargeString = require( 'string!BUILD_AN_ATOM/whatIsTheTotalCharge' );
  function CountsToChargeProblemView( countsToChargeProblem, layoutBounds, tandem ) {
    this.chargeAnswerProperty = new Property( 0, {
      tandem: tandem.createTandem( 'chargeAnswerProperty' ),
      phetioValueType: TNumber( {
        type: 'Integer'
      } )
    } );
    ProblemView.call( this, countsToChargeProblem, layoutBounds, tandem ); // Call super constructor.
    var self = this;
    var particleCountsNode = new ParticleCountsNode( countsToChargeProblem.answerAtom );
    self.problemPresentationNode.addChild( particleCountsNode );
    var questionPrompt = new MultiLineText( whatIsTheTotalChargeString, {
      align: 'left',
      font: new PhetFont( 24 ),
      maxWidth: 200,
      tandem: tandem.createTandem( 'questionPrompt' )
    } );
    self.interactiveAnswerNode.addChild( questionPrompt );
    var numberEntryNode = new NumberEntryNode(
      self.chargeAnswerProperty,
      tandem.createTandem( 'numberEntryNode' ), {
        showPlusForPositive: true,
        signAfterValue: false,
        getTextColor: ShredConstants.CHARGE_TEXT_COLOR,
        maxValue: 99,
        minValue: -99
      } );
    self.interactiveAnswerNode.addChild( numberEntryNode );
    particleCountsNode.centerX = layoutBounds.width * 0.3;
    particleCountsNode.centerY = layoutBounds.height * 0.5;
    questionPrompt.centerX = layoutBounds.width * 0.65;
    questionPrompt.centerY = layoutBounds.height * 0.5;
    numberEntryNode.left = questionPrompt.right + 10;
    numberEntryNode.centerY = questionPrompt.centerY;
  }
  buildAnAtom.register( 'CountsToChargeProblemView', CountsToChargeProblemView );
  return inherit( ProblemView, CountsToChargeProblemView, {
    checkAnswer: function() {
      var userSubmittedAnswer = new NumberAtom( {
        protonCount: this.problem.answerAtom.protonCountProperty.get(),
        neutronCount: this.problem.answerAtom.neutronCountProperty.get(),
        electronCount: this.problem.answerAtom.protonCountProperty.get() - this.chargeAnswerProperty.value
      } );
      this.problem.checkAnswer( userSubmittedAnswer );
    },
    displayCorrectAnswer: function() {
      this.chargeAnswerProperty.value = this.problem.answerAtom.chargeProperty.get();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/CountsToChargeProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/CountsToChargeProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var CountsToChargeProblemView = require( 'BUILD_AN_ATOM/game/view/CountsToChargeProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function CountsToChargeProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'CountsToChargeProblem', CountsToChargeProblem );
  return inherit( BAAGameProblem, CountsToChargeProblem, {
    createView: function( layoutBounds, tandem ) {
      return new CountsToChargeProblemView( this, layoutBounds, tandem.createTandem( 'countsToChargeProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode',['require','SHRED/AtomIdentifier','BUILD_AN_ATOM/common/BAASharedConstants','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY/nodes/Node','BUILD_AN_ATOM/game/view/NumberEntryNode','AXON/Property','SCENERY_PHET/PhetColorScheme','SCENERY/nodes/Rectangle','SHRED/ShredConstants','SCENERY/nodes/Text','DOT/Vector2','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var BAASharedConstants = require( 'BUILD_AN_ATOM/common/BAASharedConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var Property = require( 'AXON/Property' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Vector2 = require( 'DOT/Vector2' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var SYMBOL_BOX_WIDTH = 275; // In screen coords, which are roughly pixels.
  var SYMBOL_BOX_HEIGHT = 300; // In screen coords, which are roughly pixels.
  var NUMBER_FONT = new PhetFont( 56 );
  var NUMBER_INSET = 15; // In screen coords, which are roughly pixels.
  var NUMBER_ENTRY_NODE_SIDE_INSET = 10; // In screen coords, which are roughly pixels.
  function InteractiveSymbolNode( numberAtom, tandem, options ) {
    Node.call( this, options ); // Call super constructor.
    var self = this;
    options = _.extend( { // defaults
      interactiveProtonCount: false,
      interactiveMassNumber: false,
      interactiveCharge: false
    }, options );
    self.protonCountProperty = new Property( options.interactiveProtonCount ? 0 : numberAtom.protonCountProperty.get(), {
      tandem: tandem.createTandem( 'protonCountProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );
    self.massNumberProperty = new Property( options.interactiveMassNumber ? 0 : numberAtom.massNumberProperty.get(), {
      tandem: tandem.createTandem( 'massNumberProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );
    self.chargeProperty = new Property( options.interactiveCharge ? 0 : numberAtom.chargeProperty.get(), {
      tandem: tandem.createTandem( 'chargeProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );
    var boundingBox = new Rectangle( 0, 0, SYMBOL_BOX_WIDTH, SYMBOL_BOX_HEIGHT, 0, 0, {
      stroke: 'black',
      lineWidth: 2,
      fill: 'white'
    } );
    this.addChild( boundingBox );
    var symbolText = new Text( '', {
      font: new PhetFont( 150 ),
      fill: 'black',
      center: new Vector2( SYMBOL_BOX_WIDTH / 2, SYMBOL_BOX_HEIGHT / 2 )
    } );
    boundingBox.addChild( symbolText );
    var elementCaption = new Text( '', {
      font: new PhetFont( 40 ),
      fill: PhetColorScheme.RED_COLORBLIND,
      top: SYMBOL_BOX_HEIGHT + 20,
      centerX: SYMBOL_BOX_WIDTH / 2,
      maxWidth: SYMBOL_BOX_WIDTH
    } );
    boundingBox.addChild( elementCaption );
    var updateElement = function( protonCount ) {
      symbolText.text = protonCount > 0 ? AtomIdentifier.getSymbol( protonCount ) : '';
      symbolText.center = new Vector2( SYMBOL_BOX_WIDTH / 2, SYMBOL_BOX_HEIGHT / 2 );
      elementCaption.text = protonCount > 0 ? AtomIdentifier.getName( protonCount ) : '';
      elementCaption.centerX = SYMBOL_BOX_WIDTH / 2;
    };
    var interactiveNumberCenterYOffset = new Text( '8', { font: NUMBER_FONT } ).height / 2;
    if ( options.interactiveProtonCount ) {
      boundingBox.addChild( new NumberEntryNode(
        self.protonCountProperty,
        tandem.createTandem( 'protonCountEntryNode' ), {
          minValue: 0,
          maxValue: 99,
          getTextColor: function() { return PhetColorScheme.RED_COLORBLIND; },
          left: NUMBER_ENTRY_NODE_SIDE_INSET,
          centerY: SYMBOL_BOX_HEIGHT - NUMBER_INSET - interactiveNumberCenterYOffset
        } ) );
      self.protonCountProperty.link( updateElement );
    }
    else {
      var protonCountDisplay = new Text( numberAtom.protonCountProperty.get(), {
        font: NUMBER_FONT,
        fill: PhetColorScheme.RED_COLORBLIND,
        left: NUMBER_INSET,
        bottom: SYMBOL_BOX_HEIGHT - NUMBER_INSET
      } );
      boundingBox.addChild( protonCountDisplay );
      updateElement( numberAtom.protonCountProperty.get() );
    }
    if ( options.interactiveMassNumber ) {
      boundingBox.addChild( new NumberEntryNode(
        self.massNumberProperty,
        tandem.createTandem( 'massNumberEntryNode' ), {
          minValue: 0,
          maxValue: 99,
          left: NUMBER_ENTRY_NODE_SIDE_INSET,
          centerY: NUMBER_INSET + interactiveNumberCenterYOffset
        } ) );
    }
    else {
      var massNumberDisplay = new Text( numberAtom.massNumberProperty.get(), {
        font: NUMBER_FONT,
        fill: 'black',
        left: NUMBER_INSET,
        top: NUMBER_INSET
      } );
      boundingBox.addChild( massNumberDisplay );
    }
    if ( options.interactiveCharge ) {
      boundingBox.addChild( new NumberEntryNode(
        self.chargeProperty,
        tandem.createTandem( 'chargeEntryNode' ), {
          minValue: -99,
          maxValue: 99,
          showPlusForPositive: true,
          getTextColor: ShredConstants.CHARGE_TEXT_COLOR,
          right: SYMBOL_BOX_WIDTH - NUMBER_ENTRY_NODE_SIDE_INSET,
          centerY: NUMBER_INSET + interactiveNumberCenterYOffset
        } ) );
    }
    else {
      var charge = numberAtom.chargeProperty.get();
      var chargeSign = charge > 0 ? '+' : charge < 0 ? BAASharedConstants.MINUS_SIGN : '';
      var chargeDisplay = new Text( Math.abs( charge ).toString() + chargeSign, {
        font: NUMBER_FONT,
        fill: ShredConstants.CHARGE_TEXT_COLOR( numberAtom.chargeProperty.get() ),
        right: SYMBOL_BOX_WIDTH - NUMBER_INSET,
        top: NUMBER_INSET
      } );
      boundingBox.addChild( chargeDisplay );
    }
  }
  buildAnAtom.register( 'InteractiveSymbolNode', InteractiveSymbolNode );
  return inherit( Node, InteractiveSymbolNode, {
    reset: function() {
      this.protonCountProperty.reset();
      this.massNumberProperty.reset();
      this.chargeProperty.reset();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/CountsToSymbolProblemView',['require','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/InteractiveSymbolNode','BUILD_AN_ATOM/game/view/ParticleCountsNode','BUILD_AN_ATOM/game/view/ProblemView'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var InteractiveSymbolNode = require( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode' );
  var ParticleCountsNode = require( 'BUILD_AN_ATOM/game/view/ParticleCountsNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  function CountsToSymbolProblemView( toSymbolProblem, layoutBounds, tandem ) {
    this.interactiveSymbolNode = new InteractiveSymbolNode(
      toSymbolProblem.answerAtom,
      tandem.createTandem( 'interactiveSymbolNode' ), {
        interactiveProtonCount: toSymbolProblem.configurableProtonCount,
        interactiveMassNumber: toSymbolProblem.configurableMassNumber,
        interactiveCharge: toSymbolProblem.configurableCharge
      }
    );
    ProblemView.call( this, toSymbolProblem, layoutBounds, tandem ); // Call super constructor.
    this.interactiveSymbolNode.scale( 0.75 );
    this.interactiveAnswerNode.addChild( this.interactiveSymbolNode );
    var particleCountsNode = new ParticleCountsNode( toSymbolProblem.answerAtom );
    this.problemPresentationNode.addChild( particleCountsNode );
    particleCountsNode.centerX = layoutBounds.width * 0.3;
    particleCountsNode.centerY = layoutBounds.height * 0.48;
    this.interactiveSymbolNode.centerX = layoutBounds.width * 0.745;
    this.interactiveSymbolNode.centerY = layoutBounds.height * 0.54;
  }
  buildAnAtom.register( 'CountsToSymbolProblemView', CountsToSymbolProblemView );
  return inherit( ProblemView, CountsToSymbolProblemView, {
    checkAnswer: function() {
      var userSubmittedAtom = new NumberAtom( {
        protonCount: this.interactiveSymbolNode.protonCountProperty.value,
        neutronCount: this.interactiveSymbolNode.massNumberProperty.value - this.interactiveSymbolNode.protonCountProperty.value,
        electronCount: this.interactiveSymbolNode.protonCountProperty.value - this.interactiveSymbolNode.chargeProperty.value
      } );
      this.problem.checkAnswer( userSubmittedAtom );
    },
    displayCorrectAnswer: function() {
      this.interactiveSymbolNode.protonCountProperty.value = this.problem.answerAtom.protonCountProperty.get();
      this.interactiveSymbolNode.massNumberProperty.value = this.problem.answerAtom.massNumberProperty.get();
      this.interactiveSymbolNode.chargeProperty.value = this.problem.answerAtom.chargeProperty.get();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/CountsToSymbolProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/CountsToSymbolProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var CountsToSymbolProblemView = require( 'BUILD_AN_ATOM/game/view/CountsToSymbolProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function CountsToSymbolProblem( buildAnAtomGameModel, answerAtom, configurableProtonCount, configurableMassNumber, configurableCharge ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
    this.configurableProtonCount = configurableProtonCount;
    this.configurableMassNumber = configurableMassNumber;
    this.configurableCharge = configurableCharge;
  }
  buildAnAtom.register( 'CountsToSymbolProblem', CountsToSymbolProblem );
  return inherit( BAAGameProblem, CountsToSymbolProblem, {
    createView: function( layoutBounds, tandem ) {
      return new CountsToSymbolProblemView( this, layoutBounds, tandem.createTandem( 'countsToSymbolProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/ToElementProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','PHET_CORE/inherit','SHRED/ShredConstants'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  function ToElementProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'ToElementProblem', ToElementProblem );
  return inherit( BAAGameProblem, ToElementProblem, {
    checkAnswer: function( submittedAtom, submittedNeutralOrIon ) {
      assert && assert( this.problemStateProperty.get() === 'presentingProblem', 'Unexpected problem state: ' +
                                                                                 this.problemStateProperty.get() );
      this.numSubmissionsProperty.set( this.numSubmissionsProperty.get() + 1 ) ;
      var isCorrect = submittedAtom.protonCountProperty.get() === this.answerAtom.protonCountProperty.get() &&
                      submittedAtom.neutronCountProperty.get() === this.answerAtom.neutronCountProperty.get() &&
                      ( ( submittedNeutralOrIon === 'neutral' && this.answerAtom.chargeProperty.get() === 0 ) ||
                        ( submittedNeutralOrIon === 'ion' && this.answerAtom.chargeProperty.get() !== 0 ) );
      var pointsIfCorrect = this.numSubmissionsProperty.get() === 1 ? 2 : 1;
      this.model.emitCheckAnswer( isCorrect, pointsIfCorrect, this.answerAtom, submittedAtom, {
        correctCharge: this.answerAtom.chargeProperty.get() === 0 ? 'neutral' : 'ion',
        submittedCharge: submittedNeutralOrIon
      } );
      if ( isCorrect ) {
        this.scoreProperty.set( pointsIfCorrect );
        this.model.scoreProperty.set( this.model.scoreProperty.get() + this.scoreProperty.get() );
        this.problemStateProperty.set( 'problemSolvedCorrectly' );
      }
      else {
        if ( this.numSubmissionsProperty.get() < ShredConstants.MAX_PROBLEM_ATTEMPTS ) {
          this.problemStateProperty.set( 'presentingTryAgain' );
        }
        else {
          this.problemStateProperty.set( 'attemptsExhausted' );
        }
      }
    }
  } );
} );
define("string!BUILD_AN_ATOM/findTheElement",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/findTheElement");});
define("string!BUILD_AN_ATOM/ion",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/ion");});
define("string!BUILD_AN_ATOM/neutralAtom",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/neutralAtom");});
define("string!BUILD_AN_ATOM/isIt",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/isIt");});
define( 'BUILD_AN_ATOM/game/view/ToElementProblemView',['require','SUN/AquaRadioButton','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Node','SHRED/model/NumberAtom','SHRED/view/PeriodicTableNode','BUILD_AN_ATOM/game/view/ProblemView','AXON/Property','SCENERY/nodes/Text','ifphetio!PHET_IO/types/TString','string!BUILD_AN_ATOM/findTheElement','string!BUILD_AN_ATOM/ion','string!BUILD_AN_ATOM/neutralAtom','string!BUILD_AN_ATOM/isIt'],function( require ) {
  'use strict';
  var AquaRadioButton = require( 'SUN/AquaRadioButton' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var PeriodicTableNode = require( 'SHRED/view/PeriodicTableNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Property = require( 'AXON/Property' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var findTheElementString = require( 'string!BUILD_AN_ATOM/findTheElement' );
  var ionString = require( 'string!BUILD_AN_ATOM/ion' );
  var neutralAtomString = require( 'string!BUILD_AN_ATOM/neutralAtom' );
  var isItString = require( 'string!BUILD_AN_ATOM/isIt' );
  var TITLE_FONT = new PhetFont( 30 );
  var INSET = 10;
  var CELL_DIMENSION = 25;
  var MAX_WIDTH = 100; // empirically determined for long strings
  function ToElementProblemView( countsToElementProblem, layoutBounds, tandem ) {
    this.periodicTableAtom = new NumberAtom( { tandem: tandem.createTandem( 'periodicTableAtom' ) } );
    this.neutralOrIonProperty = new Property( 'noSelection', {
      tandem: tandem.createTandem( 'neutralOrIonProperty' ),
      phetioValueType: TString
    } );
    ProblemView.call( this, countsToElementProblem, layoutBounds, tandem ); // Call super constructor.
    var self = this;
    this.periodicTable = new PeriodicTableNode( this.periodicTableAtom, {
      tandem: tandem.createTandem( 'periodicTable' ),
      interactiveMax: 118,
      cellDimension: CELL_DIMENSION,
      enabledCellColor: new LinearGradient( 0, 0, 0, CELL_DIMENSION ).addColorStop( 0, 'white' ).addColorStop( 1, 'rgb( 240, 240, 240 )' ),
      selectedCellColor: 'yellow'
    } );
    this.periodicTable.scale( 0.85 ); // scale value empirically determined
    this.interactiveAnswerNode.addChild( this.periodicTable );
    var problemTitle = new Text( findTheElementString, {
      font: TITLE_FONT,
      maxWidth: this.periodicTable.width
    } );
    this.problemPresentationNode.addChild( problemTitle );
    var neutralVersusIonPrompt = new Text( isItString, {
      font: new PhetFont( 24 ),
      maxWidth: MAX_WIDTH
    } );
    var neutralAtomRadioButton = new AquaRadioButton( this.neutralOrIonProperty, 'neutral', new Text( neutralAtomString, {
      font: new PhetFont( 18 ),
      maxWidth: MAX_WIDTH
    } ), {
      radius: 8,
      tandem: tandem.createTandem( 'neutralAtomRadioButton' )
    } );
    var ionRadioButton = new AquaRadioButton( this.neutralOrIonProperty, 'ion', new Text( ionString, {
      font: new PhetFont( 18 ),
      maxWidth: MAX_WIDTH
    } ), {
      radius: 8,
      tandem: tandem.createTandem( 'ionRadioButton' )
    } );
    var neutralAtomVersusIonQuestion = new Node();
    neutralAtomVersusIonQuestion.addChild( neutralVersusIonPrompt );
    neutralAtomRadioButton.left = neutralVersusIonPrompt.right + 10;
    neutralAtomRadioButton.centerY = neutralVersusIonPrompt.centerY;
    neutralAtomVersusIonQuestion.addChild( neutralAtomRadioButton );
    ionRadioButton.left = neutralAtomVersusIonQuestion.right + 10;
    ionRadioButton.centerY = neutralVersusIonPrompt.centerY;
    neutralAtomVersusIonQuestion.addChild( ionRadioButton );
    this.interactiveAnswerNode.addChild( neutralAtomVersusIonQuestion );
    var updateNeutralAtomVersusIonQuestionVisibility = function( protonCount ) {
      neutralAtomVersusIonQuestion.visible = protonCount > 0;
    };
    this.periodicTableAtom.protonCountProperty.link( updateNeutralAtomVersusIonQuestionVisibility );
    var updateCheckAnswerButton = function( neutralOrIon ) {
      self.checkAnswerButton.enabled = neutralOrIon !== 'noSelection';
      self.checkAnswerButton.pickable = neutralOrIon !== 'noSelection';
    };
    this.neutralOrIonProperty.link( updateCheckAnswerButton );
    this.disposeToElementProblemView = function() {
      self.neutralOrIonProperty.unlink( updateCheckAnswerButton );
      self.periodicTableAtom.protonCountProperty.unlink( updateNeutralAtomVersusIonQuestionVisibility );
    };
    this.periodicTable.right = layoutBounds.width - INSET;
    this.periodicTable.centerY = layoutBounds.height * 0.55;
    var maxTitleWidth = this.periodicTable.width * 0.9;
    if ( problemTitle.width > maxTitleWidth ) {
      problemTitle.scale( maxTitleWidth / problemTitle.width );
    }
    problemTitle.centerX = this.periodicTable.centerX;
    problemTitle.bottom = this.periodicTable.top - 30; // Offset empirically determined.
    neutralAtomVersusIonQuestion.centerX = this.periodicTable.centerX;
    neutralAtomVersusIonQuestion.top = this.periodicTable.bottom + 20;
  }
  buildAnAtom.register( 'ToElementProblemView', ToElementProblemView );
  return inherit( ProblemView, ToElementProblemView, {
    checkAnswer: function() {
      var submittedAtom = new NumberAtom( {
        protonCount: this.periodicTableAtom.protonCountProperty.get(),
        neutronCount: this.problem.answerAtom.neutronCountProperty.get(),
        electronCount: this.problem.answerAtom.electronCountProperty.get()
      } );
      this.problem.checkAnswer( submittedAtom, this.neutralOrIonProperty.value );
    },
    clearAnswer: function() {
      this.periodicTableAtom.protonCountProperty.set( 0 );
      this.periodicTableAtom.neutronCountProperty.set( 0 );
      this.periodicTableAtom.electronCountProperty.set( 0 );
      this.neutralOrIonProperty.reset();
    },
    displayCorrectAnswer: function() {
      this.periodicTableAtom.protonCountProperty.set( this.problem.answerAtom.protonCountProperty.get() );
      this.periodicTableAtom.neutronCountProperty.set( this.problem.answerAtom.neutronCountProperty.get() );
      this.periodicTableAtom.electronCountProperty.set( this.problem.answerAtom.electronCountProperty.get() );
      this.neutralOrIonProperty.value = this.problem.answerAtom.chargeProperty.get() === 0 ? 'neutral' : 'ion';
    },
    dispose: function() {
      this.periodicTable.dispose();
      this.disposeToElementProblemView();
      ProblemView.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/CountsToElementProblemView',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/view/ParticleCountsNode','PHET_CORE/inherit','BUILD_AN_ATOM/game/view/ToElementProblemView'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var ParticleCountsNode = require( 'BUILD_AN_ATOM/game/view/ParticleCountsNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ToElementProblemView = require( 'BUILD_AN_ATOM/game/view/ToElementProblemView' );
  function CountsToElementProblemView( countsToElementProblem, layoutBounds, tandem ) {
    ToElementProblemView.call( this, countsToElementProblem, layoutBounds, tandem ); // Call super constructor.
    var particleCountsNode = new ParticleCountsNode( countsToElementProblem.answerAtom );
    this.problemPresentationNode.addChild( particleCountsNode );
    particleCountsNode.centerX = layoutBounds.width * 0.25;
    particleCountsNode.centerY = this.periodicTable.centerY;
  }
  buildAnAtom.register( 'CountsToElementProblemView', CountsToElementProblemView );
  return inherit( ToElementProblemView, CountsToElementProblemView );
} );
define( 'BUILD_AN_ATOM/game/model/CountsToElementProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/ToElementProblem','BUILD_AN_ATOM/game/view/CountsToElementProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var ToElementProblem = require( 'BUILD_AN_ATOM/game/model/ToElementProblem' );
  var CountsToElementProblemView = require( 'BUILD_AN_ATOM/game/view/CountsToElementProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function CountsToElementProblem( buildAnAtomGameModel, answerAtom ) {
    ToElementProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'CountsToElementProblem', CountsToElementProblem );
  return inherit( ToElementProblem, CountsToElementProblem, {
    createView: function( layoutBounds, tandem ) {
      return new CountsToElementProblemView( this, layoutBounds, tandem.createTandem( 'countsToElementProblemView' ) );
    }
  } );
} );
define("string!BUILD_AN_ATOM/whatIsTheMassNumber",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/whatIsTheMassNumber");});
define( 'BUILD_AN_ATOM/game/view/CountsToMassNumberProblemView',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','SCENERY_PHET/MultiLineText','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/NumberEntryNode','BUILD_AN_ATOM/game/view/ParticleCountsNode','BUILD_AN_ATOM/game/view/ProblemView','AXON/Property','ifphetio!PHET_IO/types/TNumber','string!BUILD_AN_ATOM/whatIsTheMassNumber'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var ParticleCountsNode = require( 'BUILD_AN_ATOM/game/view/ParticleCountsNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Property = require( 'AXON/Property' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var whatIsTheMassNumberString = require( 'string!BUILD_AN_ATOM/whatIsTheMassNumber' );
  function CountsToMassNumberProblemView( countsToMassNumberProblem, layoutBounds, tandem ) {
    this.massNumberAnswerProperty = new Property( 0, {
      tandem: tandem.createTandem( 'massNumberAnswerProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );
    ProblemView.call( this, countsToMassNumberProblem, layoutBounds, tandem ); // Call super constructor.
    var self = this;
    var particleCountsNode = new ParticleCountsNode( countsToMassNumberProblem.answerAtom );
    self.problemPresentationNode.addChild( particleCountsNode );
    var questionPrompt = new MultiLineText( whatIsTheMassNumberString, {
      align: 'left',
      font: new PhetFont( 24 ),
      maxWidth: 200,
      tandem: tandem.createTandem( 'questionPrompt' )
    } );
    self.interactiveAnswerNode.addChild( questionPrompt );
    var numberEntryNode = new NumberEntryNode(
      self.massNumberAnswerProperty,
      tandem.createTandem( 'numberEntryNode' ), {
        minValue: 0,
        maxValue: 99
      } );
    self.interactiveAnswerNode.addChild( numberEntryNode );
    particleCountsNode.centerX = layoutBounds.width * 0.3;
    particleCountsNode.centerY = layoutBounds.height * 0.5;
    questionPrompt.centerX = layoutBounds.width * 0.65;
    questionPrompt.centerY = layoutBounds.height * 0.5;
    numberEntryNode.left = questionPrompt.right + 10;
    numberEntryNode.centerY = questionPrompt.centerY;
  }
  buildAnAtom.register( 'CountsToMassNumberProblemView', CountsToMassNumberProblemView );
  return inherit( ProblemView, CountsToMassNumberProblemView, {
    checkAnswer: function() {
      var userSubmittedAnswer = new NumberAtom( {
        protonCount: this.problem.answerAtom.protonCountProperty.get(),
        neutronCount: this.massNumberAnswerProperty.value - this.problem.answerAtom.protonCountProperty.get(),
        electronCount: this.problem.answerAtom.electronCountProperty.get()
      } );
      this.problem.checkAnswer( userSubmittedAnswer );
    },
    displayCorrectAnswer: function() {
      this.massNumberAnswerProperty.value = this.problem.answerAtom.massNumberProperty.get();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/CountsToMassNumberProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/CountsToMassNumberProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var CountsToMassNumberProblemView = require( 'BUILD_AN_ATOM/game/view/CountsToMassNumberProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function CountsToMassNumberProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'CountsToMassNumberProblem', CountsToMassNumberProblem );
  return inherit( BAAGameProblem, CountsToMassNumberProblem, {
    createView: function( layoutBounds, tandem ) {
      return new CountsToMassNumberProblemView( this, layoutBounds, tandem.createTandem( 'countsToMassNumberProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode',['require','SHRED/view/AtomNode','BUILD_AN_ATOM/buildAnAtom','SCENERY/nodes/Node','PHET_CORE/inherit','SHRED/model/ParticleAtom','SHRED/view/ParticleView','SHRED/model/Particle','AXON/Property','BUILD_AN_ATOM/common/view/AtomView','BUILD_AN_ATOM/common/BAAGlobalOptions'],function( require ) {
  'use strict';
  var AtomNode = require( 'SHRED/view/AtomNode' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ParticleAtom = require( 'SHRED/model/ParticleAtom' );
  var ParticleView = require( 'SHRED/view/ParticleView' );
  var Particle = require( 'SHRED/model/Particle' );
  var Property = require( 'AXON/Property' );
  var AtomView = require( 'BUILD_AN_ATOM/common/view/AtomView' );
  var BAAGlobalOptions = require( 'BUILD_AN_ATOM/common/BAAGlobalOptions' );
  function NonInteractiveSchematicAtomNode( numberAtom, modelViewTransform, tandem ) {
    Node.call( this, { pickable: false } ); // Call super constructor.
    var particleAtom = new ParticleAtom( { tandem: tandem.createTandem( 'particleAtom' ) } );
    var atomNode = new AtomNode( particleAtom, modelViewTransform, {
      showElementNameProperty: new Property( false ),
      showNeutralOrIonProperty: new Property( false ),
      showStableOrUnstableProperty: new Property( false ),
      tandem: tandem.createTandem( 'atomNode' )
    } );
    this.addChild( atomNode );
    var particleLayer = new Node();
    this.addChild( particleLayer );
    var particleGroupTandem = tandem.createGroupTandem( 'particle' );
    var particleViewGroupTandem = tandem.createGroupTandem( 'particleView' );
    var particleViews = [];
    var createAndAddParticles = function( particleType, number ) {
      _.times( number, function() {
        var particle = new Particle( particleType, {
          tandem: particleGroupTandem.createNextTandem(),
          maxZLayer: AtomView.NUM_NUCLEON_LAYERS - 1
        } );
        particleAtom.addParticle( particle );
        var particleView = new ParticleView( particle, modelViewTransform, {
          highContrastProperty: BAAGlobalOptions.highContrastParticlesProperty,
          tandem: particleViewGroupTandem.createNextTandem()
        } );
        particleLayer.addChild( particleView );
        particleViews.push( particleView );
      } );
    };
    createAndAddParticles( 'proton', numberAtom.protonCountProperty.get() );
    createAndAddParticles( 'neutron', numberAtom.neutronCountProperty.get() );
    createAndAddParticles( 'electron', numberAtom.electronCountProperty.get() );
    particleAtom.moveAllParticlesToDestination();
    var particleViewsInNucleus = _.filter( particleLayer.children, function( particleView ) {
      return particleView.particle.destinationProperty.get().distance( particleAtom.positionProperty.get() ) < particleAtom.innerElectronShellRadius;
    } );
    if ( particleViewsInNucleus.length > 3 ) {
      particleViewsInNucleus = _.sortBy( particleViewsInNucleus, function( particleView ) {
        return -particleView.particle.destinationProperty.get().distance( particleAtom.positionProperty.get() );
      } );
      particleViewsInNucleus.forEach( function( particleView ) {
        particleLayer.removeChild( particleView );
        particleLayer.addChild( particleView );
      } );
    }
    this.disposeNonInteractiveSchematicAtomNode = function() {
      particleViews.forEach( function( particleView ) {
        particleView.dispose();
      } );
      atomNode.dispose();
    };
  }
  buildAnAtom.register( 'NonInteractiveSchematicAtomNode', NonInteractiveSchematicAtomNode );
  return inherit( Node, NonInteractiveSchematicAtomNode, {
    dispose: function() {
      this.disposeNonInteractiveSchematicAtomNode();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/SchematicToChargeProblemView',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','SCENERY_PHET/MultiLineText','BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/NumberEntryNode','BUILD_AN_ATOM/game/view/ProblemView','AXON/Property','SHRED/ShredConstants','DOT/Vector2','ifphetio!PHET_IO/types/TNumber','string!BUILD_AN_ATOM/whatIsTheTotalCharge'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var NonInteractiveSchematicAtomNode = require( 'BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var Vector2 = require( 'DOT/Vector2' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var whatIsTheTotalChargeString = require( 'string!BUILD_AN_ATOM/whatIsTheTotalCharge' );
  function SchematicToChargeProblemView( schematicToChargeProblem, layoutBounds, tandem ) {
    this.chargeAnswerProperty = new Property( 0, {
      tandem: tandem.createTandem( 'chargeAnswerProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } );
    ProblemView.call( this, schematicToChargeProblem, layoutBounds, tandem ); // Call super constructor.
    var self = this;
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( layoutBounds.width * 0.275, layoutBounds.height * 0.5 ),
      0.8 );
    var nonInteractiveSchematicNode = new NonInteractiveSchematicAtomNode( schematicToChargeProblem.answerAtom,
      modelViewTransform,
      tandem.createTandem( 'noninteractiveSchematicAtomNode' ) );
    this.problemPresentationNode.addChild( nonInteractiveSchematicNode );
    var questionPrompt = new MultiLineText( whatIsTheTotalChargeString, {
      align: 'left',
      font: new PhetFont( 24 ),
      maxWidth: 200,
      tandem: tandem.createTandem( 'questionPrompt' )
    } );
    this.interactiveAnswerNode.addChild( questionPrompt );
    var chargeEntryNode = new NumberEntryNode(
      self.chargeAnswerProperty,
      tandem.createTandem( 'chargeEntryNode' ), {
        minValue: -99,
        maxValue: 99,
        showPlusForPositive: true,
        signAfterValue: false,
        getTextColor: ShredConstants.CHARGE_TEXT_COLOR
      } );
    self.interactiveAnswerNode.addChild( chargeEntryNode );
    questionPrompt.centerX = layoutBounds.width * 0.65;
    questionPrompt.centerY = layoutBounds.height * 0.5;
    chargeEntryNode.left = questionPrompt.right + 10;
    chargeEntryNode.centerY = questionPrompt.centerY;
    this.disposeSchematicToChargeProblemView = function() {
      nonInteractiveSchematicNode.dispose();
    };
  }
  buildAnAtom.register( 'SchematicToChargeProblemView', SchematicToChargeProblemView );
  return inherit( ProblemView, SchematicToChargeProblemView, {
    checkAnswer: function() {
      var userSubmittedAnswer = new NumberAtom( {
        protonCount: this.problem.answerAtom.protonCountProperty.get(),
        neutronCount: this.problem.answerAtom.neutronCountProperty.get(),
        electronCount: this.problem.answerAtom.protonCountProperty.get() - this.chargeAnswerProperty.value
      } );
      this.problem.checkAnswer( userSubmittedAnswer );
    },
    displayCorrectAnswer: function() {
      this.chargeAnswerProperty.value = this.problem.answerAtom.chargeProperty.get();
    },
    dispose: function() {
      this.disposeSchematicToChargeProblemView();
      ProblemView.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SchematicToChargeProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/SchematicToChargeProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var SchematicToChargeProblemView = require( 'BUILD_AN_ATOM/game/view/SchematicToChargeProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SchematicToChargeProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'SchematicToChargeProblem', SchematicToChargeProblem );
  return inherit( BAAGameProblem, SchematicToChargeProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SchematicToChargeProblemView( this, layoutBounds, tandem.createTandem( 'schematicToChargeProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/SchematicToElementProblemView',['require','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode','BUILD_AN_ATOM/game/view/ToElementProblemView','DOT/Vector2'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var NonInteractiveSchematicAtomNode = require( 'BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode' );
  var ToElementProblemView = require( 'BUILD_AN_ATOM/game/view/ToElementProblemView' );
  var Vector2 = require( 'DOT/Vector2' );
  function SchematicToElementProblemView( schematicToElementProblem, layoutBounds, tandem ) {
    ToElementProblemView.call( this, schematicToElementProblem, layoutBounds, tandem ); // Call super constructor.
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( layoutBounds.width * 0.275, layoutBounds.height * 0.5 ),
      0.8 );
    var nonInteractiveSchematicNode = new NonInteractiveSchematicAtomNode(
      schematicToElementProblem.answerAtom,
      modelViewTransform,
      tandem.createTandem( 'noninteractiveSchematicAtomNode' )
    );
    this.problemPresentationNode.addChild( nonInteractiveSchematicNode );
    this.disposeSchematicToElementProblemView = function(){
      nonInteractiveSchematicNode.dispose();
    };
  }
  buildAnAtom.register( 'SchematicToElementProblemView', SchematicToElementProblemView );
  return inherit( ToElementProblemView, SchematicToElementProblemView, {
    dispose: function(){
      ToElementProblemView.prototype.dispose.call(this);
      this.disposeSchematicToElementProblemView();
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SchematicToElementProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/ToElementProblem','BUILD_AN_ATOM/game/view/SchematicToElementProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var ToElementProblem = require( 'BUILD_AN_ATOM/game/model/ToElementProblem' );
  var SchematicToElementProblemView = require( 'BUILD_AN_ATOM/game/view/SchematicToElementProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SchematicToElementProblem( buildAnAtomGameModel, answerAtom ) {
    ToElementProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'SchematicToElementProblem',  SchematicToElementProblem );
  return inherit( ToElementProblem, SchematicToElementProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SchematicToElementProblemView( this, layoutBounds, tandem.createTandem( 'schematicToElementProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/SchematicToMassNumberProblemView',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','SCENERY_PHET/MultiLineText','BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/NumberEntryNode','BUILD_AN_ATOM/game/view/ProblemView','AXON/Property','DOT/Vector2','ifphetio!PHET_IO/types/TNumber','string!BUILD_AN_ATOM/whatIsTheMassNumber'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var NonInteractiveSchematicAtomNode = require( 'BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Property = require( 'AXON/Property' );
  var Vector2 = require( 'DOT/Vector2' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var whatIsTheMassNumberString = require( 'string!BUILD_AN_ATOM/whatIsTheMassNumber' );
  function SchematicToMassNumberProblemView( schematicToMassNumberProblem, layoutBounds, tandem ) {
    this.massNumberAnswerProperty = new Property( 0, {
      tandem: tandem.createTandem( 'massNumberAnswerProperty' ),
      phetioValueType: TNumber( { type: 'Integer' } )
    } ); // Must be defined before call to super constructor.
    ProblemView.call( this, schematicToMassNumberProblem, layoutBounds, tandem ); // Call super constructor.
    var self = this;
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( layoutBounds.width * 0.275, layoutBounds.height * 0.5 ),
      0.8 );
    var nonInteractiveSchematicAtomNode = new NonInteractiveSchematicAtomNode( schematicToMassNumberProblem.answerAtom,
      modelViewTransform,
      tandem.createTandem( 'noninteractiveSchematicAtomNode' ) );
    self.problemPresentationNode.addChild( nonInteractiveSchematicAtomNode );
    var questionPrompt = new MultiLineText( whatIsTheMassNumberString, {
      align: 'left',
      font: new PhetFont( 24 ),
      maxWidth: 200,
      tandem: tandem.createTandem( 'questionPrompt' )
    } );
    self.interactiveAnswerNode.addChild( questionPrompt );
    var massEntryNode = new NumberEntryNode(
      self.massNumberAnswerProperty,
      tandem.createTandem( 'massEntryNode' ), {
        minValue: 0,
        maxValue: 99
      } );
    self.interactiveAnswerNode.addChild( massEntryNode );
    questionPrompt.centerX = layoutBounds.width * 0.65;
    questionPrompt.centerY = layoutBounds.height * 0.5;
    massEntryNode.left = questionPrompt.right + 10;
    massEntryNode.centerY = questionPrompt.centerY;
    this.disposeSchematicToMassNumberProblemView = function() {
      nonInteractiveSchematicAtomNode.dispose();
    };
  }
  buildAnAtom.register( 'SchematicToMassNumberProblemView', SchematicToMassNumberProblemView );
  return inherit( ProblemView, SchematicToMassNumberProblemView, {
    checkAnswer: function() {
      var userSubmittedAnswer = new NumberAtom( {
        protonCount: this.problem.answerAtom.protonCountProperty.get(),
        neutronCount: this.massNumberAnswerProperty.value - this.problem.answerAtom.protonCountProperty.get(),
        electronCount: this.problem.answerAtom.electronCountProperty.get()
      } );
      this.problem.checkAnswer( userSubmittedAnswer );
    },
    displayCorrectAnswer: function() {
      this.massNumberAnswerProperty.value = this.problem.answerAtom.massNumberProperty.get();
    },
    dispose: function() {
      this.disposeSchematicToMassNumberProblemView();
      ProblemView.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SchematicToMassNumberProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/SchematicToMassNumberProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var SchematicToMassNumberProblemView = require( 'BUILD_AN_ATOM/game/view/SchematicToMassNumberProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SchematicToMassNumberProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'SchematicToMassNumberProblem', SchematicToMassNumberProblem );
  return inherit( BAAGameProblem, SchematicToMassNumberProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SchematicToMassNumberProblemView( this, layoutBounds, tandem.createTandem( 'schematicToMassNumberProblemView' ) );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/SchematicToSymbolProblemView',['require','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','PHETCOMMON/view/ModelViewTransform2','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/InteractiveSymbolNode','BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode','BUILD_AN_ATOM/game/view/ProblemView','DOT/Vector2'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var InteractiveSymbolNode = require( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode' );
  var NonInteractiveSchematicAtomNode = require( 'BUILD_AN_ATOM/game/view/NonInteractiveSchematicAtomNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Vector2 = require( 'DOT/Vector2' );
  function SchematicToSymbolProblemView( toSymbolProblem, layoutBounds, tandem ) {
    this.interactiveSymbolNode = new InteractiveSymbolNode(
      toSymbolProblem.answerAtom,
      tandem.createTandem( 'interactiveSymbolNode' ), {
        interactiveProtonCount: toSymbolProblem.configurableProtonCount,
        interactiveMassNumber: toSymbolProblem.configurableMassNumber,
        interactiveCharge: toSymbolProblem.configurableCharge
      } );
    ProblemView.call( this, toSymbolProblem, layoutBounds, tandem ); // Call super constructor.
    this.interactiveSymbolNode.scale( 0.75 );
    this.interactiveAnswerNode.addChild( this.interactiveSymbolNode );
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( layoutBounds.width * 0.275, layoutBounds.height * 0.5 ),
      0.8 );
    var schematicAtomNode = new NonInteractiveSchematicAtomNode( toSymbolProblem.answerAtom, modelViewTransform, tandem.createTandem( 'noninteractiveSchematicAtomNode' ) );
    this.problemPresentationNode.addChild( schematicAtomNode );
    schematicAtomNode.left = layoutBounds.width * 0.15;
    schematicAtomNode.centerY = layoutBounds.height * 0.50;
    this.interactiveSymbolNode.centerX = layoutBounds.width * 0.745;
    this.interactiveSymbolNode.centerY = layoutBounds.height * 0.54;
    this.disposeSchematicToSymbolProblemView = function() {
      schematicAtomNode.dispose();
    };
  }
  buildAnAtom.register( 'SchematicToSymbolProblemView', SchematicToSymbolProblemView );
  return inherit( ProblemView, SchematicToSymbolProblemView, {
    checkAnswer: function() {
      var userSubmittedAtom = new NumberAtom( {
        protonCount: this.interactiveSymbolNode.protonCountProperty.value,
        neutronCount: this.interactiveSymbolNode.massNumberProperty.value - this.interactiveSymbolNode.protonCountProperty.value,
        electronCount: this.interactiveSymbolNode.protonCountProperty.value - this.interactiveSymbolNode.chargeProperty.value
      } );
      this.problem.checkAnswer( userSubmittedAtom );
    },
    displayCorrectAnswer: function() {
      this.interactiveSymbolNode.protonCountProperty.value = this.problem.answerAtom.protonCountProperty.get();
      this.interactiveSymbolNode.massNumberProperty.value = this.problem.answerAtom.massNumberProperty.get();
      this.interactiveSymbolNode.chargeProperty.value = this.problem.answerAtom.chargeProperty.get();
    },
    dispose: function() {
      this.disposeSchematicToSymbolProblemView();
      ProblemView.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SchematicToSymbolProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/SchematicToSymbolProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var SchematicToSymbolProblemView = require( 'BUILD_AN_ATOM/game/view/SchematicToSymbolProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SchematicToSymbolProblem( buildAnAtomGameModel, answerAtom, configurableProtonCount, configurableMassNumber, configurableCharge ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
    this.configurableProtonCount = configurableProtonCount;
    this.configurableMassNumber = configurableMassNumber;
    this.configurableCharge = configurableCharge;
  }
  buildAnAtom.register( 'SchematicToSymbolProblem', SchematicToSymbolProblem );
  return inherit( BAAGameProblem, SchematicToSymbolProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SchematicToSymbolProblemView( this, layoutBounds, tandem.createTandem( 'schematicToSymbolProblemView' ) );
    }
  } );
} );
define("string!BUILD_AN_ATOM/protonsColon",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/protonsColon");});
define("string!BUILD_AN_ATOM/neutronsColon",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/neutronsColon");});
define("string!BUILD_AN_ATOM/electronsColon",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/electronsColon");});
define( 'BUILD_AN_ATOM/game/view/InteractiveParticleCountsNode',['require','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','SCENERY/nodes/Node','SHRED/model/NumberAtom','BUILD_AN_ATOM/game/view/NumberEntryNode','SCENERY/nodes/Text','PHET_CORE/inherit','string!BUILD_AN_ATOM/protonsColon','string!BUILD_AN_ATOM/neutronsColon','string!BUILD_AN_ATOM/electronsColon'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Node = require( 'SCENERY/nodes/Node' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var NumberEntryNode = require( 'BUILD_AN_ATOM/game/view/NumberEntryNode' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var protonsColonString = require( 'string!BUILD_AN_ATOM/protonsColon' );
  var neutronsColonString = require( 'string!BUILD_AN_ATOM/neutronsColon' );
  var electronsColonString = require( 'string!BUILD_AN_ATOM/electronsColon' );
  var MAX_WIDTH = 200;
  function InteractiveParticleCountsNode( tandem, options ) {
    Node.call( this, options ); // Call super constructor.
    options = _.extend( { font: new PhetFont( 24 ) }, options );
    this.numberAtom = new NumberAtom( { tandem: tandem.createTandem( 'numberAtom' ) } );
    var protonCountPrompt = new Text( protonsColonString, {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( protonCountPrompt );
    var protonCountEntryNode = new NumberEntryNode(
      this.numberAtom.protonCountProperty,
      tandem.createTandem( 'protonCountEntryNode' ), {
        minValue: 0,
        maxValue: 99
      } );
    this.addChild( protonCountEntryNode );
    var neutronCountPrompt = new Text( neutronsColonString, {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( neutronCountPrompt );
    var neutronCountEntryNode = new NumberEntryNode( this.numberAtom.neutronCountProperty,
      tandem.createTandem( 'neutronCountEntryNode' ), {
        minValue: 0,
        maxValue: 99
      } );
    this.addChild( neutronCountEntryNode );
    var electronCountPrompt = new Text( electronsColonString, {
      font: options.font,
      maxWidth: MAX_WIDTH
    } );
    this.addChild( electronCountPrompt );
    var electronCountEntryNode = new NumberEntryNode(
      this.numberAtom.electronCountProperty,
      tandem.createTandem( 'electronCountEntryNode' ), {
        minValue: 0,
        maxValue: 99
      } );
    this.addChild( electronCountEntryNode );
    var maxParticleLabelWidth = Math.max( Math.max( protonCountPrompt.width, neutronCountPrompt.width ), electronCountPrompt.width );
    var interLineSpacing = protonCountEntryNode.height; // Multiplier empirically determined.
    protonCountPrompt.left = 0;
    neutronCountPrompt.left = 0;
    electronCountPrompt.left = 0;
    protonCountEntryNode.top = 0;
    neutronCountEntryNode.top = protonCountEntryNode.centerY + interLineSpacing;
    electronCountEntryNode.top = neutronCountEntryNode.centerY + interLineSpacing;
    protonCountPrompt.centerY = protonCountEntryNode.centerY;
    neutronCountPrompt.centerY = neutronCountEntryNode.centerY;
    electronCountPrompt.centerY = electronCountEntryNode.centerY;
    protonCountEntryNode.left = maxParticleLabelWidth + protonCountPrompt.height;
    neutronCountEntryNode.left = protonCountEntryNode.left;
    electronCountEntryNode.left = protonCountEntryNode.left;
  }
  buildAnAtom.register( 'InteractiveParticleCountsNode', InteractiveParticleCountsNode );
  return inherit( Node, InteractiveParticleCountsNode );
} );
define( 'BUILD_AN_ATOM/game/view/SymbolToCountsProblemView',['require','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','BUILD_AN_ATOM/game/view/InteractiveSymbolNode','BUILD_AN_ATOM/game/view/InteractiveParticleCountsNode','BUILD_AN_ATOM/game/view/ProblemView'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var InteractiveSymbolNode = require( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode' );
  var InteractiveParticleCountsNode = require( 'BUILD_AN_ATOM/game/view/InteractiveParticleCountsNode' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  function SymbolToCountsProblemView( symbolToCountsProblem, layoutBounds, tandem ) {
    this.interactiveParticleCountsNode = new InteractiveParticleCountsNode( tandem );
    ProblemView.call( this, symbolToCountsProblem, layoutBounds, tandem );
    this.interactiveAnswerNode.addChild( this.interactiveParticleCountsNode );
    var interactiveSymbolNode = new InteractiveSymbolNode(
      symbolToCountsProblem.answerAtom,
      tandem.createTandem( 'interactiveSymbolNode' )
    );
    interactiveSymbolNode.scale( 0.75 );
    this.problemPresentationNode.addChild( interactiveSymbolNode );
    interactiveSymbolNode.centerX = layoutBounds.width * 0.25;
    interactiveSymbolNode.centerY = layoutBounds.height * 0.54;
    this.interactiveParticleCountsNode.centerX = layoutBounds.width * 0.75;
    this.interactiveParticleCountsNode.centerY = layoutBounds.height * 0.49;
  }
  buildAnAtom.register( 'SymbolToCountsProblemView', SymbolToCountsProblemView );
  return inherit( ProblemView, SymbolToCountsProblemView, {
    checkAnswer: function() {
      this.problem.checkAnswer( this.interactiveParticleCountsNode.numberAtom );
    },
    displayCorrectAnswer: function() {
      this.interactiveParticleCountsNode.numberAtom.protonCountProperty.set( this.problem.answerAtom.protonCountProperty.get() );
      this.interactiveParticleCountsNode.numberAtom.neutronCountProperty.set( this.problem.answerAtom.neutronCountProperty.get() );
      this.interactiveParticleCountsNode.numberAtom.electronCountProperty.set( this.problem.answerAtom.electronCountProperty.get() );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SymbolToCountsProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/game/view/SymbolToCountsProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var SymbolToCountsProblemView = require( 'BUILD_AN_ATOM/game/view/SymbolToCountsProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SymbolToCountsProblem( buildAnAtomGameModel, answerAtom ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
  }
  buildAnAtom.register( 'SymbolToCountsProblem', SymbolToCountsProblem );
  return inherit( BAAGameProblem, SymbolToCountsProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SymbolToCountsProblemView( this, layoutBounds, tandem.createTandem( 'symbolToCountsProblemView' ) );
    }
  } );
} );
define( 'SHRED/view/InteractiveSchematicAtom',['require','SHRED/view/AtomNode','SHRED/view/BucketDragHandler','SCENERY_PHET/bucket/BucketFront','SCENERY_PHET/bucket/BucketHole','PHET_CORE/inherit','SCENERY/nodes/Node','SHRED/view/ParticleView','SHRED/shred','TANDEM/Tandem'],function( require ) {
  'use strict';
  var AtomNode = require( 'SHRED/view/AtomNode' );
  var BucketDragHandler = require( 'SHRED/view/BucketDragHandler' );
  var BucketFront = require( 'SCENERY_PHET/bucket/BucketFront' );
  var BucketHole = require( 'SCENERY_PHET/bucket/BucketHole' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var ParticleView = require( 'SHRED/view/ParticleView' );
  var shred = require( 'SHRED/shred' );
  var Tandem = require( 'TANDEM/Tandem' );
  var NUM_NUCLEON_LAYERS = 5; // This is based on max number of particles, may need adjustment if that changes.
  function InteractiveSchematicAtom( model, modelViewTransform, options ) {
    options = _.extend( {
      highContrastProperty: null,
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this );
    var self = this;
    var particleViews = []; // remember all the particleViews when using in dispose
    var atomNode = new AtomNode( model.particleAtom, modelViewTransform, {
      showElementNameProperty: model.showElementNameProperty,
      showNeutralOrIonProperty: model.showNeutralOrIonProperty,
      showStableOrUnstableProperty: model.showStableOrUnstableProperty,
      electronShellDepictionProperty: model.electronShellDepictionProperty,
      tandem: options.tandem.createTandem( 'atomNode' )
    } );
    this.addChild( atomNode );
    _.each( model.buckets, function( bucket ) {
      self.addChild( new BucketHole( bucket, modelViewTransform ) );
    } );
    var nucleonLayers = [];
    _.times( NUM_NUCLEON_LAYERS, function() {
      var nucleonLayer = new Node();
      nucleonLayers.push( nucleonLayer );
      self.addChild( nucleonLayer );
    } );
    nucleonLayers.reverse(); // Set up the nucleon layers so that layer 0 is in front.
    var electronLayer = new Node( { layerSplit: true } );
    this.addChild( electronLayer );
    var nucleonGroupTandem = options.tandem && options.tandem.createGroupTandem( 'nucleons' );
    var electronGroupTandem = options.tandem && options.tandem.createGroupTandem( 'electrons' );
    model.nucleons.forEach( function( nucleon ) {
      var particleView = new ParticleView( nucleon, modelViewTransform, {
        highContrastProperty: options.highContrastProperty,
        tandem: nucleonGroupTandem && nucleonGroupTandem.createNextTandem()
      } );
      nucleonLayers[ nucleon.zLayerProperty.get() ].addChild( particleView );
      particleViews.push( particleView );
      nucleon.zLayerProperty.link( function( zLayer ) {
        assert && assert( nucleonLayers.length > zLayer,
          'zLayer for nucleon exceeds number of layers, max number may need increasing.' );
        var onCorrectLayer = false;
        nucleonLayers[ zLayer ].children.forEach( function( particleView ) {
          if ( particleView.particle === nucleon ) {
            onCorrectLayer = true;
          }
        } );
        if ( !onCorrectLayer ) {
          var particleView = null;
          for ( var layerIndex = 0; layerIndex < nucleonLayers.length && particleView === null; layerIndex++ ) {
            for ( var childIndex = 0; childIndex < nucleonLayers[ layerIndex ].children.length; childIndex++ ) {
              if ( nucleonLayers[ layerIndex ].children[ childIndex ].particle === nucleon ) {
                particleView = nucleonLayers[ layerIndex ].children[ childIndex ];
                nucleonLayers[ layerIndex ].removeChildAt( childIndex );
                break;
              }
            }
          }
          assert && assert( particleView !== null, 'Particle view not found during relayering' );
          nucleonLayers[ zLayer ].addChild( particleView );
        }
      } );
    } );
    model.electrons.forEach( function( electron ) {
      var particleView = new ParticleView( electron, modelViewTransform, {
        highContrastProperty: options.highContrastProperty,
        tandem: electronGroupTandem.createNextTandem()
      } );
      electronLayer.addChild( particleView );
      particleViews.push( particleView );
    } );
    var updateElectronVisibility = function() {
      electronLayer.getChildren().forEach( function( electronNode ) {
        electronNode.visible = model.electronShellDepictionProperty.get() === 'orbits' || !model.particleAtom.electrons.contains( electronNode.particle );
      } );
    };
    model.particleAtom.electrons.lengthProperty.link( updateElectronVisibility );
    model.electronShellDepictionProperty.link( updateElectronVisibility );
    var bucketGroupTandem = options.tandem.createGroupTandem( 'bucketFronts' );
    _.each( model.buckets, function( bucket ) {
      var bucketFront = new BucketFront( bucket, modelViewTransform, { tandem: bucketGroupTandem.createNextTandem() } );
      self.addChild( bucketFront );
      bucketFront.addInputListener( new BucketDragHandler( bucket, bucketFront, modelViewTransform, {
        tandem: options.tandem && options.tandem.createTandem( bucket.sphereBucketTandem.tail + 'DragHandler' )
      } ) );
    } );
    this.disposeInteractiveSchematicAtom = function() {
      particleViews.forEach( function( particleView ) {
        particleView.dispose();
      } );
      atomNode.dispose();
      model.particleAtom.electrons.lengthProperty.unlink( updateElectronVisibility );
      model.electronShellDepictionProperty.unlink( updateElectronVisibility );
    };
    this.mutate( options );
  }
  shred.register( 'InteractiveSchematicAtom', InteractiveSchematicAtom );
  return inherit( Node, InteractiveSchematicAtom, {
    dispose: function() {
      this.disposeInteractiveSchematicAtom();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/view/SymbolToSchematicProblemView',['require','BUILD_AN_ATOM/common/BAAGlobalOptions','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','SHRED/view/InteractiveSchematicAtom','BUILD_AN_ATOM/game/view/InteractiveSymbolNode','PHETCOMMON/view/ModelViewTransform2','BUILD_AN_ATOM/game/view/ProblemView','DOT/Vector2'],function( require ) {
  'use strict';
  var BAAGlobalOptions = require( 'BUILD_AN_ATOM/common/BAAGlobalOptions' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var InteractiveSchematicAtom = require( 'SHRED/view/InteractiveSchematicAtom' );
  var InteractiveSymbolNode = require( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode' );
  var ModelViewTransform2 = require( 'PHETCOMMON/view/ModelViewTransform2' );
  var ProblemView = require( 'BUILD_AN_ATOM/game/view/ProblemView' );
  var Vector2 = require( 'DOT/Vector2' );
  function SymbolToSchematicProblemView( problem, layoutBounds, tandem ) {
    var modelViewTransform = ModelViewTransform2.createSinglePointScaleInvertedYMapping(
      Vector2.ZERO,
      new Vector2( layoutBounds.width * 0.275, layoutBounds.height * 0.45 ),
      0.75
    );
    this.interactiveSchematicAtom = new InteractiveSchematicAtom( problem.buildAnAtomModel, modelViewTransform, {
      highContrastProperty: BAAGlobalOptions.highContrastParticlesProperty,
      tandem: tandem.createTandem( 'interactiveSchematicAtom' )
    } );
    this.interactiveSchematicAtom.scale( 0.95 );
    ProblemView.call( this, problem, layoutBounds, tandem );
    this.interactiveAnswerNode.addChild( this.interactiveSchematicAtom );
    var interactiveSymbolNode = new InteractiveSymbolNode( problem.answerAtom, tandem.createTandem( 'interactiveSymbolNode' ) );
    interactiveSymbolNode.scale( 0.75 );
    this.problemPresentationNode.addChild( interactiveSymbolNode );
    interactiveSymbolNode.centerX = layoutBounds.width * 0.27;
    interactiveSymbolNode.centerY = layoutBounds.height * 0.52;
    this.interactiveSchematicAtom.centerX = layoutBounds.width * 0.745;
    this.interactiveSchematicAtom.centerY = layoutBounds.height * 0.51;
    this.disposeSymbolToSchematicProblemView = function() {
      this.interactiveSchematicAtom.dispose();
    };
  }
  buildAnAtom.register( 'SymbolToSchematicProblemView', SymbolToSchematicProblemView );
  return inherit( ProblemView, SymbolToSchematicProblemView, {
    checkAnswer: function() {
      this.problem.checkAnswer( this.problem.buildAnAtomModel.particleAtom );
    },
    displayCorrectAnswer: function() {
      this.problem.buildAnAtomModel.setAtomConfiguration( this.problem.answerAtom );
    },
    dispose: function() {
      this.disposeSymbolToSchematicProblemView();
      ProblemView.prototype.dispose.call( this );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/SymbolToSchematicProblem',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/BAAGameProblem','BUILD_AN_ATOM/common/model/BuildAnAtomModel','BUILD_AN_ATOM/game/view/SymbolToSchematicProblemView','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BAAGameProblem = require( 'BUILD_AN_ATOM/game/model/BAAGameProblem' );
  var BuildAnAtomModel = require( 'BUILD_AN_ATOM/common/model/BuildAnAtomModel' );
  var SymbolToSchematicProblemView = require( 'BUILD_AN_ATOM/game/view/SymbolToSchematicProblemView' );
  var inherit = require( 'PHET_CORE/inherit' );
  function SymbolToSchematicProblem( buildAnAtomGameModel, answerAtom, tandem ) {
    BAAGameProblem.call( this, buildAnAtomGameModel, answerAtom );
    this.buildAnAtomModel = new BuildAnAtomModel( tandem.createTandem( 'buildAnAtomModel' ) );
    this.buildAnAtomModel.showElementNameProperty.set( false );
    this.buildAnAtomModel.showNeutralOrIonProperty.set( false );
    this.buildAnAtomModel.showStableOrUnstableProperty.set( false );
  }
  buildAnAtom.register( 'SymbolToSchematicProblem', SymbolToSchematicProblem );
  return inherit( BAAGameProblem, SymbolToSchematicProblem, {
    createView: function( layoutBounds, tandem ) {
      return new SymbolToSchematicProblemView( this, layoutBounds, tandem.createTandem( 'symbolToSchematicProblemView' ) );
    },
    step: function( dt ) {
      this.buildAnAtomModel.step( dt );
    }
  } );
} );
define( 'BUILD_AN_ATOM/game/model/ProblemSetFactory',['require','BUILD_AN_ATOM/game/model/AtomValuePool','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/game/model/CountsToChargeProblem','BUILD_AN_ATOM/game/model/CountsToSymbolProblem','BUILD_AN_ATOM/game/model/CountsToElementProblem','BUILD_AN_ATOM/game/model/CountsToMassNumberProblem','BUILD_AN_ATOM/game/model/SchematicToChargeProblem','BUILD_AN_ATOM/game/model/SchematicToElementProblem','BUILD_AN_ATOM/game/model/SchematicToMassNumberProblem','BUILD_AN_ATOM/game/model/SchematicToSymbolProblem','BUILD_AN_ATOM/game/model/SymbolToCountsProblem','BUILD_AN_ATOM/game/model/SymbolToSchematicProblem'],function( require ) {
  'use strict';
  var AtomValuePool = require( 'BUILD_AN_ATOM/game/model/AtomValuePool' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var CountsToChargeProblem = require( 'BUILD_AN_ATOM/game/model/CountsToChargeProblem' );
  var CountsToSymbolProblem = require( 'BUILD_AN_ATOM/game/model/CountsToSymbolProblem' );
  var CountsToElementProblem = require( 'BUILD_AN_ATOM/game/model/CountsToElementProblem' );
  var CountsToMassNumberProblem = require( 'BUILD_AN_ATOM/game/model/CountsToMassNumberProblem' );
  var SchematicToChargeProblem = require( 'BUILD_AN_ATOM/game/model/SchematicToChargeProblem' );
  var SchematicToElementProblem = require( 'BUILD_AN_ATOM/game/model/SchematicToElementProblem' );
  var SchematicToMassNumberProblem = require( 'BUILD_AN_ATOM/game/model/SchematicToMassNumberProblem' );
  var SchematicToSymbolProblem = require( 'BUILD_AN_ATOM/game/model/SchematicToSymbolProblem' );
  var SymbolToCountsProblem = require( 'BUILD_AN_ATOM/game/model/SymbolToCountsProblem' );
  var SymbolToSchematicProblem = require( 'BUILD_AN_ATOM/game/model/SymbolToSchematicProblem' );
  var MAX_PROTON_NUMBER_FOR_SCHEMATIC_PROBS = 3; // Disallow schematic (Bohr model) probs above this size.
  var ProblemSetFactory = {};
  ProblemSetFactory.generate = function( level, numProblems, model, allowedProblemTypesByLevel, tandem ) {
    this.problems = [];
    this._previousProblemType = null;
    this._availableProblemTypes = [];
    var groupTandem = tandem.createGroupTandem( 'problems' );
    var atomValueList = new AtomValuePool( level );
    for ( var i = 0; i < numProblems; i++ ) {
      var problem = this._generateProblem( level, atomValueList, model, allowedProblemTypesByLevel, groupTandem.createNextTandem() );
      if ( problem !== null ) {
        this.problems.push( problem );
      }
    }
    return this.problems;
  };
  ProblemSetFactory._generateProblem = function( level, availableAtomValues, model, allowedProblemTypesByLevel, tandem ) {
    if ( this._availableProblemTypes.length === 0 ) {
      this._availableProblemTypes = allowedProblemTypesByLevel[ level ].slice();
    }
    var index = Math.floor( phet.joist.random.nextDouble() * ( this._availableProblemTypes.length ) );
    if ( this._previousProblemType !== null && this._availableProblemTypes.get( index ) === this._previousProblemType ) {
      index = ( index + 1 ) % this._availableProblemTypes.length;
    }
    var problemType = this._availableProblemTypes[ index ];
    this.previousProblemType = problemType;
    this._availableProblemTypes = _.without( this._availableProblemTypes, problemType );
    var minProtonCount = 0;
    var maxProtonCount = Number.POSITIVE_INFINITY;
    var requireCharged = false;
    if ( this._isSchematicProbType( problemType ) ) {
      maxProtonCount = MAX_PROTON_NUMBER_FOR_SCHEMATIC_PROBS;
    }
    else {
      minProtonCount = MAX_PROTON_NUMBER_FOR_SCHEMATIC_PROBS + 1;
    }
    if ( this._isChargeProbType( problemType ) ) {
      requireCharged = phet.joist.random.nextBoolean();
    }
    var atomValue = availableAtomValues.getRandomAtomValue( minProtonCount, maxProtonCount, requireCharged );
    availableAtomValues.markAtomAsUsed( atomValue );
    return this._createProblem( model, problemType, atomValue, tandem );
  };
  ProblemSetFactory._createProblem = function( model, problemType, atomValue, tandem ) {
    var problem = null;
    switch( problemType ) {
      case 'counts-to-element':
        problem = new CountsToElementProblem( model, atomValue );
        break;
      case 'counts-to-charge':
        problem = new CountsToChargeProblem( model, atomValue );
        break;
      case 'counts-to-mass':
        problem = new CountsToMassNumberProblem( model, atomValue );
        break;
      case 'counts-to-symbol-all':
        problem = new CountsToSymbolProblem( model, atomValue, true, true, true );
        break;
      case 'counts-to-symbol-charge':
        problem = new CountsToSymbolProblem( model, atomValue, false, false, true );
        break;
      case 'counts-to-symbol-mass':
        problem = new CountsToSymbolProblem( model, atomValue, false, true, false );
        break;
      case 'counts-to-symbol-proton-count':
        problem = new CountsToSymbolProblem( model, atomValue, true, false, false );
        break;
      case 'schematic-to-element':
        problem = new SchematicToElementProblem( model, atomValue );
        break;
      case 'schematic-to-charge':
        problem = new SchematicToChargeProblem( model, atomValue );
        break;
      case 'schematic-to-mass':
        problem = new SchematicToMassNumberProblem( model, atomValue );
        break;
      case 'schematic-to-symbol-all':
        problem = new SchematicToSymbolProblem( model, atomValue, true, true, true );
        break;
      case 'schematic-to-symbol-charge':
        problem = new SchematicToSymbolProblem( model, atomValue, false, false, true );
        break;
      case 'schematic-to-symbol-mass-number':
        problem = new SchematicToSymbolProblem( model, atomValue, false, true, false );
        break;
      case 'schematic-to-symbol-proton-count':
        problem = new SchematicToSymbolProblem( model, atomValue, true, false, false );
        break;
      case 'symbol-to-counts':
        problem = new SymbolToCountsProblem( model, atomValue );
        break;
      case 'symbol-to-schematic':
        problem = new SymbolToSchematicProblem( model, atomValue, tandem );
        break;
      default:
        throw new Error( 'Error: Request to create unknown problem type, type = ' + problemType );
    }
    return problem;
  };
  ProblemSetFactory._isSchematicProbType = function( problemType ) {
    return ( problemType === 'schematic-to-element' ||
             problemType === 'schematic-to-charge' ||
             problemType === 'schematic-to-mass' ||
             problemType === 'schematic-to-symbol-all' ||
             problemType === 'schematic-to-symbol-proton-count' ||
             problemType === 'schematic-to-symbol-charge' ||
             problemType === 'schematic-to-symbol-mass-number' ||
             problemType === 'symbol-to-schematic' );
  };
  ProblemSetFactory._isChargeProbType = function( problemType ) {
    return ( problemType === 'schematic-to-charge' ||
             problemType === 'counts-to-charge' ||
             problemType === 'counts-to-symbol-charge' ||
             problemType === 'schematic-to-symbol-charge'
    );
  };
  buildAnAtom.register( 'ProblemSetFactory', ProblemSetFactory );
  return ProblemSetFactory;
} );
define("PHET_IO/types/TArray", function(){return function(){ return function(){}; };});
define( 'BUILD_AN_ATOM/game/model/TBAAGameModel',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','BUILD_AN_ATOM/buildAnAtom','ifphetio!PHET_IO/types/TArray','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var TArray = require( 'ifphetio!PHET_IO/types/TArray' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var TBAAGameModel = function( gameModel, phetioID ) {
    assertInstanceOf( gameModel, phet.buildAnAtom.BAAGameModel );
    TObject.call( this, gameModel, phetioID );
  };
  phetioInherit( TObject, 'TBAAGameModel', TBAAGameModel, {
    startGameLevel: {
      returnType: TVoid,
      parameterTypes: [ TString ],
      implementation: function( levelType ) {
        this.instance.startGameLevel( levelType );
      },
      documentation: 'Start one of the following games: periodic-table-game, mass-and-charge-game, symbol-game, advanced-symbol-game'
    },
    setAllowedProblemTypesByLevel: {
      returnType: TVoid,
      parameterTypes: [ TArray( TArray( TString ) ) ],
      implementation: function( allowedProblemTypesByLevel ) {
        this.instance.setAllowedProblemTypesByLevel( allowedProblemTypesByLevel );
      },
      documentation: 'Specify which problem types may be presented to the user for each level.'
    }
  }, {
    documentation: 'The model for the Game',
    events: 'levelCompleted'
  } );
  buildAnAtom.register( 'TBAAGameModel', TBAAGameModel );
  return TBAAGameModel;
} );
define( 'BUILD_AN_ATOM/game/model/BAAGameModel',['require','AXON/Property','PHET_CORE/inherit','BUILD_AN_ATOM/game/model/ProblemSetFactory','SHRED/ShredConstants','BUILD_AN_ATOM/buildAnAtom','TANDEM/axon/TandemEmitter','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber','ifphetio!PHET_IO/types/TObject','BUILD_AN_ATOM/game/model/TBAAGameModel'],function( require ) {
  'use strict';
  var Property = require( 'AXON/Property' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ProblemSetFactory = require( 'BUILD_AN_ATOM/game/model/ProblemSetFactory' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var TandemEmitter = require( 'TANDEM/axon/TandemEmitter' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var TBAAGameModel = require( 'BUILD_AN_ATOM/game/model/TBAAGameModel' );
  var PROBLEMS_PER_LEVEL = 5;
  var POSSIBLE_POINTS_PER_PROBLEM = 2;
  var MAX_POINTS_PER_GAME_LEVEL = PROBLEMS_PER_LEVEL * POSSIBLE_POINTS_PER_PROBLEM;
  function BAAGameModel( tandem ) {
    var self = this;
    this.allowedProblemTypesByLevel = [
      [ 'schematic-to-element', 'counts-to-element' ],
      [ 'counts-to-charge', 'counts-to-mass', 'schematic-to-charge', 'schematic-to-mass' ],
      [ 'schematic-to-symbol-charge', 'schematic-to-symbol-mass-number', 'schematic-to-symbol-proton-count', 'counts-to-symbol-charge', 'counts-to-symbol-mass' ],
      [ 'schematic-to-symbol-all', 'symbol-to-schematic', 'symbol-to-counts', 'counts-to-symbol-all' ]
    ];
    this.stateProperty = new Property( 'selectGameLevel' ); // Current state of the game.  Each problem is a unique state.
    this.soundEnabledProperty = new Property( true, {
      tandem: tandem.createTandem( 'soundEnabledProperty' ),
      phetioValueType: TBoolean
    } );
    this.timerEnabledProperty = new Property( false, {
      tandem: tandem.createTandem( 'timerEnabledProperty' ),
      phetioValueType: TBoolean
    } );
    this.levelProperty = new Property( 0, {
      tandem: tandem.createTandem( 'levelProperty' ),
      phetioValueType: TNumber()
    } );
    this.problemSetProperty = new Property( [] );
    this.problemIndexProperty = new Property( 0, {
      tandem: tandem.createTandem( 'problemIndexProperty' ),
      phetioValueType: TNumber()
    } );
    this.scoreProperty = new Property( 0, {
      tandem: tandem.createTandem( 'scoreProperty' ),
      phetioValueType: TNumber()
    } ); // Score on current game level.
    this.elapsedTimeProperty = new Property( 0 );
    this.stepListeners = [];
    this.levelCompletedEmitter = new TandemEmitter( {
      tandem: tandem.createTandem( 'levelCompletedEmitter' ),
      phetioArgumentTypes: [ TObject ]
    } );
    this.bestScores = []; // Properties that track progress on each game level.
    this.scores = []; // Properties that track score at each game level
    this.bestTimeVisible = []; // Properties that track whether to show best time at each game level
    self.bestTimes = []; // Best times at each level.
    _.times( ShredConstants.LEVEL_NAMES.length, function() {
      self.bestScores.push( new Property( 0 ) );
      self.scores.push( new Property( 0 ) );
      self.bestTimes.push( new Property( null ) );
      self.bestTimeVisible.push( new Property( false ) );
    } );
    this.timerEnabledProperty.lazyLink( function( timerEnabled ) {
      for ( var i = 0; i < ShredConstants.LEVEL_NAMES.length; i++ ) {
        self.bestTimeVisible[ i ].value = timerEnabled && self.scores[ i ].value === MAX_POINTS_PER_GAME_LEVEL;
      }
    } );
    this.newBestTime = false;
    this.checkAnswerEmitter = new TandemEmitter( {
      tandem: tandem.createTandem( 'checkAnswerEmitter' ),
      phetioArgumentTypes: [ TObject ]
    } );
    this.problemSetGroupTandem = tandem.createGroupTandem( 'problemSets' );
    tandem.addInstance( this, TBAAGameModel );
  }
  buildAnAtom.register( 'BAAGameModel', BAAGameModel );
  return inherit( Object, BAAGameModel, {
    step: function( dt ) {
      if ( this.timerEnabledProperty.get() &&
           this.stateProperty.get !== 'selectGameLevel' &&
           this.stateProperty.get !== 'levelCompleted' ) {
        this.elapsedTimeProperty.set( this.elapsedTimeProperty.get() + dt );
      }
      if ( this.stateProperty.get() && ( typeof( this.stateProperty.get().step ) !== 'undefined' ) ) {
        this.stateProperty.get().step( dt );
      }
      this.stepListeners.forEach( function( stepListener ) { stepListener( dt ); } );
    },
    startGameLevel: function( levelName ) {
      this.levelProperty.set( ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( levelName ) );
      this.problemIndexProperty.set( 0 );
      this.problemSetProperty.set( ProblemSetFactory.generate( this.levelProperty.get(), PROBLEMS_PER_LEVEL, this,
        this.allowedProblemTypesByLevel, this.problemSetGroupTandem.createNextTandem() ) );
      this.scoreProperty.set( 0 );
      this.newBestTime = false;
      this.bestTimeVisible[ this.levelProperty.get() ].value = false;
      this.elapsedTimeProperty.reset();
      if ( this.problemSetProperty.get().length > 0 ) {
        this.stateProperty.set( this.problemSetProperty.get()[ 0 ] );
      }
      else {
        this.stateProperty.set( 'levelCompleted' );
      }
    },
    newGame: function() {
      this.stateProperty.set( 'selectGameLevel' );
      this.scoreProperty.set( 0 );
    },
    next: function() {
      var level = this.levelProperty.get();
      if ( this.problemSetProperty.get().length > this.problemIndexProperty.get() + 1 ) {
        this.problemIndexProperty.set( this.problemIndexProperty.get() + 1 );
        this.stateProperty.set( this.problemSetProperty.get()[ this.problemIndexProperty.get() ] );
      }
      else {
        if ( this.scoreProperty.get() > this.bestScores[ level ].value ) {
          this.bestScores[ level ].value = this.scoreProperty.get();
        }
        if ( this.timerEnabledProperty.get() && this.scoreProperty.get() === MAX_POINTS_PER_GAME_LEVEL &&
             ( this.bestTimes[ level ].value === null || this.elapsedTimeProperty.get() < this.bestTimes[ level ].value ) ) {
          this.newBestTime = this.bestTimes[ level ].value === null ? false : true; // Don't set this flag for the first 'best time', only when the time improves.
          this.bestTimes[ level ].value = this.elapsedTimeProperty.get();
        }
        if ( this.scoreProperty.get() === MAX_POINTS_PER_GAME_LEVEL && this.timerEnabledProperty.get() ) {
          this.bestTimeVisible[ level ].value = true;
        }
        this.scores[ level ].value = this.scoreProperty.get();
        this.levelCompletedEmitter.emit1( {
          level: level,
          maxPoints: MAX_POINTS_PER_GAME_LEVEL,
          problems: PROBLEMS_PER_LEVEL,
          timerEnabled: this.timerEnabledProperty.get(),
          elapsedTime: this.elapsedTimeProperty.get(),
          bestTimes: this.bestTimes[ level ],
          newBestTime: this.newBestTime
        } );
        this.stateProperty.set( 'levelCompleted' );
      }
    },
    reset: function() {
      this.stateProperty.reset();
      this.soundEnabledProperty.reset();
      this.timerEnabledProperty.reset();
      this.levelProperty.reset();
      this.problemSetProperty.reset();
      this.problemIndexProperty.reset();
      this.scoreProperty.reset();
      this.elapsedTimeProperty.reset();
      this.bestScores.forEach( function( bestScoreProperty ) { bestScoreProperty.reset(); } );
      this.scores.forEach( function( scoreProperty ) { scoreProperty.reset(); } );
      this.bestTimes.forEach( function( bestTimeProperty ) { bestTimeProperty.reset(); } );
      this.bestTimeVisible.push( function( bestTimeVisibleProperty ) { bestTimeVisibleProperty.reset(); } );
    },
    addStepListener: function( stepListener ) {
      this.stepListeners.push( stepListener );
    },
    removeStepListener: function( stepListener ) {
      this.stepListeners = _.without( this.stepListeners, stepListener );
    },
    setAllowedProblemTypesByLevel: function( allowedProblemTypesByLevel ) {
      this.allowedProblemTypesByLevel = allowedProblemTypesByLevel;
    },
    emitCheckAnswer: function( isCorrect, pointsIfCorrect, answerAtom, submittedAtom, extension ) {
      var arg = {
        isCorrect: isCorrect,
        correctProtonCount: answerAtom.protonCountProperty.get(),
        correctNeutronCount: answerAtom.neutronCountProperty.get(),
        correctElectronCount: answerAtom.electronCountProperty.get(),
        submittedProtonCount: submittedAtom.protonCountProperty.get(),
        submittedNeutronCount: submittedAtom.neutronCountProperty.get(),
        submittedElectronCount: submittedAtom.electronCountProperty.get(),
        points: isCorrect ? pointsIfCorrect : 0
      };
      this.checkAnswerEmitter.emit1( _.extend( extension, arg ) );
    }
  }, {
    MAX_POINTS_PER_GAME_LEVEL: MAX_POINTS_PER_GAME_LEVEL,
    PROBLEMS_PER_LEVEL: PROBLEMS_PER_LEVEL
  } );
} );
define( 'SCENERY_PHET/StarShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2','DOT/Util','KITE/segments/Line','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Vector2 = require( 'DOT/Vector2' );
  var Util = require( 'DOT/Util' );
  var Line = require( 'KITE/segments/Line' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  function StarShape( options ) {
    options = _.extend( {
      value: 1,
      outerRadius: 15,
      innerRadius: 7.5
    }, options );
    Tandem.disallowTandem( options );
    Shape.call( this );
    if ( options.value === 0 ) {
      return;
    }
    var points = [];
    var i = 0;
    for ( i = 0; i < 10; i++ ) {
      var angle = i / 10 * Math.PI * 2 - Math.PI / 2;
      var radius = i % 2 === 0 ? options.outerRadius : options.innerRadius;
      var x = radius * Math.cos( angle );
      var y = radius * Math.sin( angle );
      points.push( new Vector2( x, y ) );
    }
    if ( options.value === 1 ) {
      this.moveTo( points[ 0 ].x, points[ 0 ].y );
      for ( i = 1; i < points.length; i++ ) {
        this.lineTo( points[ i ].x, points[ i ].y );
      }
      this.close();
      return;
    }
    var minX = points[ 0 ].x;
    var maxX = points[ 0 ].x;
    for ( i = 1; i < points.length; i++ ) {
      if ( points[ i ].x < minX ) {
        minX = points[ i ].x;
      }
      if ( points[ i ].x > maxX ) {
        maxX = points[ i ].x;
      }
    }
    var starWidth = maxX - minX;
    var fillPosition = options.value * starWidth + minX;
    var verticalLine = new Line( new Vector2( fillPosition, -options.outerRadius * 2 ), new Vector2( fillPosition, options.outerRadius * 2 ) );
    var getIntersection = function( segment ) {
      return Util.lineSegmentIntersection( segment.start.x, segment.start.y, segment.end.x, segment.end.y, verticalLine.start.x, verticalLine.start.y, verticalLine.end.x, verticalLine.end.y );
    };
    var segment = function( a, b ) {
      return new Line( new Vector2( points[ a ].x, points[ a ].y ), new Vector2( points[ b ].x, points[ b ].y ) );
    };
    var topSegments = [ segment( 8, 9 ), segment( 9, 0 ), segment( 0, 1 ), segment( 1, 2 ) ];
    var bottomSegments = [ segment( 8, 7 ), segment( 7, 6 ), segment( 6, 5 ), segment( 5, 4 ), segment( 4, 3 ), segment( 3, 2 ) ];
    var intersection = null;
    var highlightedPoints = [];
    var intersectedTop = false;
    for ( i = topSegments.length - 1; i >= 0; i-- ) {
      var topSegment = topSegments[ i ];
      intersection = getIntersection( topSegment );
      if ( intersection ) {
        highlightedPoints.push( intersection );
        intersectedTop = true;
      }
      if ( intersectedTop ) {
        highlightedPoints.push( topSegment.start );
      }
    }
    for ( i = 0; i < bottomSegments.length; i++ ) {
      var bottomSegment = bottomSegments[ i ];
      intersection = getIntersection( bottomSegment );
      if ( intersection ) {
        highlightedPoints.push( intersection );
        break;
      }
      else {
        highlightedPoints.push( bottomSegment.end );
      }
    }
    this.moveTo( highlightedPoints[ 0 ].x, highlightedPoints[ 0 ].y );
    for ( i = 1; i < highlightedPoints.length; i++ ) {
      this.lineTo( highlightedPoints[ i ].x, highlightedPoints[ i ].y );
    }
  }
  sceneryPhet.register( 'StarShape', StarShape );
  return inherit( Shape, StarShape );
} );
define( 'SCENERY_PHET/StarNode',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY_PHET/StarShape','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var StarShape = require( 'SCENERY_PHET/StarShape' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  function StarNode( options ) {
    options = _.extend( {
      filledFill: '#fcff03',
      filledStroke: 'black',
      filledLineWidth: 1.5,
      filledLineJoin: 'round',
      emptyFill: '#e1e1e1', //pretty gray
      emptyStroke: '#d3d1d1 ',//darker gray than the fill, but still pretty faint
      emptyLineWidth: 1.5,
      emptyLineJoin: 'round'
    }, options );
    Node.call( this );
    var backgroundStar = new Path( null, {
      stroke: options.emptyStroke,
      fill: options.emptyFill,
      lineWidth: options.emptyLineWidth,
      lineJoin: options.emptyLineJoin,
      boundsMethod: 'none' // optimization for faster creation and usage
    } );
    var o2 = _.clone( options );
    o2.value = 1;
    var backgroundStarShape = new StarShape( o2 );
    backgroundStar.setShape( backgroundStarShape );
    function getBounds() {
      return backgroundStarShape.bounds;
    }
    backgroundStar.computeShapeBounds = getBounds; // optimization - override bounds calculation to used pre-computed value
    this.addChild( backgroundStar );
    var foregroundStar = new Path( new StarShape( options ), {
      stroke: options.filledStroke,
      fill: options.filledFill,
      lineWidth: options.filledLineWidth,
      lineJoin: options.filledLineJoin,
      boundsMethod: 'none' // optimization for faster creation and usage
    } );
    foregroundStar.computeShapeBounds = getBounds; // optimization - override bounds calculation to used pre-computed value
    foregroundStar.shape = new StarShape( options );
    this.addChild( foregroundStar );
    this.mutate( options );
  }
  sceneryPhet.register( 'StarNode', StarNode );
  return inherit( Node, StarNode );
} );
define( 'VEGAS/ProgressIndicator',['require','PHET_CORE/inherit','SCENERY_PHET/StarNode','SCENERY/nodes/HBox','VEGAS/vegas'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var StarNode = require( 'SCENERY_PHET/StarNode' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var vegas = require( 'VEGAS/vegas' );
  function ProgressIndicator( numStars, scoreProperty, perfectScore, options ) {
    options = _.extend( {
      starOuterRadius: 10,
      starInnerRadius: 5,
      starFilledLineWidth: 1.5,
      starEmptyLineWidth: 1.5
    }, options );
    HBox.call( this, { spacing: 3, children: [] } );
    var self = this;
    scoreProperty.link( function( score ) {
      assert && assert( score <= perfectScore );
      var children = [];
      var proportion = score / perfectScore;
      var numFilledStars = Math.floor( proportion * numStars );
      var starOptions = {
        outerRadius: options.starOuterRadius,
        innerRadius: options.starInnerRadius,
        filledLineWidth: options.starFilledLineWidth,
        emptyLineWidth: options.starEmptyLineWidth
      };
      for ( var i = 0; i < numFilledStars; i++ ) {
        children.push( new StarNode( _.extend( { value: 1 }, starOptions ) ) );
      }
      var remainder = proportion * numStars - numFilledStars;
      if ( remainder > 1E-6 ) {
        children.push( new StarNode( _.extend( { value: remainder }, starOptions ) ) );
      }
      var numEmptyStars = numStars - children.length;
      for ( i = 0; i < numEmptyStars; i++ ) {
        children.push( new StarNode( _.extend( { value: 0 }, starOptions ) ) );
      }
      self.children = children;
    } );
    this.mutate( options );
  }
  vegas.register( 'ProgressIndicator', ProgressIndicator );
  return inherit( HBox, ProgressIndicator );
} );
define("string!VEGAS/pattern.0hours.1minutes.2seconds",function(){return window.phet.chipper.strings.get("VEGAS/pattern.0hours.1minutes.2seconds");});
define("string!VEGAS/pattern.0minutes.1seconds",function(){return window.phet.chipper.strings.get("VEGAS/pattern.0minutes.1seconds");});
define( 'VEGAS/GameTimer',['require','PHET_CORE/inherit','AXON/Property','PHETCOMMON/util/StringUtils','PHET_CORE/Timer','VEGAS/vegas','string!VEGAS/pattern.0hours.1minutes.2seconds','string!VEGAS/pattern.0minutes.1seconds'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Timer = require( 'PHET_CORE/Timer' );
  var vegas = require( 'VEGAS/vegas' );
  var pattern0Hours1Minutes2SecondsString = require( 'string!VEGAS/pattern.0hours.1minutes.2seconds' );
  var pattern0Minutes1SecondsString = require( 'string!VEGAS/pattern.0minutes.1seconds' );
  function GameTimer() {
    this.elapsedTimeProperty = new Property( 0 );
    this.isRunningProperty = new Property( false );
    this.intervalId = null; // @private
  }
  vegas.register( 'GameTimer', GameTimer );
  return inherit( Object, GameTimer, {
    reset: function(){
      this.elapsedTimeProperty.reset();
      this.isRunningProperty.reset();
    },
    start: function() {
      if ( !this.isRunningProperty.value ) {
        var self = this;
        self.elapsedTimeProperty.value = 0;
        self.intervalId = Timer.setInterval( function() {
          self.elapsedTimeProperty.value = self.elapsedTimeProperty.value + 1;
        }, 1000 ); // fire once per second
        self.isRunningProperty.value = true;
      }
    },
    stop: function() {
      if ( this.isRunningProperty.value ) {
        Timer.clearInterval( this.intervalId );
        this.intervalId = null;
        this.isRunningProperty.value = false;
      }
    },
    restart: function() {
      this.stop();
      this.start();
    }
  }, {
    formatTime: function( time ) {
      var hours = Math.floor( time / 3600 );
      var minutes = Math.floor( (time - (hours * 3600)) / 60 );
      var seconds = Math.floor( time - (hours * 3600) - (minutes * 60) );
      var minutesString = ( minutes > 9 || hours === 0 ) ? minutes : ( '0' + minutes );
      var secondsString = ( seconds > 9 ) ? seconds : ( '0' + seconds );
      if ( hours > 0 ) {
        return StringUtils.format( pattern0Hours1Minutes2SecondsString, hours, minutesString, secondsString );
      }
      else {
        return StringUtils.format( pattern0Minutes1SecondsString, minutesString, secondsString );
      }
    }
  } );
} );
define("string!VEGAS/keepTrying",function(){return window.phet.chipper.strings.get("VEGAS/keepTrying");});
define("string!VEGAS/good",function(){return window.phet.chipper.strings.get("VEGAS/good");});
define("string!VEGAS/great",function(){return window.phet.chipper.strings.get("VEGAS/great");});
define("string!VEGAS/excellent",function(){return window.phet.chipper.strings.get("VEGAS/excellent");});
define("string!VEGAS/label.score.max",function(){return window.phet.chipper.strings.get("VEGAS/label.score.max");});
define("string!VEGAS/label.time",function(){return window.phet.chipper.strings.get("VEGAS/label.time");});
define("string!VEGAS/yourNewBest",function(){return window.phet.chipper.strings.get("VEGAS/yourNewBest");});
define("string!VEGAS/pattern.0yourBest",function(){return window.phet.chipper.strings.get("VEGAS/pattern.0yourBest");});
define("string!VEGAS/continue",function(){return window.phet.chipper.strings.get("VEGAS/continue");});
define("string!VEGAS/label.level",function(){return window.phet.chipper.strings.get("VEGAS/label.level");});
define( 'VEGAS/LevelCompletedNode',['require','SCENERY/util/Color','VEGAS/ProgressIndicator','VEGAS/GameTimer','PHET_CORE/inherit','SCENERY_PHET/MultiLineText','SUN/Panel','SCENERY_PHET/PhetFont','AXON/Property','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','SUN/buttons/TextPushButton','SCENERY/nodes/VBox','VEGAS/vegas','TANDEM/Tandem','string!VEGAS/keepTrying','string!VEGAS/good','string!VEGAS/great','string!VEGAS/excellent','string!VEGAS/label.score.max','string!VEGAS/label.time','string!VEGAS/yourNewBest','string!VEGAS/pattern.0yourBest','string!VEGAS/continue','string!VEGAS/label.level'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var ProgressIndicator = require( 'VEGAS/ProgressIndicator' );
  var GameTimer = require( 'VEGAS/GameTimer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var Panel = require( 'SUN/Panel' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Property = require( 'AXON/Property' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TextPushButton = require( 'SUN/buttons/TextPushButton' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var vegas = require( 'VEGAS/vegas' );
  var Tandem = require( 'TANDEM/Tandem' );
  var keepTryingString = require( 'string!VEGAS/keepTrying' );
  var goodString = require( 'string!VEGAS/good' );
  var greatString = require( 'string!VEGAS/great' );
  var excellentString = require( 'string!VEGAS/excellent' );
  var labelScoreMaxString = require( 'string!VEGAS/label.score.max' );
  var labelTimeString = require( 'string!VEGAS/label.time' );
  var yourNewBestString = require( 'string!VEGAS/yourNewBest' );
  var pattern0YourBestString = require( 'string!VEGAS/pattern.0yourBest' );
  var continueString = require( 'string!VEGAS/continue' );
  var labelLevelString = require( 'string!VEGAS/label.level' );
  function LevelCompletedNode( level, score, perfectScore, numStars, timerEnabled, elapsedTime, bestTimeAtThisLevel, isNewBestTime, continueFunction, options ) {
    options = _.extend( {
      levelVisible: true, // display the level number?
      fill: new Color( 180, 205, 255 ),
      stroke: 'black',
      lineWidth: 2,
      cornerRadius: 35,
      xMargin: 20,
      yMargin: 20,
      ySpacing: 30,
      titleFont: new PhetFont( { size: 28, weight: 'bold' } ),
      infoFont: new PhetFont( { size: 22, weight: 'bold' } ),
      buttonFont: new PhetFont( 26 ),
      buttonFill: new Color( 255, 255, 0 ),
      starDiameter: 62,
      tandem: Tandem.tandemRequired()
    }, options );
    var children = [];
    var proportionCorrect = score / perfectScore;
    var titleText = keepTryingString;
    if ( proportionCorrect > 0.95 ) {
      titleText = excellentString;
    }
    else if ( proportionCorrect > 0.75 ) {
      titleText = greatString;
    }
    else if ( proportionCorrect >= 0.5 ) {
      titleText = goodString;
    }
    var title = new Text( titleText, { font: options.titleFont } );
    children.push( title );
    children.push( new ProgressIndicator( numStars, new Property( score ), perfectScore, {
      starInnerRadius: options.starDiameter / 4,
      starOuterRadius: options.starDiameter / 2
    } ) );
    if ( options.levelVisible ) {
      children.push( new Text( StringUtils.format( labelLevelString, level + 1 ), { font: options.infoFont } ) );
    }
    children.push( new Text( StringUtils.format( labelScoreMaxString, score, perfectScore ), { font: options.infoFont } ) );
    if ( timerEnabled ) {
      var time = new MultiLineText( StringUtils.format( labelTimeString, GameTimer.formatTime( elapsedTime ) ), {
        font: options.infoFont,
        align: 'center'
      } );
      if ( isNewBestTime ) {
        time.text = time.text + '\n' + yourNewBestString;
      }
      else if ( bestTimeAtThisLevel !== null ) {
        time.text = time.text + '\n' + StringUtils.format( pattern0YourBestString, GameTimer.formatTime( bestTimeAtThisLevel ) );
      }
      children.push( time );
    }
    children.push( new TextPushButton( continueString, {
      listener: continueFunction,
      font: options.buttonFont,
      baseColor: options.buttonFill,
      tandem: options.tandem.createTandem( 'continueButton' )
    } ) );
    Panel.call( this, new VBox( { children: children, spacing: options.ySpacing } ), options );
  }
  vegas.register( 'LevelCompletedNode', LevelCompletedNode );
  return inherit( Panel, LevelCompletedNode );
} );
define( 'SCENERY/display/drawables/CanvasNodeDrawable',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/display/CanvasSelfDrawable','SCENERY/display/SelfDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var CanvasSelfDrawable = require( 'SCENERY/display/CanvasSelfDrawable' );
  var SelfDrawable = require( 'SCENERY/display/SelfDrawable' );
  var emptyArray = []; // constant, used for line-dash
  function CanvasNodeDrawable( renderer, instance ) {
    this.initialize( renderer, instance );
  }
  scenery.register( 'CanvasNodeDrawable', CanvasNodeDrawable );
  inherit( CanvasSelfDrawable, CanvasNodeDrawable, {
    initialize: function( renderer, instance ) {
      return this.initializeCanvasSelfDrawable( renderer, instance );
    },
    paintCanvas: function( wrapper, node ) {
      assert && assert( !node.selfBounds.isEmpty(), 'CanvasNode should not be used with an empty canvasBounds. ' +
                                                    'Please set canvasBounds (or use setCanvasBounds()) on ' + node.constructor.name );
      if ( !node.selfBounds.isEmpty() ) {
        var context = wrapper.context;
        context.save();
        context.fillStyle = 'black';
        context.strokeStyle = 'black';
        context.lineWidth = 1;
        context.lineCap = 'butt';
        context.lineJoin = 'miter';
        context.lineDash = emptyArray;
        context.lineDashOffset = 0;
        context.miterLimit = 10;
        node.paintCanvas( context );
        context.restore();
      }
    }
  } );
  SelfDrawable.Poolable.mixin( CanvasNodeDrawable );
  return CanvasNodeDrawable;
} );
define( 'SCENERY/nodes/CanvasNode',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/display/Renderer','SCENERY/display/drawables/CanvasNodeDrawable'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Renderer = require( 'SCENERY/display/Renderer' );
  var CanvasNodeDrawable = require( 'SCENERY/display/drawables/CanvasNodeDrawable' );
  function CanvasNode( options ) {
    Node.call( this, options );
    this.setRendererBitmask( Renderer.bitmaskCanvas );
  }
  scenery.register( 'CanvasNode', CanvasNode );
  inherit( Node, CanvasNode, {
    _mutatorKeys: [ 'canvasBounds' ].concat( Node.prototype._mutatorKeys ),
    setCanvasBounds: function( selfBounds ) {
      this.invalidateSelf( selfBounds );
    },
    set canvasBounds( value ) { this.setCanvasBounds( value ); },
    getCanvasBounds: function() {
      return this.getSelfBounds();
    },
    get canvasBounds() { return this.getCanvasBounds(); },
    isPainted: function() {
      return true;
    },
    paintCanvas: function( context ) {
      throw new Error( 'CanvasNode needs paintCanvas implemented' );
    },
    invalidatePaint: function() {
      var stateLen = this._drawables.length;
      for ( var i = 0; i < stateLen; i++ ) {
        this._drawables[ i ].markDirty();
      }
    },
    canvasPaintSelf: function( wrapper ) {
      this.paintCanvas( wrapper.context );
    },
    containsPointSelf: function( point ) {
      return false;
    },
    createCanvasDrawable: function( renderer, instance ) {
      return CanvasNodeDrawable.createFromPool( renderer, instance );
    },
    getBasicConstructor: function( propLines ) {
      return 'new scenery.CanvasNode( {' + propLines + '} )'; // TODO: no real way to do this nicely?
    }
  } );
  return CanvasNode;
} );
define( 'VEGAS/RewardNode',['require','PHET_CORE/inherit','SCENERY/nodes/CanvasNode','JOIST/ScreenView','SCENERY_PHET/StarNode','SCENERY_PHET/FaceNode','DOT/Bounds2','SCENERY/nodes/Node','VEGAS/vegas'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var CanvasNode = require( 'SCENERY/nodes/CanvasNode' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var StarNode = require( 'SCENERY_PHET/StarNode' );
  var FaceNode = require( 'SCENERY_PHET/FaceNode' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var vegas = require( 'VEGAS/vegas' );
  var DEBUG = false; // shows a gray rectangle for the CanvasNode to help ensure that its bounds are accurate
  var MAX_SPEED = 200; // The maximum speed an image can fall in screen pixels per second.
  function RewardNode( options ) {
    var self = this;
    this.canvasDisplayBounds = new Bounds2( 0, 0, 0, 0 );
    this.options = options = _.extend( {
      scaleForResolution: 2,
      nodes: RewardNode.createRandomNodes( [
        new FaceNode( 40, { headStroke: 'black', headLineWidth: 1.5 } ),
        new StarNode()
      ], 150 ),
      stepSource: null
    }, options );
    if ( options.stepSource ) {
      this.stepCallback = function( dt ) {self.step( dt );};
      options.stepSource.on( 'step', this.stepCallback );
    }
    this.imageWrappers = []; // @private
    var uniqueNodes = _.uniq( this.options.nodes );
    uniqueNodes.forEach( function( node, i ) {
      self.imageWrappers.push( {
        image: null,
        width: node.width,
        height: node.height,
        node: node
      } );
      var parent = new Node( { children: [ node ], scale: options.scaleForResolution } );
      parent.toImage( function( image ) { self.imageWrappers[ i ].image = image; } );
    } );
    CanvasNode.call( this, options );
    this.inited = false;
  }
  vegas.register( 'RewardNode', RewardNode );
  return inherit( CanvasNode, RewardNode, {
      paintCanvas: function( context ) {
        if ( DEBUG ) {
          var bounds = this.canvasDisplayBounds;
          context.fillStyle = 'rgba(50,50,50,0.5)';
          context.fillRect( bounds.minX, bounds.minY, bounds.width, bounds.height );
          context.strokeStyle = '#0000ff';
          context.lineWidth = 5;
          context.strokeRect( bounds.minX, bounds.minY, bounds.width, bounds.height );
        }
        context.scale( 1 / this.options.scaleForResolution, 1 / this.options.scaleForResolution );
        if ( this.rewards ) {
          for ( var i = 0; i < this.rewards.length; i++ ) {
            var reward = this.rewards[ i ];
            if ( reward.imageWrapper.image ) {
              context.drawImage( reward.imageWrapper.image, reward.x, reward.y );
            }
          }
        }
      },
      getScene: function() {
        return this.getUniqueTrail().nodes[ 0 ];
      },
      getScreenView: function() {
        return this.getUniqueTrail( function( node ) { return node instanceof ScreenView; } ).rootNode();
      },
      init: function() {
        var self = this;
        this.scene = this.getScene();
        this.screenView = this.getScreenView();
        this.updateBounds = function() {
          var local = self.globalToLocalBounds( phet.joist.sim.display.bounds );
          self.setCanvasBounds( local );
          self.canvasDisplayBounds = local;
        };
        this.screenView.on( 'transform', this.updateBounds );
        this.updateBounds();
        this.rewards = [];
        for ( var i = 0; i < this.options.nodes.length; i++ ) {
          var node = this.options.nodes[ i ];
          (function( node ) {
            var imageWrapper = _.find( self.imageWrappers, function( imageWrapper ) {return imageWrapper.node === node;} );
            self.rewards.push( {
              imageWrapper: imageWrapper,
              x: self.sampleImageXValue( imageWrapper ),
              y: self.sampleImageYValue( imageWrapper ),
              speed: (Math.random() + 1) * MAX_SPEED
            } );
          })( node );
        }
        this.inited = true;
      },
      stop: function() {
        this.options.stepSource.off( 'step', this.stepCallback );
      },
      sampleImageXValue: function( imageWrapper ) {
        return (Math.random() * this.canvasDisplayBounds.width + this.canvasDisplayBounds.left) * this.options.scaleForResolution - imageWrapper.width / 2;
      },
      sampleImageYValue: function( imageWrapper ) {
        return this.canvasDisplayBounds.top - Math.random() * this.canvasDisplayBounds.height * 2 - MAX_SPEED - imageWrapper.height;
      },
      step: function( dt ) {
        if ( !this.inited && this.getScene() !== null ) {
          this.init();
        }
        var maxY = this.canvasDisplayBounds.height * this.options.scaleForResolution;
        for ( var i = 0; i < this.rewards.length; i++ ) {
          var reward = this.rewards[ i ];
          reward.y += reward.speed * dt;
          if ( reward.y > maxY ) {
            reward.x = this.sampleImageXValue( reward.imageWrapper );
            reward.y = this.sampleImageYValue( reward.imageWrapper );
          }
        }
        this.invalidatePaint();
      },
      dispose: function() {
        if ( this.options.stepSource ) {
          this.stop();
        }
        this.screenView.off( 'transform', this.updateBounds );
        CanvasNode.prototype.dispose.call( this );
      }
    },
    {
      createRandomNodes: function( nodes, count ) {
        var array = [];
        for ( var i = 0; i < count; i++ ) {
          array.push( nodes[ i % nodes.length ] );
        }
        return array;
      }
    } );
} );
define( 'BUILD_AN_ATOM/game/view/BAARewardNode',['require','SHRED/AtomIdentifier','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/FaceNode','PHET_CORE/inherit','BUILD_AN_ATOM/game/view/InteractiveSymbolNode','SHRED/model/NumberAtom','VEGAS/RewardNode'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var FaceNode = require( 'SCENERY_PHET/FaceNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var InteractiveSymbolNode = require( 'BUILD_AN_ATOM/game/view/InteractiveSymbolNode' );
  var NumberAtom = require( 'SHRED/model/NumberAtom' );
  var RewardNode = require( 'VEGAS/RewardNode' );
  var NUMBER_OF_NODES = 75;
  var NUMBER_OF_SYMBOL_NODES = 5;
  var FACE_DIAMETER = 40;
  var MIN_CHILD_NODE_WIDTH = 40;
  var MAX_CHILD_NODE_WIDTH = MIN_CHILD_NODE_WIDTH * 2;
  function BAARewardNode( tandem ) {
    var nodes = this.createNodes( tandem );
    RewardNode.call( this, { nodes: nodes } );
  }
  buildAnAtom.register( 'BAARewardNode', BAARewardNode );
  return inherit( RewardNode, BAARewardNode, {
    _createRandomStableAtom: function() {
      var atomicNumber = 1 + phet.joist.random.nextInt( 18 ); // Limit to Argon, since that's as high as translations go.
      return new NumberAtom( {
        protonCount: atomicNumber,
        neutronCount: AtomIdentifier.getNumNeutronsInMostCommonIsotope( atomicNumber ),
        electronCount: atomicNumber
      } );
    },
    createNodes: function( tandem ) {
      var self = this;
      var nodes = [];
      var groupTandem = tandem.createGroupTandem( 'interactiveSymbolNodes' );
      for ( var i = 0; i < NUMBER_OF_SYMBOL_NODES; i++ ){
        var interactiveSymbolNode = new InteractiveSymbolNode( self._createRandomStableAtom(), groupTandem.createNextTandem() );
        interactiveSymbolNode.scale( ( MIN_CHILD_NODE_WIDTH +
                                       phet.joist.random.nextDouble() *
                                       ( MAX_CHILD_NODE_WIDTH - MIN_CHILD_NODE_WIDTH ) ) /
                                     interactiveSymbolNode.width );
        nodes.push( interactiveSymbolNode );
      }
      var faceNode = new FaceNode( FACE_DIAMETER );
      nodes.push( faceNode );
      return RewardNode.createRandomNodes( nodes, NUMBER_OF_NODES );
    }
  } );
} );
define( 'SCENERY_PHET/SimpleClockIcon',['require','SCENERY/nodes/Circle','PHET_CORE/inherit','SCENERY/nodes/Line','SCENERY/nodes/Node','SCENERY_PHET/sceneryPhet'],function( require ) {
  'use strict';
  var Circle = require( 'SCENERY/nodes/Circle' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Line = require( 'SCENERY/nodes/Line' );
  var Node = require( 'SCENERY/nodes/Node' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  function SimpleClockIcon( radius, options ) {
    Node.call( this );
    options = _.extend( { fill: 'white', stroke: 'black', lineWidth: 2 }, options );
    this.addChild( new Circle( radius, options ) );
    this.addChild( new Circle( radius * 0.15, { fill: options.stroke } ) );
    var lineOptionsForClockHands = {
      stroke: options.stroke,
      lineWidth: options.lineWidth,
      lineCap: 'round',
      lineJoin: 'round'
    };
    this.addChild( new Line( 0, 0, 0, -radius * 0.75, lineOptionsForClockHands ) );
    this.addChild( new Line( 0, 0, radius * 0.45, radius * 0.3, lineOptionsForClockHands ) );
    this.centerX = radius;
    this.centerY = radius;
    this.mutate( options );
  }
  sceneryPhet.register( 'SimpleClockIcon', SimpleClockIcon );
  return inherit( Node, SimpleClockIcon );
} );
define("string!VEGAS/startOver",function(){return window.phet.chipper.strings.get("VEGAS/startOver");});
define("string!VEGAS/label.scorePattern",function(){return window.phet.chipper.strings.get("VEGAS/label.scorePattern");});
define("string!VEGAS/pattern.0challenge.1max",function(){return window.phet.chipper.strings.get("VEGAS/pattern.0challenge.1max");});
define( 'VEGAS/ScoreboardBar',['require','SCENERY/util/Color','VEGAS/GameTimer','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','SCENERY_PHET/SimpleClockIcon','PHETCOMMON/util/StringUtils','SCENERY/nodes/Text','SUN/buttons/TextPushButton','VEGAS/vegas','TANDEM/Tandem','string!VEGAS/startOver','string!VEGAS/label.level','string!VEGAS/label.scorePattern','string!VEGAS/pattern.0challenge.1max'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var GameTimer = require( 'VEGAS/GameTimer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var SimpleClockIcon = require( 'SCENERY_PHET/SimpleClockIcon' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TextPushButton = require( 'SUN/buttons/TextPushButton' );
  var vegas = require( 'VEGAS/vegas' );
  var Tandem = require( 'TANDEM/Tandem' );
  var startOverString = require( 'string!VEGAS/startOver' );
  var labelLevelString = require( 'string!VEGAS/label.level' );
  var labelScorePatternString = require( 'string!VEGAS/label.scorePattern' );
  var pattern0Challenge1MaxString = require( 'string!VEGAS/pattern.0challenge.1max' );
  function ScoreboardBar( screenWidth, challengeIndexProperty, challengesPerGameProperty, levelProperty, scoreProperty, elapsedTimeProperty, timerEnabledProperty, startOverCallback, options ) {
    options = _.extend( {
      levelVisible: true,
      challengeNumberVisible: true,
      font: new PhetFont( 20 ),
      textFill: 'white',
      startOverButtonText: startOverString,
      startOverButtonTextFill: 'black',
      startOverButtonBaseColor: new Color( 229, 243, 255 ),
      startOverButtonXMargin: 10,
      startOverButtonYMargin: 5,
      clockIconRadius: 15,
      xSpacing: 50,
      leftMargin: 20,
      rightMargin: 20,
      yMargin: 10,
      backgroundFill: 'rgb( 49, 117, 202 )',
      backgroundStroke: null,
      backgroundLineWidth: 1,
      tandem: Tandem.tandemRequired()
    }, options );
    var textOptions = { fill: options.textFill, font: options.font };
    var levelNode = new Text( '', textOptions );
    levelProperty.link( function( level ) {
      levelNode.text = StringUtils.format( labelLevelString, level + 1 );
    } );
    var challengeNumberNode = new Text( '', textOptions );
    var updateChallengeString = function() {
      challengeNumberNode.text = StringUtils.format( pattern0Challenge1MaxString, challengeIndexProperty.get() + 1, challengesPerGameProperty.get() );
    };
    challengeIndexProperty.link( updateChallengeString );
    challengesPerGameProperty.link( updateChallengeString );
    var scoreNode = new Text( '', textOptions );
    scoreProperty.link( function( score ) {
      scoreNode.text = StringUtils.format( labelScorePatternString, score );
    } );
    var timerNode = new Node( { pickable: false } );
    var clockIcon = new SimpleClockIcon( options.clockIconRadius );
    var timeValue = new Text( '', textOptions );
    timerNode.addChild( clockIcon );
    timerNode.addChild( timeValue );
    timeValue.left = clockIcon.right + 8;
    timeValue.centerY = clockIcon.centerY;
    elapsedTimeProperty.link( function( elapsedTime ) {
      timeValue.text = GameTimer.formatTime( elapsedTime );
    } );
    var nodes = [ levelNode, challengeNumberNode, scoreNode, timerNode ]; // in left-to-right order
    if ( !options.levelVisible ) { nodes.splice( nodes.indexOf( levelNode ), 1 ); }
    if ( !options.challengeNumberVisible ) { nodes.splice( nodes.indexOf( challengeNumberNode ), 1 ); }
    for ( var i = 0; i < nodes.length; i++ ) {
      if ( i > 0 ) {
        nodes[ i ].left = nodes[ i - 1 ].right + options.xSpacing;
        nodes[ i ].centerY = nodes[ i - 1 ].centerY;
      }
    }
    var leftParentNode = new Node( {
      children: nodes,
      maxWidth: 0.75 * ( screenWidth - options.leftMargin - options.rightMargin ) // constrain width for i18n
    } );
    var startOverButton = new TextPushButton( options.startOverButtonText, {
      listener: startOverCallback,
      font: options.font,
      textFill: options.startOverButtonTextFill,
      baseColor: options.startOverButtonBaseColor,
      xMargin: options.startOverButtonXMargin,
      yMargin: options.startOverButtonYMargin,
      maxWidth: screenWidth - leftParentNode.maxWidth - options.leftMargin - options.rightMargin - options.xSpacing, // constrain width for i18n
      tandem: options.tandem.createTandem( 'startOverButton' )
    } );
    var backgroundHeight = Math.max( leftParentNode.height, startOverButton.height ) + ( 2 * options.yMargin );
    var backgroundNode = new Rectangle( 0, 0, 4 * screenWidth, backgroundHeight,
      { fill: options.backgroundFill, stroke: options.backgroundStroke, lineWidth: options.backgroundLineWidth } );
    leftParentNode.centerY = startOverButton.centerY = backgroundNode.centerY; // vertically aligned
    leftParentNode.left = backgroundNode.centerX - ( screenWidth / 2 ) + options.leftMargin; // left end
    startOverButton.right = backgroundNode.centerX + ( screenWidth / 2 ) - options.rightMargin; // right end
    options.children = [ backgroundNode, leftParentNode, startOverButton ];
    Node.call( this, options );
    timerEnabledProperty.link( function( timerEnabled ) {
      timerNode.visible = timerEnabled;
    } );
  }
  vegas.register( 'ScoreboardBar', ScoreboardBar );
  return inherit( Node, ScoreboardBar );
} );
define( 'VEGAS/LevelSelectionButton',['require','DOT/Dimension2','VEGAS/GameTimer','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','VEGAS/ProgressIndicator','SCENERY/nodes/Rectangle','SUN/buttons/RectangularPushButton','SCENERY/nodes/Text','VEGAS/vegas','TANDEM/Tandem'],function( require ) {
  'use strict';
  var Dimension2 = require( 'DOT/Dimension2' );
  var GameTimer = require( 'VEGAS/GameTimer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var ProgressIndicator = require( 'VEGAS/ProgressIndicator' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var Text = require( 'SCENERY/nodes/Text' );
  var vegas = require( 'VEGAS/vegas' );
  var Tandem = require( 'TANDEM/Tandem' );
  var SCALING_TOLERANCE = 1E-4; // Empirically chosen as something the human eye is unlikely to notice.
  function LevelSelectionButton( icon, numStars, fireFunction, scoreProperty, perfectScore, options ) {
    assert && assert( icon instanceof Node );
    assert && assert( typeof numStars === 'number' );
    Node.call( this );
    options = _.extend( {
      buttonWidth: 150,
      buttonHeight: 150,
      cornerRadius: 10,
      baseColor: 'rgb( 242, 255, 204 )',
      buttonXMargin: 10,
      buttonYMargin: 10,
      progressIndicatorProportion: 0.2, // percentage of the button height occupied by the progress indicator, (0,0.5]
      progressIndicatorMinXMargin: 10,
      progressIndicatorMinYMargin: 5,
      iconToProgressIndicatorYSpace: 10,
      bestTimeProperty: null, // null if no best time || {Property.<number>} best time in seconds
      bestTimeVisibleProperty: null, // null || Property.<boolean>} controls visibility of best time
      bestTimeFill: 'black',
      bestTimeFont: new PhetFont( 24 ),
      bestTimeYSpacing: 10,  // vertical space between drop shadow and best time
      tandem: Tandem.tandemRequired()
    }, options );
    assert && assert( options.progressIndicatorProportion > 0 && options.progressIndicatorProportion <= 0.5, 'progressIndicatorProportion value out of range' );
    var maxContentWidth = options.buttonWidth - 2 * options.buttonXMargin;
    var progressIndicatorBackground = new Rectangle( 0, 0, maxContentWidth,
      options.buttonHeight * options.progressIndicatorProportion, options.cornerRadius, options.cornerRadius, {
        fill: 'white',
        stroke: 'black',
        lineWidth: 1,
        pickable: false
      } );
    var progressIndicator = new ProgressIndicator( numStars, scoreProperty, perfectScore, {
      pickable: false,
      starDiameter: options.buttonWidth / ( numStars + 1 )
    } );
    progressIndicator.scale( Math.min(
      ( progressIndicatorBackground.width - 2 * options.progressIndicatorMinXMargin ) / progressIndicator.width,
      ( progressIndicatorBackground.height - 2 * options.progressIndicatorMinYMargin ) / progressIndicator.height ) );
    var iconSize = new Dimension2( maxContentWidth, options.buttonHeight - progressIndicatorBackground.height -
                                                    2 * options.buttonYMargin - options.iconToProgressIndicatorYSpace );
    var adjustedIcon = LevelSelectionButton.createSizedImageNode( icon, iconSize );
    adjustedIcon.pickable = false; // TODO: is this needed?
    var contentNode = new Node();
    if ( progressIndicatorBackground.width > adjustedIcon.width ) {
      adjustedIcon.centerX = progressIndicatorBackground.centerX;
    }
    else {
      progressIndicatorBackground.centerX = adjustedIcon.centerX;
    }
    progressIndicatorBackground.top = adjustedIcon.bottom + options.iconToProgressIndicatorYSpace;
    progressIndicator.center = progressIndicatorBackground.center;
    contentNode.addChild( adjustedIcon );
    contentNode.addChild( progressIndicatorBackground );
    contentNode.addChild( progressIndicator );
    var buttonOptions = {
      content: contentNode,
      xMargin: options.buttonXMargin,
      yMargin: options.buttonYMargin,
      baseColor: options.baseColor,
      cornerRadius: options.cornerRadius,
      listener: fireFunction,
      tandem: options.tandem.createTandem( 'button' )
    };
    var button = new RectangularPushButton( buttonOptions );
    this.addChild( button );
    if ( options.bestTimeProperty ) {
      var bestTimeNode = new Text( '', { font: options.bestTimeFont, fill: options.bestTimeFill } );
      this.addChild( bestTimeNode );
      options.bestTimeProperty.link( function( bestTime ) {
        bestTimeNode.text = ( bestTime ? GameTimer.formatTime( bestTime ) : '' );
        bestTimeNode.centerX = button.centerX;
        bestTimeNode.top = button.bottom + options.bestTimeYSpacing;
      } );
      if ( options.bestTimeVisibleProperty ) {
        options.bestTimeVisibleProperty.linkAttribute( bestTimeNode, 'visible' );
      }
    }
    this.mutate( options );
  }
  vegas.register( 'LevelSelectionButton', LevelSelectionButton );
  return inherit( Node, LevelSelectionButton, {}, {
    createSizedImageNode: function( icon, size ) {
      icon.scale( Math.min( size.width / icon.bounds.width, size.height / icon.bounds.height ) );
      if ( Math.abs( icon.bounds.width - size.width ) < SCALING_TOLERANCE &&
           Math.abs( icon.bounds.height - size.height ) < SCALING_TOLERANCE ) {
        return icon;
      }
      var background = Rectangle.dimension( size, { fill: null } );
      icon.center = background.center;
      background.addChild( icon );
      return background;
    }
  } );
} );
define("image!BUILD_AN_ATOM/mass_charge_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define("image!BUILD_AN_ATOM/periodic_table_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define("image!BUILD_AN_ATOM/question_mark_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define( 'SUN/buttons/ToggleButtonInteractionStateProperty',['require','AXON/DerivedProperty','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  function ToggleButtonInteractionStateProperty( buttonModel ) {
    DerivedProperty.call(
      this,
      [ buttonModel.overProperty, buttonModel.downProperty, buttonModel.enabledProperty ],
      function( over, down, enabled ) {
        return !enabled ? 'disabled' :
               over && !(down ) ? 'over' :
               down ? 'pressed' :
               'idle';
      }
    );
  }
  sun.register( 'ToggleButtonInteractionStateProperty', ToggleButtonInteractionStateProperty );
  return inherit( DerivedProperty, ToggleButtonInteractionStateProperty );
} );
define( 'SUN/buttons/ToggleButtonModel',['require','SUN/buttons/ButtonModel','AXON/Emitter','PHET_CORE/inherit','SUN/sun'],function( require ) {
  'use strict';
  var ButtonModel = require( 'SUN/buttons/ButtonModel' );
  var Emitter = require( 'AXON/Emitter' );
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  function ToggleButtonModel( valueOff, valueOn, property ) {
    var self = this;
    this.valueOff = valueOff;
    this.valueOn = valueOn;
    this.valueProperty = property;
    ButtonModel.call( this );
    this.startedCallbacksForToggledEmitter = new Emitter();
    this.endedCallbacksForToggledEmitter = new Emitter();
    var downListener = function( down ) {
      if ( self.enabledProperty.get() && self.overProperty.get() ) {
        if ( !down ) {
          self.toggle();
        }
      }
    };
    this.downProperty.link( downListener ); // @private
    this.disposeToggleButtonModel = function() {
      self.downProperty.unlink( downListener );
    };
  }
  sun.register( 'ToggleButtonModel', ToggleButtonModel );
  return inherit( ButtonModel, ToggleButtonModel, {
    dispose: function() {
      this.disposeToggleButtonModel();
      ButtonModel.prototype.dispose.call( this );
    },
    toggle: function() {
      assert && assert( this.valueProperty.value === this.valueOff || this.valueProperty.value === this.valueOn );
      var oldValue = this.valueProperty.value;
      var newValue = this.valueProperty.value === this.valueOff ? this.valueOn : this.valueOff;
      this.startedCallbacksForToggledEmitter.emit2( oldValue, newValue );
      this.valueProperty.value = newValue;
      this.endedCallbacksForToggledEmitter.emit();
    }
  } );
} );
define( 'SUN/buttons/TToggleButton',['require','ifphetio!PHET_IO/assertions/assertInstanceOfTypes','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var assertInstanceOfTypes = require( 'ifphetio!PHET_IO/assertions/assertInstanceOfTypes' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TToggleButton( phetioValueType ) {
    var validateTandems = phet.phetio && phet.phetio.queryParameters.phetioValidateTandems;
    var TToggleButtonImpl = function TToggleButtonImpl( toggleButton, phetioID ) {
      assert && assert( !!phetioValueType || !validateTandems, 'phetioValueType must be specified' );
      TNode.call( this, toggleButton, phetioID );
      assertInstanceOfTypes( toggleButton, [
        phet.sun.ToggleButton,
        phet.sceneryPhet.PlayPauseButton,
        phet.sun.RoundStickyToggleButton,
        phet.sun.RectangularToggleButton,
        phet.sun.RoundMomentaryButton,
        phet.sun.BooleanRoundToggleButton
      ] );
      var model = toggleButton.toggleButtonModel || toggleButton.buttonModel;  // Handle BooleanRoundStickyToggleButton too
      toEventOnEmit( model.startedCallbacksForToggledEmitter, model.endedCallbacksForToggledEmitter, 'user', phetioID, this.constructor, 'toggled',
        function( oldValue, newValue ) {
          return {
            oldValue: phetioValueType.toStateObject( oldValue ),
            newValue: phetioValueType.toStateObject( newValue )
          };
        } );
    };
    return phetioInherit( TNode, 'TToggleButton', TToggleButtonImpl, {}, {
      documentation: 'A button that toggles state (in/out) when pressed',
      events: [ 'toggled' ]
    } );
  }
  sun.register( 'TToggleButton', TToggleButton );
  return TToggleButton;
} );
define( 'SUN/buttons/RectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularButtonView','SUN/sun','SUN/buttons/ToggleButtonInteractionStateProperty','SUN/buttons/ToggleButtonModel','TANDEM/Tandem','SUN/buttons/TToggleButton'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularButtonView = require( 'SUN/buttons/RectangularButtonView' );
  var sun = require( 'SUN/sun' );
  var ToggleButtonInteractionStateProperty = require( 'SUN/buttons/ToggleButtonInteractionStateProperty' );
  var ToggleButtonModel = require( 'SUN/buttons/ToggleButtonModel' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TToggleButton = require( 'SUN/buttons/TToggleButton' );
  function RectangularToggleButton( valueOff, valueOn, property, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TToggleButton( property.phetioValueType )
    }, options );
    this.toggleButtonModel = new ToggleButtonModel( valueOff, valueOn, property, options );
    RectangularButtonView.call( this, this.toggleButtonModel, new ToggleButtonInteractionStateProperty( this.toggleButtonModel ), options );
  }
  sun.register( 'RectangularToggleButton', RectangularToggleButton );
  return inherit( RectangularButtonView, RectangularToggleButton );
} );
define( 'SUN/ToggleNode',['require','PHET_CORE/inherit','TANDEM/Tandem','SCENERY/nodes/Node','SUN/sun'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Node = require( 'SCENERY/nodes/Node' );
  var sun = require( 'SUN/sun' );
  function ToggleNode( trueNode, falseNode, booleanProperty, options ) {
    options = _.extend( {
      tandem: Tandem.tandemRequired()
    }, options );
    Node.call( this );
    falseNode.center = trueNode.center;
    this.addChild( falseNode );
    this.addChild( trueNode );
    booleanProperty.link( function( value ) {
      trueNode.setVisible( value );
      falseNode.setVisible( !value );
      trueNode.setAccessibleContentDisplayed( value );
      falseNode.setAccessibleContentDisplayed( !value );
    } );
    this.mutate( options );
  }
  sun.register( 'ToggleNode', ToggleNode );
  return inherit( Node, ToggleNode );
} );
define( 'SUN/buttons/BooleanRectangularToggleButton',['require','PHET_CORE/inherit','SUN/buttons/RectangularToggleButton','SUN/sun','SUN/ToggleNode','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var RectangularToggleButton = require( 'SUN/buttons/RectangularToggleButton' );
  var sun = require( 'SUN/sun' );
  var ToggleNode = require( 'SUN/ToggleNode' );
  var Tandem = require( 'TANDEM/Tandem' );
  function BooleanRectangularToggleButton( trueNode, falseNode, booleanProperty, options ) {
    options = _.extend( { tandem: Tandem.tandemRequired() }, options );
    assert && assert( !options.content, 'options.content cannot be set' );
    options.content = new ToggleNode( trueNode, falseNode, booleanProperty, {
      tandem: options.tandem.createTandem( 'toggleNode' )
    } );
    RectangularToggleButton.call( this, false, true, booleanProperty, options );
  }
  sun.register( 'BooleanRectangularToggleButton', BooleanRectangularToggleButton );
  return inherit( RectangularToggleButton, BooleanRectangularToggleButton );
} );
define( 'SCENERY_PHET/buttons/SoundToggleButton',['require','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SCENERY_PHET/SceneryPhetA11yStrings','SUN/buttons/BooleanRectangularToggleButton','SCENERY_PHET/sceneryPhet','SCENERY_PHET/accessibility/AriaHerald','SCENERY_PHET/PhetColorScheme'],function( require ) {
  'use strict';
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var SceneryPhetA11yStrings = require( 'SCENERY_PHET/SceneryPhetA11yStrings' );
  var BooleanRectangularToggleButton = require( 'SUN/buttons/BooleanRectangularToggleButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var AriaHerald = require( 'SCENERY_PHET/accessibility/AriaHerald' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var WIDTH = 45;
  var HEIGHT = 45;
  var MARGIN = 4;
  var X_WIDTH = WIDTH * 0.25; // Empirically determined.
  function SoundToggleButton( property, options ) {
    var soundOffNode = new Node();
    var soundOnNode = new FontAwesomeNode( 'volume_up' );
    var contentScale = ( WIDTH - ( 2 * MARGIN ) ) / soundOnNode.width;
    soundOnNode.scale( contentScale );
    soundOffNode.addChild( new FontAwesomeNode( 'volume_off', { scale: contentScale } ) );
    var soundOffX = new Path( new Shape().moveTo( 0, 0 ).lineTo( X_WIDTH, X_WIDTH ).moveTo( 0, X_WIDTH ).lineTo( X_WIDTH, 0 ), {
      stroke: 'black',
      lineWidth: 3,
      left: soundOffNode.width + 5,
      centerY: soundOffNode.centerY
    } );
    soundOffNode.addChild( soundOffX );
    BooleanRectangularToggleButton.call( this, soundOnNode, soundOffNode, property, _.extend( {
      baseColor: PhetColorScheme.PHET_LOGO_YELLOW,
      minWidth: WIDTH,
      minHeight: HEIGHT,
      xMargin: MARGIN,
      yMargin: MARGIN,
      tagName: 'button',
      accessibleLabel: SceneryPhetA11yStrings.soundToggleLabelString
    }, options ) );
    this.focusHighlight = new Shape.bounds( this.localBounds.dilated( 5 ) );
    var self = this;
    var clickListener = this.addAccessibleInputListener( {
      click: function( event ) {
        self.buttonModel.toggle();
      }
    } );
    var pressedListener = function( value ) {
      self.setAccessibleAttribute( 'aria-pressed', !value );
      var alertString = value ? SceneryPhetA11yStrings.simSoundOnString : SceneryPhetA11yStrings.simSoundOffString;
      AriaHerald.announcePolite( alertString );
    };
    property.lazyLink( pressedListener );
    self.setAccessibleAttribute( 'aria-pressed', !property.get() );
    this.disposeSoundToggleButton = function() {
      self.removeAccessibleInputListener( clickListener );
      property.unlink( pressedListener );
    };
  }
  sceneryPhet.register( 'SoundToggleButton', SoundToggleButton );
  return inherit( BooleanRectangularToggleButton, SoundToggleButton, {
    dispose: function() {
      this.disposeSoundToggleButton();
      BooleanRectangularToggleButton.prototype.dispose.call( this );
    }
  } );
} );
define("image!BUILD_AN_ATOM/symbol_question_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAIAAAAiOjnJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABR5JREFUeNrs3L9OI0cAwOF1RJcm8AbHtddE0AOSeYFI+AFSmCpNGru5FEljmvRQ5AGwdFU6I0GREndpIW9wfgRnfJasuV2wd9djndd8n0467mTwsvPT7OwfyDKApmjN/5pOp/YFaZJqzaL6zo5gE4SFsBAWwgJhISyEVcd4PL66ujo+Pm59rd/vh/+3Z5toMpmEset0OsnGdFrFaDQ6Ojpa+TUHg8GUhvj8+XO32105pr1eb+WXqhlWyKV8r+12O2yxYdtyj4+P+/v7Jcc0zClPT0+Jw6pU1WI7jNzOVDV3eHi4ZL6oHFbYguIbhNTi97i+vr64uKgxf/KtFFc14ZgYVjuLF9ze3hbHNByLkoUVvlb8KeHNXntl2JTcdiyfPPlWwkQQD1OYuuKklo9p+NwEYeWmqyVVvbgdJq3tFI458TCFUS4/pq9NWtXCyq2uysxA8QxnpbWdq6vcEXDlp+TOHF9caVW7jjUej+PpKlf6i+KNiD+dLXF3d/faeJUZ0+XDWiesMhex5kv7+J/Pz8/GcqvEI3L0RZlz/JJffK/k68Kxb37t9ebmpurZ6WJhaCy3Slh9h+VKyCtMXWUOQYtxnEwmK1+2wUeTh8Nhp9NZbE04HhvLHbjnc3BwEE83xSI3/mhyfAjPXaqgocLxKl7qLJnnNhVWmGDjjSh/bGZrhXV2v9+vtNjPkp/Kxu86Pw46vd+lOz9L7upsMKzclTSPOTTdaDTKnXu9doF+g2Hl0nZptOnK38zZYFjhNCGuKnzsLuEu3UxcWdVGwiqefC6ZMNl+xaekVlaVPqxwBMxVVWYjaMqdxPLTRMqwig+Lqarpah98koVVPGVQ1Y4trSoNaJqwiqcM4X8MTNPFj4xWPa9PcOW93+8v7gYuJsziY6w08SL74uN6A7pX740nk0lIKr4bOH+q1a2b3XuipvyDD+veKwzvenx8HFcVegrrd1XtpHrPO+3VqOr8/Dwuut1uh7nKAAirfljFqrrdbvHiLE03Xfv5vAqHwrCuylU1GAxUxbphhXPAXFW9Xs8e5EVlH00OS/UwXcWnoMUrWJBVfTQ591tshsNhqyI/pdMUl5eX6w9cqbDmP8hhj5M4LFWxkbDK/BwZ1Fm8w0YW75D+UAjCQlh1PTw8lL9+Fl68/d/R6elpyW8nvFJYmLFAWAgLYYGwEBbCAmEhLIQFwkJYCAuEhbAQFggLYSEsEBbCQlggLISFsEBYCAthgbAQFsICYSEshAXCQlgIC4SFsBAWCAthsWv2dv47PDs7M8xmLIQFwkJYCAuEhbAQFggLYSEsEBbCSuP+/n669U5OToQFwkJYCAuEhbAQFggLYSEsEBbCQlggLISFsEBYCAthgbAQFsICYSEshAXCQlgIC4SFsBAWCAthISwQFsJCWAgLhIWwEBYIC2EhLBAWbyys5/+y1vezP+8/2LPCSqf/mx1K6rCu/syGn+xQkoZ181fW/2hvstCa/zWdTteaq3JVHb7Lnv61c99oUq1ZVHtrr6s+zsKCr60RVjgHvPwlu7u3E0m3xgqz1PsPqiJdWGGdHpLKLaraZ9ngD3uTNcIafpodBGMhqdHf2f4P9iaJLjeEierxn6z3q/1IosX74bts8Ht28ZM9SKKwjn6c9dT92b4jaVgW6Wx8jQXCQlgIC4SFsBAWCAthISwQFsJCWCAshIWwQFgIC2GBsBAWDZPi1xhBnNSXX2NkxsKhEGEhLBAWwkJYICyEhbAA4G36X4ABACUWCwLJrqXFAAAAAElFTkSuQmCC';
return img;});
define( 'SCENERY_PHET/buttons/TimerToggleButton',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SCENERY_PHET/SimpleClockIcon','SUN/buttons/BooleanRectangularToggleButton','SCENERY_PHET/sceneryPhet','SCENERY_PHET/PhetColorScheme'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Shape = require( 'KITE/Shape' );
  var SimpleClockIcon = require( 'SCENERY_PHET/SimpleClockIcon' );
  var BooleanRectangularToggleButton = require( 'SUN/buttons/BooleanRectangularToggleButton' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var WIDTH = 45;
  var HEIGHT = 45;
  var MARGIN = 4;
  var X_STROKE_WIDTH = 6;
  function TimerToggleButton( timerRunningProperty, options ) {
    var clockRadius = WIDTH * 0.35;
    var timerOnNode = new SimpleClockIcon( clockRadius );
    var timerOffNode = new Node();
    var timerOffNodeBackground = new SimpleClockIcon( clockRadius, { opacity: 0.8 } );
    timerOffNode.addChild( timerOffNodeBackground );
    var xNode = new Shape();
    var xNodeWidth = timerOffNode.width * 0.8;
    xNode.moveTo( 0, 0 );
    xNode.lineTo( xNodeWidth, xNodeWidth );
    xNode.moveTo( 0, xNodeWidth );
    xNode.lineTo( xNodeWidth, 0 );
    timerOffNode.addChild( new Path( xNode, {
      stroke: 'red',
      opacity: 0.55,
      lineWidth: X_STROKE_WIDTH,
      lineCap: 'round',
      centerX: timerOffNode.width / 2,
      centerY: timerOffNode.height / 2
    } ) );
    BooleanRectangularToggleButton.call( this, timerOnNode, timerOffNode, timerRunningProperty, _.extend( {
      baseColor: PhetColorScheme.PHET_LOGO_YELLOW,
      minWidth: WIDTH,
      minHeight: HEIGHT,
      xMargin: MARGIN,
      yMargin: MARGIN
    }, options ) );
  }
  sceneryPhet.register( 'TimerToggleButton', TimerToggleButton );
  return inherit( BooleanRectangularToggleButton, TimerToggleButton );
} );
define("string!BUILD_AN_ATOM/chooseYourGame",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/chooseYourGame");});
define( 'BUILD_AN_ATOM/game/view/StartGameLevelNode',['require','BUILD_AN_ATOM/game/model/BAAGameModel','BUILD_AN_ATOM/common/BAASharedConstants','BUILD_AN_ATOM/buildAnAtom','SCENERY/nodes/Image','PHET_CORE/inherit','VEGAS/LevelSelectionButton','image!BUILD_AN_ATOM/mass_charge_icon.png','SCENERY/nodes/Node','image!BUILD_AN_ATOM/periodic_table_icon.png','SCENERY_PHET/PhetFont','image!BUILD_AN_ATOM/question_mark_icon.png','SCENERY_PHET/buttons/ResetAllButton','SHRED/ShredConstants','SCENERY_PHET/buttons/SoundToggleButton','image!BUILD_AN_ATOM/symbol_question_icon.png','SCENERY/nodes/Text','SCENERY_PHET/buttons/TimerToggleButton','string!BUILD_AN_ATOM/chooseYourGame'],function( require ) {
  'use strict';
  var BAAGameModel = require( 'BUILD_AN_ATOM/game/model/BAAGameModel' );
  var BAASharedConstants = require( 'BUILD_AN_ATOM/common/BAASharedConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LevelSelectionButton = require( 'VEGAS/LevelSelectionButton' );
  var massChargeIcon = require( 'image!BUILD_AN_ATOM/mass_charge_icon.png' );
  var Node = require( 'SCENERY/nodes/Node' );
  var periodicTableIcon = require( 'image!BUILD_AN_ATOM/periodic_table_icon.png' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var questionMarkIcon = require( 'image!BUILD_AN_ATOM/question_mark_icon.png' );
  var ResetAllButton = require( 'SCENERY_PHET/buttons/ResetAllButton' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var SoundToggleButton = require( 'SCENERY_PHET/buttons/SoundToggleButton' );
  var symbolQuestionIcon = require( 'image!BUILD_AN_ATOM/symbol_question_icon.png' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TimerToggleButton = require( 'SCENERY_PHET/buttons/TimerToggleButton' );
  var chooseYourGameString = require( 'string!BUILD_AN_ATOM/chooseYourGame' );
  var CONTROLS_INSET = 10;
  var NUM_STARS_ON_BUTTON = 5;
  var BASE_COLOR = '#D4AAD4';
  function StartGameLevelNode( gameModel, layoutBounds, tandem ) {
    Node.call( this ); // Call super constructor.
    var title = new Text( chooseYourGameString, {
      font: new PhetFont( 30 ),
      maxWidth: layoutBounds.width
    } );
    this.addChild( title );
    var periodicTableGameButton = new LevelSelectionButton(
      new Image( periodicTableIcon ),
      NUM_STARS_ON_BUTTON,
      function() {
        gameModel.startGameLevel( 'periodic-table-game', tandem.createTandem( 'periodicTableGame' ) );
      },
      gameModel.scores[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'periodic-table-game' ) ],
      BAAGameModel.MAX_POINTS_PER_GAME_LEVEL,
      _.extend( {
          tandem: tandem.createTandem( 'periodicTableGameButton' )
        },
        {
          baseColor: BASE_COLOR,
          bestTimeProperty: gameModel.bestTimes[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'periodic-table-game' ) ],
          bestTimeVisibleProperty: gameModel.bestTimeVisible[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'periodic-table-game' ) ]
        }
      )
    );
    this.addChild( periodicTableGameButton );
    var massAndChargeGameButton = new LevelSelectionButton(
      new Image( massChargeIcon ),
      NUM_STARS_ON_BUTTON,
      function() {
        gameModel.startGameLevel( 'mass-and-charge-game', tandem.createTandem( 'massAndChargeGame' ) );
      },
      gameModel.scores[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'mass-and-charge-game' ) ],
      BAAGameModel.MAX_POINTS_PER_GAME_LEVEL, {
        tandem: tandem.createTandem( 'massAndChargeGameButton' ),
        baseColor: BASE_COLOR,
        bestTimeProperty: gameModel.bestTimes[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'mass-and-charge-game' ) ],
        bestTimeVisibleProperty: gameModel.bestTimeVisible[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'mass-and-charge-game' ) ]
      }
    );
    this.addChild( massAndChargeGameButton );
    var symbolGameButton = new LevelSelectionButton(
      new Image( symbolQuestionIcon ),
      NUM_STARS_ON_BUTTON,
      function() {
        gameModel.startGameLevel( 'symbol-game', tandem.createTandem( 'symbolGame' ) );
      },
      gameModel.scores[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'symbol-game' ) ],
      BAAGameModel.MAX_POINTS_PER_GAME_LEVEL, {
        tandem: tandem.createTandem( 'symbolGameButton' ),
        baseColor: BASE_COLOR,
        bestTimeProperty: gameModel.bestTimes[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'symbol-game' ) ],
        bestTimeVisibleProperty: gameModel.bestTimeVisible[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'symbol-game' ) ]
      }
    );
    this.addChild( symbolGameButton );
    var advancedSymbolGameButton = new LevelSelectionButton(
      new Image( questionMarkIcon ),
      NUM_STARS_ON_BUTTON,
      function() {
        gameModel.startGameLevel( 'advanced-symbol-game', tandem.createTandem( 'advancedSymbolGame' ) );
      },
      gameModel.scores[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'advanced-symbol-game' ) ],
      BAAGameModel.MAX_POINTS_PER_GAME_LEVEL, {
        tandem: tandem.createTandem( 'advancedSymbolGameButton' ),
        baseColor: BASE_COLOR,
        bestTimeProperty: gameModel.bestTimes[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'advanced-symbol-game' ) ],
        bestTimeVisibleProperty: gameModel.bestTimeVisible[ ShredConstants.MAP_LEVEL_NAME_TO_NUMBER( 'advanced-symbol-game' ) ]
      }
    );
    this.addChild( advancedSymbolGameButton );
    var timerToggleButton = new TimerToggleButton( gameModel.timerEnabledProperty, {
      stroke: 'gray',
      tandem: tandem.createTandem( 'timerToggleButton' )
    } );
    this.addChild( timerToggleButton );
    var soundToggleButton = new SoundToggleButton( gameModel.soundEnabledProperty, {
      stroke: 'gray',
      tandem: tandem.createTandem( 'soundToggleButton' )
    } );
    this.addChild( soundToggleButton );
    var resetAllButton = new ResetAllButton( {
      listener: function() {
        gameModel.reset();
      },
      radius: BAASharedConstants.RESET_BUTTON_RADIUS,
      tandem: tandem.createTandem( 'resetAllButton' ),
      touchAreaDilation: 8
    } );
    this.addChild( resetAllButton );
    var buttonWidth = periodicTableGameButton.width; // Note: Assumes all buttons are the same size.
    var interButtonXSpace = buttonWidth * 0.2;
    var buttonCenterY = layoutBounds.height * 0.5;
    periodicTableGameButton.right = layoutBounds.centerX - 1.5 * interButtonXSpace - buttonWidth;
    periodicTableGameButton.centerY = buttonCenterY;
    massAndChargeGameButton.left = periodicTableGameButton.right + interButtonXSpace;
    massAndChargeGameButton.centerY = buttonCenterY;
    symbolGameButton.left = massAndChargeGameButton.right + interButtonXSpace;
    symbolGameButton.centerY = buttonCenterY;
    advancedSymbolGameButton.left = symbolGameButton.right + interButtonXSpace;
    advancedSymbolGameButton.centerY = buttonCenterY;
    resetAllButton.right = layoutBounds.width - CONTROLS_INSET;
    resetAllButton.bottom = layoutBounds.height - CONTROLS_INSET;
    title.centerX = layoutBounds.width / 2;
    title.centerY = periodicTableGameButton.top / 2;
    soundToggleButton.left = CONTROLS_INSET;
    soundToggleButton.bottom = layoutBounds.height - CONTROLS_INSET;
    timerToggleButton.left = CONTROLS_INSET;
    timerToggleButton.bottom = soundToggleButton.top - 10;
  }
  buildAnAtom.register( 'StartGameLevelNode', StartGameLevelNode );
  return inherit( Node, StartGameLevelNode );
} );
define( 'BUILD_AN_ATOM/game/view/BAAGameView',['require','BUILD_AN_ATOM/game/model/BAAGameModel','BUILD_AN_ATOM/common/BAAQueryParameters','BUILD_AN_ATOM/buildAnAtom','VEGAS/GameAudioPlayer','PHET_CORE/inherit','VEGAS/LevelCompletedNode','SCENERY/nodes/Node','AXON/Property','BUILD_AN_ATOM/game/view/BAARewardNode','VEGAS/ScoreboardBar','JOIST/ScreenView','BUILD_AN_ATOM/game/view/StartGameLevelNode','SHRED/ShredConstants'],function( require ) {
  'use strict';
  var BAAGameModel = require( 'BUILD_AN_ATOM/game/model/BAAGameModel' );
  var BAAQueryParameters = require( 'BUILD_AN_ATOM/common/BAAQueryParameters' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var GameAudioPlayer = require( 'VEGAS/GameAudioPlayer' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LevelCompletedNode = require( 'VEGAS/LevelCompletedNode' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var BAARewardNode = require( 'BUILD_AN_ATOM/game/view/BAARewardNode' );
  var ScoreboardBar = require( 'VEGAS/ScoreboardBar' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var StartGameLevelNode = require( 'BUILD_AN_ATOM/game/view/StartGameLevelNode' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  function BAAGameView( gameModel, tandem ) {
    ScreenView.call( this, { layoutBounds: ShredConstants.LAYOUT_BOUNDS } ); // Call super constructor.
    var self = this;
    var rootNode = new Node();
    self.addChild( rootNode );
    var startGameLevelNode = new StartGameLevelNode(
      gameModel,
      this.layoutBounds,
      tandem.createTandem( 'startGameLevelNode' )
    );
    var scoreboard = new ScoreboardBar(
      this.layoutBounds.width,
      gameModel.problemIndexProperty,
      new Property( BAAGameModel.PROBLEMS_PER_LEVEL ),
      gameModel.levelProperty,
      gameModel.scoreProperty,
      gameModel.elapsedTimeProperty,
      gameModel.timerEnabledProperty,
      function() { gameModel.newGame(); }, {
        levelVisible: false,
        tandem: tandem.createTandem( 'scoreboard' )
      }
    );
    scoreboard.centerX = this.layoutBounds.centerX;
    scoreboard.top = 0;
    var gameAudioPlayer = new GameAudioPlayer( gameModel.soundEnabledProperty );
    this.rewardNode = null;
    var problemViewGroupTandem = tandem.createGroupTandem( 'problemView' );
    var previousView = null;
    function disposePreviousView() {
      if ( previousView ) {
        previousView.dispose();
        previousView = null;
      }
    }
    gameModel.stateProperty.link( function( state ) {
      if ( state === 'selectGameLevel' ) {
        rootNode.removeAllChildren();
        disposePreviousView();
        rootNode.addChild( startGameLevelNode );
        if ( self.rewardNode !== null ) {
          self.rewardNode.dispose();
        }
        self.rewardNode = null;
      }
      else if ( state === 'levelCompleted' ) {
        rootNode.removeAllChildren();
        disposePreviousView();
        if ( gameModel.scoreProperty.get() === BAAGameModel.MAX_POINTS_PER_GAME_LEVEL || BAAQueryParameters.reward ) {
          self.rewardNode = new BAARewardNode( tandem.createTandem( 'rewardNode' ) );
          rootNode.addChild( self.rewardNode );
          gameAudioPlayer.gameOverPerfectScore();
        }
        else if ( gameModel.scoreProperty.get() > 0 ) {
          gameAudioPlayer.gameOverImperfectScore();
        }
        rootNode.addChild( new LevelCompletedNode( gameModel.levelProperty.get(), gameModel.scoreProperty.get(),
          BAAGameModel.MAX_POINTS_PER_GAME_LEVEL,
          BAAGameModel.PROBLEMS_PER_LEVEL, gameModel.timerEnabledProperty.get(), gameModel.elapsedTimeProperty.get(),
          gameModel.bestTimes[ gameModel.levelProperty.get() ].value, gameModel.newBestTime,
          function() { gameModel.stateProperty.set( 'selectGameLevel' ); }, {
            centerX: self.layoutBounds.width / 2,
            centerY: self.layoutBounds.height / 2,
            levelVisible: false,
            maxWidth: self.layoutBounds.width,
            tandem: tandem.createTandem( 'levelCompletedNode' )
          } ) );
      }
      else if ( typeof( state.createView ) === 'function' ) {
        rootNode.removeAllChildren();
        disposePreviousView();
        var problemView = state.createView( self.layoutBounds, problemViewGroupTandem.createNextTandem() );
        rootNode.addChild( problemView );
        rootNode.addChild( scoreboard );
        previousView = problemView;
      }
    } );
  }
  buildAnAtom.register( 'BAAGameView', BAAGameView );
  return inherit( ScreenView, BAAGameView, {
    step: function( elapsedTime ) {
      if ( this.rewardNode ) {
        this.rewardNode.step( elapsedTime );
      }
    }
  } );
} );
define("string!BUILD_AN_ATOM/game",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/game");});
define("image!BUILD_AN_ATOM/game_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define("image!BUILD_AN_ATOM/game_icon_small.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define( 'BUILD_AN_ATOM/game/GameScreen',['require','BUILD_AN_ATOM/game/model/BAAGameModel','BUILD_AN_ATOM/game/view/BAAGameView','BUILD_AN_ATOM/buildAnAtom','SCENERY/nodes/Image','PHET_CORE/inherit','AXON/Property','JOIST/Screen','string!BUILD_AN_ATOM/game','image!BUILD_AN_ATOM/game_icon.png','image!BUILD_AN_ATOM/game_icon_small.png'],function( require ) {
  'use strict';
  var BAAGameModel = require( 'BUILD_AN_ATOM/game/model/BAAGameModel' );
  var BAAGameView = require( 'BUILD_AN_ATOM/game/view/BAAGameView' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var Screen = require( 'JOIST/Screen' );
  var gameString = require( 'string!BUILD_AN_ATOM/game' );
  var gameIcon = require( 'image!BUILD_AN_ATOM/game_icon.png' );
  var gameIconSmall = require( 'image!BUILD_AN_ATOM/game_icon_small.png' );
  function GameScreen( tandem ) {
    Screen.call(
      this,
      function() { return new BAAGameModel( tandem.createTandem( 'model' ) ); },
      function( model ) { return new BAAGameView( model, tandem.createTandem( 'view' ) ); },
      {
        name: gameString,
        backgroundColorProperty: new Property( 'rgb( 255, 254, 223 )' ),
        homeScreenIcon: new Image( gameIcon ),
        navigationBarIcon: new Image( gameIconSmall ),
        tandem: tandem
      }
    );
  }
  buildAnAtom.register( 'GameScreen', GameScreen );
  return inherit( Screen, GameScreen );
} );
define( 'JOIST/JoistA11yStrings',['require','JOIST/joist'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var JoistA11yStrings = {
    hotKeysAndHelpString: 'Keyboard Shortcuts',
    closeString: 'Close',
    simResourcesAndToolsString: 'Sim Resources and Tools',
    phetString: 'PhET Menu'
  };
  if ( phet.chipper.queryParameters.stringTest === 'xss' ) {
    for ( var key in JoistA11yStrings ) {
      JoistA11yStrings[ key ] += '<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2NkYGD4DwABCQEBtxmN7wAAAABJRU5ErkJggg==" onload="window.location.href=atob(\'aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1kUXc0dzlXZ1hjUQ==\')" />';
    }
  }
  if ( assert ) { Object.freeze( JoistA11yStrings ); }
  joist.register( 'JoistA11yStrings', JoistA11yStrings );
  return JoistA11yStrings;
} );
define( 'PHET_CORE/detectPrefixEvent',['require','PHET_CORE/phetCore'],function( require ) {
  'use strict';
  var phetCore = require( 'PHET_CORE/phetCore' );
  function detectPrefixEvent( obj, name, isEvent ) {
    if ( obj[ 'on' + name ] !== undefined ) { return name; }
    if ( obj[ 'on' + 'moz' + name ] !== undefined ) { return 'moz' + name; }
    if ( obj[ 'on' + 'Moz' + name ] !== undefined ) { return 'Moz' + name; } // some prefixes seem to have all-caps?
    if ( obj[ 'on' + 'webkit' + name ] !== undefined ) { return 'webkit' + name; }
    if ( obj[ 'on' + 'ms' + name ] !== undefined ) { return 'ms' + name; }
    if ( obj[ 'on' + 'o' + name ] !== undefined ) { return 'o' + name; }
    return undefined;
  }
  phetCore.register( 'detectPrefixEvent', detectPrefixEvent );
  return detectPrefixEvent;
} );
define( 'JOIST/FullScreen',['require','PHET_CORE/platform','PHET_CORE/detectPrefix','PHET_CORE/detectPrefixEvent','AXON/Property','JOIST/joist'],function( require ) {
  'use strict';
  var platform = require( 'PHET_CORE/platform' );
  var detectPrefix = require( 'PHET_CORE/detectPrefix' );
  var detectPrefixEvent = require( 'PHET_CORE/detectPrefixEvent' );
  var Property = require( 'AXON/Property' );
  var joist = require( 'JOIST/joist' );
  var requestFullscreenPropertyName = detectPrefix( document.body, 'requestFullscreen' ) ||
                                      detectPrefix( document.body, 'requestFullScreen' ); // Firefox capitalization
  var exitFullscreenPropertyName = detectPrefix( document, 'exitFullscreen' ) ||
                                   detectPrefix( document, 'cancelFullScreen' ); // Firefox
  var fullscreenElementPropertyName = detectPrefix( document, 'fullscreenElement' ) ||
                                      detectPrefix( document, 'fullScreenElement' ); // Firefox capitalization
  var fullscreenEnabledPropertyName = detectPrefix( document, 'fullscreenEnabled' ) ||
                                      detectPrefix( document, 'fullScreenEnabled' ); // Firefox capitalization
  var fullscreenChangeEvent = detectPrefixEvent( document, 'fullscreenchange' );
  if ( fullscreenChangeEvent === 'msfullscreenchange' ) {
    fullscreenChangeEvent = 'MSFullscreenChange';
  }
  var FullScreen = {
    isFullScreen: function() {
      return !!document[ fullscreenElementPropertyName ];
    },
    isFullScreenEnabled: function() {
      return document[ fullscreenEnabledPropertyName ] && !platform.safari7;
    },
    enterFullScreen: function( sim ) {
      if ( !platform.ie9 && !platform.ie10 ) {
        sim.display.domElement[ requestFullscreenPropertyName ] && sim.display.domElement[ requestFullscreenPropertyName ]();
      }
      else if ( typeof window.ActiveXObject !== 'undefined' ) { // Older IE.
        var wscript = new window.ActiveXObject( 'WScript.Shell' );
        if ( wscript !== null ) {
          wscript.SendKeys( '{F11}' );
        }
      }
    },
    exitFullScreen: function() {
      document[ exitFullscreenPropertyName ] && document[ exitFullscreenPropertyName ]();
    },
    toggleFullScreen: function( sim ) {
      if ( FullScreen.isFullScreen() ) {
        FullScreen.exitFullScreen();
      }
      else {
        FullScreen.enterFullScreen( sim );
      }
    },
    isFullScreenProperty: new Property( false )
  };
  document.addEventListener( fullscreenChangeEvent, function( evt ) {
    FullScreen.isFullScreenProperty.set( FullScreen.isFullScreen() );
  } );
  joist.register( 'FullScreen', FullScreen );
  return FullScreen;
} );
define( 'JOIST/Dialog',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/input/Input','SUN/Panel','SUN/buttons/RectangularPushButton','JOIST/joist','JOIST/JoistA11yStrings','SCENERY_PHET/accessibility/AriaHerald','SCENERY/accessibility/AccessibilityUtil','JOIST/FullScreen','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Input = require( 'SCENERY/input/Input' );
  var Panel = require( 'SUN/Panel' );
  var RectangularPushButton = require( 'SUN/buttons/RectangularPushButton' );
  var joist = require( 'JOIST/joist' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var AriaHerald = require( 'SCENERY_PHET/accessibility/AriaHerald' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var FullScreen = require( 'JOIST/FullScreen' );
  var Tandem = require( 'TANDEM/Tandem' );
  var closeString = JoistA11yStrings.closeString;
  function Dialog( content, options ) {
    var self = this;
    options = _.extend( {
      modal: false, // {boolean} modal dialogs prevent interaction with the rest of the sim while open
      title: null, // {Node} title to be displayed at top
      titleAlign: 'center', // horizontal alignment of the title: {string} left, right or center
      titleSpacing: 20, // {number} how far the title is placed above the content
      hasCloseButton: true, // whether to put a close 'X' button is upper-right corner
      layoutStrategy: Dialog.DEFAULT_LAYOUT_STRATEGY,
      cornerRadius: 10, // {number} radius of the dialog's corners
      resize: true, // {boolean} whether to resize if content's size changes
      fill: 'white', // {string|Color}
      stroke: 'black', // {string|Color}
      backgroundPickable: true,
      xMargin: 20,
      yMargin: 20,
      closeButtonBaseColor: '#d00',
      closeButtonMargin: 5, // {number} how far away should the close button be from the panel border
      tandem: Tandem.tandemRequired(),
      tagName: 'div',
      ariaRole: 'dialog',
      focusOnCloseNode: null // {Node} receives focus on close, if null focus returns to element that had focus on open
    }, options );
    this.isModal = options.modal;
    assert && assert( this.isModal, 'Non-modal dialogs not currently supported' );
    this.isShowing = false;
    var dialogContent = new Node( {
      children: [ content ]
    } );
    if ( options.title ) {
      var titleNode = options.title;
      dialogContent.addChild( titleNode );
      var updateTitlePosition = function() {
        switch( options.titleAlign ) {
          case 'center':
            titleNode.centerX = content.centerX;
            break;
          case 'left':
            titleNode.left = content.left;
            break;
          case 'right':
            titleNode.right = content.right;
            break;
          default:
            throw new Error( 'unknown titleAlign for Dialog: ' + options.titleAlign );
        }
        titleNode.bottom = content.top - options.titleSpacing;
      };
      if ( options.resize ) {
        content.on( 'bounds', updateTitlePosition );
        titleNode.on( 'localBounds', updateTitlePosition );
      }
      updateTitlePosition();
    }
    Panel.call( this, dialogContent, options );
    if ( options.hasCloseButton ) {
      var crossSize = 10;
      var crossNode = new Path( new Shape().moveTo( 0, 0 ).lineTo( crossSize, crossSize ).moveTo( 0, crossSize ).lineTo( crossSize, 0 ), {
        stroke: '#fff',
        lineWidth: 3
      } );
      var closeButton = new RectangularPushButton( {
        content: crossNode,
        baseColor: options.closeButtonBaseColor,
        xMargin: 5,
        yMargin: 5,
        listener: function() {
          self.hide();
        },
        accessibleFire: function() {
          self.focusActiveElement();
        },
        tandem: options.tandem.createTandem( 'closeButton' ),
        tagName: 'button',
        accessibleLabel: closeString
      } );
      this.addChild( closeButton );
      var updateClosePosition = function() {
        closeButton.right = dialogContent.right + options.xMargin - options.closeButtonMargin;
        closeButton.top = dialogContent.top - options.xMargin + options.closeButtonMargin;
        closeButton.focusHighlight = Shape.bounds( crossNode.bounds.dilated( 10 ) );
      };
      if ( options.resize ) {
        dialogContent.on( 'bounds', updateClosePosition );
        if ( options.title ) {
          options.title.on( 'bounds', updateClosePosition );
        }
      }
      updateClosePosition();
    }
    var sim = window.phet.joist.sim;
    this.updateLayout = function() {
      options.layoutStrategy( self, sim.boundsProperty.value, sim.screenBoundsProperty.value, sim.scaleProperty.value );
    };
    this.updateLayout();
    this.sim = sim;
    this.accessibleOrder = [ titleNode, dialogContent ];
    content.tagName && content.setAriaDescribesNode( this );
    if ( options.title ) {
      options.title.tagName && options.title.setAriaLabelsNode( this );
    }
    this.sim.resizedEmitter.addListener( this.updateLayout );
    this.activeElement = options.focusOnCloseNode || null;
    var escapeListener = this.addAccessibleInputListener( {
      keydown: function( event ) {
        if ( event.keyCode === Input.KEY_ESCAPE ) {
          event.preventDefault();
          self.hide();
          self.focusActiveElement();
        }
        else if ( event.keyCode === Input.KEY_TAB && FullScreen.isFullScreen() ) {
          var activeElement = document.activeElement;
          var noNextFocusable = AccessibilityUtil.getNextFocusable() === activeElement;
          var noPreviousFocusable = AccessibilityUtil.getPreviousFocusable() === activeElement;
          if ( noNextFocusable && noPreviousFocusable ) {
            event.preventDefault();
          }
        }
      }
    } );
    this.disposeDialog = function() {
      options.tandem.removeInstance( this );
      self.sim.resizedEmitter.removeListener( self.updateLayout );
      self.removeAccessibleInputListener( escapeListener );
      if ( options.hasCloseButton ) {
        closeButton.dispose();
      }
      if ( options.resize ) {
        dialogContent.off( 'bounds', updateClosePosition );
        if ( options.title ) {
          options.title.off( 'bounds', updateClosePosition );
          titleNode.off( 'localBounds', updateTitlePosition );
          content.off( 'bounds', updateTitlePosition );
        }
      }
      dialogContent.removeAllChildren();
      dialogContent.detach();
    };
  }
  joist.register( 'Dialog', Dialog );
  Dialog.DEFAULT_LAYOUT_STRATEGY = function( dialog, simBounds, screenBounds, scale ) {
    dialog.center = simBounds.center.times( 1.0 / scale );
  };
  return inherit( Panel, Dialog, {
    show: function() {
      if ( !this.isShowing ) {
        window.phet.joist.sim.showPopup( this, this.isModal );
        this.isShowing = true;
        this.activeElement = this.activeElement || document.activeElement;
        this.setAccessibleViewsHidden( true );
        this.updateLayout();
      }
    },
    hide: function() {
      if ( this.isShowing ) {
        window.phet.joist.sim.hidePopup( this, this.isModal );
        this.isShowing = false;
        this.setAccessibleViewsHidden( false );
      }
    },
    dispose: function() {
      this.hide();
      this.disposeDialog();
      Panel.prototype.dispose.call( this );
    },
    setAccessibleViewsHidden: function( hidden ) {
      for ( var i = 0; i < this.sim.screens.length; i++ ) {
        this.sim.screens[ i ].view.accessibleContentDisplayed = !hidden;
      }
      this.sim.navigationBar.accessibleContentDisplayed = !hidden;
      this.sim.navigationBar.keyboardHelpButton.accessibleHidden = hidden;
      AriaHerald.clearAll();
    },
    focusActiveElement: function() {
      this.activeElement && this.activeElement.focus();
    }
  } );
} );
define( 'JOIST/TDialog',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','JOIST/joist','ifphetio!PHET_IO/phetioInherit','SUN/TPanel'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var joist = require( 'JOIST/joist' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var TPanel = require( 'SUN/TPanel' );
  function TDialog( dialog, phetioID ) {
    TPanel.call( this, dialog, phetioID );
    assertInstanceOf( dialog, phet.sun.Panel );
  }
  phetioInherit( TPanel, 'TDialog', TDialog, {}, {
    documentation: 'A dialog panel'
  } );
  joist.register( 'TDialog', TDialog );
  return TDialog;
} );
define( 'JOIST/TOptionsDialog',['require','JOIST/TDialog','ifphetio!PHET_IO/assertions/assertInstanceOf','JOIST/joist','ifphetio!PHET_IO/phetioInherit'],function( require ) {
  'use strict';
  var TDialog = require( 'JOIST/TDialog' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var joist = require( 'JOIST/joist' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  function TOptionsDialog( dialog, phetioID ) {
    assertInstanceOf( dialog, phet.sun.Panel );
    TDialog.call( this, dialog, phetioID );
  }
  phetioInherit( TDialog, 'TOptionsDialog', TOptionsDialog, {}, {
    documentation: 'A dialog panel'
  } );
  joist.register( 'TOptionsDialog', TOptionsDialog );
  return TOptionsDialog;
} );
define("string!JOIST/options.title",function(){return window.phet.chipper.strings.get("JOIST/options.title");});
define( 'JOIST/OptionsDialog',['require','SCENERY/nodes/Text','PHET_CORE/inherit','SCENERY_PHET/PhetFont','JOIST/Dialog','JOIST/joist','TANDEM/Tandem','JOIST/TOptionsDialog','string!JOIST/options.title'],function( require ) {
  'use strict';
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Dialog = require( 'JOIST/Dialog' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TOptionsDialog = require( 'JOIST/TOptionsDialog' );
  var optionsTitleString = require( 'string!JOIST/options.title' );
  function OptionsDialog( optionsNode, options ) {
    options = _.extend( {
      titleAlign: 'center',
      modal: true,
      hasCloseButton: true,
      tandem: Tandem.tandemRequired(),
      phetioType: TOptionsDialog
    }, options );
    if ( !options.title ) {
      options.title = new Text( optionsTitleString, {
        font: new PhetFont( 30 ),
        maxWidth: 400,
        tandem: options.tandem.createTandem( 'title' )
      } );
    }
    Dialog.call( this, optionsNode, options );
    this.disposeOptionsDialog = function(){
      options.title && options.title.dispose();
    };
  }
  joist.register( 'OptionsDialog', OptionsDialog );
  return inherit( Dialog, OptionsDialog, {
    dispose: function() {
      this.disposeOptionsDialog();
      Dialog.prototype.dispose.call( this );
    }
  }, {
    DEFAULT_FONT: new PhetFont( 15 ),
    DEFAULT_SPACING: 10
  } );
} );
define("string!BUILD_AN_ATOM/highContrastParticles",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/highContrastParticles");});
define( 'BUILD_AN_ATOM/common/view/GlobalOptionsNode',['require','BUILD_AN_ATOM/buildAnAtom','SUN/CheckBox','PHET_CORE/inherit','JOIST/OptionsDialog','SCENERY/nodes/Text','SCENERY/nodes/VBox','string!BUILD_AN_ATOM/highContrastParticles'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var CheckBox = require( 'SUN/CheckBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var OptionsDialog = require( 'JOIST/OptionsDialog' );
  var Text = require( 'SCENERY/nodes/Text' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var highContrastParticlesString = require( 'string!BUILD_AN_ATOM/highContrastParticles' );
  function GlobalOptionsNode( highContrastParticlesProperty, tandem ) {
    var highContrastParticlesCheckbox = new CheckBox(
      new Text( highContrastParticlesString, { font: OptionsDialog.DEFAULT_FONT } ),
      highContrastParticlesProperty,
      {
        tandem: tandem.createTandem( 'highContrastParticlesCheckbox' )
      }
    );
    VBox.call( this, {
      children: [ highContrastParticlesCheckbox ],
      spacing: OptionsDialog.DEFAULT_SPACING,
      align: 'left'
    } );
    this.disposeGlobalOptionsNode = function() {
      highContrastParticlesCheckbox.dispose();
    };
  }
  buildAnAtom.register( 'GlobalOptionsNode', GlobalOptionsNode );
  return inherit( VBox, GlobalOptionsNode, {
    dispose: function() {
      this.disposeGlobalOptionsNode();
      VBox.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/HighlightNode',['require','SCENERY/util/Color','SCENERY/nodes/HBox','PHET_CORE/inherit','SCENERY/util/LinearGradient','SCENERY/nodes/Rectangle','JOIST/joist'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var inherit = require( 'PHET_CORE/inherit' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var joist = require( 'JOIST/joist' );
  function HighlightNode( width, height, options ) {
    options = _.extend( {
      fill: 'white',
      highlightWidth: 1,
      pickable: false
    }, options );
    var innerColor = options.fill;
    var outerColor = Color.toColor( innerColor ).withAlpha( 0 ); // transparent
    var barOptions = {
      fill: new LinearGradient( 0, 0, 0, height )
        .addColorStop( 0, outerColor )
        .addColorStop( 0.5, innerColor )
        .addColorStop( 1, outerColor )
    };
    var leftBar = new Rectangle( 0, 0, options.highlightWidth, height, barOptions );
    var rightBar = new Rectangle( 0, 0, options.highlightWidth, height, barOptions );
    options.children = [ leftBar, rightBar ];
    options.spacing = width;
    HBox.call( this, options );
  }
  joist.register( 'HighlightNode', HighlightNode );
  return inherit( HBox, HighlightNode );
} );
define( 'JOIST/TJoistButton',['require','SCENERY/nodes/TNode','JOIST/joist','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var TNode = require( 'SCENERY/nodes/TNode' );
  var joist = require( 'JOIST/joist' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TJoistButton( joistButton, phetioID ) {
    assertInstanceOf( joistButton, phet.joist.JoistButton );
    TNode.call( this, joistButton, phetioID );
    toEventOnEmit(
      joistButton.buttonModel.startedCallbacksForFiredEmitter,
      joistButton.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }
  phetioInherit( TNode, 'TJoistButton', TJoistButton, {}, {
    documentation: 'The buttons used in the home screen and navigation bar',
    events: [ 'fired' ]
  } );
  joist.register( 'TJoistButton', TJoistButton );
  return TJoistButton;
} );
define( 'JOIST/JoistButton',['require','SCENERY/nodes/Node','PHET_CORE/inherit','KITE/Shape','JOIST/HighlightNode','SUN/buttons/ButtonListener','SUN/buttons/PushButtonInteractionStateProperty','SUN/buttons/PushButtonModel','AXON/Property','JOIST/joist','JOIST/TJoistButton'],function( require ) {
  'use strict';
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Shape = require( 'KITE/Shape' );
  var HighlightNode = require( 'JOIST/HighlightNode' );
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var PushButtonInteractionStateProperty = require( 'SUN/buttons/PushButtonInteractionStateProperty' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var Property = require( 'AXON/Property' );
  var joist = require( 'JOIST/joist' );
  var TJoistButton = require( 'JOIST/TJoistButton' );
  function JoistButton( content, navigationBarFillProperty, tandem, options ) {
    options = _.extend( {
      cursor: 'pointer', // {string}
      listener: null, // {function}
      highlightExtensionWidth: 0,
      highlightExtensionHeight: 0,
      highlightCenterOffsetX: 0,
      highlightCenterOffsetY: 0
    }, options );
    this.buttonModel = new PushButtonModel( options );
    var createHighlight = function( fill ) {
      return new HighlightNode( content.width + options.highlightExtensionWidth, content.height + options.highlightExtensionHeight, {
        centerX: content.centerX + options.highlightCenterOffsetX,
        centerY: content.centerY + options.highlightCenterOffsetY,
        fill: fill,
        pickable: false
      } );
    };
    var brightenHighlight = createHighlight( 'white' );
    var darkenHighlight = createHighlight( 'black' );
    Node.call( this, { children: [ content, brightenHighlight, darkenHighlight ] } );
    var interactionStateProperty = new PushButtonInteractionStateProperty( this.buttonModel );
    this.interactionStateProperty = interactionStateProperty;
    Property.multilink( [ interactionStateProperty, navigationBarFillProperty ], function( interactionState, navigationBarFill ) {
      var useDarkenHighlight = navigationBarFill !== 'black';
      brightenHighlight.visible = !useDarkenHighlight && (interactionState === 'over' || interactionState === 'pressed');
      darkenHighlight.visible = useDarkenHighlight && (interactionState === 'over' || interactionState === 'pressed');
    } );
    this.addInputListener( new ButtonListener( this.buttonModel ) );
    this.mouseArea = this.touchArea = Shape.bounds( this.bounds );
    this.mutate( _.omit( options, 'tandem' ) );
    tandem.addInstance( this, TJoistButton );
  }
  joist.register( 'JoistButton', JoistButton );
  return inherit( Node, JoistButton );
} );
define( 'JOIST/HomeButton',['require','SUN/FontAwesomeNode','PHET_CORE/inherit','JOIST/JoistButton','SCENERY/nodes/Node','AXON/Property','SCENERY/nodes/Rectangle','JOIST/joist'],function( require ) {
  'use strict';
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var joist = require( 'JOIST/joist' );
  function HomeButton( navBarHeight, navigationBarFillProperty, tandem, options ) {
    options = _.extend( {
      highlightExtensionWidth: 4,
      listener: null
    }, options );
    var homeIcon = new FontAwesomeNode( 'home' );
    homeIcon.setScaleMagnitude( 0.48 * navBarHeight / homeIcon.height );
    var background = new Rectangle( 0, 0, homeIcon.width + 12, navBarHeight );
    homeIcon.center = background.center;
    var content = new Node( { children: [ background, homeIcon ] } );
    JoistButton.call( this, content, navigationBarFillProperty, tandem, options );
    Property.multilink( [ this.interactionStateProperty, navigationBarFillProperty ], function( interactionState, navigationBarFill ) {
      if ( navigationBarFill === 'black' ) {
        homeIcon.fill = interactionState === 'pressed' ? 'gray' : 'white';
      }
      else {
        homeIcon.fill = interactionState === 'pressed' ? '#444' : '#222';
      }
    } );
  }
  joist.register( 'HomeButton', HomeButton );
  return inherit( JoistButton, HomeButton );
} );
define( 'JOIST/TNavigationBarScreenButton',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TNavigationBarScreenButton( navigationBarScreenButton, phetioID ) {
    assertInstanceOf( navigationBarScreenButton, phet.joist.NavigationBarScreenButton );
    TNode.call( this, navigationBarScreenButton, phetioID );
    toEventOnEmit(
      navigationBarScreenButton.buttonModel.startedCallbacksForFiredEmitter,
      navigationBarScreenButton.buttonModel.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired'
    );
  }
  phetioInherit( TNode, 'TNavigationBarScreenButton', TNavigationBarScreenButton, {}, {
    documentation: 'A pressable button in the simulation\'s navigation bar',
    events: [ 'fired' ]
  } );
  joist.register( 'TNavigationBarScreenButton', TNavigationBarScreenButton );
  return TNavigationBarScreenButton;
} );
define( 'JOIST/NavigationBarScreenButton',['require','SUN/buttons/ButtonListener','AXON/DerivedProperty','JOIST/HighlightNode','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetFont','AXON/Property','SUN/buttons/PushButtonModel','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','DOT/Util','SCENERY/nodes/VBox','JOIST/joist','TANDEM/Tandem','SCENERY_PHET/PhetColorScheme','JOIST/TNavigationBarScreenButton'],function( require ) {
  'use strict';
  var ButtonListener = require( 'SUN/buttons/ButtonListener' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var HighlightNode = require( 'JOIST/HighlightNode' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Property = require( 'AXON/Property' );
  var PushButtonModel = require( 'SUN/buttons/PushButtonModel' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Util = require( 'DOT/Util' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var TNavigationBarScreenButton = require( 'JOIST/TNavigationBarScreenButton' );
  var HIGHLIGHT_SPACING = 4;
  function NavigationBarScreenButton( navigationBarFillProperty, screenIndexProperty, screens, screen, navBarHeight, options ) {
    assert && assert( screen.name, 'name is required for screen ' + screens.indexOf( screen ) );
    assert && assert( screen.navigationBarIcon, 'navigationBarIcon is required for screen ' + screen.name );
    function clicked() {
      screenIndexProperty.value = screens.indexOf( screen );
    }
    options = _.extend( {
      cursor: 'pointer',
      textDescription: screen.name + ' Screen: Button',
      tandem: Tandem.tandemRequired(),
      maxButtonWidth: null // {number|null} the maximum width of the button, causes text and/or icon to be scaled down if necessary
    }, options );
    Node.call( this );
    var icon = new Node( {
      children: [ screen.navigationBarIcon ], // wrap in case this icon is used in multiple place (eg, home screen and navbar)
      maxHeight: 0.625 * navBarHeight,
      tandem: options.tandem.createTandem( 'icon' )
    } );
    var selectedProperty = new DerivedProperty( [ screenIndexProperty ], function( screenIndex ) {
      return screenIndex === screens.indexOf( screen );
    } );
    this.buttonModel = new PushButtonModel( {
      listener: clicked
    } );
    this.addInputListener( new ButtonListener( this.buttonModel ) );
    options.tandem.addInstance( this, TNavigationBarScreenButton );
    var text = new Text( screen.name, {
      font: new PhetFont( 10 ),
      tandem: options.tandem.createTandem( 'text' )
    } );
    var box = new VBox( {
      children: [ icon, text ],
      pickable: false,
      spacing: Math.max( 0, 12 - text.height ), // see https://github.com/phetsims/joist/issues/143
      usesOpacity: true, // hint, since we change its opacity
      maxHeight: navBarHeight
    } );
    var overlay = new Rectangle( 0, 0, box.width, box.height, { center: box.center } );
    var highlightWidth = overlay.width + ( 2 * HIGHLIGHT_SPACING );
    var brightenHighlight = new HighlightNode( highlightWidth, overlay.height, {
      center: box.center,
      fill: 'white'
    } );
    var darkenHighlight = new HighlightNode( highlightWidth, overlay.height, {
      center: box.center,
      fill: 'black'
    } );
    this.addChild( box );
    this.addChild( overlay );
    this.addChild( brightenHighlight );
    this.addChild( darkenHighlight );
    Property.multilink( [
      selectedProperty,
      this.buttonModel.downProperty,
      this.buttonModel.overProperty,
      navigationBarFillProperty
    ], function update( selected, down, over, navigationBarFill ) {
      var useDarkenHighlights = ( navigationBarFill !== 'black' );
      var selectedTextColor = useDarkenHighlights ? 'black' : PhetColorScheme.PHET_LOGO_YELLOW;
      var unselectedTextColor = useDarkenHighlights ? 'gray' : 'white';
      text.fill = selected ? selectedTextColor : unselectedTextColor;
      box.opacity = selected ? 1.0 : ( down ? 0.65 : 0.5 );
      brightenHighlight.visible = !useDarkenHighlights && ( over || down );
      darkenHighlight.visible = useDarkenHighlights && ( over || down );
    } );
    if ( options.maxButtonWidth && ( this.width > options.maxButtonWidth ) ) {
      text.maxWidth = icon.maxWidth = options.maxButtonWidth - ( this.width - box.width );
      overlay.setRect( 0, 0, box.width, overlay.height );
      overlay.center = box.center;
      brightenHighlight.spacing = darkenHighlight.spacing = overlay.width + ( 2 * HIGHLIGHT_SPACING );
      brightenHighlight.center = darkenHighlight.center = box.center;
      assert && assert( Util.toFixed( this.width, 0 ) === Util.toFixed( options.maxButtonWidth, 0 ) );
    }
    this.mutate( _.omit( options, 'tandem' ) );
  }
  joist.register( 'NavigationBarScreenButton', NavigationBarScreenButton );
  return inherit( Node, NavigationBarScreenButton );
} );
define( 'SCENERY/nodes/Leaf',['require','SCENERY/scenery'],function( require ) {
  'use strict';
  var scenery = require( 'SCENERY/scenery' );
  var Leaf = {
    mixin: function( type ) {
      var proto = type.prototype;
      proto.insertChild = function( index, node ) {
        throw new Error( 'Attempt to insert child into Leaf' );
      };
      proto.removeChildWithIndex = function( node, indexOfChild ) {
        throw new Error( 'Attempt to remove child from Leaf' );
      };
    }
  };
  scenery.register( 'Leaf', Leaf );
  return scenery.Leaf;
} );
define( 'SCENERY/nodes/Spacer',['require','PHET_CORE/inherit','SCENERY/scenery','DOT/Bounds2','SCENERY/nodes/Node','SCENERY/nodes/Leaf'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Leaf = require( 'SCENERY/nodes/Leaf' );
  function Spacer( width, height, options ) {
    assert && assert( typeof width === 'number' && isFinite( width ), 'width should be a finite number' );
    assert && assert( typeof height === 'number' && isFinite( height ), 'height should be a finite number' );
    Node.call( this );
    this.localBounds = new Bounds2( 0, 0, width, height );
    this.mutate( options );
  }
  scenery.register( 'Spacer', Spacer );
  inherit( Node, Spacer );
  Leaf.mixin( Spacer ); // prevent children from being added, since we're overriding local bounds
  return Spacer;
} );
define( 'SCENERY/nodes/VStrut',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Spacer'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Spacer = require( 'SCENERY/nodes/Spacer' );
  function VStrut( height, options ) {
    Spacer.call( this, 0, height, options );
  }
  scenery.register( 'VStrut', VStrut );
  return inherit( Spacer, VStrut );
} );
define("string!JOIST/credits.title",function(){return window.phet.chipper.strings.get("JOIST/credits.title");});
define("string!JOIST/credits.leadDesign",function(){return window.phet.chipper.strings.get("JOIST/credits.leadDesign");});
define("string!JOIST/credits.softwareDevelopment",function(){return window.phet.chipper.strings.get("JOIST/credits.softwareDevelopment");});
define("string!JOIST/credits.team",function(){return window.phet.chipper.strings.get("JOIST/credits.team");});
define("string!JOIST/credits.contributors",function(){return window.phet.chipper.strings.get("JOIST/credits.contributors");});
define("string!JOIST/credits.qualityAssurance",function(){return window.phet.chipper.strings.get("JOIST/credits.qualityAssurance");});
define("string!JOIST/credits.graphicArts",function(){return window.phet.chipper.strings.get("JOIST/credits.graphicArts");});
define("string!JOIST/credits.translation",function(){return window.phet.chipper.strings.get("JOIST/credits.translation");});
define("string!JOIST/credits.thanks",function(){return window.phet.chipper.strings.get("JOIST/credits.thanks");});
define( 'JOIST/CreditsNode',['require','SCENERY/nodes/VBox','SCENERY/nodes/Text','PHET_CORE/inherit','SCENERY_PHET/PhetFont','SCENERY_PHET/MultiLineText','PHETCOMMON/util/StringUtils','SCENERY/nodes/VStrut','SCENERY/nodes/TNode','JOIST/joist','string!JOIST/credits.title','string!JOIST/credits.leadDesign','string!JOIST/credits.softwareDevelopment','string!JOIST/credits.team','string!JOIST/credits.contributors','string!JOIST/credits.qualityAssurance','string!JOIST/credits.graphicArts','string!JOIST/credits.translation','string!JOIST/credits.thanks'],function( require ) {
  'use strict';
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var joist = require( 'JOIST/joist' );
  var creditsTitleString = require( 'string!JOIST/credits.title' );
  var creditsLeadDesignString = require( 'string!JOIST/credits.leadDesign' );
  var creditsSoftwareDevelopmentString = require( 'string!JOIST/credits.softwareDevelopment' );
  var creditsTeamString = require( 'string!JOIST/credits.team' );
  var creditsContributorsString = require( 'string!JOIST/credits.contributors' );
  var creditsQualityAssuranceString = require( 'string!JOIST/credits.qualityAssurance' );
  var creditsGraphicArtsString = require( 'string!JOIST/credits.graphicArts' );
  var creditsTranslationString = require( 'string!JOIST/credits.translation' );
  var creditsThanksString = require( 'string!JOIST/credits.thanks' );
  function CreditsNode( credits, tandem, options ) {
    var titleFont = new PhetFont( { size: 14, weight: 'bold' } );
    var font = new PhetFont( 12 );
    var multiLineTextOptions = { font: font, align: 'left' };
    var children = [];
    var addTandemToOptions = function( tandemName ) {
      return _.extend( {
        tandem: tandem.createTandem(tandemName),
        phetioType: TNode
      }, multiLineTextOptions );
    };
    children.push( new Text( creditsTitleString, {
      font: titleFont,
      tagName: 'h2',
      accessibleLabel: creditsTitleString
    } ) );
    if ( credits.leadDesign ) {
      children.push( new MultiLineText( StringUtils.format( creditsLeadDesignString, '\u202a' + credits.leadDesign + '\u202c' ), addTandemToOptions('creditsLeadDesignString') ) );
    }
    if ( credits.softwareDevelopment ) {
      children.push( new MultiLineText( StringUtils.format( creditsSoftwareDevelopmentString, '\u202a' + credits.softwareDevelopment + '\u202c' ), addTandemToOptions('creditsSoftwareDevelopmentString') ) );
    }
    if ( credits.team ) {
      children.push( new MultiLineText( StringUtils.format( creditsTeamString, '\u202a' + credits.team + '\u202c' ), addTandemToOptions('creditsTeamString') ) );
    }
    if ( credits.contributors ) {
      children.push( new MultiLineText( StringUtils.format( creditsContributorsString, '\u202a' + credits.contributors + '\u202c' ), addTandemToOptions('creditsContributorsString') ) );
    }
    if ( credits.qualityAssurance ) {
      children.push( new MultiLineText( StringUtils.format( creditsQualityAssuranceString, '\u202a' + credits.qualityAssurance + '\u202c' ), addTandemToOptions('creditsQualityAssuranceString') ) );
    }
    if ( credits.graphicArts ) {
      children.push( new MultiLineText( StringUtils.format( creditsGraphicArtsString, '\u202a' + credits.graphicArts + '\u202c' ), addTandemToOptions('creditsGraphicArtsString') ) );
    }
    if ( credits.translation ) {
      if ( children.length > 0 ) { children.push( new VStrut( 10 ) ); }
      children.push( new Text( creditsTranslationString, { font: titleFont, tagName: 'h2', accessibleLabel: creditsTranslationString } ) );
      children.push( new MultiLineText( credits.translation, addTandemToOptions('creditsTranslationString') ) );
    }
    if ( credits.thanks ) {
      if ( children.length > 0 ) { children.push( new VStrut( 10 ) ); }
      children.push( new Text( creditsThanksString, { font: titleFont, tagName: 'h2', accessibleLabel: creditsThanksString } ) );
      children.push( new MultiLineText( credits.thanks, addTandemToOptions('creditsThanksString') ) );
    }
    VBox.call( this, _.extend( {
      align: 'left',
      spacing: 1,
      children: children
    }, options ) );
    this.disposeCreditsNode = function() {
      children.forEach( function( child ) {
        child.dispose && child.dispose();
      } );
    };
  }
  joist.register( 'CreditsNode', CreditsNode );
  return inherit( VBox, CreditsNode, {
    dispose: function() {
      this.disposeCreditsNode();
      VBox.prototype.dispose.call( this );
    }
  } );
} );
define( 'SCENERY_PHET/SpinningIndicatorNode',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/nodes/Circle','SCENERY/util/Color','SCENERY_PHET/sceneryPhet','TANDEM/Tandem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Circle = require( 'SCENERY/nodes/Circle' );
  var Color = require( 'SCENERY/util/Color' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Tandem = require( 'TANDEM/Tandem' );
  function SpinningIndicatorNode( options ) {
    Tandem.indicateUninstrumentedCode();
    options = _.extend( {
      indicatorSize: 15, // {number} - The width/height taken up by the indicator.
      indicatorSpeed: 1, // {number} - A multiplier for how fast/slow the indicator will spin.
      elementFactory: SpinningIndicatorNode.rectangleFactory, // {function( options ) => {Node}} - To create the elements
      elementQuantity: 16, // {number} - How many elements should exist
      activeColor: 'rgba(0,0,0,1)', // {string|Color} - The active "mostly visible" color at the lead.
      inactiveColor: 'rgba(0,0,0,0.15)' // {string|Color} - The inactive "mostly invisible" color at the tail.
    }, options );
    this.options = options;
    Node.call( this, options );
    this.indicatorRotation = Math.PI * 2; // @private Current angle of rotation (starts at 2pi so our modulo opreation is safe below)
    this.activeColor = new Color( options.activeColor ); // @private
    this.inactiveColor = new Color( options.inactiveColor ); // @private
    this.angleDelta = 2 * Math.PI / options.elementQuantity;
    this.elements = [];
    var angle = 0;
    for ( var i = 0; i < options.elementQuantity; i++ ) {
      var element = options.elementFactory( this.options );
      element.right = options.indicatorSize / 2;
      element.centerY = 0;
      element.rotate( angle, true );
      angle += this.angleDelta;
      this.elements.push( element );
      this.addChild( element );
    }
    this.step( 0 ); // initialize colors
  }
  sceneryPhet.register( 'SpinningIndicatorNode', SpinningIndicatorNode );
  return inherit( Node, SpinningIndicatorNode, {
    step: function( dt ) {
      this.indicatorRotation += dt * 10.0 * this.options.indicatorSpeed;
      var angle = this.indicatorRotation;
      for ( var i = 0; i < this.elements.length; i++ ) {
        var ratio = Math.pow( ( angle / ( 2 * Math.PI ) ) % 1, 0.5 );
        if ( ratio < 0.2 ) {
          ratio = 1 - ratio * 5;
        }
        else {
          ratio = ( ratio - 0.2 ) * 10 / 8;
        }
        var red = ratio * this.inactiveColor.red + ( 1 - ratio ) * this.activeColor.red;
        var green = ratio * this.inactiveColor.green + ( 1 - ratio ) * this.activeColor.green;
        var blue = ratio * this.inactiveColor.blue + ( 1 - ratio ) * this.activeColor.blue;
        var alpha = ratio * this.inactiveColor.alpha + ( 1 - ratio ) * this.activeColor.alpha;
        this.elements[i].fill = new Color( red, green, blue, alpha );
        angle -= this.angleDelta;
      }
    }
  }, {
    rectangleFactory: function( options ) {
      return new Rectangle( 0, 0, options.indicatorSize * 0.175, 1.2 * options.indicatorSize / options.elementQuantity );
    },
    circleFactory: function( options ) {
      return new Circle( 0.8 * options.indicatorSize / options.elementQuantity );
    }
  } );
} );
define( 'JOIST/packageJSON',['require','JOIST/joist','text!REPOSITORY/package.json'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var packageString = require( 'text!REPOSITORY/package.json' );
  var packageJSON = JSON.parse( packageString );
  packageJSON.version = window.getVersionForBrand( phet.chipper.brand, packageJSON.version );
  joist.register( 'packageJSON', packageJSON );
  return packageJSON;
} );
define( 'JOIST/SimVersion',['require','PHET_CORE/inherit','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  function SimVersion( version ) {
    assert && assert( version.major !== undefined );
    assert && assert( version.minor !== undefined );
    assert && assert( version.maintenance !== undefined );
    this.major = version.major; // @public - {number} major - Major version number
    this.minor = version.minor; // @public - {number} minor - Major version number
    this.maintenance = version.maintenance; // @public - {number} maintenance - Major version number
    this.suffix = version.suffix; // @public - {string} [suffix] - Optional suffix (like 'dev.3')
    this.buildTimestamp = version.buildTimestamp; // @public - {string} [buildTimestamp] - Optional build timestamp,
  }
  joist.register( 'SimVersion', SimVersion );
  return inherit( Object, SimVersion, {
    compare: function( version ) {
      if ( this.major < version.major ) { return -1; }
      if ( this.major > version.major ) { return 1; }
      if ( this.minor < version.minor ) { return -1; }
      if ( this.minor > version.minor ) { return 1; }
      if ( this.maintenance < version.maintenance ) { return -1; }
      if ( this.maintenance > version.maintenance ) { return 1; }
      return 0; // equal
    },
    get isSimNotPublished() {
      return this.major < 1 || // e.g. 0.0.0-dev.1
             ( this.major === 1 && // e.g. 1.0.0-dev.1
               this.minor === 0 &&
               this.maintenance === 0 &&
               this.suffix );
    },
    toString: function() {
      return this.major + '.' + this.minor + '.' + this.maintenance + ( this.suffix ? '-' + this.suffix : '' );
    }
  }, {
    parse: function( versionString, buildTimestamp ) {
      var matches = versionString.match( /(\d+)\.(\d+)\.(\d+)(-(.+))?/ );
      if ( !matches ) {
        throw new Error( 'could not parse version: ' + versionString );
      }
      return new SimVersion( {
        major: parseInt( matches[ 1 ], 10 ),
        minor: parseInt( matches[ 2 ], 10 ),
        maintenance: parseInt( matches[ 3 ], 10 ),
        suffix: matches[ 5 ],
        buildTimestamp: buildTimestamp
      } );
    }
  } );
} );
define( 'BRAND/../../js/brand',['require','PHET_CORE/Namespace'],function( require ) {
  'use strict';
  var Namespace = require( 'PHET_CORE/Namespace' );
  return new Namespace( 'brand' );
} );
define("string!JOIST/termsPrivacyAndLicensing",function(){return window.phet.chipper.strings.get("JOIST/termsPrivacyAndLicensing");});
define("string!JOIST/translation.credits.link",function(){return window.phet.chipper.strings.get("JOIST/translation.credits.link");});
define("string!JOIST/thirdParty.credits.link",function(){return window.phet.chipper.strings.get("JOIST/thirdParty.credits.link");});
define( 'BRAND/Brand',['require','BRAND/../../js/brand','string!JOIST/termsPrivacyAndLicensing','string!JOIST/translation.credits.link','string!JOIST/thirdParty.credits.link'],function( require ) {
  'use strict';
  var brand = require( 'BRAND/../../js/brand' );
  var termsPrivacyAndLicensingString = require( 'string!JOIST/termsPrivacyAndLicensing' );
  var translationCreditsLinkString = require( 'string!JOIST/translation.credits.link' );
  var thirdPartyCreditsLinkString = require( 'string!JOIST/thirdParty.credits.link' );
  var Brand = {
    id: 'phet',
    name: 'CLB Sáng tạo trẻ \u2122 THPT Nguyễn Trường Tộ', // no i18n
    copyright: 'Copyright © 2024-{{year}} CLB Sáng tạo trẻ', // no i18n
    isPhetApp: phet.chipper.queryParameters[ 'phet-app' ] || phet.chipper.queryParameters[ 'phet-android-app' ],
    getLinks: function( simName, locale ) {
    }
  };
  brand.register( 'Brand', Brand );
  return Brand;
} );
define( 'JOIST/UpdateCheck',['require','PHET_CORE/inherit','AXON/Property','JOIST/packageJSON','JOIST/SimVersion','BRAND/Brand','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var packageJSON = require( 'JOIST/packageJSON' ); // parse name/version out of the package.json
  var SimVersion = require( 'JOIST/SimVersion' );
  var Brand = require( 'BRAND/Brand' );
  var joist = require( 'JOIST/joist' );
  var simName = packageJSON.name;
  var simVersion = SimVersion.parse( packageJSON.version, phet.chipper.buildTimestamp );
  var requestProtocolString = ( 'https:' === document.location.protocol ? 'https:' : 'http:' );
  function UpdateCheck() {
    this.stateProperty = new Property( 'unchecked', {
      validValues: [
        'up-to-date',  // Simulation version is equal to or greater than the currently published version.
        'out-of-date', // Simulation version is less than currently published version (or equal but has a suffix)
        'checking',    // Request to server sent out, has not processed reply yet.
        'offline',     // Last attempt to check failed, most likely offline
        'unchecked'    // No attempt as been made to check the version against the latest online.
      ]
    } );
    this.latestVersionProperty = new Property( null );
    this.ourVersion = simVersion; // @public (joist-internal) {SimVersion} version of the sim that is running
    this.timeoutCallback = this.timeout.bind( this ); // @public (joist-internal)
  }
  inherit( Object, UpdateCheck, {
    areUpdatesChecked: Brand.id === 'phet' && !Brand.isPhetApp && phet.chipper.queryParameters.yotta,
    updateURL: 'http://phet.colorado.edu/html-sim-update' +
               '?simulation=' + encodeURIComponent( simName ) +
               '&version=' + encodeURIComponent( simVersion.toString() ) +
               '&buildTimestamp=' + encodeURIComponent( '' + phet.chipper.buildTimestamp ),
    timeoutId: -1,
    timeoutMilliseconds: 15000,
    clearTimeout: function() {
      window.clearTimeout( this.timeoutId );
    },
    setTimeout: function() {
      this.timeoutId = window.setTimeout( this.timeoutCallback, this.timeoutMilliseconds );
    },
    resetTimeout: function() {
      if ( this.stateProperty.value === 'checking' ) {
        this.clearTimeout();
        this.setTimeout();
      }
    },
    timeout: function() {
      this.stateProperty.value = 'offline';
    },
    check: function() {
      var self = this;
      if ( !this.areUpdatesChecked || ( self.stateProperty.value !== 'unchecked' && self.stateProperty.value !== 'offline' ) ) {
        return;
      }
      if ( this.ourVersion.isSimNotPublished ) {
        self.stateProperty.value = 'up-to-date';
        return;
      }
      var req = new XMLHttpRequest();
      if ( 'withCredentials' in req ) {
        self.stateProperty.value = 'checking';
        self.setTimeout();
        req.onload = function() {
          self.clearTimeout();
          try {
            var data = JSON.parse( req.responseText );
            if ( data.error ) {
              console.log( 'Update check failure: ' + data.error );
              self.stateProperty.value = 'offline';
            }
            else {
              if ( self.updateURL ) {
                self.updateURL = data.updateURL;
              }
              self.latestVersion = SimVersion.parse( data.latestVersion, data.buildTimestamp );
              if ( data.state === 'out-of-date' || data.state === 'up-to-date' ) {
                self.stateProperty.value = data.state;
              }
              else {
                console.log( 'Failed to get proper state: ' + data.state );
                self.stateProperty.value = 'offline';
              }
            }
          }
          catch( e ) {
            self.stateProperty.value = 'offline';
          }
        };
        req.onerror = function() {
          self.clearTimeout();
          self.stateProperty.value = 'offline';
        };
        req.open( 'post', requestProtocolString + '//phet.colorado.edu/services/check-html-updates', true ); // enable CORS
        req.send( JSON.stringify( {
          api: '1.0',
          simulation: simName,
          locale: phet.joist.sim.locale,
          currentVersion: self.ourVersion.toString(),
          buildTimestamp: phet.chipper.buildTimestamp
        } ) );
      }
    }
  } );
  var singleton = new UpdateCheck();
  joist.register( 'UpdateCheck', singleton );
  return singleton;
} );
define( 'JOIST/LinkText',['require','PHET_CORE/inherit','SCENERY/nodes/Text','SCENERY/input/ButtonListener','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Text = require( 'SCENERY/nodes/Text' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var joist = require( 'JOIST/joist' );
  function LinkText( text, url, options ) {
    options = _.extend( {
      handleEvent: false // whether the up in the click event should be handled, e.g. to prevent the About dialog closing.
    }, options );
    Text.call( this, text, _.extend( {
      fill: 'rgb(27,0,241)', // blue, like a typical hypertext link
      cursor: 'pointer',
      tagName: 'a',
      accessibleLabel: text
    }, options ) );
    this.addInputListener( new ButtonListener( {
      fire: function( event ) {
        options.handleEvent && event.handle();
        if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
          var newWindow = window.open( url, '_blank' ); // open in a new window/tab
          newWindow.focus();
        }
      }
    } ) );
    this.setAccessibleAttribute( 'href', url );
    this.setAccessibleAttribute( 'target', '_blank' );
  }
  joist.register( 'LinkText', LinkText );
  return inherit( Text, LinkText );
} );
define("string!JOIST/updates.upToDate",function(){return window.phet.chipper.strings.get("JOIST/updates.upToDate");});
define("string!JOIST/updates.outOfDate",function(){return window.phet.chipper.strings.get("JOIST/updates.outOfDate");});
define("string!JOIST/updates.checking",function(){return window.phet.chipper.strings.get("JOIST/updates.checking");});
define("string!JOIST/updates.offline",function(){return window.phet.chipper.strings.get("JOIST/updates.offline");});
define("string!JOIST/updates.newVersionAvailable",function(){return window.phet.chipper.strings.get("JOIST/updates.newVersionAvailable");});
define("string!JOIST/updates.yourCurrentVersion",function(){return window.phet.chipper.strings.get("JOIST/updates.yourCurrentVersion");});
define("string!JOIST/updates.getUpdate",function(){return window.phet.chipper.strings.get("JOIST/updates.getUpdate");});
define("string!JOIST/updates.noThanks",function(){return window.phet.chipper.strings.get("JOIST/updates.noThanks");});
define( 'JOIST/UpdateNodes',['require','SCENERY/nodes/HBox','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY/nodes/Rectangle','PHETCOMMON/util/StringUtils','SCENERY_PHET/PhetFont','SUN/FontAwesomeNode','SUN/buttons/TextPushButton','SCENERY_PHET/SpinningIndicatorNode','SCENERY/nodes/VStrut','JOIST/UpdateCheck','JOIST/LinkText','JOIST/joist','string!JOIST/updates.upToDate','string!JOIST/updates.outOfDate','string!JOIST/updates.checking','string!JOIST/updates.offline','string!JOIST/updates.newVersionAvailable','string!JOIST/updates.yourCurrentVersion','string!JOIST/updates.getUpdate','string!JOIST/updates.noThanks'],function( require ) {
  'use strict';
  var HBox = require( 'SCENERY/nodes/HBox' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var TextPushButton = require( 'SUN/buttons/TextPushButton' );
  var SpinningIndicatorNode = require( 'SCENERY_PHET/SpinningIndicatorNode' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var LinkText = require( 'JOIST/LinkText' );
  var joist = require( 'JOIST/joist' );
  var updatesUpToDateString = require( 'string!JOIST/updates.upToDate' );
  var updatesOutOfDateString = require( 'string!JOIST/updates.outOfDate' );
  var updatesCheckingString = require( 'string!JOIST/updates.checking' );
  var updatesOfflineString = require( 'string!JOIST/updates.offline' );
  var updatesNewVersionAvailableString = require( 'string!JOIST/updates.newVersionAvailable' );
  var updatesYourCurrentVersionString = require( 'string!JOIST/updates.yourCurrentVersion' );
  var updatesGetUpdateString = require( 'string!JOIST/updates.getUpdate' );
  var updatesNoThanksString = require( 'string!JOIST/updates.noThanks' );
  var updateTextFont = new PhetFont( 14 );
  var MAX_WIDTH = 550;
  var UpdateNodes = {
    createCheckingNode: function( options ) {
      var spinningIndicatorNode = new SpinningIndicatorNode( { indicatorSize: options.big ? 24 : 18 } );
      var checkingNode = new HBox( _.extend( {
        spacing: options.big ? 10 : 8,
        maxWidth: MAX_WIDTH,
        children: [
          spinningIndicatorNode,
          new Text( updatesCheckingString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],
        tagName: 'p',
        accessibleLabel: updatesCheckingString
      }, options ) );
      checkingNode.step = function( dt ) {
        if ( UpdateCheck.stateProperty === 'checking' ) {
          spinningIndicatorNode.step( dt );
        }
      };
      checkingNode.stepListener = checkingNode.step.bind( checkingNode );
      return checkingNode;
    },
    createUpToDateNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 8,
        maxWidth: MAX_WIDTH,
        children: [
          new Rectangle( 0, 0, 20, 20, 5, 5, { fill: '#5c3', scale: options.big ? 1.2 : 1, children: [
            new FontAwesomeNode( 'check', { fill: '#fff', scale: 0.38, centerX: 10, centerY: 10 } )
          ] } ),
          new Text( updatesUpToDateString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],
        tagName: 'p',
        accessibleLabel: updatesUpToDateString
      }, options ) );
    },
    createOutOfDateAboutNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 8,
        cursor: 'pointer',
        maxWidth: MAX_WIDTH,
        children: [
          new FontAwesomeNode( 'warning_sign', { fill: '#E87600', scale: 0.5 } ), // "safety orange", according to Wikipedia
          new LinkText( updatesOutOfDateString, UpdateCheck.updateURL, { font: updateTextFont } )
        ],
        tagName: 'div'
      }, options ) );
    },
    createOutOfDateDialogNode: function( dialog, ourVersionString, latestVersionString, options ) {
      return new VBox( _.extend( {
        spacing: 15,
        maxWidth: MAX_WIDTH,
        children: [
          new VBox( { spacing: 5, align: 'left', children: [
            new Text( StringUtils.format( updatesNewVersionAvailableString, latestVersionString ), {
              font: new PhetFont( 16 ), fontWeight: 'bold'
            } ),
            new Text( StringUtils.format( updatesYourCurrentVersionString, ourVersionString ), {
              font: updateTextFont
            } )
          ] } ),
          new HBox( { spacing: 25, children: [
            new TextPushButton( updatesGetUpdateString, { baseColor: '#6f6', font: updateTextFont, listener: function() {
              if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
                var newWindow = window.open( UpdateCheck.updateURL, '_blank' ); // open in a new window/tab
                newWindow && newWindow.focus();
              }
            } } ),
            new TextPushButton( updatesNoThanksString, { baseColor: '#ddd', font: updateTextFont, listener: function() {
              dialog.hide();
            } } )
          ] } )
        ]
      }, options ) );
    },
    createOfflineNode: function( options ) {
      return new HBox( _.extend( {
        spacing: 0,
        maxWidth: MAX_WIDTH,
        children: [
          new VStrut( 20 ), // spacer to match layout of other nodes
          new Text( updatesOfflineString, { font: new PhetFont( options.big ? 16 : 14 ), fontWeight: options.big ? 'bold' : 'normal' } )
        ],
        tagName: 'p',
        accessibleLabel: updatesOfflineString
      }, options ) );
    }
  };
  joist.register( 'UpdateNodes', UpdateNodes );
  return UpdateNodes;
} );
define("string!JOIST/versionPattern",function(){return window.phet.chipper.strings.get("JOIST/versionPattern");});
define( 'JOIST/AboutDialog',['require','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/input/ButtonListener','SCENERY_PHET/PhetFont','PHETCOMMON/util/StringUtils','SCENERY/nodes/VStrut','JOIST/Dialog','PHET_CORE/Timer','JOIST/CreditsNode','JOIST/UpdateNodes','JOIST/UpdateCheck','JOIST/LinkText','SCENERY_PHET/RichText','SCENERY_PHET/MultiLineText','JOIST/packageJSON','JOIST/joist','JOIST/TDialog','SCENERY/nodes/TNode','string!JOIST/versionPattern'],function( require ) {
  'use strict';
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var VStrut = require( 'SCENERY/nodes/VStrut' );
  var Dialog = require( 'JOIST/Dialog' );
  var Timer = require( 'PHET_CORE/Timer' );
  var CreditsNode = require( 'JOIST/CreditsNode' );
  var UpdateNodes = require( 'JOIST/UpdateNodes' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var LinkText = require( 'JOIST/LinkText' );
  var RichText = require( 'SCENERY_PHET/RichText' );
  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );
  var packageJSON = require( 'JOIST/packageJSON' );
  var joist = require( 'JOIST/joist' );
  var TDialog = require( 'JOIST/TDialog' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var versionPatternString = require( 'string!JOIST/versionPattern' );
  var MAX_WIDTH = 550;
  function AboutDialog( name, version, credits, Brand, locale, phetButton, tandem ) {
    var self = this;
    this.aboutDialogTandem = tandem;
    var children = [];
    var titleText = new Text( name, {
      font: new PhetFont( 28 ),
      maxWidth: MAX_WIDTH,
      tagName: 'h1',
      accessibleLabel: name
    } );
    children.push( titleText );
    var versionString = StringUtils.format( versionPatternString, version );
    children.push( new Text( versionString, {
      font: new PhetFont( 20 ),
      maxWidth: MAX_WIDTH,
      tagName: 'p',
      accessibleLabel: versionString
    } ) );
    if ( phet.chipper.buildTimestamp ) {
      children.push( new Text( phet.chipper.buildTimestamp, {
        font: new PhetFont( 13 ),
        maxWidth: MAX_WIDTH,
        tagName: 'p',
        accessibleLabel: phet.chipper.buildTimestamp
      } ) );
    }
    if ( UpdateCheck.areUpdatesChecked ) {
      var positionOptions = { left: 0, top: 0 };
      var checkingNode = UpdateNodes.createCheckingNode( positionOptions );
      var upToDateNode = UpdateNodes.createUpToDateNode( positionOptions );
      var outOfDateNode = UpdateNodes.createOutOfDateAboutNode( positionOptions );
      var offlineNode = UpdateNodes.createOfflineNode( positionOptions );
      this.updateStepListener = checkingNode.stepListener;
      this.updateVisibilityListener = function( state ) {
        checkingNode.visible = state === 'checking';
        upToDateNode.visible = state === 'up-to-date';
        outOfDateNode.visible = state === 'out-of-date';
        offlineNode.visible = state === 'offline';
        checkingNode.accessibleContentDisplayed = checkingNode.visible;
        upToDateNode.accessibleContentDisplayed = upToDateNode.visible;
        outOfDateNode.accessibleContentDisplayed = outOfDateNode.visible;
        offlineNode.accessibleContentDisplayed = offlineNode.visible;
      };
      children.push( new Node( {
        children: [
          checkingNode,
          upToDateNode,
          outOfDateNode,
          offlineNode
        ],
        maxWidth: MAX_WIDTH
      } ) );
    }
    children.push( new VStrut( 15 ) );
    if ( Brand.name ) {
      children.push( new RichText( Brand.name, {
        font: new PhetFont( 16 ),
        supScale: 0.5,
        supYOffset: 2,
        maxWidth: MAX_WIDTH,
        tagName: 'h2',
        accessibleLabel: Brand.name
      } ) );
    }
    if ( Brand.copyright ) {
      var year = phet.chipper.buildTimestamp ? // defined for built versions
                 phet.chipper.buildTimestamp.split( '-' )[ 0 ] : // e.g. "2017-04-20 19:04:59 UTC" -> "2017"
                 new Date().getFullYear(); // in requirejs mode
      var copyright = StringUtils.fillIn( Brand.copyright, { year: year } );
      children.push( new Text( copyright, {
        font: new PhetFont( 12 ), maxWidth: MAX_WIDTH,
        tagName: 'p',
        accessibleLabel: copyright
      } ) );
    }
    if ( Brand.additionalLicenseStatement ) {
      this.additionalLicenseStatement = new MultiLineText( Brand.additionalLicenseStatement, {
          font: new PhetFont( 10 ),
          fill: 'gray',
          align: 'left',
          maxWidth: MAX_WIDTH,
          tandem: tandem.createTandem( 'additionalLicenseStatement' ),
          phetioType: TNode
        }
      );
      children.push( this.additionalLicenseStatement );
    }
    if ( credits && ( Brand.id === 'phet' || Brand.id === 'phet-io' ) ) {
      children.push( new VStrut( 15 ) );
      this.creditsNode = new CreditsNode( credits, tandem.createTandem( 'creditsNode' ), {
        maxWidth: MAX_WIDTH
      } );
      children.push( this.creditsNode );
    }
    var links = Brand.getLinks( packageJSON.name, locale );
    if ( links && links.length > 0 ) {
      children.push( new VStrut( 15 ) );
      for ( var i = 0; i < links.length; i++ ) {
        var link = links[ i ];
        children.push( new LinkText( link.text, link.url, {
          font: new PhetFont( 14 ),
          maxWidth: MAX_WIDTH
        } ) );
      }
    }
    var content = new VBox( {
      align: 'left',
      spacing: 5,
      children: children,
      tagName: 'div'
    } );
    Dialog.call( this, content, {
      modal: true,
      hasCloseButton: true,
      tandem: tandem.createSupertypeTandem(),
      focusOnCloseNode: phetButton,
      xMargin: 25,
      yMargin: 25
    } );
    titleText.setAriaLabelsNode( this );
    var closeListener = new ButtonListener( {
      fire: self.hide.bind( self )
    } );
    this.addInputListener( closeListener );
    tandem.addInstance( this, TDialog );
    this.disposeAboutDialog = function() {
      this.removeInputListener( closeListener );
      this.aboutDialogTandem.removeInstance( this );
      this.creditsNode && this.creditsNode.dispose();
      this.additionalLicenseStatement && this.additionalLicenseStatement.dispose();
    };
  }
  joist.register( 'AboutDialog', AboutDialog );
  return inherit( Dialog, AboutDialog, {
    show: function() {
      if ( UpdateCheck.areUpdatesChecked ) {
        UpdateCheck.resetTimeout();
        if ( UpdateCheck.stateProperty.value === 'offline' || UpdateCheck.stateProperty.value === 'unchecked' ) {
          UpdateCheck.check();
        }
        Timer.addStepListener( this.updateStepListener );
        UpdateCheck.stateProperty.link( this.updateVisibilityListener );
      }
      Dialog.prototype.show.call( this );
    },
    hide: function() {
      if ( this.isShowing ) {
        Dialog.prototype.hide.call( this );
        if ( UpdateCheck.areUpdatesChecked ) {
          UpdateCheck.stateProperty.unlink( this.updateVisibilityListener );
          Timer.removeStepListener( this.updateStepListener );
        }
      }
    },
    dispose: function() {
      this.disposeAboutDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/UpdateDialog',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/input/ButtonListener','JOIST/Dialog','PHET_CORE/Timer','JOIST/UpdateNodes','JOIST/UpdateCheck','JOIST/joist'],function( require ) {
  'use strict';
  var Node = require( 'SCENERY/nodes/Node' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Dialog = require( 'JOIST/Dialog' );
  var Timer = require( 'PHET_CORE/Timer' );
  var UpdateNodes = require( 'JOIST/UpdateNodes' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var joist = require( 'JOIST/joist' );
  function UpdateDialog( phetButton ) {
    assert && assert( UpdateCheck.areUpdatesChecked,
      'Updates need to be checked for UpdateDialog to be created' );
    var self = this;
    var positionOptions = { centerX: 0, centerY: 0, big: true };
    var checkingNode = UpdateNodes.createCheckingNode( positionOptions );
    var upToDateNode = UpdateNodes.createUpToDateNode( positionOptions );
    var outOfDateNode = new Node();
    var offlineNode = UpdateNodes.createOfflineNode( positionOptions );
    function updateOutOfDateNode() {
      var latestVersionString = UpdateCheck.latestVersion ? UpdateCheck.latestVersion.toString() : 'x.x.xx';
      var ourVersionString = UpdateCheck.ourVersion.toString();
      outOfDateNode.tagName = 'div';
      outOfDateNode.children = [
        UpdateNodes.createOutOfDateDialogNode( self, ourVersionString, latestVersionString, positionOptions )
      ];
    }
    updateOutOfDateNode();
    this.updateStepListener = checkingNode.stepListener;
    this.updateVisibilityListener = function( state ) {
      if ( state === 'out-of-date' ) {
        updateOutOfDateNode();
      }
      checkingNode.visible = state === 'checking';
      upToDateNode.visible = state === 'up-to-date';
      outOfDateNode.visible = state === 'out-of-date';
      offlineNode.visible = state === 'offline';
      checkingNode.accessibleContentDisplayed = checkingNode.visible;
      upToDateNode.accessibleContentDisplayed = upToDateNode.visible;
      outOfDateNode.accessibleContentDisplayed = outOfDateNode.visible;
      offlineNode.accessibleContentDisplayed = offlineNode.visible;
    };
    var content = new Node( {
      children: [
        checkingNode,
        upToDateNode,
        outOfDateNode,
        offlineNode
      ],
      tagName: 'div'
    } );
    Dialog.call( this, content, {
      modal: true,
      hasCloseButton: true,
      xMargin: 30,
      yMargin: 30,
      focusOnCloseNode: phetButton
    } );
    var buttonListener = new ButtonListener( {
      fire: self.hide.bind( self )
    } );
    this.addInputListener( buttonListener );
    this.disposeUpdateDialog = function() {
      self.removeInputListener( buttonListener );
    };
  }
  joist.register( 'UpdateDialog', UpdateDialog );
  return inherit( Dialog, UpdateDialog, {
    show: function() {
      if ( UpdateCheck.areUpdatesChecked ) {
        UpdateCheck.resetTimeout();
        if ( UpdateCheck.stateProperty.value === 'offline' || UpdateCheck.stateProperty === 'unchecked' ) {
          UpdateCheck.check();
        }
        Timer.addStepListener( this.updateStepListener );
        UpdateCheck.stateProperty.link( this.updateVisibilityListener );
      }
      Dialog.prototype.show.call( this );
    },
    hide: function() {
      if ( this.isShowing ) {
        Dialog.prototype.hide.call( this );
        if ( UpdateCheck.areUpdatesChecked ) {
          UpdateCheck.stateProperty.unlink( this.updateVisibilityListener );
          Timer.removeStepListener( this.updateStepListener );
        }
      }
    },
    dispose: function() {
      this.disposeUpdateDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );
define( 'SUN/TMenuItem',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SUN/sun','SCENERY/nodes/TNode','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sun = require( 'SUN/sun' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TMenuItem( menuItem, phetioID ) {
    assertInstanceOf( menuItem, phet.scenery.Node );
    TNode.call( this, menuItem, phetioID );
    toEventOnEmit(
      menuItem.startedCallbacksForFiredEmitter,
      menuItem.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }
  phetioInherit( TNode, 'TMenuItem', TMenuItem, {}, {
    documentation: 'The item buttons shown in a popup menu',
    events: [ 'fired' ]
  } );
  sun.register( 'TMenuItem', TMenuItem );
  return TMenuItem;
} );
define( 'SUN/MenuItem',['require','PHET_CORE/inherit','SUN/sun','SUN/FontAwesomeNode','AXON/Emitter','SCENERY_PHET/PhetFont','SCENERY/input/ButtonListener','SCENERY/nodes/Rectangle','SCENERY/nodes/Node','SCENERY/nodes/Text','TANDEM/Tandem','SCENERY/accessibility/AccessibilityUtil','SUN/TMenuItem'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var sun = require( 'SUN/sun' );
  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );
  var Emitter = require( 'AXON/Emitter' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Tandem = require( 'TANDEM/Tandem' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var TMenuItem = require( 'SUN/TMenuItem' );
  var CHECK_MARK_NODE = new FontAwesomeNode( 'check', {
    fill: 'rgba(0,0,0,0.7)',
    scale: 0.4
  } );
  var FONT_SIZE = 18;
  var HIGHLIGHT_COLOR = '#a6d2f4';
  var MAX_ITEM_WIDTH = 400;
  var CHECK_PADDING = 2;  // padding between the check and text
  var CHECK_OFFSET = CHECK_MARK_NODE.width + CHECK_PADDING; // offset that includes the check mark's width and padding
  var LEFT_X_MARGIN = 2;
  var RIGHT_X_MARGIN = 5;
  var Y_MARGIN = 3;
  var CORNER_RADIUS = 5;
  function MenuItem( width, height, closeCallback, text, callback, options ) {
    var self = this;
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      textFill: 'black',
      tagName: 'button',
      focusAfterCallback: false // whether or not next focusable element should receive focus after the callback
    }, options );
    Node.call( this );
    var textNode = new Text( text, {
      font: new PhetFont( FONT_SIZE ),
      fill: options.textFill,
      maxWidth: MAX_ITEM_WIDTH,
      tandem: options.tandem.createTandem( 'textNode' )
    } );
    var highlight = new Rectangle( 0, 0, width + LEFT_X_MARGIN + RIGHT_X_MARGIN + CHECK_OFFSET,
      height + Y_MARGIN + Y_MARGIN, CORNER_RADIUS, CORNER_RADIUS );
    this.addChild( highlight );
    this.addChild( textNode );
    textNode.left = highlight.left + LEFT_X_MARGIN + CHECK_OFFSET; // text is left aligned
    textNode.centerY = highlight.centerY;
    this.startedCallbacksForFiredEmitter = new Emitter();
    this.endedCallbacksForFiredEmitter = new Emitter();
    this.addInputListener( {
      enter: function() { highlight.fill = HIGHLIGHT_COLOR; },
      exit: function() { highlight.fill = null; }
    } );
    var fire = function( event ) {
      self.startedCallbacksForFiredEmitter.emit();
      closeCallback( event );
      callback( event );
      self.endedCallbacksForFiredEmitter.emit();
    };
    this.addInputListener( new ButtonListener( {
      fire: fire
    } ) );
    this.separatorBefore = options.separatorBefore;
    var checkListener;
    if ( options.checkedProperty ) {
      var checkMarkWrapper = new Node( {
        children: [ CHECK_MARK_NODE ],
        right: textNode.left - CHECK_PADDING,
        centerY: textNode.centerY
      } );
      checkListener = function( isChecked ) {
        checkMarkWrapper.visible = isChecked;
      };
      options.checkedProperty.link( checkListener );
      this.addChild( checkMarkWrapper );
    }
    var clickListener = this.addAccessibleInputListener( {
      click: function( event ) {
        fire();
        var rootElement = phet.joist.display.accessibleDOMElement;
        options.focusAfterCallback && AccessibilityUtil.getNextFocusable( rootElement ).focus();
      }
    } );
    this.mutate( {
      cursor: 'pointer',
      tandem: options.tandem,
      phetioType: TMenuItem,
      parentContainerTagName: 'li',
      parentContainerAriaRole: 'none', // this is required for JAWS to handle focus correctly, see https://github.com/phetsims/john-travoltage/issues/225
      accessibleLabel: text,
      ariaRole: 'menuitem',
      tagName: options.tagName
    } );
    this.disposeMenuItem = function() {
      if ( options.checkedProperty ) {
        options.checkedProperty.unlink( checkListener );
      }
      self.removeAccessibleInputListener( clickListener );
    };
  }
  sun.register( 'MenuItem', MenuItem );
  return inherit( Node, MenuItem, {
    dispose: function() {
      this.disposeMenuItem();
      Node.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/ScreenshotGenerator',['require','PHET_CORE/inherit','SCENERY/util/CanvasContextWrapper','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var CanvasContextWrapper = require( 'SCENERY/util/CanvasContextWrapper' );
  var joist = require( 'JOIST/joist' );
  function ScreenshotGenerator() {
  }
  joist.register( 'ScreenshotGenerator', ScreenshotGenerator );
  return inherit( Object, ScreenshotGenerator, {}, {
    generateScreenshot: function( sim, mimeType ) {
      mimeType = mimeType || 'image/png';
      var canvas = document.createElement( 'canvas' );
      canvas.width = sim.display.width;
      canvas.height = sim.display.height;
      var context = canvas.getContext( '2d' );
      context.fillStyle = sim.display.domElement.style.backgroundColor;
      context.fillRect( 0, 0, canvas.width, canvas.height );
      var wrapper = new CanvasContextWrapper( canvas, context );
      sim.rootNode.renderToCanvasSubtree( wrapper );
      var dataURL = canvas.toDataURL( mimeType );
      return dataURL;
    }
  } );
} );
define( 'JOIST/TPhetMenu',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  function TPhetMenu( phetMenu, phetioID ) {
    TNode.call( this, phetMenu, phetioID );
    assertInstanceOf( phetMenu, phet.joist.PhetMenu );
  }
  phetioInherit( TNode, 'TPhetMenu', TPhetMenu, {}, {
    documentation: 'The PhET Menu in the bottom right of the screen',
    event: [ 'fired' ]
  } );
  joist.register( 'TPhetMenu', TPhetMenu );
  return TPhetMenu;
} );
define("string!JOIST/menuItem.options",function(){return window.phet.chipper.strings.get("JOIST/menuItem.options");});
define("string!JOIST/menuItem.about",function(){return window.phet.chipper.strings.get("JOIST/menuItem.about");});
define("string!JOIST/menuItem.mailInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.mailInputEventsLog");});
define("string!JOIST/menuItem.outputInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.outputInputEventsLog");});
define("string!JOIST/menuItem.phetWebsite",function(){return window.phet.chipper.strings.get("JOIST/menuItem.phetWebsite");});
define("string!JOIST/menuItem.reportAProblem",function(){return window.phet.chipper.strings.get("JOIST/menuItem.reportAProblem");});
define("string!JOIST/menuItem.screenshot",function(){return window.phet.chipper.strings.get("JOIST/menuItem.screenshot");});
define("string!JOIST/menuItem.fullscreen",function(){return window.phet.chipper.strings.get("JOIST/menuItem.fullscreen");});
define("string!JOIST/menuItem.getUpdate",function(){return window.phet.chipper.strings.get("JOIST/menuItem.getUpdate");});
define("string!JOIST/menuItem.submitInputEventsLog",function(){return window.phet.chipper.strings.get("JOIST/menuItem.submitInputEventsLog");});
define( 'JOIST/PhetMenu',['require','PHET_CORE/platform','SCENERY/nodes/Node','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/AboutDialog','JOIST/OptionsDialog','JOIST/UpdateDialog','SUN/MenuItem','SCENERY/nodes/Rectangle','SCENERY_PHET/PhetFont','JOIST/FullScreen','BRAND/Brand','JOIST/ScreenshotGenerator','JOIST/UpdateCheck','JOIST/joist','PHETCOMMON/util/StringUtils','AXON/DerivedProperty','SCENERY/input/Input','SCENERY/display/Display','SCENERY/accessibility/AccessibilityUtil','JOIST/TPhetMenu','string!JOIST/menuItem.options','string!JOIST/menuItem.about','string!JOIST/menuItem.mailInputEventsLog','string!JOIST/menuItem.outputInputEventsLog','string!JOIST/menuItem.phetWebsite','string!JOIST/menuItem.reportAProblem','string!JOIST/menuItem.screenshot','string!JOIST/menuItem.fullscreen','string!JOIST/menuItem.getUpdate','string!JOIST/menuItem.submitInputEventsLog'],function( require ) {
  'use strict';
  var platform = require( 'PHET_CORE/platform' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var AboutDialog = require( 'JOIST/AboutDialog' );
  var OptionsDialog = require( 'JOIST/OptionsDialog' );
  var UpdateDialog = require( 'JOIST/UpdateDialog' );
  var MenuItem = require( 'SUN/MenuItem' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var FullScreen = require( 'JOIST/FullScreen' );
  var Brand = require( 'BRAND/Brand' );
  var ScreenshotGenerator = require( 'JOIST/ScreenshotGenerator' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var joist = require( 'JOIST/joist' );
  var StringUtils = require( 'PHETCOMMON/util/StringUtils' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var Input = require( 'SCENERY/input/Input' );
  var Display = require( 'SCENERY/display/Display' );
  var AccessibilityUtil = require( 'SCENERY/accessibility/AccessibilityUtil' );
  var TPhetMenu = require( 'JOIST/TPhetMenu' );
  var menuItemOptionsString = require( 'string!JOIST/menuItem.options' );
  var menuItemAboutString = require( 'string!JOIST/menuItem.about' );
  var menuItemMailInputEventsLogString = require( 'string!JOIST/menuItem.mailInputEventsLog' );
  var menuItemOutputInputEventsLogString = require( 'string!JOIST/menuItem.outputInputEventsLog' );
  var menuItemPhetWebsiteString = require( 'string!JOIST/menuItem.phetWebsite' );
  var menuItemReportAProblemString = require( 'string!JOIST/menuItem.reportAProblem' );
  var menuItemScreenshotString = require( 'string!JOIST/menuItem.screenshot' );
  var menuItemFullscreenString = require( 'string!JOIST/menuItem.fullscreen' );
  var menuItemGetUpdateString = require( 'string!JOIST/menuItem.getUpdate' );
  var menuItemSubmitInputEventsLogString = require( 'string!JOIST/menuItem.submitInputEventsLog' );
  var FONT_SIZE = 18;
  var MAX_ITEM_WIDTH = 400;
  var fuzzMouse = phet.chipper.queryParameters.fuzzMouse;
  var createBubble = function( width, height ) {
    var rectangle = new Rectangle( 0, 0, width, height, 8, 8, { fill: 'white', lineWidth: 1, stroke: 'black' } );
    var tail = new Shape();
    tail.moveTo( width - 20, height - 2 );
    tail.lineToRelative( 0, 20 );
    tail.lineToRelative( -20, -20 );
    tail.close();
    var tailOutline = new Shape();
    tailOutline.moveTo( width - 20, height );
    tailOutline.lineToRelative( 0, 20 - 2 );
    tailOutline.lineToRelative( -18, -18 );
    var bubble = new Node();
    bubble.addChild( rectangle );
    bubble.addChild( new Path( tail, { fill: 'white' } ) );
    bubble.addChild( new Path( tailOutline, { stroke: 'black', lineWidth: 1 } ) );
    return bubble;
  };
  function PhetMenu( sim, tandem, options ) {
    var isPhETBrand = Brand.id === 'phet';
    var isPhetApp = Brand.isPhetApp;
    options = _.extend( {
      showSaveAndLoad: false
    }, options );
    var self = this;
    Node.call( self );
    var aboutDialog = null;
    var optionsDialog = null;
    var updateDialog = null;
    var itemDescriptors = [
      {
        text: menuItemOptionsString,
        present: !!sim.options.optionsNode,
        callback: function() {
          if ( !optionsDialog ) {
            optionsDialog = new OptionsDialog( sim.options.optionsNode, { tandem: tandem.createTandem( 'optionsDialog' ) } );
          }
          optionsDialog.show();
        },
        tandem: tandem.createTandem( 'optionsMenuItem' ),
        tagName: 'button',
        focusAfterCallback: true
      },
      {
        text: menuItemPhetWebsiteString,
        tandem: tandem.createTandem( 'phetWebsiteMenuItem' ),
        present: isPhETBrand,
        callback: function() {
          if ( !fuzzMouse ) {
            if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
              var phetWindow = window.open( 'http://phet.colorado.edu/' + sim.locale, '_blank' );
              phetWindow && phetWindow.focus();
            }
          }
        },
        tagName: 'button'
      },
      {
        text: menuItemOutputInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          console.log( sim.getRecordedInputEventLogString() );
        },
        tagName: 'button'
      },
      {
        text: menuItemSubmitInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          sim.submitEventLog();
        },
        tagName: 'button'
      },
      {
        text: menuItemMailInputEventsLogString,
        present: !!sim.options.recordInputEventLog,
        callback: function() {
          sim.mailEventLog();
        },
        tagName: 'button'
      },
      {
        text: menuItemReportAProblemString,
        present: isPhETBrand && !isPhetApp,
        callback: function() {
          var dependenciesCopy = phet.chipper.dependencies ? JSON.parse( JSON.stringify( phet.chipper.dependencies ) ) : {};
          delete dependenciesCopy.comment;
          for ( var key in dependenciesCopy ) {
            if ( dependenciesCopy[ key ].sha ) {
              dependenciesCopy[ key ].sha = dependenciesCopy[ key ].sha.substring( 0, 8 );
            }
          }
          var url = 'http://phet.colorado.edu/files/troubleshooting/' +
                    '?sim=' + encodeURIComponent( sim.name ) +
                    '&version=' + encodeURIComponent( sim.version + ' ' +
                    ( phet.chipper.buildTimestamp ? phet.chipper.buildTimestamp : '(require.js)' ) ) +
                    '&url=' + encodeURIComponent( window.location.href ) +
                    '&dependencies=' + encodeURIComponent( JSON.stringify( dependenciesCopy ) );
          if ( !fuzzMouse ) {
            if ( !window.phet || !phet.chipper || !phet.chipper.queryParameters || phet.chipper.queryParameters.allowLinks ) {
              var reportWindow = window.open( url, '_blank' );
              reportWindow && reportWindow.focus();
            }
          }
        },
        tandem: tandem.createTandem( 'reportAProblemMenuItem' ),
        tagName: 'button'
      },
      {
        text: 'QR code',
        present: phet.chipper.queryParameters.qrCode,
        callback: function() {
          if ( !fuzzMouse ) {
            var win = window.open( 'http://api.qrserver.com/v1/create-qr-code/?data=' + encodeURIComponent( window.location.href ) + '&size=220x220&margin=0', '_blank' );
            win && win.focus();
          }
        },
        tandem: tandem.createTandem( 'qrCodeMenuItem' ),
        tagName: 'button'
      },
      {
        text: menuItemGetUpdateString,
        present: UpdateCheck.areUpdatesChecked,
        textFill: new DerivedProperty( [ UpdateCheck.stateProperty ], function( state ) {
          return state === 'out-of-date' ? '#0a0' : '#000';
        } ),
        callback: function() {
          if ( !updateDialog ) {
            var phetButton = sim.navigationBar.phetButton;
            updateDialog = new UpdateDialog( phetButton );
          }
          updateDialog.show();
        },
        tandem: tandem.createTandem( 'getUpdateMenuItem' ),
        tagName: 'button',
        focusAfterCallback: true
      },
      {
        text: menuItemScreenshotString,
        present: !platform.ie9 && !isPhetApp, // Not supported by IE9, see https://github.com/phetsims/joist/issues/212
        callback: function() {
          var dataURL = ScreenshotGenerator.generateScreenshot( sim );
          if ( window.Blob && !!new window.Blob() ) {
            var requiredPrefix = 'data:image/png;base64,';
            assert && assert( dataURL.slice( 0, requiredPrefix.length ) === requiredPrefix );
            var dataBase64 = dataURL.slice( requiredPrefix.length );
            var byteChars = window.atob( dataBase64 );
            var byteArray = new window.Uint8Array( byteChars.length );
            for ( var i = 0; i < byteArray.length; i++ ) {
              byteArray[ i ] = byteChars.charCodeAt( i ); // need check to make sure this cast doesn't give problems?
            }
            var blob = new window.Blob( [ byteArray ], { type: 'image/png' } );
            var filename = StringUtils.stripEmbeddingMarks( sim.name ) + ' screenshot.png';
            if ( !fuzzMouse ) {
              window.saveAs( blob, filename );
            }
          }
          else if ( !fuzzMouse ) {
            window.open( dataURL, '_blank', '' );
          }
        },
        tandem: tandem.createTandem( 'screenshotMenuItem' ),
        tagName: 'button'
      },
      {
        text: menuItemFullscreenString,
        present: FullScreen.isFullScreenEnabled() && !isPhetApp && !fuzzMouse && !platform.mobileSafari,
        checkedProperty: FullScreen.isFullScreenProperty,
        callback: function() {
          FullScreen.toggleFullScreen( sim );
        },
        tandem: tandem.createTandem( 'fullScreenMenuItem' ),
        tagName: 'button'
      },
      {
        text: menuItemAboutString,
        present: true,
        separatorBefore: isPhETBrand,
        callback: function() {
          if ( !aboutDialog ) {
            var phetButton = sim.navigationBar.phetButton;
            aboutDialog = new AboutDialog( sim.name, sim.version, sim.credits, Brand, sim.locale, phetButton, tandem.createTandem( 'aboutDialog' ) );
          } 
          aboutDialog.show();
        },
        tandem: tandem.createTandem( 'aboutMenuItem' ),
        tagName: 'button',
        focusAfterCallback: true
      }
    ];
    var keepItemDescriptors = _.filter( itemDescriptors, function( itemDescriptor ) {return itemDescriptor.present;} );
    var textNodes = _.map( keepItemDescriptors, function( item ) {
      return new Text( item.text, {
        font: new PhetFont( FONT_SIZE ),
        maxWidth: MAX_ITEM_WIDTH
      } );
    } );
    var maxTextWidth = _.maxBy( textNodes, function( node ) {return node.width;} ).width;
    var maxTextHeight = _.maxBy( textNodes, function( node ) {return node.height;} ).height;
    var items = this.items = _.map( keepItemDescriptors, function( itemDescriptor ) {
        return new MenuItem(
          maxTextWidth,
          maxTextHeight,
          options.closeCallback,
          itemDescriptor.text,
          itemDescriptor.callback,
          {
            textFill: itemDescriptor.textFill,
            checkedProperty: itemDescriptor.checkedProperty,
            separatorBefore: itemDescriptor.separatorBefore,
            tandem: itemDescriptor.tandem,
            tagName: itemDescriptor.tagName,
            focusAfterCallback: itemDescriptor.focusAfterCallback
          }
        );
      }
    );
    var separatorWidth = _.maxBy( items, function( item ) {return item.width;} ).width;
    var itemHeight = _.maxBy( items, function( item ) {return item.height;} ).height;
    var content = new Node();
    var y = 0;
    var ySpacing = 2;
    var separator;
    _.each( items, function( item ) {
      if ( item.separatorBefore && items[ 0 ] !== item ) {
        y += ySpacing;
        separator = new Path( Shape.lineSegment( 0, y, separatorWidth, y ), { stroke: 'gray', lineWidth: 1 } );
        content.addChild( separator );
        y = y + separator.height + ySpacing;
      }
      item.top = y;
      content.addChild( item );
      y += itemHeight;
    } );
    var X_MARGIN = 5;
    var Y_MARGIN = 5;
    var bubble = createBubble( content.width + X_MARGIN + X_MARGIN, content.height + Y_MARGIN + Y_MARGIN );
    self.addChild( bubble );
    self.addChild( content );
    content.left = X_MARGIN;
    content.top = Y_MARGIN;
    this.isShowing = false;
    this.tagName = 'ul';
    this.ariaRole = 'menu';
    var keydownListener = this.addAccessibleInputListener( {
      keydown: function( event ) {
        var firstItem = self.items[ 0 ];
        var lastItem = self.items[ self.items.length - 1 ];
        if ( Input.isArrowKey( event.keyCode ) ) {
          event.preventDefault();
        }
        if ( event.keyCode === Input.KEY_DOWN_ARROW ) {
          var nextFocusable = lastItem.focussed ? firstItem : AccessibilityUtil.getNextFocusable();
          nextFocusable.focus();
        }
        else if ( event.keyCode === Input.KEY_UP_ARROW ) {
          var previousFocusable = firstItem.focussed ? lastItem : AccessibilityUtil.getPreviousFocusable();
          previousFocusable.focus();
        }
        else if ( event.keyCode === Input.KEY_ESCAPE ) {
          options.closeCallback();
          sim.navigationBar.phetButton.focus();
        }
        else if ( event.keyCode === Input.KEY_TAB ) {
          options.closeCallback();
          sim.navigationBar.phetButton.focus();
        }
      }
    } );
    var focusListener = function( focus ) {
      if ( focus && !_.includes( focus.trail.nodes, self ) ) {
        self.hide();
      }
    };
    Display.focusProperty.lazyLink( focusListener );
    tandem.addInstance( this, TPhetMenu );
    this.disposePhetMenu = function() {
      tandem.removeInstance( self );
      self.removeAccessibleInputListener( keydownListener );
      Display.focusProperty.unlink( focusListener );
    };
  }
  joist.register( 'PhetMenu', PhetMenu );
  inherit( Node, PhetMenu, {
    show: function() {
      if ( !this.isShowing ) {
        Display.focusProperty.set( null );
        window.phet.joist.sim.showPopup( this, true );
        this.isShowing = true;
      }
    },
    hide: function() {
      if ( this.isShowing ) {
        this.isShowing = false;
        window.phet.joist.sim.hidePopup( this, true );
      }
    },
    dispose: function() {
      this.disposePhetMenu();
      _.each( this.items, function( item ) {
        item.dispose();
      } );
      Node.prototype.dispose.call( this );
    }
  } );
  return PhetMenu;
} );
(function( global ) {
  function mipmapDownscale( mipmap, createData ) {
    var R = 0;
    var G = 1;
    var B = 2;
    var A = 3;
    var GAMMA = 2.2;
    var width = mipmap.width;
    var height = mipmap.height;
    var data = mipmap.data;
    function inside( row, col ) {
      return row < height && col < width;
    }
    function pixel( row, col ) {
      if ( !inside( row, col ) ) {
        return [ 0, 0, 0, 0 ];
      }
      var index = 4 * ( row * width + col );
      return [
        Math.pow( data[ index + R ] / 255, GAMMA ), // red
        Math.pow( data[ index + G ] / 255, GAMMA ), // green
        Math.pow( data[ index + B ] / 255, GAMMA ), // blue
        Math.pow( data[ index + A ] / 255, GAMMA ) // alpha
      ];
    }
    var smallWidth = Math.ceil( width / 2 );
    var smallHeight = Math.ceil( height / 2 );
    var smallData = createData( smallWidth, smallHeight );
    function smallPixel( row, col ) {
      return 4 * ( row * smallWidth + col );
    }
    for ( var row = 0; row < height; row++ ) {
      for ( var col = 0; col < width; col++ ) {
        var p1 = pixel( 2 * row, 2 * col ); // upper-left
        var p2 = pixel( 2 * row, 2 * col + 1 ); // upper-right
        var p3 = pixel( 2 * row + 1, 2 * col ); // lower-left
        var p4 = pixel( 2 * row + 1, 2 * col + 1 ); // lower-right
        var output = [ 0, 0, 0, 0 ];
        var alphaSum = p1[ A ] + p2[ A ] + p3[ A ] + p4[ A ];
        output[ R ] = ( p1[ R ] * p1[ A ] + p2[ R ] * p2[ A ] + p3[ R ] * p3[ A ] + p4[ R ] * p4[ A ] ) / alphaSum;
        output[ G ] = ( p1[ G ] * p1[ A ] + p2[ G ] * p2[ A ] + p3[ G ] * p3[ A ] + p4[ G ] * p4[ A ] ) / alphaSum;
        output[ B ] = ( p1[ B ] * p1[ A ] + p2[ B ] * p2[ A ] + p3[ B ] * p3[ A ] + p4[ B ] * p4[ A ] ) / alphaSum;
        output[ A ] = alphaSum / 4; // average of alphas
        var outputIndex = smallPixel( row, col );
        smallData[ outputIndex + R ] = Math.floor( Math.pow( output[ R ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + G ] = Math.floor( Math.pow( output[ G ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + B ] = Math.floor( Math.pow( output[ B ], 1 / GAMMA ) * 255 );
        smallData[ outputIndex + A ] = Math.floor( Math.pow( output[ A ], 1 / GAMMA ) * 255 );
      }
    }
    return {
      data: smallData,
      width: smallWidth,
      height: smallHeight
    };
  }
  global.define && global.define( function() {
    return mipmapDownscale;
  } );
  if ( typeof module !== 'undefined' ) {
    module.exports = mipmapDownscale;
  }
})( this );
define("../../chipper/js/common/mipmapDownscale", function(){});
define('mipmap',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define("mipmap!BRAND/logo.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["BRAND/logo.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );
define("mipmap!BRAND/logo-on-white.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["BRAND/logo-on-white.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );
define( 'JOIST/PhetButton',['require','SCENERY/nodes/Node','SCENERY/nodes/Image','KITE/Shape','SCENERY/nodes/Path','PHET_CORE/inherit','JOIST/PhetMenu','AXON/Property','JOIST/JoistButton','JOIST/UpdateCheck','SCENERY/util/TransformTracker','JOIST/JoistA11yStrings','JOIST/joist','mipmap!BRAND/logo.png','mipmap!BRAND/logo-on-white.png'],function( require ) {
  'use strict';
  var Node = require( 'SCENERY/nodes/Node' );
  var Image = require( 'SCENERY/nodes/Image' );
  var Shape = require( 'KITE/Shape' );
  var Path = require( 'SCENERY/nodes/Path' );
  var inherit = require( 'PHET_CORE/inherit' );
  var PhetMenu = require( 'JOIST/PhetMenu' );
  var Property = require( 'AXON/Property' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var TransformTracker = require( 'SCENERY/util/TransformTracker' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );
  var phetString = JoistA11yStrings.phetString;
  var brightLogoMipmap = require( 'mipmap!BRAND/logo.png' ); // on a black navbar
  var darkLogoMipmap = require( 'mipmap!BRAND/logo-on-white.png' ); // on a white navbar
  var PHET_LOGO_HEIGHT = 108;
  var PHET_LOGO_SCALE = 0.28;  // scale applied to the PhET logo
  assert && assert( brightLogoMipmap instanceof Array, 'logo must be a mipmap' );
  var LOGO_SCALE = PHET_LOGO_SCALE / brightLogoMipmap[ 0 ].height * PHET_LOGO_HEIGHT;
  function PhetButton( sim, backgroundFillProperty, textFillProperty, tandem ) {
    var phetMenu = new PhetMenu( sim, tandem.createTandem( 'phetMenu' ), {
      showSaveAndLoad: sim.options.showSaveAndLoad,
      closeCallback: function() {
        phetMenu.hide();
      }
    } );
    function onResize( bounds, screenBounds, scale ) {
      phetMenu.right = bounds.right / scale - 2 / scale;
      var navBarHeight = bounds.height - screenBounds.height;
      phetMenu.bottom = screenBounds.bottom / scale + navBarHeight / 2 / scale;
    }
    sim.resizedEmitter.addListener( onResize );
    var options = {
      textDescription: 'PhET Menu Button',
      highlightExtensionWidth: 6,
      highlightExtensionHeight: 5,
      highlightCenterOffsetY: 4,
      listener: function() {
        phetMenu.show();
      },
      tagName: 'button',
      accessibleLabel: phetString
    };
    var logoImage = new Image( brightLogoMipmap, {
      scale: LOGO_SCALE,
      pickable: false
    } );
    var optionsShape = new Shape();
    var optionsCircleRadius = 2.5;
    for ( var i = 0; i < 3; i++ ) {
      var circleOffset = i * 3.543 * optionsCircleRadius;
      optionsShape.arc( 0, circleOffset, optionsCircleRadius, 0, 2 * Math.PI, false );
    }
    var optionsButton = new Path( optionsShape, {
      left: logoImage.width + 8,
      bottom: logoImage.bottom - 0.5,
      pickable: false
    } );
    var icon = new Node( { children: [ logoImage, optionsButton ] } );
    JoistButton.call( this, icon, backgroundFillProperty, tandem, options );
    this.focusHighlight = Shape.bounds( icon.bounds.dilated( 4 ) );
    Property.multilink( [ backgroundFillProperty, sim.showHomeScreenProperty, UpdateCheck.stateProperty ],
      function( backgroundFill, showHomeScreen, updateState ) {
        var backgroundIsWhite = backgroundFill !== 'black' && !showHomeScreen;
        var outOfDate = updateState === 'out-of-date';
        optionsButton.fill = backgroundIsWhite ? ( outOfDate ? '#0a0' : '#222' ) : ( outOfDate ? '#3F3' : 'white' );
        logoImage.image = backgroundIsWhite ? darkLogoMipmap : brightLogoMipmap;
      } );
    this.addAccessibleInputListener( {
      click: function() {
        phetMenu.show();
        phetMenu.items[ 0 ].focus();
      }
    } );
    this.setAccessibleAttribute( 'aria-haspopup', true );
  }
  joist.register( 'PhetButton', PhetButton );
  return inherit( JoistButton, PhetButton, {}, {
      HORIZONTAL_INSET: 10,
      VERTICAL_INSET: 0,
      linkPhetButtonTransform: function( homeScreen, navigationBar, rootNode ) {
        var homeScreenButton = homeScreen.view.phetButton;
        var navBarButtonTracker = new TransformTracker( navigationBar.phetButton.getUniqueTrailTo( rootNode ), {
          isStatic: true // our listener won't change any listeners - TODO: replace with emitter? see https://github.com/phetsims/scenery/issues/594
        } );
        var homeScreenTracker = new TransformTracker( homeScreenButton.getParent().getUniqueTrailTo( rootNode ), {
          isStatic: true // our listener won't change any listeners - TODO: replace with emitter? see https://github.com/phetsims/scenery/issues/594
        } );
        function transformPhetButton() {
          homeScreenButton.matrix = homeScreenTracker.matrix.inverted().timesMatrix( navBarButtonTracker.matrix );
        }
        navBarButtonTracker.addListener( transformPhetButton );
        homeScreenTracker.addListener( transformPhetButton );
        transformPhetButton();
      }
    }
  );
} );
define( 'JOIST/Frame',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/util/LinearGradient','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var LinearGradient = require( 'SCENERY/util/LinearGradient' );
  var joist = require( 'JOIST/joist' );
  function Frame( content, options ) {
    options = _.extend( {
      xMargin1: 6,
      yMargin1: 6,
      cornerRadius: 0 // radius of the rounded corners on the background
    }, options );
    Node.call( this );
    var frameWidth = content.width + 2 * options.xMargin1;
    var frameHeight = content.height + 2 * options.yMargin1;
    this.gradient = new LinearGradient( 0, 0, frameWidth, 0 ).addColorStop( 0, '#fbff41' ).addColorStop( 118 / 800.0, '#fef98b' ).addColorStop( 372 / 800.0, '#feff40' ).addColorStop( 616 / 800, '#fffccd' ).addColorStop( 1, '#fbff41' );
    this.rectangle = new Rectangle( 0, 0, frameWidth, frameHeight, options.cornerRadius, options.cornerRadius, {
      stroke: this.gradient,
      lineWidth: 3,
      x: content.x - options.xMargin1,
      y: content.y - options.yMargin1
    } );
    this.addChild( this.rectangle );
    this.mutate( options );
    this.frameWidth = frameWidth;
    this.frameHeight = frameHeight;
  }
  joist.register( 'Frame', Frame );
  inherit( Node, Frame, {
    setHighlighted: function( highlighted ) {
      this.rectangle.lineWidth = highlighted ? 4.5 : 3;
      if ( highlighted ) {
        this.rectangle.setRect( -1.5 / 2, -1.5 / 2, this.frameWidth + 1.5, this.frameHeight + 1.5 );
      }
      else {
        this.rectangle.setRect( 0, 0, this.frameWidth, this.frameHeight );
      }
    }
  } );
  return Frame;
} );
define( 'JOIST/TScreenButton',['require','JOIST/joist','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TScreenButton( button, phetioID ) {
    assertInstanceOf( button, phet.scenery.VBox );
    TNode.call( this, button, phetioID );
    toEventOnEmit(
      button.startedCallbacksForFiredEmitter,
      button.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }
  phetioInherit( TNode, 'TScreenButton', TScreenButton, {}, {
    documentation: 'A pressable button in the simulation, in the home screen',
    events: [ 'fired' ]
  } );
  joist.register( 'TScreenButton', TScreenButton );
  return TScreenButton;
} );
define( 'JOIST/ScreenButton',['require','PHET_CORE/inherit','JOIST/joist','AXON/Emitter','SCENERY/nodes/Rectangle','SCENERY/nodes/VBox','SCENERY/nodes/Text','SCENERY_PHET/PhetFont','SCENERY/nodes/Node','JOIST/Frame','DOT/Util','SCENERY_PHET/PhetColorScheme','KITE/Shape','JOIST/TScreenButton'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Emitter = require( 'AXON/Emitter' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var VBox = require( 'SCENERY/nodes/VBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Frame = require( 'JOIST/Frame' );
  var Util = require( 'DOT/Util' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Shape = require( 'KITE/Shape' );
  var TScreenButton = require( 'JOIST/TScreenButton' );
  var LARGE_ICON_HEIGHT = 140;
  function ScreenButton( large, sim, index, highlightedScreenIndexProperty, tandem, options ) {
    var self = this;
    options = _.extend( {
      opacity: 1,  // The small screen's nodes have an opacity of .5
      tandem: tandem, // To be passed into mutate, but tandem should be a required param in joist
      phetioType: TScreenButton
    }, options );
    var screen = sim.screens[ index ];
    this.startedCallbacksForFiredEmitter = new Emitter();
    this.endedCallbacksForFiredEmitter = new Emitter();
    var smallIconScale = Util.linear( 2, 4, 0.875, 0.50, sim.screens.length );
    var height = large ? LARGE_ICON_HEIGHT : smallIconScale * LARGE_ICON_HEIGHT;
    var icon = new Node( {
      opacity: options.opacity,
      children: [ screen.homeScreenIcon ],
      scale: height / screen.homeScreenIcon.height
    } );
    var frame = large ? new Frame( icon ) : new Rectangle( 0, 0, icon.width, icon.height, {
                        stroke: options.showSmallHomeScreenIconFrame ? '#dddddd' : null,
                        lineWidth: 0.7
                      } );
    var iconWithFrame = new Node( {
      opacity: options.opacity,
      children: [ frame, icon ]
    } );
    var text = new Text( screen.name, {
      font: new PhetFont( large ? 42 : 18 ),
      fill: large ? PhetColorScheme.PHET_LOGO_YELLOW : 'gray', // Color match with the PhET Logo yellow
      tandem: tandem.createTandem( 'text' )
    } );
    if ( text.width > iconWithFrame.width ) {
      text.scale( iconWithFrame.width / text.width );
    }
    highlightedScreenIndexProperty.link( function( highlightedIndex ) {
      var highlighted = highlightedIndex === index;
      frame.setHighlighted && frame.setHighlighted( highlighted );
      icon.opacity = (large || highlighted) ? 1 : 0.5;
      text.fill = (large || highlighted) ? 'white' : 'gray';
    } );
    VBox.call( this, {
      children: [
        iconWithFrame,
        text
      ]
    } );
    var buttonDown = large ?
                     function() {
                       sim.showHomeScreenProperty.value = false;
                       highlightedScreenIndexProperty.value = -1;
                     } :
                     function() {
                       sim.screenIndexProperty.value = index;
                     };
    this.addInputListener( {
      down: function( event ) {
        self.startedCallbacksForFiredEmitter.emit();
        buttonDown();
        self.endedCallbacksForFiredEmitter.emit();
      }
    } );
    if ( !large ) {
      this.highlightListener = {
        over: function( event ) {
          highlightedScreenIndexProperty.value = index;
        },
        out: function( event ) {
          highlightedScreenIndexProperty.value = -1;
        }
      };
      this.addInputListener( {
        over: function( event ) {
          if ( event.pointer.isTouch ) {
            sim.screenIndexProperty.value = index;
          }
        }
      } );
    }
    this.mouseArea = this.touchArea = Shape.bounds( this.bounds ); // cover the gap in the vbox
    this.disposeScreenButton = function() {
      highlightedScreenIndexProperty.unlink();
    };
    this.mutate( options );
  }
  joist.register( 'ScreenButton', ScreenButton );
  return inherit( VBox, ScreenButton, {
    dispose: function() {
      this.disposeScreenButton();
      VBox.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/HomeScreenView',['require','JOIST/PhetButton','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/ScreenView','JOIST/ScreenButton','AXON/Property','SCENERY_PHET/PhetFont','DOT/Bounds2','JOIST/joist'],function( require ) {
  'use strict';
  var PhetButton = require( 'JOIST/PhetButton' );
  var Node = require( 'SCENERY/nodes/Node' );
  var HBox = require( 'SCENERY/nodes/HBox' );
  var Text = require( 'SCENERY/nodes/Text' );
  var inherit = require( 'PHET_CORE/inherit' );
  var ScreenView = require( 'JOIST/ScreenView' );
  var ScreenButton = require( 'JOIST/ScreenButton' );
  var Property = require( 'AXON/Property' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var joist = require( 'JOIST/joist' );
  var LAYOUT_BOUNDS = new Bounds2( 0, 0, 768, 504 );
  var TITLE_FONT_FAMILY = 'Century Gothic, Futura';
  function HomeScreenView( sim, tandem, options ) {
    var self = this;
    options = _.extend( {
      showSmallHomeScreenIconFrame: false,
      warningNode: null // {Node | null}, to display below the icons as a warning if available
    }, options );
    ScreenView.call( this, { layoutBounds: LAYOUT_BOUNDS } );
    var title = new Text( sim.name, {
      font: new PhetFont( {
        size: 52,
        family: TITLE_FONT_FAMILY
      } ),
      fill: 'white',
      y: 110,
      tandem: tandem.createTandem( 'title' )
    } );
    this.addChild( title );
    title.scale( Math.min( 1, 0.9 * this.layoutBounds.width / title.width ) );
    title.centerX = this.layoutBounds.centerX;
    var highlightedScreenIndexProperty = new Property( -1 );
    var screenChildren = _.map( sim.screens, function( screen ) {
      assert && assert( screen.name, 'name is required for screen ' + sim.screens.indexOf( screen ) );
      assert && assert( screen.homeScreenIcon, 'homeScreenIcon is required for screen ' + screen.name );
      var index = sim.screens.indexOf( screen );
      var largeTandem = tandem.createTandem( screen.tandem.tail + 'LargeButton' );
      var isLarge = true;
      var largeScreenButton = new ScreenButton(
        isLarge,
        sim,
        index,
        highlightedScreenIndexProperty,
        largeTandem,
        {
          resize: false,
          cursor: 'pointer'
        } );
      var smallTandem = tandem.createTandem( screen.tandem.tail + 'SmallButton' );
      isLarge = false;
      var smallScreenButton = new ScreenButton(
        isLarge,
        sim,
        index,
        highlightedScreenIndexProperty,
        smallTandem,
        {
          spacing: 3,
          cursor: 'pointer',
          showSmallHomeScreenIconFrame: options.showSmallHomeScreenIconFrame,
        }
      );
      smallScreenButton.addInputListener( smallScreenButton.highlightListener );
      largeScreenButton.addInputListener( smallScreenButton.highlightListener );
      return { screen: screen, small: smallScreenButton, large: largeScreenButton, index: index };
    } );
    var iconsParentNode = new Node();
    self.addChild( iconsParentNode );
    var spacing = ( sim.screens.length <= 3 ) ? 60 : 33;
    var hBox = null;
    sim.screenIndexProperty.link( function( screenIndex ) {
      if ( hBox ) {
        hBox.removeAllChildren(); // because icons have reference to hBox (their parent)
        iconsParentNode.removeChild( hBox );
      }
      var icons = _.map( screenChildren, function( screenChild ) {return screenChild.index === screenIndex ? screenChild.large : screenChild.small;} );
      hBox = new HBox( { spacing: spacing, children: icons, align: 'top', resize: false } );
      iconsParentNode.addChild( hBox );
      iconsParentNode.centerX = self.layoutBounds.width / 2;
      iconsParentNode.top = 170;
    } );
    var homeScreenFillProperty = new Property( 'black' );
    var homeScreenTextFillProperty = new Property( 'white' );
    this.phetButton = new PhetButton( sim, homeScreenFillProperty, homeScreenTextFillProperty, tandem.createTandem( 'phetButton' ) );
    this.addChild( this.phetButton );
    if ( options.warningNode ) {
      var warningNode = options.warningNode;
      this.addChild( warningNode );
      warningNode.centerX = this.layoutBounds.centerX;
      warningNode.bottom = this.layoutBounds.maxY - 20;
    }
  }
  joist.register( 'HomeScreenView', HomeScreenView );
  return inherit( ScreenView, HomeScreenView, {},
    {
      TITLE_FONT_FAMILY: TITLE_FONT_FAMILY,
      LAYOUT_BOUNDS: LAYOUT_BOUNDS
    }
  );
} );
define("string!JOIST/keyboardShortcuts.title",function(){return window.phet.chipper.strings.get("JOIST/keyboardShortcuts.title");});
define( 'JOIST/KeyboardHelpDialog',['require','PHET_CORE/inherit','JOIST/Dialog','JOIST/joist','SCENERY/input/ButtonListener','SCENERY/nodes/Path','SCENERY/nodes/Text','KITE/Shape','JOIST/JoistA11yStrings','SCENERY_PHET/PhetFont','string!JOIST/keyboardShortcuts.title'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Dialog = require( 'JOIST/Dialog' );
  var joist = require( 'JOIST/joist' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Path = require( 'SCENERY/nodes/Path' );
  var Text = require( 'SCENERY/nodes/Text' );
  var Shape = require( 'KITE/Shape' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var CLOSE_BUTTON_WIDTH = 7;
  var CLOSE_BUTTON_MARGIN = 10;
  var HELP_CONTENT_MARGIN = 20;
  var TITLE_MAX_WIDTH = 500;
  var keyboardShortcutsTitleString = require( 'string!JOIST/keyboardShortcuts.title' );
  function KeyboardHelpDialog( keyboardHelpButton, helpContent, options ) {
    var titleText = new Text( keyboardShortcutsTitleString, {
      font: new PhetFont( {
        weight: 'bold',
        size: 20
      } ),
      maxWidth: TITLE_MAX_WIDTH,
      tagName: 'h1',
      accessibleLabel: JoistA11yStrings.hotKeysAndHelpString
    } );
    options = _.extend( {
      titleAlign: 'center',
      title: titleText,
      modal: true,
      hasCloseButton: false,
      fill: 'rgb( 214, 237, 249 )',
      xMargin: HELP_CONTENT_MARGIN,
      yMargin: HELP_CONTENT_MARGIN,
      titleSpacing: HELP_CONTENT_MARGIN,
      focusOnCloseNode: keyboardHelpButton
    }, options );
    var closeButtonShape = new Shape();
    closeButtonShape.moveTo( -CLOSE_BUTTON_WIDTH, - CLOSE_BUTTON_WIDTH ).lineTo( CLOSE_BUTTON_WIDTH, CLOSE_BUTTON_WIDTH );
    closeButtonShape.moveTo( CLOSE_BUTTON_WIDTH, -CLOSE_BUTTON_WIDTH ).lineTo( -CLOSE_BUTTON_WIDTH, CLOSE_BUTTON_WIDTH );
    this.closeButtonPath = new Path( closeButtonShape, {
      stroke: 'black',
      lineCap: 'round',
      lineWidth: 2,
      cursor: 'pointer',
      tagName: 'button',
      accessibleLabel: JoistA11yStrings.closeString,
      focusHighlight: Shape.bounds( closeButtonShape.getBounds().dilated( 10 ) )
    } );  
    var self = this;
    var buttonListener = new ButtonListener( {
      down: function() {
        self.hide();
      }
    } );
    this.closeButtonPath.addInputListener( buttonListener );
    var areaX = this.closeButtonPath.left - this.closeButtonPath.width * 2;
    var areaY = this.closeButtonPath.top - CLOSE_BUTTON_MARGIN / 2;
    var width = this.closeButtonPath.width * 4;
    var height = this.closeButtonPath.height + CLOSE_BUTTON_MARGIN;
    this.closeButtonPath.mouseArea = Shape.rect( areaX, areaY, width, height );
    this.closeButtonPath.touchArea = this.closeButtonPath.mouseArea;
    Dialog.call( this, helpContent, options );
    this.closeButtonPath.right = helpContent.right + 2 * HELP_CONTENT_MARGIN - CLOSE_BUTTON_MARGIN;
    this.closeButtonPath.top = helpContent.top + CLOSE_BUTTON_MARGIN;
    this.addChild( this.closeButtonPath );
    var clickListener = this.closeButtonPath.addAccessibleInputListener( {
      click: function() {
        self.hide();
        self.focusActiveElement();  
      } }
    );
    this.disposeKeyboardHelpDialog = function() {
      self.closeButtonPath.removeInputListener( buttonListener );
      self.closeButtonPath.removeAccessibleInputListener( clickListener );
    };
  }
  joist.register( 'KeyboardHelpDialog', KeyboardHelpDialog );
  return inherit( Dialog, KeyboardHelpDialog, {
    dispose: function() {
      this.disposeKeyboardHelpDialog();
      Dialog.prototype.dispose.call( this );
    }
  } );
} );
define("mipmap!JOIST/keyboard-icon.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["JOIST/keyboard-icon.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );
define("mipmap!JOIST/keyboard-icon-on-white.png", function(){
  var mipmaps = window.phet.chipper.mipmaps["JOIST/keyboard-icon-on-white.png"];
  window.phetImages = window.phetImages || []
  mipmaps.forEach( function( mipmap ) {
    mipmap.img = new Image();
    window.phetImages.push( mipmap.img );
    mipmap.img.src = mipmap.url;
    mipmap.canvas = document.createElement( 'canvas' );
    mipmap.canvas.width = mipmap.width;
    mipmap.canvas.height = mipmap.height;
    var context = mipmap.canvas.getContext( '2d' );
    mipmap.updateCanvas = function() {
      if ( mipmap.img.complete && ( typeof mipmap.img.naturalWidth === 'undefined' || mipmap.img.naturalWidth > 0 ) ) {
        context.drawImage( mipmap.img, 0, 0 );
        delete mipmap.updateCanvas;
      }
    };
  } );
  return mipmaps;
} );
define( 'JOIST/KeyboardHelpButton',['require','PHET_CORE/inherit','AXON/Property','KITE/Shape','SCENERY/nodes/Image','JOIST/JoistButton','JOIST/KeyboardHelpDialog','JOIST/JoistA11yStrings','JOIST/joist','mipmap!JOIST/keyboard-icon.png','mipmap!JOIST/keyboard-icon-on-white.png'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var Shape = require( 'KITE/Shape' );
  var Image = require( 'SCENERY/nodes/Image' );
  var JoistButton = require( 'JOIST/JoistButton' );
  var KeyboardHelpDialog = require( 'JOIST/KeyboardHelpDialog' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );
  var brightIconMipmap = require( 'mipmap!JOIST/keyboard-icon.png' ); // on a black navbar
  var darkIconMipmap = require( 'mipmap!JOIST/keyboard-icon-on-white.png' ); // on a white navbar
  assert && assert( brightIconMipmap instanceof Array, 'icon must be a mipmap' );
  var HELP_BUTTON_HEIGHT = 67;
  var HELP_BUTTON_SCALE = 0.32;  // scale applied to the icon
  var BUTTON_SCALE = HELP_BUTTON_SCALE / brightIconMipmap[ 0 ].height * HELP_BUTTON_HEIGHT;
  function KeyboardHelpButton( sim, backgroundFillProperty, tandem ) {
    var self = this;
    var keyboardHelpDialog = null;
    var openDialog = function() {
      if ( !keyboardHelpDialog ) {
        keyboardHelpDialog = new KeyboardHelpDialog( self, sim.keyboardHelpNode, {
          tandem: tandem.createTandem( 'keyboardHelpDialog' )
        } );
      }
      keyboardHelpDialog.show();
    };
    var options = {
      highlightExtensionWidth: 5,
      highlightExtensionHeight: 10,
      highlightCenterOffsetY: 3,
      listener: openDialog,
      tagName: 'button',
      accessibleLabel: JoistA11yStrings.hotKeysAndHelpString
    };
    var icon = new Image( brightIconMipmap, {
      scale: BUTTON_SCALE,
      pickable: false
    } );
    JoistButton.call( this, icon, backgroundFillProperty, tandem, options );
    this.focusHighlight = Shape.bounds( icon.bounds.dilated( 5 ) );
    Property.multilink( [ backgroundFillProperty, sim.showHomeScreenProperty ],
      function( backgroundFill, showHomeScreen ) {
        var backgroundIsWhite = backgroundFill !== 'black' && !showHomeScreen;
        icon.image = backgroundIsWhite ? darkIconMipmap : brightIconMipmap;
      } );
    this.clickListener = this.addAccessibleInputListener( {
      click: function() {
        openDialog();
        keyboardHelpDialog.closeButtonPath.focus();
      } }
    );
  }
  joist.register( 'KeyboardHelpButton', KeyboardHelpButton );
  return inherit( JoistButton, KeyboardHelpButton, {
    dispose: function() {
      this.removeAccessibleInputListener( this.clickListener );
      JoistButton.prototype.dispose && JoistButton.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/NavigationBar',['require','DOT/Dimension2','JOIST/HomeButton','PHET_CORE/inherit','PHET_CORE/platform','JOIST/NavigationBarScreenButton','JOIST/HomeScreenView','SCENERY/nodes/Node','JOIST/PhetButton','JOIST/KeyboardHelpButton','SCENERY_PHET/PhetFont','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','JOIST/JoistA11yStrings','JOIST/joist'],function( require ) {
  'use strict';
  var Dimension2 = require( 'DOT/Dimension2' );
  var HomeButton = require( 'JOIST/HomeButton' );
  var inherit = require( 'PHET_CORE/inherit' );
  var platform = require( 'PHET_CORE/platform' );
  var NavigationBarScreenButton = require( 'JOIST/NavigationBarScreenButton' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetButton = require( 'JOIST/PhetButton' );
  var KeyboardHelpButton = require( 'JOIST/KeyboardHelpButton' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var JoistA11yStrings = require( 'JOIST/JoistA11yStrings' );
  var joist = require( 'JOIST/joist' );
  var NAVIGATION_BAR_SIZE = new Dimension2( HomeScreenView.LAYOUT_BOUNDS.width, 40 );
  var TITLE_LEFT_MARGIN = 10;
  var TITLE_RIGHT_MARGIN = 25;
  var PHET_BUTTON_LEFT_MARGIN = 13;
  var PHET_BUTTON_RIGHT_MARGIN = PhetButton.HORIZONTAL_INSET; // same position as PhetButton on home screen
  var PHET_BUTTON_BOTTOM_MARGIN = PhetButton.VERTICAL_INSET; // same position as PhetButton on home screen
  var KEYBOARD_HELP_BUTTON_LEFT_MARGIN = 50;
  var HOME_BUTTON_LEFT_MARGIN = 5;
  var HOME_BUTTON_RIGHT_MARGIN = HOME_BUTTON_LEFT_MARGIN;
  var SCREEN_BUTTON_SPACING = 0;
  var MINIMUM_SCREEN_BUTTON_WIDTH = 60; // Make sure each button is at least a minimum width so they don't get too close together, see #279
  function NavigationBar( sim, screens, tandem ) {
    this.screens = screens;
    Node.call( this );
    this.background = new Rectangle( 0, 0, NAVIGATION_BAR_SIZE.width, NAVIGATION_BAR_SIZE.height, {
      pickable: true
    } );
    sim.lookAndFeel.navigationBarFillProperty.linkAttribute( this.background, 'fill' );
    this.addChild( this.background );
    this.barContents = new Node();
    this.addChild( this.barContents );
    this.titleTextNode = new Text( sim.name, {
      font: new PhetFont( 16 ),
      tandem: tandem.createTandem( 'titleTextNode' )
    } );
    sim.lookAndFeel.navigationBarTextFillProperty.linkAttribute( this.titleTextNode, 'fill' );
    this.barContents.addChild( this.titleTextNode );
    this.phetButton = new PhetButton( sim, sim.lookAndFeel.navigationBarFillProperty, sim.lookAndFeel.navigationBarTextFillProperty, tandem.createTandem( 'phetButton' ) );
    this.barContents.addChild( this.phetButton );
    this.keyboardHelpButton = new KeyboardHelpButton( sim, sim.lookAndFeel.navigationBarFillProperty, tandem.createTandem( 'keyboardHelpButton' ) );
    if ( sim.accessible && sim.keyboardHelpNode && !platform.mobileSafari ) {
      this.barContents.addChild( this.keyboardHelpButton );
    }
    if ( screens.length === 1 ) {
      this.titleTextNode.maxWidth = HomeScreenView.LAYOUT_BOUNDS.width - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN -
                                    this.phetButton.width - PHET_BUTTON_RIGHT_MARGIN - this.keyboardHelpButton.width - KEYBOARD_HELP_BUTTON_LEFT_MARGIN;
    }
    else {
      var maxTitleWidth = Math.min( this.titleTextNode.width, 0.20 * HomeScreenView.LAYOUT_BOUNDS.width );
      this.homeButton = new HomeButton(
        NAVIGATION_BAR_SIZE.height,
        sim.lookAndFeel.navigationBarFillProperty,
        tandem.createTandem( 'homeButton' ), {
          listener: function() {
            sim.showHomeScreenProperty.value = true;
          }
        } );
      phet.chipper.queryParameters.homeScreen && this.barContents.addChild( this.homeButton );
      var availableLeft = ( HomeScreenView.LAYOUT_BOUNDS.width / 2 ) - TITLE_LEFT_MARGIN - maxTitleWidth - TITLE_RIGHT_MARGIN -
                            this.homeButton.width - HOME_BUTTON_RIGHT_MARGIN;
      var availableRight = ( HomeScreenView.LAYOUT_BOUNDS.width / 2 ) - this.phetButton.width - PHET_BUTTON_RIGHT_MARGIN -
                             this.keyboardHelpButton.width - KEYBOARD_HELP_BUTTON_LEFT_MARGIN;
      var availableTotal = 2 * Math.min( availableLeft, availableRight );
      var screenButtonWidth = ( availableTotal - ( screens.length - 1 ) * SCREEN_BUTTON_SPACING ) / screens.length;
      var screenButtons = _.map( screens, function( screen ) {
        return new NavigationBarScreenButton(
          sim.lookAndFeel.navigationBarFillProperty,
          sim.screenIndexProperty,
          sim.screens,
          screen,
          NAVIGATION_BAR_SIZE.height, {
            maxButtonWidth: screenButtonWidth,
            tandem: tandem.createTandem( screen.tandem.tail + 'Button' )
          } );
      } );
      var maxScreenButtonWidth = Math.max( MINIMUM_SCREEN_BUTTON_WIDTH, _.maxBy( screenButtons, function( button ) {
        return button.width;
      } ).width );
      var spaceBetweenButtons = maxScreenButtonWidth + SCREEN_BUTTON_SPACING;
      for ( var i = 0; i < screenButtons.length; i++ ) {
        screenButtons[ i ].centerX = spaceBetweenButtons * ( i - ( screenButtons.length - 1 ) / 2 );
      }
      this.screenButtonsContainer = new Node( {
        children: screenButtons,
        x: this.background.centerX, // since we have buttons centered around our origin, this centers the buttons
        centerY: this.background.centerY,
        maxWidth: availableTotal // in case we have so many screens that the screen buttons need to be scaled down
      } );
      this.barContents.addChild( this.screenButtonsContainer );
      this.accessibleOrder = [ this.screenButtonsContainer, this.homeButton ];
      this.titleTextNode.maxWidth = this.screenButtonsContainer.left - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN -
                                HOME_BUTTON_RIGHT_MARGIN - this.homeButton.width - HOME_BUTTON_LEFT_MARGIN;
    }
    this.titleTextNode.left = TITLE_LEFT_MARGIN;
    this.titleTextNode.centerY = NAVIGATION_BAR_SIZE.height / 2;
    this.phetButton.bottom = NAVIGATION_BAR_SIZE.height - PHET_BUTTON_BOTTOM_MARGIN;
    this.keyboardHelpButton.centerY = this.phetButton.centerY;
    if ( this.screens.length !== 1 ) {
      this.screenButtonsContainer.centerY = NAVIGATION_BAR_SIZE.height / 2;
      this.homeButton.centerY = NAVIGATION_BAR_SIZE.height / 2;
    }
    this.layout( 1, NAVIGATION_BAR_SIZE.width, NAVIGATION_BAR_SIZE.height );
    this.tagName = 'footer';
    this.ariaLabel = JoistA11yStrings.simResourcesAndToolsString;
    this.accessibleOrder = [ this.keyboardHelpButton, this.phetButton ];
  }
  joist.register( 'NavigationBar', NavigationBar );
  return inherit( Node, NavigationBar, {
    layout: function( scale, width, height ) {
      this.background.rectWidth = width;
      this.background.rectHeight = height;
      this.barContents.setScaleMagnitude( scale );
      var right;
      if ( NAVIGATION_BAR_SIZE.width * scale < width ) {
        right = width / scale;
      }
      else {
        right = NAVIGATION_BAR_SIZE.width;
      }
      this.phetButton.right = right - PHET_BUTTON_RIGHT_MARGIN;
      this.keyboardHelpButton.right = this.phetButton.left - PHET_BUTTON_LEFT_MARGIN;
      if ( this.screens.length !== 1 ) {
        this.screenButtonsContainer.x = right / 2 + this.homeButton.width / 2;
        this.homeButton.right = this.screenButtonsContainer.left - HOME_BUTTON_RIGHT_MARGIN;
        this.titleTextNode.maxWidth = this.homeButton.left - TITLE_LEFT_MARGIN - TITLE_RIGHT_MARGIN;
      }
    }
  }, {
    NAVIGATION_BAR_SIZE: NAVIGATION_BAR_SIZE
  } );
} );
define( 'JOIST/HomeScreen',['require','PHET_CORE/inherit','JOIST/Screen','JOIST/HomeScreenView','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Screen = require( 'JOIST/Screen' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );
  function HomeScreen( sim, tandem, options ) {
    options = _.extend( {
      backgroundColorProperty: new Property( 'black' )
    }, options );
    assert && assert( !options.tandem, 'tandem is a required constructor parameter, not an option' );
    options.tandem = tandem;
    Screen.call( this,
      function() { return {}; },
      function() {
        return new HomeScreenView( sim, tandem.createTandem( 'view' ), _.pick( options, [
          'showSmallHomeScreenIconFrame',
          'warningNode'
        ] ) );
      },
      options
    );
  }
  joist.register( 'HomeScreen', HomeScreen );
  return inherit( Screen, HomeScreen );
} );
define( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var scenery = require( 'SCENERY/scenery' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  function Plane( options ) {
    Rectangle.call( this, -2000, -2000, 6000, 6000, options );
  }
  scenery.register( 'Plane', Plane );
  return inherit( Rectangle, Plane );
} );
define( 'SCENERY_PHET/TBarrierRectangle',['require','SCENERY/nodes/TNode','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetioInherit','SCENERY_PHET/sceneryPhet','ifphetio!PHET_IO/events/toEventOnEmit'],function( require ) {
  'use strict';
  var TNode = require( 'SCENERY/nodes/TNode' );
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  function TBarrierRectangle( barrierRectangle, phetioID ) {
    assertInstanceOf( barrierRectangle, phet.scenery.Rectangle );
    TNode.call( this, barrierRectangle, phetioID );
    toEventOnEmit( barrierRectangle.startedCallbacksForFiredEmitter,
      barrierRectangle.endedCallbacksForFiredEmitter,
      'user',
      phetioID,
      this.constructor,
      'fired' );
  }
  phetioInherit( TNode, 'TBarrierRectangle', TBarrierRectangle, {}, {
    documentation: 'Shown when a dialog is present, so that clicking on the invisible barrier rectangle will dismiss the dialog',
    events: [ 'fired' ],
    dataStreamOnlyType: true
  } );
  sceneryPhet.register( 'TBarrierRectangle', TBarrierRectangle );
  return TBarrierRectangle;
} );
define( 'SCENERY_PHET/BarrierRectangle',['require','PHET_CORE/inherit','SCENERY_PHET/sceneryPhet','AXON/Emitter','SCENERY/nodes/Plane','SCENERY/input/ButtonListener','TANDEM/Tandem','SCENERY_PHET/TBarrierRectangle'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var sceneryPhet = require( 'SCENERY_PHET/sceneryPhet' );
  var Emitter = require( 'AXON/Emitter' );
  var Plane = require( 'SCENERY/nodes/Plane' );
  var ButtonListener = require( 'SCENERY/input/ButtonListener' );
  var Tandem = require( 'TANDEM/Tandem' );
  var TBarrierRectangle = require( 'SCENERY_PHET/TBarrierRectangle' );
  function BarrierRectangle( modalNodeStack, options ) {
    var self = this;
    options = _.extend( {
      tandem: Tandem.tandemRequired(),
      phetioType: TBarrierRectangle
    }, options );
    Plane.call( this );
    this.startedCallbacksForFiredEmitter = new Emitter();
    this.endedCallbacksForFiredEmitter = new Emitter();
    modalNodeStack.lengthProperty.link( function( numBarriers ) {
      self.visible = numBarriers > 0;
    } );
    this.addInputListener( new ButtonListener( {
      fire: function( event ) {
        self.startedCallbacksForFiredEmitter.emit();
        assert && assert( modalNodeStack.length > 0, 'There must be a Node in the stack to hide.' );
        modalNodeStack.get( modalNodeStack.length - 1 ).hide();
        self.endedCallbacksForFiredEmitter.emit();
      }
    } ) );
    this.disposeBarrierRectangle = function() {
      modalNodeStack.lengthProperty.unlink();
    };
    this.mutate( options );
  }
  sceneryPhet.register( 'BarrierRectangle', BarrierRectangle );
  return inherit( Plane, BarrierRectangle, {
    dispose: function() {
      this.disposeBarrierRectangle();
      Plane.prototype.dispose.call( this );
    }
  } );
} );
define( 'JOIST/Profiler',['require','PHET_CORE/inherit','JOIST/joist'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var FIELD_SEPARATOR = ' \u2014 '; // em dash, a long horizontal dash
  var HISTOGRAM_LENGTH = 30;
  function Profiler() {
    this.allTimes = [];  // {number[]} times for all frames, in ms
    this.histogram = []; // {number[]} array index corresponds to number of ms, value is number of frames at that time
    this.longTimes = []; // {number[]} any frame times that didn't fit in histogram
    this.frameStartTime = 0; // {number} start time of the current frame
    this.previousFrameStartTime = 0; // {number} start time of the previous frame
    for ( var i = 0; i < HISTOGRAM_LENGTH; i++ ) {
      this.histogram.push( 0 );
    }
    $( 'body' ).append( '<div style="z-index: 99999999;position: absolute;color:red" id="phetProfiler" ></div>' );
  }
  joist.register( 'Profiler', Profiler );
  return inherit( Object, Profiler, {
    frameStarted: function() {
      this.frameStartTime = Date.now();
    },
    frameEnded: function() {
      if ( this.allTimes.length > 0 && this.allTimes.length % 60 === 0 ) {
        var totalTime = 0;
        for ( var i = 0; i < this.allTimes.length; i++ ) {
          totalTime += this.allTimes[ i ];
        }
        var averageFPS = Math.round( 1000 / (totalTime / this.allTimes.length) );
        var text = '' + averageFPS + ' FPS';
        var averageFrameTime = Math.round( totalTime / this.allTimes.length );
        text = text + FIELD_SEPARATOR + averageFrameTime + 'ms/frame';
        text = text + FIELD_SEPARATOR + this.histogram;
        if ( this.longTimes.length > 0 ) {
          this.longTimes.sort( function( a, b ) { return b - a; } ); // sort longTimes in descending order
          text = text + FIELD_SEPARATOR + this.longTimes;
        }
        $( '#phetProfiler' ).html( text );
        for ( i = 0; i < HISTOGRAM_LENGTH; i++ ) {
          this.histogram[ i ] = 0;
        }
        this.longTimes.length = 0;
        this.allTimes.length = 0;
      }
      if ( this.previousFrameStartTime ) {
        var dt = this.frameStartTime - this.previousFrameStartTime;
        this.allTimes.push( dt );
        if ( dt < HISTOGRAM_LENGTH ) {
          this.histogram[ dt ]++; // increment the histogram cell for the corresponding time
        }
        else {
          this.longTimes.push( dt ); // time doesn't fit in histogram, record in longTimes
        }
      }
      this.previousFrameStartTime = this.frameStartTime;
    }
  }, {
    start: function( sim ) {
      var profiler = new Profiler();
      sim.frameStartedEmitter.addListener( function() {
        profiler.frameStarted();
      } );
      sim.frameEndedEmitter.addListener( function() {
        profiler.frameEnded();
      } );
    }
  } );
} );
define( 'JOIST/LookAndFeel',['require','SCENERY/util/Color','AXON/DerivedProperty','PHET_CORE/inherit','JOIST/joist','AXON/Property'],function( require ) {
  'use strict';
  var Color = require( 'SCENERY/util/Color' );
  var DerivedProperty = require( 'AXON/DerivedProperty' );
  var inherit = require( 'PHET_CORE/inherit' );
  var joist = require( 'JOIST/joist' );
  var Property = require( 'AXON/Property' );
  function LookAndFeel() {
    this.backgroundColorProperty = new Property( 'black' );
    this.navigationBarFillProperty = new DerivedProperty( [ this.backgroundColorProperty ],
      function( backgroundColor ) {
        var screenIsBlack = !!new Color( backgroundColor ).equals( Color.BLACK );
        return screenIsBlack ? 'white' : 'black';
      } );
    this.navigationBarTextFillProperty = new DerivedProperty( [ this.navigationBarFillProperty ],
      function( navigationBarFill ) {
        return navigationBarFill === 'black' ? 'white' : 'black';
      } );
  }
  joist.register( 'LookAndFeel', LookAndFeel );
  return inherit( Object, LookAndFeel, {
    reset: function() {
      this.backgroundColorProperty.reset();
    }
  } );
} );
define("PHET_IO/SimIFrameAPI", function(){return function(){ return function(){}; };});
define( 'JOIST/TSim',['require','ifphetio!PHET_IO/assertions/assertInstanceOf','ifphetio!PHET_IO/phetio','ifphetio!PHET_IO/phetioInherit','JOIST/joist','ifphetio!PHET_IO/SimIFrameAPI','ifphetio!PHET_IO/types/TFunctionWrapper','ifphetio!PHET_IO/types/TObject','ifphetio!PHET_IO/events/toEventOnEmit','ifphetio!PHET_IO/types/TString','ifphetio!PHET_IO/types/TVoid'],function( require ) {
  'use strict';
  var assertInstanceOf = require( 'ifphetio!PHET_IO/assertions/assertInstanceOf' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  var phetioInherit = require( 'ifphetio!PHET_IO/phetioInherit' );
  var joist = require( 'JOIST/joist' );
  var SimIFrameAPI = require( 'ifphetio!PHET_IO/SimIFrameAPI' );
  var TFunctionWrapper = require( 'ifphetio!PHET_IO/types/TFunctionWrapper' );
  var TObject = require( 'ifphetio!PHET_IO/types/TObject' );
  var toEventOnEmit = require( 'ifphetio!PHET_IO/events/toEventOnEmit' );
  var TString = require( 'ifphetio!PHET_IO/types/TString' );
  var TVoid = require( 'ifphetio!PHET_IO/types/TVoid' );
  var SIM_STARTED = 'simStarted';
  function TSim( sim, phetioID ) {
    assertInstanceOf( sim, phet.joist.Sim );
    TObject.call( this, sim, phetioID );
    toEventOnEmit( sim.startedSimConstructorEmitter, sim.endedSimConstructionEmitter, 'model', phetioID, this.constructor, SIM_STARTED,
      function( value ) {
        var simData = {
          repoName: value.repoName,
          simName: value.simName,
          simVersion: value.simVersion,
          simURL: value.url,
          userAgent: window.navigator.userAgent,
          randomSeed: value.randomSeed,
          wrapperMetadata: window.simStartedMetadata,
          provider: 'PhET THPT Nguyễn Trường Tộ, CLB Sáng tạo trẻ' // See #137
        };
        delete window.simStartedMetadata;
        return simData;
      } );
    phetio.sim = sim;
    sim.endedSimConstructionEmitter.addListener( function() {
      SimIFrameAPI.triggerSimInitialized();
      phetio.simulationStarted();
    } );
  }
  phetioInherit( TObject, 'TSim', TSim, {
    disableRequestAnimationFrame: {
      returnType: TVoid,
      parameterTypes: [],
      implementation: function() {
        this.instance.disableRequestAnimationFrame();
      },
      documentation: 'Prevents the simulation from animating/updating'
    },
    addEventListener: {
      returnType: TVoid,
      parameterTypes: [ TString, TFunctionWrapper( TVoid, [ TString, TFunctionWrapper( TVoid, [] ) ] ) ],
      implementation: function( eventName, listener ) {
        this.instance.onStatic( eventName, listener );
      },
      documentation: 'Add an event listener to the sim instance'
    },
    getScreenshotDataURL: {
      returnType: TString,
      parameterTypes: [],
      implementation: function() {
        return window.phet.joist.ScreenshotGenerator.generateScreenshot( this.instance );
      },
      documentation: 'Gets a base64 representation of a screenshot of the simulation as a data url'
    }
  }, {
    documentation: 'The type for the simulation instance',
    events: [
      SIM_STARTED
    ]
  } );
  joist.register( 'TSim', TSim );
  return TSim;
} );
define( 'JOIST/thirdPartySupport/LegendsOfLearningSupport',['require','JOIST/joist','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var inherit = require( 'PHET_CORE/inherit' );
  function LegendsOfLearningSupport( sim ) {
    this.sim = sim;
    window.addEventListener( 'message', function( message ) {
        if ( message.data.messageName === 'pause' ) {
          sim.activeProperty.value = false;
        }
        else if ( message.data.messageName === 'resume' ) {
          sim.activeProperty.value = true;
        }
      }
    );
  }
  joist.register( 'LegendsOfLearningSupport', LegendsOfLearningSupport );
  return inherit( Object, LegendsOfLearningSupport, {
    start: function() {
      this.sim.endedSimConstructionEmitter.addListener( function() {
        window.parent && window.parent.postMessage( { message: 'init' }, '*' );
      } );
    }
  } );
} );
define( 'JOIST/Sim',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Dimension2','SCENERY/util/Features','JOIST/NavigationBar','JOIST/HomeScreen','JOIST/HomeScreenView','JOIST/UpdateCheck','SCENERY/util/Util','SCENERY/display/Display','SCENERY/nodes/Node','AXON/Property','AXON/BooleanProperty','AXON/ObservableArray','PHET_CORE/platform','PHET_CORE/Timer','SCENERY_PHET/BarrierRectangle','JOIST/Profiler','JOIST/LookAndFeel','JOIST/ScreenshotGenerator','JOIST/packageJSON','JOIST/PhetButton','JOIST/joist','TANDEM/Tandem','DOT/Util','AXON/Emitter','TANDEM/axon/TandemEmitter','JOIST/TSim','JOIST/thirdPartySupport/LegendsOfLearningSupport','ifphetio!PHET_IO/types/TBoolean','ifphetio!PHET_IO/types/TNumber'],function( require ) {
  'use strict';
  var inherit = require( 'PHET_CORE/inherit' );
  var Bounds2 = require( 'DOT/Bounds2' );
  var Dimension2 = require( 'DOT/Dimension2' );
  var Features = require( 'SCENERY/util/Features' );
  var NavigationBar = require( 'JOIST/NavigationBar' );
  var HomeScreen = require( 'JOIST/HomeScreen' );
  var HomeScreenView = require( 'JOIST/HomeScreenView' );
  var UpdateCheck = require( 'JOIST/UpdateCheck' );
  var Util = require( 'SCENERY/util/Util' );
  var Display = require( 'SCENERY/display/Display' );
  var Node = require( 'SCENERY/nodes/Node' );
  var Property = require( 'AXON/Property' );
  var BooleanProperty = require( 'AXON/BooleanProperty' );
  var ObservableArray = require( 'AXON/ObservableArray' );
  var platform = require( 'PHET_CORE/platform' );
  var Timer = require( 'PHET_CORE/Timer' );
  var BarrierRectangle = require( 'SCENERY_PHET/BarrierRectangle' );
  var Profiler = require( 'JOIST/Profiler' );
  var LookAndFeel = require( 'JOIST/LookAndFeel' );
  var ScreenshotGenerator = require( 'JOIST/ScreenshotGenerator' );
  var packageJSON = require( 'JOIST/packageJSON' );
  var PhetButton = require( 'JOIST/PhetButton' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var DotUtil = require( 'DOT/Util' );// eslint-disable-line
  var Emitter = require( 'AXON/Emitter' );
  var TandemEmitter = require( 'TANDEM/axon/TandemEmitter' );
  var TSim = require( 'JOIST/TSim' );
  var LegendsOfLearningSupport = require( 'JOIST/thirdPartySupport/LegendsOfLearningSupport' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var TNumber = require( 'ifphetio!PHET_IO/types/TNumber' );
  var PROGRESS_BAR_WIDTH = 273;
  phet.joist.elapsedTime = 0; // in milliseconds, use this in Tween.start for replicable playbacks
  phet.joist.playbackModeEnabledProperty = new BooleanProperty( false );
  function Sim( name, screens, options ) {
    var self = this;
    phet.joist.playbackModeEnabledProperty.lazyLink( function( playbackModeEnabled ) {
      throw new Error( 'playbackModeEnabledProperty cannot be changed after Sim construction has begun' );
    } );
    var tandem = Tandem.createRootTandem();
    var simTandem = tandem.createTandem( 'sim' );
    this.tandem = tandem;
    this.startedSimConstructorEmitter = new Emitter();
    this.endedSimConstructionEmitter = new Emitter();
    this.resizedEmitter = new Emitter();
    this.frameStartedEmitter = new Emitter();
    this.frameEndedEmitter = new TandemEmitter( {
      tandem: simTandem.createTandem( 'frameEndedEmitter' ),
      phetioArgumentTypes: [ TNumber( { units: 'seconds' } ) ],
      phetioEmitData: false // An adapter in phetio will create input events when recording for playback.
    } );
    var initialScreen = phet.chipper.queryParameters.initialScreen;
    if ( QueryStringMachine.containsKey( 'screens' ) ) {
      var newScreens = [];
      phet.chipper.queryParameters.screens.forEach( function( userIndex ) {
        var screenIndex = userIndex - 1; // screens query parameter is 1-based
        if ( screenIndex < 0 || screenIndex > screens.length - 1 ) {
          throw new Error( 'invalid screen index: ' + userIndex );
        }
        newScreens.push( screens[ screenIndex ] );
      } );
      if ( initialScreen !== 0 ) {
        var index = _.indexOf( newScreens, screens[ initialScreen - 1 ] );
        assert && assert( index !== -1, 'screen not found' );
        initialScreen = index + 1;
      }
      screens = newScreens;
    }
    options = _.extend( {
      showHomeScreen: ( screens.length > 1 ) && phet.chipper.queryParameters.homeScreen,
      screenIndex: initialScreen === 0 ? 0 : initialScreen - 1,
      credits: {},
      optionsNode: null,
      homeScreenWarningNode: null,
      recordInputEventLog: false,
      inputEventLogName: undefined,
      showSaveAndLoad: false,
      showSmallHomeScreenIconFrame: false,
      accessibility: phet.chipper.queryParameters.accessibility,
      keyboardHelpNode: null,
      rootRenderer: platform.edge ? 'canvas' : 'svg'
    }, options );
    this.options = options;
    options.rootRenderer = phet.chipper.queryParameters.rootRenderer || options.rootRenderer;
    this.showHomeScreenProperty = new Property( initialScreen === 0 ? options.showHomeScreen : false, {
      tandem: tandem.createTandem( 'sim.showHomeScreenProperty' ),
      phetioValueType: TBoolean
    } );
    this.screenIndexProperty = new Property( options.screenIndex, {
      tandem: tandem.createTandem( 'sim.screenIndexProperty' ),
      phetioValueType: TNumber( { values: _.range( 0, screens.length ) } )
    } );
    this.activeProperty = new Property( !phet.joist.playbackModeEnabledProperty.value, {
      tandem: tandem.createTandem( 'sim.activeProperty' ),
      phetioValueType: TBoolean
    } );
    this.browserTabVisibleProperty = new Property( true, {
      tandem: tandem.createTandem( 'browserTabVisibleProperty' ),
      phetioValueType: TBoolean,
      phetioInstanceDocumentation: 'this Property is read-only, do not attempt to set its value'
    } );
    document.addEventListener( 'visibilitychange', function() {
      self.browserTabVisibleProperty.set( document.visibilityState === 'visible' );
    }, false );
    this.scaleProperty = new Property( 1 );
    this.boundsProperty = new Property( null );
    this.screenBoundsProperty = new Property( null );
    this.currentScreenProperty = new Property( null );
    simTandem.addInstance( this, TSim );
    this.lookAndFeel = new LookAndFeel();
    assert && assert( window.phet.joist.launchCalled, 'Sim must be launched using SimLauncher, ' +
                                                      'see https://github.com/phetsims/joist/issues/142' );
    this.destroyed = false;
    this.accessible = options.accessibility;
    this.keyboardHelpNode = options.keyboardHelpNode;
    assert && assert( !window.phet.joist.sim, 'Only supports one sim at a time' );
    window.phet.joist.sim = self;
    window.phet.joist.ScreenshotGenerator = ScreenshotGenerator;
    this.name = name;                   // @public (joist-internal)
    this.version = packageJSON.version; // @public (joist-internal)
    this.credits = options.credits;     // @public (joist-internal)
    this.frameCounter = 0;
    this.resizePending = true;
    this.inputEventLog = [];                 // @public (joist-internal)
    this.inputEventBounds = Bounds2.NOTHING; // @public (joist-internal)
    this.locale = phet.chipper.locale || 'en';
    if ( QueryStringMachine.containsKey( 'locale' ) ) {
      $( 'title' ).html( name );
    }
    if ( phet.chipper.queryParameters.recordInputEventLog ) {
      options.recordInputEventLog = true;
      options.inputEventLogName = phet.chipper.queryParameters.recordInputEventLog;
    }
    if ( phet.chipper.queryParameters.playbackInputEventLog ) {
      options.playbackInputEventLog = true;
      options.inputEventLogName = phet.chipper.queryParameters.playbackInputEventLog;
    }
    if ( phet.chipper.queryParameters.fuzzMouse ) {
      window.open = function() {
        return {
          focus: function() {},
          blur: function() {}
        };
      };
    }
    this.startedSimConstructorEmitter.emit1( {
      repoName: packageJSON.name,
      simName: this.name,
      simVersion: this.version,
      url: window.location.href,
      randomSeed: window.phet.chipper.randomSeed
    } );
    var $body = $( 'body' );
    $body.css( 'padding', '0' ).css( 'margin', '0' ).css( 'overflow', 'hidden' );
    var ariaLiveContainer = document.getElementById( 'aria-live-elements' );
    if ( ariaLiveContainer ) {
      ariaLiveContainer.style[ Features.userSelect ] = 'none';
    }
    if ( document.getElementById( 'sim' ) && document.getElementById( 'sim' ).parentNode === document.body ) {
      document.body.removeChild( document.getElementById( 'sim' ) );
    }
    document.onselectstart = function() {
      return false;
    };
    this.rootNode = new Node( { renderer: options.rootRenderer } );
    this.activeProperty.lazyLink( function( active ) {
      if ( !active ) {
        self.rootNode.interruptSubtreeInput();
      }
    } );
    this.display = new Display( self.rootNode, {
      allowSceneOverflow: false,
      allowWebGL: phet.chipper.queryParameters.webgl,
      accessibility: options.accessibility,
      isApplication: false,
      assumeFullWindow: true // a bit faster if we can assume no coordinate translations are needed for the display.
    } );
    this.activeProperty.link( function( active ) {
      self.display.interactive = active;
      if ( active ) {
        assert && assert( !phet.joist.playbackModeEnabledProperty.value, 'The sim must remain inactive while playbackModeEnabledProperty is true' );
      }
    } );
    var simDiv = self.display.domElement;
    simDiv.id = 'sim';
    document.body.appendChild( simDiv );
    var heartbeatDiv = this.heartbeatDiv = document.createElement( 'div' );
    heartbeatDiv.style.opacity = 0;
    heartbeatDiv.style.position = 'absolute';
    heartbeatDiv.style.left = '0';
    heartbeatDiv.style.top = '0';
    heartbeatDiv.style.width = '0';
    heartbeatDiv.style.height = '0';
    heartbeatDiv.style.clip = 'rect(0,0,0,0)';
    heartbeatDiv.setAttribute( 'aria-hidden', true ); // hide div from screen readers (a11y)
    simDiv.appendChild( heartbeatDiv );
    if ( phet.chipper.queryParameters.sceneryLog ) {
      this.display.scenery.enableLogging( phet.chipper.queryParameters.sceneryLog );
    }
    if ( phet.chipper.queryParameters.sceneryStringLog ) {
      this.display.scenery.switchLogToString();
    }
    this.display.initializeEvents(); // sets up listeners on the document with preventDefault(), and forwards those events to our scene
    window.phet.joist.rootNode = this.rootNode; // make the scene available for debugging
    window.phet.joist.display = this.display; // make the display available for debugging
    self.display.setPointerDisplayVisible( phet.chipper.queryParameters.showPointers );
    self.display.setPointerAreaDisplayVisible( phet.chipper.queryParameters.showPointerAreas );
    self.display.setCanvasNodeBoundsVisible( phet.chipper.queryParameters.showCanvasNodeBounds );
    self.display.setFittedBlockBoundsVisible( phet.chipper.queryParameters.showFittedBlockBounds );
    function sleep( millis ) {
      var date = new Date();
      var curDate;
      do {
        curDate = new Date();
      } while ( curDate - date < millis );
    }
    window.phet.joist.makeEverythingSlow = function() {
      window.setInterval( function() { sleep( 64 ); }, 16 );
    };
    window.phet.joist.makeRandomSlowness = function() {
      window.setInterval( function() { sleep( Math.ceil( 100 + Math.random() * 200 ) ); }, Math.ceil( 100 + Math.random() * 200 ) );
    };
    this.screens = screens;
    if ( screens.length > 1 ) {
      this.homeScreen = new HomeScreen( this, tandem.createTandem( 'homeScreen' ), {
        warningNode: options.homeScreenWarningNode,
        showSmallHomeScreenIconFrame: options.showSmallHomeScreenIconFrame
      } );
      this.homeScreen.initializeModelAndView();
    }
    else {
      this.homeScreen = null;
    }
    this.navigationBar = new NavigationBar( this, screens, tandem.createTandem( 'navigationBar' ) );
    this.updateBackground = function() {
      self.lookAndFeel.backgroundColorProperty.value = self.currentScreenProperty.value ?
                                                       self.currentScreenProperty.value.backgroundColorProperty.value :
                                                       self.homeScreen.backgroundColorProperty.value;
    };
    this.lookAndFeel.backgroundColorProperty.link( function( backgroundColor ) {
      self.display.backgroundColor = backgroundColor;
    } );
    Property.multilink( [ this.showHomeScreenProperty, this.screenIndexProperty ],
      function( showHomeScreen, screenIndex ) {
        self.currentScreenProperty.value = ( showHomeScreen && self.homeScreen ) ? null : screens[ screenIndex ];
        self.updateBackground();
      } );
    this.currentScreenProperty.lazyLink( function( newScreen, oldScreen ) {
      if ( oldScreen === null ) {
        self.homeScreen.view.interruptSubtreeInput();
      }
      else {
        oldScreen.view.interruptSubtreeInput();
      }
    } );
    phet.chipper.queryParameters.legendsOfLearning && new LegendsOfLearningSupport( this ).start();
  }
  joist.register( 'Sim', Sim );
  return inherit( Object, Sim, {
    finishInit: function( screens, tandem ) {
      var self = this;
      if ( this.homeScreen ) {
        this.rootNode.addChild( this.homeScreen.view );
      }
      _.each( screens, function( screen ) {
        screen.view.layerSplit = true;
        self.rootNode.addChild( screen.view );
      } );
      this.rootNode.addChild( this.navigationBar );
      if ( this.homeScreen ) {
        PhetButton.linkPhetButtonTransform( this.homeScreen, this.navigationBar, this.rootNode );
      }
      Property.multilink( [ this.showHomeScreenProperty, this.screenIndexProperty ],
        function( showHomeScreen, screenIndex ) {
          if ( self.homeScreen ) {
            if ( showHomeScreen ) {
              self.homeScreen.activeProperty.set( true );
              self.homeScreen.view.setVisible( true );
            }
            else {
              self.homeScreen.view.setVisible( false );
              self.homeScreen.activeProperty.set( false );
            }
          }
          for ( var i = 0; i < screens.length; i++ ) {
            var screen = screens[ i ];
            var visible = ( !showHomeScreen && screenIndex === i );
            if ( visible ) {
              screen.activeProperty.set( visible );
            }
            screen.view.setVisible( visible );
            if ( !visible ) {
              screen.activeProperty.set( visible );
            }
          }
          self.navigationBar.setVisible( !showHomeScreen );
          self.updateBackground();
        } );
      this.topLayer = new Node();
      this.rootNode.addChild( this.topLayer );
      this.modalNodeStack = new ObservableArray( {
      } ); // {Node} with node.hide()
      this.barrierRectangle = new BarrierRectangle(
        this.modalNodeStack,
        {
          fill: 'rgba(0,0,0,0.3)',
          pickable: true,
          tandem: tandem.createTandem( 'sim.barrierRectangle' )
        } );
      this.topLayer.addChild( this.barrierRectangle );
      var resizeListener = function() {
        if ( !phet.joist.playbackModeEnabledProperty.value ) {
          self.resizePending = true;
        }
      };
      $( window ).resize( resizeListener );
      window.addEventListener( 'resize', resizeListener );
      window.addEventListener( 'orientationchange', resizeListener );
      window.visualViewport && window.visualViewport.addEventListener( 'resize', resizeListener );
      this.resizeToWindow();
      UpdateCheck.check();
      this.lastTime = -1;
      this.boundRunAnimationLoop = this.runAnimationLoop.bind( this );
    },
    showPopup: function( node, isModal ) {
      assert && assert( node );
      assert && assert( !!node.hide, 'Missing node.hide() for showPopup' );
      assert && assert( !this.topLayer.hasChild( node ), 'Popup already shown' );
      if ( isModal ) {
        this.modalNodeStack.push( node );
      }
      this.topLayer.addChild( node );
    },
    hidePopup: function( node, isModal ) {
      assert && assert( node && this.modalNodeStack.contains( node ) );
      assert && assert( this.topLayer.hasChild( node ), 'Popup was not shown' );
      if ( isModal ) {
        this.modalNodeStack.remove( node );
      }
      this.topLayer.removeChild( node );
    },
    resizeToWindow: function() {
      this.resizePending = false;
      this.resize( window.innerWidth, window.innerHeight );
    },
    resize: function( width, height ) {
      var self = this;
      var scale = Math.min( width / HomeScreenView.LAYOUT_BOUNDS.width, height / HomeScreenView.LAYOUT_BOUNDS.height );
      var navBarHeight = scale * NavigationBar.NAVIGATION_BAR_SIZE.height;
      self.navigationBar.layout( scale, width, navBarHeight );
      self.navigationBar.y = height - navBarHeight;
      self.display.setSize( new Dimension2( width, height ) );
      var screenHeight = height - self.navigationBar.height;
      _.each( self.screens, function( m ) {
        m.view.layout( width, screenHeight );
      } );
      self.topLayer.setScaleMagnitude( scale );
      self.homeScreen && self.homeScreen.view.layout( width, height );
      if ( platform.mobileSafari ) {
        window.scrollTo( 0, 0 );
      }
      this.scaleProperty.value = scale;
      this.boundsProperty.value = new Bounds2( 0, 0, width, height );
      this.screenBoundsProperty.value = new Bounds2( 0, 0, width, screenHeight );
      this.resizedEmitter.emit3( this.boundsProperty.value, this.screenBoundsProperty.value, this.scaleProperty.value );
    },
    start: function() {
      var self = this;
      var workItems = [];
      var screens = this.screens;
      screens.forEach( function initializeScreen( screen ) {
        workItems.push( function() {
          screen.backgroundColorProperty.link( self.updateBackground );
          screen.initializeModel();
        } );
        workItems.push( function() {
          screen.initializeView();
        } );
      } );
      var runItem = function( i ) {
        setTimeout(
          function() {
            workItems[ i ]();
            var progress = DotUtil.linear( 0, workItems.length - 1, 0.25, 1.0, i );
            if ( document.getElementById( 'progressBarForeground' ) ) {
              document.getElementById( 'progressBarForeground' ).setAttribute( 'width', (progress * PROGRESS_BAR_WIDTH) + '' );
            }
            if ( i + 1 < workItems.length ) {
              runItem( i + 1 );
            }
            else {
              setTimeout( function() {
                self.finishInit( screens, self.tandem );
                Util.polyfillRequestAnimationFrame();
                if ( phet.chipper.queryParameters.profiler ) {
                  Profiler.start( self );
                }
                self.boundRunAnimationLoop();
                if ( phet.chipper.queryParameters.postMessageOnLoad ) {
                  window.parent && window.parent.postMessage( JSON.stringify( {
                    type: 'load',
                    url: window.location.href
                  } ), '*' );
                }
                $( '#splash' ).remove();
                $( '#progressBar' ).remove();
                self.endedSimConstructionEmitter.emit();
              }, 25 ); // pause for a few milliseconds with the progress bar filled in before going to the home screen
            }
          },
          30 / workItems.length
        );
      };
      runItem( 0 );
    },
    destroy: function() {
      this.destroyed = true;
      var simDiv = this.display.domElement;
      simDiv.parentNode && simDiv.parentNode.removeChild( simDiv );
    },
    runAnimationLoop: function() {
      if ( !this.destroyed ) {
        window.requestAnimationFrame( this.boundRunAnimationLoop );
      }
      if ( this.activeProperty.value ) {
        var time = Date.now();
        var elapsedTimeMilliseconds = (this.lastTime === -1) ? (1000.0 / 60.0) : (time - this.lastTime);
        this.lastTime = time;
        var dt = elapsedTimeMilliseconds / 1000.0;
        if ( dt >= 0 ) {
          this.stepSimulation( dt );
        }
      }
    },
    getSelectedScreen: function() {
      return this.showHomeScreenProperty.value ? null : this.screens[ this.screenIndexProperty.value ];
    },
    stepSimulation: function( dt ) {
      this.frameStartedEmitter.emit();
      this.frameCounter++;
      phetAllocation && phetAllocation( 'loop' );
      if ( this.frameCounter % 1000 === 0 ) {
        this.heartbeatDiv.innerHTML = Math.random();
      }
      if ( this.resizePending ) {
        this.resizeToWindow();
      }
      if ( phet.chipper.queryParameters.fuzzMouse ) {
        this.display.fuzzMouseEvents( phet.chipper.queryParameters.fuzzRate );
      }
      var screen = this.getSelectedScreen();
      if ( screen && screen.maxDT ) {
        dt = Math.min( dt, screen.maxDT );
      }
      phet.joist.elapsedTime = phet.joist.elapsedTime + dt * 1000;
      Timer.step( dt );
      if ( screen && screen.model.step && dt ) {
        screen.model.step( dt );
      }
      if ( window.TWEEN ) {
        window.TWEEN.update( phet.joist.elapsedTime );
      }
      if ( screen && screen.view.step ) {
        screen.view.step( dt );
      }
      this.display.updateDisplay();
      this.frameEndedEmitter.emit1( dt );
    }
  } );
} );
define( 'JOIST/checkNamespaces',['require','JOIST/joist'],function( require ) {
  'use strict';
  var joist = require( 'JOIST/joist' );
  var checkNamespaces = function() {
    var defined = window.requirejs._defined || window.require.s.contexts._.defined;
    var visit = function( problemHandler ) {
      for ( var moduleName in defined ) {
        if ( moduleName.indexOf( '!' ) >= 0 ) {
          continue;
        }
        if ( moduleName.indexOf( '/' ) < 0 ) {
          continue;
        }
        if ( moduleName.indexOf( '..' ) >= 0 ) {
          continue;
        }
        var prefix = moduleName.slice( 0, moduleName.indexOf( '/' ) ); // e.g. 'SCENERY_PHET'
        var name = moduleName.slice( moduleName.lastIndexOf( '/' ) + 1 ); // e.g. 'ArrowButton'
        var prefixTokens = prefix.toLowerCase().split( '_' );
        var namespace = [ prefixTokens[ 0 ] ].concat( prefixTokens.slice( 1 ).map( function( token ) {
          return token.charAt( 0 ).toUpperCase() + token.slice( 1 );
        } ) ).join( '' );
        if ( name === namespace || name === ( namespace + 'Namespace' ) ) {
          continue;
        }
        var namespacedObject = phet[ namespace ] && phet[ namespace ][ name ];
        if ( !namespacedObject ) {
          problemHandler( 'not namespaced: ' + namespace + '.' + name );
        }
        if ( namespacedObject && namespacedObject !== defined[ moduleName ] ) {
          problemHandler( namespace + '.' + name + ' is different than the expected namespaced object' );
        }
      }
    };
    visit( function( errorMessage ) {
      console.log( errorMessage );
    } );
    visit( function( errorMessage ) {
      assert && assert( false, errorMessage );
    } );
  };
  joist.register( 'checkNamespaces', checkNamespaces );
  return checkNamespaces;
} );
define( 'DOT/Random',['require','DOT/Util','DOT/dot','PHET_CORE/inherit'],function( require ) {
  'use strict';
  var Util = require( 'DOT/Util' );
  var dot = require( 'DOT/dot' );
  var inherit = require( 'PHET_CORE/inherit' );
  function Random( options ) {
    options = _.extend( {
      seed: null,
      staticSeed: false
    }, options );
    if ( options.seed !== null && options.staticSeed ) {
      assert && assert( false, 'cannot specify seed and staticSeed, use one or the other' );
    }
    var seed = options.staticSeed ? window.phet.chipper.randomSeed : options.seed;
    this.setSeed( seed );
  }
  inherit( Object, Random, {
    setSeed: function( seed ) {
      this.seed = seed;
      this.seedrandom = this.seed !== null ? new Math.seedrandom( this.seed + '' ) : null;
    },
    nextBoolean: function() {
      return this.nextDouble() >= 0.5;
    },
    nextInt: function( n ) {
      var value = this.nextDouble() * n;
      return value | 0; // convert to int by removing the decimal places
    },
    nextIntBetween: function( min, max ) {
      assert && assert( arguments.length === 2, 'nextIntBetween must have exactly 2 arguments' );
      assert && assert( Util.isInteger( min ), 'min must be an integer: ' + min );
      assert && assert( Util.isInteger( max ), 'max must be an integer: ' + max );
      var range = max - min;
      return this.nextInt( range + 1 ) + min;
    },
    sample: function( array ) {
      assert && assert( array.length > 0, 'Array should have at least 1 item.' );
      var index = this.nextIntBetween( 0, array.length - 1 );
      return array[ index ];
    },
    shuffle: function( array ) {
      assert && assert( array, 'Array should exist' );
      var self = this;
      var index = -1;
      var result = new Array( array.length );
      _.forEach( array, function( value ) {
        var rand = self.nextIntBetween( 0, ++index );
        result[ index ] = result[ rand ];
        result[ rand ] = value;
      } );
      return result;
    },
    nextDouble: function() {
      return this.seed === null ? Math.random() : this.seedrandom();
    },
    nextGaussian: function() {
      return Util.boxMullerTransform( 0, 1, this );
    }
  } );
  dot.register( 'Random', Random );
  return Random;
} );
define("PHET_IO/types/TPhETIO", function(){return function(){ return function(){}; };});
define( 'JOIST/SimLauncher',['require','JOIST/checkNamespaces','JOIST/joist','TANDEM/Tandem','DOT/Random','ifphetio!PHET_IO/SimIFrameAPI','ifphetio!PHET_IO/types/TPhETIO','ifphetio!PHET_IO/phetio'],function( require ) {
  'use strict';
  var checkNamespaces = require( 'JOIST/checkNamespaces' );
  var joist = require( 'JOIST/joist' );
  var Tandem = require( 'TANDEM/Tandem' );
  var Random = require( 'DOT/Random' );
  var SimIFrameAPI = require( 'ifphetio!PHET_IO/SimIFrameAPI' );
  var TPhETIO = require( 'ifphetio!PHET_IO/types/TPhETIO' );
  var phetio = require( 'ifphetio!PHET_IO/phetio' );
  var SimLauncher = {
    launch: function( callback ) {
      assert && assert( !window.phet.launchCalled, 'Tried to launch twice' );
      window.phet.joist.launchCalled = true;
      var elementsToRemove = [];
      function doneLoadingImages() {
        window.phetLaunchSimulation = function() {
          Tandem.launch();
          phet.joist.random = new Random( { staticSeed: true } );
          callback();
        };
        if ( phet.phetio ) {
          new Tandem( 'phetio' ).addInstance( phetio, TPhETIO );
          SimIFrameAPI.initialize(); // calls back to window.phetLaunchSimulation
        }
        if ( phet.phetio && !phet.phetio.queryParameters.phetioStandalone ) {
        }
        else {
          window.phetLaunchSimulation();
        }
      }
      var loaded = 0;
      function isImageOK( img ) {
        if ( !img.complete ) {
          return false;
        }
        if ( typeof img.naturalWidth !== 'undefined' && img.naturalWidth === 0 ) {
          return false;
        }
        return true;
      }
      if ( window.phetImages ) {
        for ( var i = 0; i < window.phetImages.length; i++ ) {
          var phetImage = window.phetImages[ i ];
          if ( isImageOK( phetImage ) ) {
            loaded++;
            if ( loaded === window.phetImages.length ) {
              doneLoadingImages();
            }
          }
          else {
            phetImage.onload = function() {
              loaded++;
              if ( loaded === window.phetImages.length ) {
                doneLoadingImages();
              }
            };
          }
        }
      }
      else {
        doneLoadingImages();
      }
      $( window ).load( function() {
        _.each( elementsToRemove, function( element ) {
          if ( element.parentNode ) {
            element.parentNode.removeChild( element );
          }
        } );
      } );
      assert && checkNamespaces();
    }
  };
  joist.register( 'SimLauncher', SimLauncher );
  return SimLauncher;
} );
define( 'BUILD_AN_ATOM/symbol/view/SymbolNode',['require','SHRED/AtomIdentifier','BUILD_AN_ATOM/common/BAASharedConstants','BUILD_AN_ATOM/buildAnAtom','SCENERY_PHET/PhetFont','BUILD_AN_ATOM/common/view/ChargeMeter','SCENERY/nodes/Image','image!BUILD_AN_ATOM/scale.png','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY_PHET/PhetColorScheme','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','SHRED/ShredConstants','DOT/Vector2'],function( require ) {
  'use strict';
  var AtomIdentifier = require( 'SHRED/AtomIdentifier' );
  var BAASharedConstants = require( 'BUILD_AN_ATOM/common/BAASharedConstants' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var PhetFont = require( 'SCENERY_PHET/PhetFont' );
  var ChargeMeter = require( 'BUILD_AN_ATOM/common/view/ChargeMeter' );
  var Image = require( 'SCENERY/nodes/Image' );
  var scaleIcon = require( 'image!BUILD_AN_ATOM/scale.png' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Node = require( 'SCENERY/nodes/Node' );
  var PhetColorScheme = require( 'SCENERY_PHET/PhetColorScheme' );
  var Rectangle = require( 'SCENERY/nodes/Rectangle' );
  var Text = require( 'SCENERY/nodes/Text' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var Vector2 = require( 'DOT/Vector2' );
  var SYMBOL_BOX_WIDTH = 275; // In screen coords, which are roughly pixels.
  var SYMBOL_BOX_HEIGHT = 300; // In screen coords, which are roughly pixels.
  var NUMBER_FONT = new PhetFont( 56 );
  var NUMBER_INSET = 20; // In screen coords, which are roughly pixels.
  function SymbolNode( numberAtom, tandem, options ) {
    Node.call( this, { pickable: false } ); // Call super constructor.
    var boundingBox = new Rectangle( 0, 0, SYMBOL_BOX_WIDTH, SYMBOL_BOX_HEIGHT, 0, 0, {
      stroke: 'black',
      lineWidth: 2,
      fill: 'white',
      tandem: tandem.createTandem( 'boundingBox' )
    } );
    this.addChild( boundingBox );
    var symbolText = new Text( '', {
      font: new PhetFont( 150 ),
      fill: 'black',
      center: new Vector2( SYMBOL_BOX_WIDTH / 2, SYMBOL_BOX_HEIGHT / 2 ),
      tandem: tandem.createTandem( 'symbolText' )
    } );
    var textCenter = new Vector2( SYMBOL_BOX_WIDTH / 2, SYMBOL_BOX_HEIGHT / 2 );
    numberAtom.protonCountProperty.link( function( protonCount ) {
      var symbol = AtomIdentifier.getSymbol( protonCount );
      symbolText.text = protonCount > 0 ? symbol : '';
      symbolText.center = textCenter;
    } );
    boundingBox.addChild( symbolText );
    var atomicNumberDisplay = new Text( '0', {
      font: NUMBER_FONT,
      fill: PhetColorScheme.RED_COLORBLIND,
      tandem: tandem.createTandem( 'atomicNumberDisplay' )
    } );
    numberAtom.protonCountProperty.link( function( protonCount ) {
      atomicNumberDisplay.text = protonCount;
      atomicNumberDisplay.left = NUMBER_INSET;
      atomicNumberDisplay.bottom = SYMBOL_BOX_HEIGHT - NUMBER_INSET;
    } );
    boundingBox.addChild( atomicNumberDisplay );
    var massNumberDisplay = new Text( '0', {
      font: NUMBER_FONT,
      fill: 'black',
      tandem: tandem.createTandem( 'massNumberDisplay' )
    } );
    boundingBox.addChild( massNumberDisplay );
    numberAtom.massNumberProperty.link( function( massNumber ) {
      massNumberDisplay.text = massNumber.toString();
      massNumberDisplay.left = NUMBER_INSET;
      massNumberDisplay.top = NUMBER_INSET;
    } );
    var chargeDisplay = new Text( '0', {
      font: NUMBER_FONT,
      fill: 'black',
      tandem: tandem.createTandem( 'chargeDisplay' )
    } );
    boundingBox.addChild( chargeDisplay );
    numberAtom.chargeProperty.link( function( charge ) {
      var chargeChar = charge > 0 ? '+' : charge < 0 ? BAASharedConstants.MINUS_SIGN : '';
      chargeDisplay.text = Math.abs( charge ).toString( 10 ) + chargeChar;
      chargeDisplay.fill = ShredConstants.CHARGE_TEXT_COLOR( charge );
      chargeDisplay.right = SYMBOL_BOX_WIDTH - NUMBER_INSET;
      chargeDisplay.top = NUMBER_INSET;
    } );
    var scaleImage = new Image( scaleIcon, { tandem: tandem.createTandem( 'scaleImage' ) } );
    scaleImage.scale( 0.32 ); // Scale empirically determined to match design layout.
    this.addChild( scaleImage );
    var chargeMeter = new ChargeMeter( numberAtom, tandem.createTandem( 'chargeMeter' ), {
      showNumericalReadout: false
    } );
    chargeMeter.scale( 1.5 );
    this.addChild( chargeMeter );
    scaleImage.left = 0;
    scaleImage.centerY = massNumberDisplay.centerY;
    boundingBox.top = 0;
    boundingBox.left = scaleImage.right + 10;
    chargeMeter.left = boundingBox.right + 10;
    chargeMeter.centerY = chargeDisplay.centerY;
    options.tandem = tandem;
    this.mutate( options );
  }
  buildAnAtom.register( 'SymbolNode', SymbolNode );
  return inherit( Node, SymbolNode );
} );
define("string!BUILD_AN_ATOM/symbol",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/symbol");});
define( 'BUILD_AN_ATOM/symbol/view/SymbolView',['require','SUN/AccordionBox','BUILD_AN_ATOM/common/view/AtomView','BUILD_AN_ATOM/buildAnAtom','PHET_CORE/inherit','AXON/Property','SHRED/ShredConstants','BUILD_AN_ATOM/symbol/view/SymbolNode','SCENERY/nodes/Text','ifphetio!PHET_IO/types/TBoolean','string!BUILD_AN_ATOM/symbol'],function( require ) {
  'use strict';
  var AccordionBox = require( 'SUN/AccordionBox' );
  var AtomView = require( 'BUILD_AN_ATOM/common/view/AtomView' );
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var ShredConstants = require( 'SHRED/ShredConstants' );
  var SymbolNode = require( 'BUILD_AN_ATOM/symbol/view/SymbolNode' );
  var Text = require( 'SCENERY/nodes/Text' );
  var TBoolean = require( 'ifphetio!PHET_IO/types/TBoolean' );
  var symbolString = require( 'string!BUILD_AN_ATOM/symbol' );
  function SymbolView( model, tandem ) {
    AtomView.call( this, model, tandem );
    this.symbolAccordionBoxExpandedProperty = new Property( true, {
      tandem: tandem.createTandem( 'symbolAccordionBoxExpandedProperty' ),
      phetioValueType: TBoolean
    } );
    var symbolNode = new SymbolNode( model.particleAtom, tandem.createTandem( 'symbolNode' ), {
      scale: 0.43 
    } );
    var symbolAccordionBox = new AccordionBox( symbolNode, {
      titleNode: new Text( symbolString, {
        font: ShredConstants.ACCORDION_BOX_TITLE_FONT,
        maxWidth: ShredConstants.ACCORDION_BOX_TITLE_MAX_WIDTH,
        tandem: tandem.createTandem( 'symbolAccordionBoxTitle' )
      } ),
      fill: ShredConstants.DISPLAY_PANEL_BACKGROUND_COLOR,
      minWidth: this.periodicTableAccordionBox.width,
      contentAlign: 'center',
      titleAlignX: 'left',
      buttonAlign: 'right',
      buttonTouchAreaXDilation: 8,
      buttonTouchAreaYDilation: 8,
      expandedProperty: this.symbolAccordionBoxExpandedProperty,
      tandem: tandem.createTandem( 'symbolAccordionBox' ),
      accessibleAccordionTitle: symbolString
    } );
    this.controlPanelLayer.addChild( symbolAccordionBox );
    symbolAccordionBox.top = this.periodicTableAccordionBox.top + this.periodicTableAccordionBox.height + 10;
    symbolAccordionBox.left = this.periodicTableAccordionBox.left;
  }
  buildAnAtom.register( 'SymbolView', SymbolView );
  return inherit( AtomView, SymbolView, {
    reset: function() {
      AtomView.prototype.reset.call( this );
      this.symbolAccordionBoxExpandedProperty.reset();
    }
  } );
} );
define("image!BUILD_AN_ATOM/element_icon.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,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';
return img;});
define("image!BUILD_AN_ATOM/element_icon_small.png", function(){ var img = new Image();
window.phetImages = window.phetImages || []
window.phetImages.push(img);
img.src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJMAAABkCAIAAAANEJXjAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA+ZJREFUeNrsnc9Lk2EcwJ1Oy3Sv5lVwt3AXj+u0JFxQUEFdXesPUG9itfAkOu/Tg9BFM+xU2SEFlSDrkAmBlw1vE0e3cJszM6d99dW3bZqlqDzP3s+HB3l9Nxy+H76/3m3v60hm5ktAQ0o5BJgDzMF/4DzrF3g5NjE29s7Oh3j8bURLc0tL3z59/EqI6GfOJBgIBAOtdju4/pu3tDfndjdc8/kIFDoUwBzmoDg7lIOsJJMLCwt/e7Spqam2pkapI7XWG14fHpYNY3TE6fXa15xoO6L1mp6cUKSj2UokZG1MzZjaiDlt+Pnq9Y/IwD+ftjk353AZZZ7G4q9zElIbmdXc9WxoyHxI8qRkS1Uagfr68qteWQ7DOOJpqUBwra/PpjHXs/+fd7S3qVPkLty/J0s20g+Cvz7P0VsWMjL6Ih6PmwHX0dZGltYj5qTP7OzqMre7n4ZU6yqPqG2SJK1fJSK/X9mrc3WLMVuYiwwOirySnZNkbo0CTloSqX+WNimEznPsUJwqBFxkYHAv4EIhjfKVdJKu5yPmtkSbM+dXW9S5zq5HZsA1+3w2fD9B15iLx5dGRketCqdmMTNbyuxywprwZI9MC2bPaVNz1iQgAafm20AiqWASF3PyUypcrrlzaEkUMvdhdtYKOGsMVw1zEj+kyDV67JstV1aSZoZ0N0hT2aCmOWsSp8794e6d27LoNXTtLcEW5qSjqaiqzl2nUm4L/uaNs/zkDzFHzAHmAHOg9lSgCDJNFpx4kz2Y08Gcu0Gv9yjIltQ5wBxQ545HT/4H7oKtAWXPgGMu31xvnrlmn099c2RL6hxgDjCHOcAcYA5zgDnAHGAOc4A5wBzmAHOAOcAc5gBzgDnMAeYAc4C54kT7zzif7Ev+zT7f1OQEMQeYA8xhDuhQToPuUOgsvtO9kVkl5gBzgDnMAR3KPtlobDMa3UrsXNzaYRjlXu953pQIcydk5XqL6SyXMo+nuj+MP6Wz5UFtu1EYPeebSmHu+K9dX1/VH659P1O3GLs8/8W60LVSt5wiWx6COLO2HYZLzJm3AhCjiFG9QynZvx1mdjmxPrx3U5vKjnbEaGAu93aY0l5K/qzwtyBGs3luO5XKPH5i5kxQ3ZzkRulQZF3avbCryFvrC2+n0rjRJuYuPgxakZeNRXGjqLlsNCblLXeky02SDpeBG0U7lO10SszJKvN4Sg3XViotM7j5kOzhHIoGvaUIy+aP59X9YcSoa87p9daMv9mYnpa0KfFnOpOdFX6/TOWIUTrmJCVWkhWLY54DzGEOMAdadig9vX0FV5YHYs6mOJKZeY4CMQeYA8xhDtTitwADALZWTTjBoNW4AAAAAElFTkSuQmCC';
return img;});
define( 'BUILD_AN_ATOM/symbol/SymbolScreen',['require','BUILD_AN_ATOM/buildAnAtom','BUILD_AN_ATOM/common/model/BuildAnAtomModel','SCENERY/nodes/Image','PHET_CORE/inherit','AXON/Property','JOIST/Screen','BUILD_AN_ATOM/symbol/view/SymbolView','string!BUILD_AN_ATOM/symbol','image!BUILD_AN_ATOM/element_icon.png','image!BUILD_AN_ATOM/element_icon_small.png'],function( require ) {
  'use strict';
  var buildAnAtom = require( 'BUILD_AN_ATOM/buildAnAtom' );
  var BuildAnAtomModel = require( 'BUILD_AN_ATOM/common/model/BuildAnAtomModel' );
  var Image = require( 'SCENERY/nodes/Image' );
  var inherit = require( 'PHET_CORE/inherit' );
  var Property = require( 'AXON/Property' );
  var Screen = require( 'JOIST/Screen' );
  var SymbolView = require( 'BUILD_AN_ATOM/symbol/view/SymbolView' );
  var symbolString = require( 'string!BUILD_AN_ATOM/symbol' );
  var elementIcon = require( 'image!BUILD_AN_ATOM/element_icon.png' );
  var elementIconSmall = require( 'image!BUILD_AN_ATOM/element_icon_small.png' );
  function SymbolScreen( tandem ) {
    Screen.call(
      this,
      function() { return new BuildAnAtomModel( tandem.createTandem( 'model' ) ); },
      function( model ) { return new SymbolView( model, tandem.createTandem( 'view' ) ); },
      {
        name: symbolString,
        backgroundColorProperty: new Property( 'rgb( 242, 255, 204 )' ),
        homeScreenIcon: new Image( elementIcon ),
        navigationBarIcon: new Image( elementIconSmall ),
        tandem: tandem
      }
    );
  }
  buildAnAtom.register( 'SymbolScreen', SymbolScreen );
  return inherit( Screen, SymbolScreen );
} );
define("string!BUILD_AN_ATOM/build-an-atom.title",function(){return window.phet.chipper.strings.get("BUILD_AN_ATOM/build-an-atom.title");});
define( 'build-an-atom-main',['require','BUILD_AN_ATOM/buildanatom/BuildAnAtomScreen','BUILD_AN_ATOM/common/BAAGlobalOptions','BUILD_AN_ATOM/game/GameScreen','BUILD_AN_ATOM/common/view/GlobalOptionsNode','JOIST/Sim','JOIST/SimLauncher','BUILD_AN_ATOM/symbol/SymbolScreen','TANDEM/Tandem','string!BUILD_AN_ATOM/build-an-atom.title'],function( require ) {
  'use strict';
  var BuildAnAtomScreen = require( 'BUILD_AN_ATOM/buildanatom/BuildAnAtomScreen' );
  var BAAGlobalOptions = require( 'BUILD_AN_ATOM/common/BAAGlobalOptions' );
  var GameScreen = require( 'BUILD_AN_ATOM/game/GameScreen' );
  var GlobalOptionsNode = require( 'BUILD_AN_ATOM/common/view/GlobalOptionsNode' );
  var Sim = require( 'JOIST/Sim' );
  var SimLauncher = require( 'JOIST/SimLauncher' );
  var SymbolScreen = require( 'BUILD_AN_ATOM/symbol/SymbolScreen' );
  var Tandem = require( 'TANDEM/Tandem' );
  var buildAnAtomTitleString = require( 'string!BUILD_AN_ATOM/build-an-atom.title' );
  var tandem = Tandem.createRootTandem();
  var simOptions = {
    credits: {
      leadDesign: 'Nguyễn Minh Tuấn Hoàng',
      softwareDevelopment: 'Trần Thị Thanh Thảo',
      team: 'Hoàng Minh Tuấn',
      qualityAssurance: 'Trương Viết Duy Chương',
      thanks: 'Được xây dựng trên nền ngôn ngữ lập trình HTML5, CSS3 và JAVASCRIPT.'
    },
    optionsNode: new GlobalOptionsNode( BAAGlobalOptions.highContrastParticlesProperty, tandem )
  };
  SimLauncher.launch( function() {
    new Sim(
      buildAnAtomTitleString,
      [
        new BuildAnAtomScreen( tandem.createTandem( 'atomScreen' ) ),
        new SymbolScreen( tandem.createTandem( 'symbolScreen' ) ),
        new GameScreen( tandem.createTandem( 'gameScreen' ) )
      ],
      simOptions
    ).start();
  } );
} );
require(["build-an-atom-main"]);
}());</script>
</body>
</html>
